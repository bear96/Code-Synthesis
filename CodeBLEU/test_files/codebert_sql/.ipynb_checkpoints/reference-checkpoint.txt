select max(id), parent from tree group by parent;

CREATE GLOBAL TEMPORARY TABLE comments ON COMMIT PRESERVE ROWS 
    AS SELECT * FROM test@db;

SELECT INTO TEST(ID, NAME,DESCRIPTION, COMMENT)
SELECT ID, NAME, 
       dbms_lob.substr(description, 4000, 1), 
       dbms_lob.substr(description, 4000, 1)
  FROM comments;

UPDATE categories SET code = CONCAT(code, '_standard') WHERE id = 1;

select * from user where id=100 limit 1

var queryUsers = dc.lkUsers.Where(p => p.UserID == userId);
var queryLinks = dc.lkDeptLinks.Where(p => queryUsers.ref.Any(x=>x== p));
var queryDept = dc.lkDepts.Where(p => queryLinks.deptid.Any(x=> x == p.deptid));
return  queryDept
        .Select(x=>new {ID = x.deptId, Name = x.deptName, Detail = x.Detail})
        .ToList();

IF @dbnum = 1
    USE Db1;
ELSE
    USE DefaultDb;

SELECT A.name, A.regionID, b.Name
FROM countries A
   Join regions B 
      on B.id = A.RegionId
ORDER BY A.name ASC

SELECT a.*
FROM   Article AS a
JOIN  (
    SELECT article_id
    FROM   Comment
    GROUP  BY article_id
    ORDER  BY count(*) DESC
    LIMIT  10
    ) AS c ON c.article_id = a.id;

SELECT 
   (SELECT Max(StartDate) FROM myTable WHERE phName = "Name") as MaxDate, 
   id, name , phName , startDate, endDate
FROM myTable
WHERE phName = "Name"

INSERT INTO match VALUES(1001, TO_DATE('20130515', 'YYYYMMDD'), 90000, 'American Airlines Arena', 001);

- (void)resetDateFilters {
    self.dateMinSetFilter = [NSDate distantPast];
    self.dateMaxSetFilter = [NSDate distantFuture];

    // destroy the FRC here, delete cache if necessary
}

 //Clears learnDataTable:
 mDb.execSQL("DELETE FROM learnDataTable");
 //Insert 5 random rows from dic:
 mDb.execSQL("INSERT INTO learnDataTable (english, bangla) SELECT english ,bangla FROM dic ORDER BY RANDOM() LIMIT 5");

SET @year := 2013;

SELECT
SUM(if (CONCAT(@year, '-01') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jan,
SUM(if (CONCAT(@year, '-02') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Feb,
SUM(if (CONCAT(@year, '-03') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Mar,
SUM(if (CONCAT(@year, '-04') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Apr,
SUM(if (CONCAT(@year, '-05') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) May,
SUM(if (CONCAT(@year, '-06') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jun,
SUM(if (CONCAT(@year, '-07') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jul,
SUM(if (CONCAT(@year, '-08') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Aug,
SUM(if (CONCAT(@year, '-09') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Sep,
SUM(if (CONCAT(@year, '-10') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Oct,
SUM(if (CONCAT(@year, '-11') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Nov,
SUM(if (CONCAT(@year, '-12') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) `Dec`

FROM insurances  i
INNER JOIN policies p ON p.id = i.policy_id 
WHERE (i.initial_date >= p.date_ini
   AND i.final_date   <= p.date_expired) 
  ;

CREATE VIEW history_view
AS SELECT h.id, h.name, 
min(CASE WHEN h.code = 1 THEN time_date) AS start_date,
min(CASE when h.code = 2 THEN time_date) AS process_date,
min(CASE when h.code = 3 THEN time_date) AS finish_date
FROM history h
group by h.id, h.name;

order by (fruit = 'Melon') desc,
         rand()
limit 3;

Select 
min(DATEADD(HOUR,DATEDIFF (HOUR,'2011-01-01',CreateOn )/5*5,'2011-01-01')) 
   as Start_time,
max(DATEADD(HOUR,(DATEDIFF (HOUR,'2011-01-01',CreateOn )/5+1)*5,'2011-01-01')) 
   as End_Time,
DATEDIFF (HOUR,'2011-01-01',CreateOn )/5 as Interval_Number, 
Count(*) as _Count
From Table1
Group By DATEDIFF (HOUR,'2011-01-01',CreateOn )/5

DBMS_OUTPUT.put_line('Some Message');

CREATE TABLE #NEWTABLE
(
    NEW_CUST_KEY int not null ,
    CUST_ID int not null, 
    CUST_EMAIL nvarchar(100) null   
)
------------------------------------
insert into #NEWTABLE (NEW_CUST_KEY,CUST_ID,CUST_EMAIL)
SELECT ROW_NUMBER() OVER(ORDER BY CUST_ID, CUST_EMAIL) AS NEW_CUST_KEY, CUST_ID, CUST_EMAIL 
FROM
(
    SELECT CUST_ID, CUST_EMAIL
    FROM OLDTABLE 
    GROUP BY CUST_ID, CUST_EMAIL
) T


UPDATE Upd SET NEW_CUST_KEY = T.NEW_CUST_KEY
FROM #NEWTABLE Upd
join (
    SELECT CUST_ID, min(NEW_CUST_KEY) AS NEW_CUST_KEY 
    FROM #NEWTABLE 
    GROUP BY CUST_ID) T
on Upd.CUST_ID = T.CUST_ID

UPDATE Upd SET NEW_CUST_KEY = T.NEW_CUST_KEY
FROM #NEWTABLE Upd
join (
    SELECT CUST_EMAIL, min(NEW_CUST_KEY) AS NEW_CUST_KEY 
    FROM #NEWTABLE 
    GROUP BY CUST_EMAIL) T    
on nullif(Upd.CUST_EMAIL,'') = nullif(T.CUST_EMAIL,'')    

UPDATE Upd SET NEW_CUST_KEY = T.CHANGE_CUST_KEY
FROM #NEWTABLE Upd
join (
    SELECT NEW_CUST_KEY, ROW_NUMBER() OVER(ORDER BY NEW_CUST_KEY) AS CHANGE_CUST_KEY
    FROM #NEWTABLE 
    GROUP BY NEW_CUST_KEY) T
on Upd.NEW_CUST_KEY = T.NEW_CUST_KEY

select * from #NEWTABLE

SELECT a.ItemID, a.Name
FROM things a
WHERE name IN (SELECT name FROM things WHERE itemID = 1)

select * from Publisher 
where Motor COLLATE Macedonian_BIN like '%" + ed + "%' ";

select
    user_id, user_login_date,
    row_number() over(
        partition by user_id
        order by user_login_date
    ) as date_id
from users
order by user_id, date_id

with xml_source as (select 1 id, 'xyz' val, 'y' flag
                      from dual
                    union all
                    select 2, 'abc', 'y'
                      from dual
                    union all
                    select 3, 'def', 'y'
                      from dual
                    union all
                    select 4, 'ghi', 'y'
                      from dual
                    union all
                    select 5, 'jkl', 'y'
                      from dual
                    union all
                    select 6, 'mno', 'y' from dual)

 select xmlagg(xmlelement(TABLE_NAME, (xmlelement(TABLE_ROW, XMLATTRIBUTES(x.id AS ID), xmlforest(x.val as Value)))))
  from xml_source x

SELECT COUNT(sid) FROM
(
    SELECT sid FROM Labs LIMIT 2, 18446744073709551615
) T1

SELECT   DAY(`date`) AS `date`
         SUM(CASE WHEN HOUR(`date`) BETWEEN 6 AND 12 THEN value ELSE 0 END) AS `morning`,
         SUM(CASE WHEN HOUR(`date`) BETWEEN 12 AND 18 THEN value ELSE 0 END) AS `afternoon`,
         SUM(CASE WHEN HOUR(`date`) < 6 OR HOUR(`date`) > 18 THEN value ELSE 0 END) AS `evening`
FROM     my_table
GROUP BY DAY(`date`)

def cartest(request):
    cars = list(Car._default_manager.filter(user__username__exact='michael')[:5])
    first_car_name = car[0]
    another_car = car[1]
    return HttpResponse(len(connection.queries))

WITH recordList
AS
(
    SELECT  ID, DATE, Amt,
            DENSE_RANK() OVER (PARTITION BY ID ORDER BY DATE ASC) rn
    FROM    tableName
)
SELECT  ID, DATE, Amt
FROM    recordList
WHERE   rn <= 2

(DT_WSTR,4)YEAR(DATEADD("dd", - @[User::Days] , GETDATE())) + "-"    
+ RIGHT("0" + (DT_WSTR,2)MONTH(DATEADD("dd", - @[User::Days] , GETDATE())), 2) + "-"
+   RIGHT("0" + (DT_WSTR,2)DAY(DATEADD("dd", - @[User::Days] , GETDATE())), 2)

SELECT trippin.PostData.Id, trippin.AccountData.username, trippin.PostData.posttext,     
    trippin.CategoryData.categoryname, 
    SUM(CASE WHEN likes.liked = 1 THEN 1 ELSE 0 END) as TimesLiked, 
    SUM(CASE WHEN likes.liked = 0 THEN 1 ELSE 0 END) as TimesDisLiked 
FROM trippin.PostData    
INNER JOIN trippin.AccountData ON trippin.PostData.accountid = trippin.AccountData.id
INNER JOIN trippin.CategoryData ON trippin.CategoryData.id = trippin.PostData.categoryid
LEFT OUTER JOIN trippin.LikesDislikesData likes ON likes.postid = trippin.PostData.id
                    -- remove                      AND likes.accountid = trippin.AccountData.id

GROUP BY trippin.PostData.Id, (trippin.AccountData.username), (trippin.PostData.posttext), (trippin.categorydata.categoryname);

Select Cast(Dep_Gender as Char(6)) as Gender,
    Count(1) 'Number Counted'
From Dependent
Group By Cast(Dep_Gender as Char(6))

with
src_type_2 as (
  select c.target_id, a.name
    from table_c c
    join table_a on a.id = c.source_id
    join table_b on b.id = a.type_id
    where b.type_name = 'Type 2'
),
all_type_1 as (
  select a.id, a.name
  from table_a a
  join table_b on b.id = a.type_id
  where b.type_name = 'Type 1'
)
select tgt.name, src.name
  from all_type_1 tgt
  left join src_type_2 src on src.target_id = tgt.id

SELECT * FROM T 
WHERE  tog = 'yes' and val in (select val from t where tog='no')

UNION 

SELECT * FROM T 
WHERE  tog = 'no'  and val in (select val from t where tog='yes')

SELECT  table1.FullName
,       sub1.sum_points
,       table3.Name
,       sub2.sum_points
FROM    table1
JOIN    table3
ON      table1.ParentCustomerId = table3.AccountId
JOIN    (
        SELECT  Asp_SalemadebyId
        ,       SUM(Asp_PointsAwarded) sum_points
        FROM    table2
        GROUP BY
                Asp_SalemadebyId
        ) sub1 
ON      table1.ContactId = sub1.Asp_SalemadebyId
JOIN    (
        SELECT  Asp_PointsAwardedToId
        ,       SUM(Asp_PointsAwarded) sum_points
        FROM    table4
        GROUP BY
                Asp_PointsAwardedToId
        ) sub2
ON      table1.ContactId = sub2.Asp_PointsAwardedToId
WHERE   table3.asp_mimanagerid = '10CACCBD-70A7-DD11-9C65-001EC9B77038')

DECLARE @Sql varchar(50) = 'TEST|00000298398293|EQ5|Patient'


SELECT
    PARSENAME(REPLACE(@sql,'|','.'),4),
    PARSENAME(REPLACE(@sql,'|','.'),3),
    PARSENAME(REPLACE(@sql,'|','.'),2),
    PARSENAME(REPLACE(@sql,'|','.'),1)

SELECT  AVG(period)
FROM    (
        SELECT  TIME_TO_SEC(TIMEDIFF(@date_posted, date_posted)) AS period,
                @date_posted := date_posted
        FROM    (
                SELECT @date_posted := NULL
                ) vars,
                messages
        ORDER BY
                date_posted
        ) q

{% for item in query_results %}
    <tr>
        <td>{{ item.name }}</td>
        <td>{{ item.definition }}</td>
        <td>{{ item.fundstellen }}</td>
        <td>{{ item.wissenswertes }}</td>
        <td>
            {% for tag in item.tags.all %}
                {{ tag }}
            {% endfor %}
        </td>
    </tr>
{% endfor %}

    SELECT fp.id, 
           usr.id as UserID, 
           usr.firstname,
           usr.lastname, 
           c.id as CourseID, 
           c.fullname, 
           c.idnumber, 
           fd.name, 
           fd.timemodified as DiscussionCreatedOn, 
           fp.created AS TimeofPost, 
           fp.modified, 
           fp.subject, 
           fp.message
      FROM mdl_forum_posts fp
INNER JOIN mdl_forum_discussions fd ON fp.discussion = fd.id
INNER JOIN mdl_forum f ON f.id = fd.forum
INNER JOIN mdl_course c ON f.course = c.id 
INNER JOIN mdl_user usr ON fp.userid = usr.id
     WHERE EXISTS (SELECT 1 
                     FROM mdl_user_enrolments ue
               INNER JOIN mdl_enrol e ON ue.enrolid = e.id 
                    WHERE usr.id = ue.userid 
                      AND e.courseid = f.course)

WITH tblB AS (
  SELECT 1 CountryID, 'England' Country FROM dual
  UNION
  SELECT 2 CountryID, 'Wales' Country FROM dual
  UNION
  SELECT 3 CountryID, 'Scotland' Country FROM dual
  UNION
  SELECT 4 CountryID, 'Ireland' Country FROM dual
), tblC AS (
  SELECT 1 StudentID, 1 CountryID, 'ABC-Student' Student FROM dual
  UNION
  SELECT 2 StudentID, 2 CountryID, 'XYZ-Student' Student FROM dual
), tblA AS (
  SELECT 1 SchoolID, 3 CountryID, 1 StudentID, 'ABC-School' School FROM dual
  UNION
  SELECT 2 SchoolID, 4 CountryID, 2 StudentID, 'XYZ-SChool' School FROM dual
)
SELECT a.SchoolID, a.School, b.Country, c.Student, b2.Country     Student_Country
FROM tblA a 
JOIN tblB b ON b.CountryID = a.CountryID
JOIN tblC c ON c.StudentID = a.StudentID
JOIN tblB b2 ON b2.CountryID = c.CountryID

WITH cte AS (
  -- Base condition, where do we start the search?
  SELECT t.* FROM tblPartTable t WHERE t.PartNumber = '100X'
  UNION ALL
  -- Continue condition, how do we find the next part from the current one?
  SELECT t.* FROM tblPartTable t JOIN cte ON t.PartNumber = cte.NextPartNumber
)
SELECT partnumber, active FROM cte;

select min(DateAndTime) as minDateAndTime, max(DateAndTime) as maxDateAndTime
from (select pt.*,
             sum(case when datediff(second, prevdt, DateAndTime) <= 1 then 0 else 1 end) over 
                 (order by DateAndTime) as grp
      from (select pt.*, lag(DateAndTime) over (order by DateAndTime) as prevdt
            from ProductTracker pt
            where LineFaultStatus = 1 and
                  DateAndTime > '2014-04-07 8:00:00' and
                  DateAndTime < '2014-04-07 17:00:00'
           ) pt
     ) pt
group by grp
order by 1;

SELECT SUM(Qty) as Qty,DATE_FORMAT(Date, '%b') Month from table
GROUP BY DATE_FORMAT(Date,'%Y-%m')

select  count(distinct author)
from    (
        SELECT  author
        FROM    comics 
        WHERE   author NOT IN ( SELECT email FROM bans ) 
        UNION ALL
        SELECT  email 
        FROM    users 
        WHERE   email NOT IN ( SELECT email FROM bans )
        ) as SubQueryAlias

SELECT ID, Name, Addr, PhoneNumber, Descr FROM CusInfo i
WHERE Type_ID = 'type_01' AND 
      3 = (select count(distinct case when c.Cri_ID in ('a','b') then 1
                                      when c.Cri_ID in ('c','d') then 2
                                      when c.Cri_ID in ('e','f') then 3
                                 end)
           from CusCri c
           WHERE c.Cus_ID = i.ID and c.Cri_ID in ('a','b','c','d','e','f') )

SELECT
   MONTH([Date]) [Month],
   YEAR([Date]) [Year],
   COUNT(*) [Total],
   COUNT(CASE WHEN Status IN ('Gone', 'Cancelled') THEN 1 END) [Lost],
   COUNT(CASE WHEN Status= 'Won' THEN 1 END) [Won]
FROM
   MyTable
GROUP BY
   MONTH([Date]),
   YEAR([Date])

select
    ic.UserName, 
    ic.primaryconsultantid, 
    ic.starters, 
    ic.[month],
    ic.[year],
    ic.totalvalue,
    cg.threshold as Threshold, 
    cgv.percentage as Percentage
from
(
    select
        u.username + ' ' + u.surname as UserName, 
        tt.primaryconsultantid, 
        count(tt.invoiceid) as starters,
        datename(mm, tt.invoiceissueddate) as [month], 
        datepartT(yy, tt.invoiceissueddate) as [year],
        cast(sum((tt.value / tt.exchangerate) * (tt.primaryconsultantperc / 100)) as numeric(8,2)) as totalvalue,
    from InvoiceCommissions as tt
        inner join Users as u on u.userid = tt.primaryconsultantid
    group by
        tt.primaryconsultantid, 
        datename(mm, tt.invoiceissueddate), datepart(yy, tt.invoiceissueddate),
        u.username + ' ' + u.surname
) as ic
    inner join commissionconsultants as cc on cc.userid = ic.primaryconsultantid
    inner join commissiongrades as cg on cg.gradeid = cc.gradeid
    inner join commissiongradevalues as cgv on cgv.gradeid = cc.gradeid and cgv.starters = ic.starters

SELECT k.KUNDENID AS ID, 
       vorname AS Vorname, 
       nachname AS Nachname, 
       LPAD(
         CONCAT(IFNULL(ROUND(SUM(Betrag), 2), 0), ' Euro')
       , 13, ' ') AS Gesamt  
FROM kunde k  
LEFT JOIN verkauf v ON k.KUNDENID = v.KUNDENID  
GROUP BY k.KUNDENID;

select r.* from R where R.a = 100

SELECT  SQL_CALC_FOUND_ROWS
    `contact_data`.`id`,
    `contact_data`.`name`,
    MAX(CASE WHEN fields.`key` = :field1 THEN fields.`value` END) AS `fields0`,
    MAX(CASE WHEN fields.`key` = :field2 THEN fields.`value` END) AS `fields1`,
    MAX(CASE WHEN fields.`key` = :field3 THEN fields.`value` END) AS `fields2`,
    ...etc...
    CONTACT_DATA_TAGS(
        GROUP_CONCAT(DISTINCT `contact_data_tags`.`name`),
        GROUP_CONCAT(DISTINCT `contact_data_assignment`.`user`),
        GROUP_CONCAT(DISTINCT `contact_data_read`.`user`)
    ) AS `tags`,
    GROUP_CONCAT(DISTINCT `contact_data_assignment`.`user`) AS `assignments`,
    `contact_data`.`updated`,
    `contact_data`.`created`
FROM
    `contact_data`
LEFT JOIN contact_data_tags ON contact_data.`id` = contact_data_tags.`data`
LEFT JOIN contact_data_assignment ON contact_data.`id` = contact_data_assignment.`data`
LEFT JOIN contact_data_read ON contact_data.`id` = contact_data_read.`data`
LEFT JOIN contact_data_fields AS fields
       ON contact_data.`id` = fields.`contact_data_id` 
...etc...
GROUP BY contact_data.`id`
ORDER BY `id` DESC

factory.selectFrom(ScoreCard.SCORE_CARD)
       .orderBy(OloScoreCard.SCORE_CARD_ID.cast(Integer.class).descending())
       .limit(0, 1);

select group_concat(sub)
from post
where cat = 1;

select set_vertica_options('EE','ENABLE_JOIN_SPILL');  

SELECT 
    one.id AS id,
    one.something1 AS something1,
    one.something2 AS something2,
    two.name AS name
FROM one
JOIN two ON one.id = two.id

  SELECT MemberId = y.i.value('(./text())[1]', 'nvarchar(1000)'),
         TokenId  = u.j.value('(./text())[1]', 'nvarchar(1000)')             
  FROM 
  ( 
    SELECT 
        m = CONVERT(XML, '<i>' 
            + REPLACE(MemberId, ',' , '</i><i>') 
            + '</i>').query('.'),
        t= CONVERT(XML, '<j>' 
            + REPLACE(TokenId, ',' , '</j><j>') 
            + '</j>').query('.')
    FROM member_tokens
  ) AS a 
  CROSS APPLY m.nodes('i') AS y(i)
  CROSS APPLY t.nodes('j') AS u(j)

KeyWords
----------
KeyWordId Int Identity(1,1)
KeyWord VarChar(200)

KeyFieldKeyWords
----------------
Keyfield Int
KeyWordId Int

select distinct on (name) id, name, version
from metadata
where name in ('foo', 'bar')
order by name, version desc

SELECT TableA.[Name] AS FirstName, TableB.LastName
FROM TableA 
  INNER JOIN TableB ON TableA.LastNameId = TableB.LastNameId

SELECT
    sfo.entity_id,
    sfo.increment_id,
    sfoi.name,
    sfoi.product_type,
    sfoi.price,
    sfoi.original_price,
    sfo.status,
    sfi.state
FROM
    sales_flat_order sfo
INNER JOIN
    sales_flat_order_item sfoi ON sfoi.order_id = sfo.entity_id
LEFT JOIN
    sales_flat_invoice sfi ON sfi.order_id = sfo.entity_id
ORDER BY
    sfo.entity_id DESC
LIMIT
    500

SELECT DISTINCT
    A.ID,
    A.SurveyID,
    A.PersonID,
    A.Answer,
    B.QuestionID,
    B.Question
FROM TblAnswers A INNER JOIN TblQuestion B
    ON A.QuestionID=B.QuestionID

SELECT  M.ID,
        M.Value,
        D.ID DETAILID,
        D.Value DetailValue,
        D.Date
FROM TABLE_MASTER M
LEFT JOIN ( SELECT *
            FROM TABLE_DETAIL1
            UNION ALL
            SELECT *
            FROM TABLE_DETAIL2) D
    ON M.ID = D.MASTER_ID

    select a.Id L,b.id R
      into #cross
      from MyTable a
inner join mytable b on a.id <= b.id

SELECT cm.*
FROM conversations_messages cm
JOIN conversations c ON cm.conversation_id = c.id
JOIN conversations_users cu ON cu.conversation_id = c.id
WHERE cu.user_id = 1
AND NOT EXISTS (    SELECT 'a'
                    FROM conversations_messages cm2
                    WHERE cm2.conversation_id = cm.conversation_id
                    AND cm2.created_at > cm.created_at
                    )
GROUP BY c.id

SELECT TO_CHAR(TRUNC(scheme.table.reg_date,'dd'),'DD.MM.YYYY') AS "DATE", COUNT(*)
FROM scheme.table
WHERE scheme.table.reg_date
BETWEEN TO_DATE('01.08.2013','dd.mm.yyyy') AND TO_DATE('28.08.2013','dd.mm.yyyy')
GROUP BY TRUNC(scheme.table.reg_date,'dd');

DECLARE @input XML = '<root>
 <log realm="ABC" at="Wed Oct 15 00:00:02 2014.211" lifespan="2279ms">
  <receive>
    <isomsg direction="IN">
      <header>6000911384</header>
      <field id="0" value="0800"/>
      <field id="3" value="980000"/>
      <field id="11" value="000852"/>
    </isomsg>
  </receive>
</log>
</root>'

SELECT
    At = xc.value('../../../@at', 'varchar(50)'),
    Lifespan = xc.value('../../../@lifespan', 'varchar(25)'),
    Direction = xc.value('../@direction', 'varchar(10)'),
    ID = XC.value('@id', 'int'),
    Value = xc.value('@value', 'varchar(25)')
FROM
    @Input.nodes('/root/log/receive/isomsg/field') AS XT(XC)

Private Sub Form_Current
  Laborer1.RowSource = ReferenceField.Value
  Laborer1.Requery 'I don't believe you need this, but you might.
End Sub

#!/bin/bash

result=$(sqlplus64 -S <username>/<password>@<IPADDRESS>/<SERVICENAME> << EOF
set serveroutput on;
begin
   dbms_output.put_line('hello '||'$0');
end;
/
exit;
EOF
)
echo "result=$result"

delete from your_table
where id not in
(
   select * from 
   (
      select id from your_table
      order by id desc
      limit 1000
   ) x
)

SELECT (EXISTS (SELECT 1 FROM test WHERE id = 100))::int;

DECLARE @CounterInitialValue INT
DECLARE @NewCounterValue INT
SELECT @CounterInitialValue = SELECT counter FROM MyTable WHERE MyID = 1234

-- do stuff with the counter value

UPDATE MyTable
   SET counter = counter + 1
WHERE
   MyID = 1234
   AND 
   counter = @CounterInitialValue -- prevents the update if counter changed.

-- the value of counter must not change in this scenario.
-- so we rollback if the update affected no rows
IF( @@ROWCOUNT = 0 )
    ROLLBACK

  SELECT *
    FROM DATA d
    JOIN USERS u ON u.user_id = d.user_id
   WHERE NOT EXISTS (SELECT NULL 
                       FROM DATA t
                      WHERE t.id = d.id
                        AND CONVERT('10:00:00', TIME) BETWEEN t.start_time AND t.end_time)
GROUP BY u.usrID

CREATE TABLE US_Address (
  AddressID int,
  Streetline varchar(80),
  City varchar(80),
  State char(2),
  ZIP char(5),
  StateName varchar(80),
  StateTax DECIMAL(5,2)
)

INSERT INTO tblSurveyReport(FirstName) SELECT FirstName FROM tblSurveyData where FirstColumn = 'A0'

INSERT INTO tblSurveyReport(MiddleName) SELECT MiddleName FROM tblSurveyData where FirstColumn = 'A1'

select max(ID) from [Table]

SELECT LENGTH(TRANSLATE(TO_CHAR(3.0123456789),'1234567890.-','1234567890')) 
FROM dual

with cte as(select *, ceiling(1.0 * row_number() over(order by Wins, Id) / 2) as rn 
             from Player)
select c1.Id, c1.Name, c2.Id, c2.name
from cte c1
join cte c2 on c1.rn = c2.rn and c1.Id > c2.Id;

SELECT dept.Name, COUNT(emp.id) as timesOccurring 
FROM departments dept
INNER JOIN employees emp
ON emp.dept_id = dept.id
GROUP BY dept.Name
ORDER BY timesOccurring 

select red, green, blue, count(*)
from t
group by red, green, blue;

SELECT COALESCE(UNIX_TIMESTAMP(Date(p.published_at)),0) as 'day', 
       COALESCE(SUM(case when p.status = 2 then p.value end),0) as 'total_accepted',
       COALESCE(SUM(case when p.status = 1 then p.value end),0) as 'total_open',
       COALESCE(SUM(case when p.status = 3 then p.value end),0) as 'total_declined',
       COALESCE(SUM(case when p.status !=0  then p.value end),0) as 'total_published'
FROM posts as p
WHERE p.published_at IS NOT NULL
GROUP BY DATE(p.published_at);

select *
from orders o1
where o1.city = 'Austin'
  and exists (select ordernumber
              from orders o2
              where o1.ordernumber = o2.ordernumber
              group by ordernumber
              having count(distinct city) >1)

20130320
2013-03-20
2013 mar 20
March 20, 2013
2013.03.20

SELECT GROUP_CONCAT(CONCAT('CF', CustomFieldID, ' AS `', CustomFieldName, '`')) INTO fieldNames
FROM qcdt_jobs_CustomFields
WHERE projectId = 181;

PREPARE stmt FROM CONCAT('SELECT JobID, ', fieldNames, ' Etc. FROM qcdt_jobs_customfields_181 where JobID=1');
EXECUTE stmt;

  select c.customerID, c.name, a.UAN, a.balance, a.overdraft
  From customer c join current_acc a
  on c.customerID = a.customerID and a ='current account'

friend_list = sqlexec "select user2_id from relations where user1_id = "
                      + current_user_id
photolist = []
for friend in friend_list:
    photolist += sqlexec "select user_id, id, date_uploaded from photos"
                 + " where user_id = "
                 + friend.get("user2_id")
                 + " order by date_uploaded desc fetch first 3 rows only"

# Now do something with photolist

IF NOT EXISTS(SELECT 1 FROM [MyDB].[dbo].[Accounts] WHERE MyID = @MyID)
    INSERT INTO [MyDB].[dbo].[Accounts]
        (MyID, Phone, MyDate, Agent, Charge, Vendor)
        VALUES 
        (@MyID, @Phone, @MyDATE, @Agent, @Charge, @Vendor)

SELECT *
FROM Patients p
WHERE 
    DATEDIFF(d, 
             (SELECT MIN(AppointmentDate) FROM Appointments a WHERE a.PatientID = p.PatientID),
             (SELECT MAX(AppointmentDate) FROM Appointments a WHERE a.PatientID = p.PatientID)) >= 365

select a.col1, a.col2, b.col1, b.col2, c.col1, c.col2
 from view a, view b, view c
 where a.col3 = 1
  and  b.col3 = 2
  and  c.col3 = 3

SELECT ID, z.cnt
FROM mytable
CROSS APPLY (SELECT COUNT(*) AS cnt 
             FROM (VALUES (x1), (x2), (x3), (x4)) x(y)
             WHERE x.y > 0) z

SELECT COUNT(*)
FROM jwemaildb.LogFileRecords
WHERE
    date > = DATEADD(month, DATEDIFF(month, 0, GETDATE())-1, 0) AND
    date <  DATEADD(month, DATEDIFF(month, 0, GETDATE()), 0) AND
    CAST(RIGHT(eAlertSentDate, 4) + LEFT(eAlertSentDate, 4) AS date) BETWEEN       
    DATEADD(dd , 1 - DAY(GETDATE()), DATEADD(mm, -1 ,GETDATE())) AND
    DATEADD(dd , 1 - DAY(GETDATE()), GETDATE())

set @isweekday=case when (DATEPART(dw, @tempdate) + @@DATEFIRST) % 7 NOT IN (0, 1) then 1 else 0 end

SELECT      TblLoan.LoanID,
            TblCustomer.LastName,
            Payment.TotalPaid AS Payments, 
            Nz(TblLoan.FutureValue) - Nz(Payment.TotalPaid) AS Balance
FROM        TblLoan 
LEFT JOIN   (
                SELECT  LoanID,
                        sum(TotalAmount) as TotalPaid 
                FROM    TblPayment group by LoanID
            )  AS Payment 
        ON  Payment.LoanID = TblLoan.LoanID 
LEFT JOIN   TblCustomer ON TblLoan.CustomerID = TblCustomer.CustID
WHERE       Nz(TblLoan.FutureValue) - Nz(Payment.TotalPaid) <= 0;

SELECT TOP 1 ID, COUNT(*) AS CountOfRows
FROM UnknownTable
GROUP BY ID
ORDER BY CountOfRows DESC

SELECT `activities`.*, `admins`.`admin_role_id`
FROM (`activities`)
LEFT JOIN `admins` ON `admins`.`activity_id`=`activities`.`id` AND admins.member_id=27500
    JOIN (`transactions_items`
    JOIN `transactions` ON `transactions`.`id` = `transactions_items`.`id`
    JOIN `products` ON `products`.`id` = `transactions_items`.`product_id`)
ON `activities`.`id`=`products`.`activity_ID`
WHERE `transactions`.`member_id` =  27500
AND `activities`.`active` =  1

SELECT FirstName, LastName, Line1, City, State, ZipCode
FROM Customers JOIN Addresses
ON (Customers.ShippingAddressId = Addresses.AddressID);

select * 
from session_actions 
where find_in_set(`action_type`,'login_failed,channel_recorded');

select t1.id,t1.values,t2.values from
table1 t1 
left outer join
table t2 on nvl(t1.id,0)=nvl(t2.id,0)

SELECT 'MYTABLE_A' AS MYTABLENAME, CASE WHEN EXISTS
                   ( SELECT *
                     FROM MYTABLE_A
                     WHERE timestamp = to_char(sysdate-1, 'yyyymmdd') || '0000'
                   )
            THEN 0
            ELSE 1
       END AS FLAG_MYTABLE_A
from DUAL
UNION ALL
SELECT 'MYTABLE_B' AS MYTABLENAME, CASE WHEN EXISTS
                   ( SELECT *, timestamp
                     FROM MYTABLE_B
                     WHERE
                     timestamp = to_char(sysdate-1, 'yyyymmdd') || '0000'
                   )                       )
            THEN 0
            ELSE 1
       END AS FLAG_MYTABLE_B
from DUAL;

Select Name, sum(case when DayAci = 'Sunday' then 1 else 0 END) as Sunday,
       sum(case when DayAci = 'Monday' then 1 else 0 END) as Monday,
       sum(case when DayAci = 'Tuesday' then 1 else 0 END) as Tuesday,
       sum(case when DayAci = 'Wednesday' then 1 else 0 END) as Wednesday,
       sum(case when DayAci = 'Thursday' then 1 else 0 END) as Thursday,
       sum(case when DayAci = 'Friday' then 1 else 0 END) as Friday,
       sum(case when DayAci = 'Saturday' then 1 else 0 END) as Saturday,
       count(*) as Total, max(cap.prevTotal) as prevTotal
 from Caraccident ca left outer join
      (select cap.name, count(*) as prevTotal
       from CaraccidentPrev cap
       where cap.Accident = 'Near-miss'
       group by cap.name
      ) cap
      on cap.name = ca.name
 where Accident = 'Near-miss'
 group by Name;

DECLARE @tempString AS varchar(max)
SET @tempString =''

;WITH firstCte AS
(
    SELECT
        CAST('<M>' + REPLACE(contactpeopleids, ',','</M><M>') + '</M>' AS XML) AS Names
    FROM
        soTable1

    -- THIS WHERE CLAUSE MUST MATCH THE FINAL WHERE CLAUSE
    WHERE
        name = 'John'
        AND surname = 'Cobaing'
)
,secondCte AS
(
    SELECT
        Split.a.value('.','VARCHAR(100)') AS NameIds

    FROM
        firstCte

    CROSS APPLY Names.nodes('/M') Split(a)
)
,thirdCte AS
(
    SELECT
        t2.name + ' ' + t2.lastname AS theContactName

    FROM
        secondCte t1

    -- NOTE: IF THE IDS YOU EXTRACT FROM TABLE 1 DO NOT HAVE A MATCH IN TABLE 2 YOU WILL GET NO RESULT FOR THAT ID HERE!
    -- IF YOU WANT NULL RESULTS CHANGE THIS TO A 'LEFT JOIN'    
    INNER JOIN
        soTable2 t2 ON t1.NameIds = t2.id
)
SELECT
    @tempString = @tempString + ',' + theContactName

FROM
    thirdCte

;
-- The select substring is used to remove the leading ',' 
SELECT 
    name,
    surname,
    age,
    location,
    SUBSTRING(@tempString,2,LEN(@tempString)) AS contactpeoplenames

FROM
    soTable1

WHERE
    name = 'John'
    AND surname = 'Cobaing'

select
    (select name
        from table2 where id = (
        select top 1 arr_id
        from table1
        group by arr_id
        order by count(*) desc)
    )  as most_arrivals,
    (select name
        from table2 where id = (
        select top 1 dep_id
        from table1
        group by dep_id
        order by count(*) desc)
    ) as most_departures

;with pc as (
    select p.personid, tc.titleid, count(*) as cnt_pc
    from person p
    inner join personcertification pc on p.personid = pc.personid
    inner join titlecertifications tc on pc.certificationid = tc.certificationid
    group by p.personid, tc.titleid
),
tc as (
    select t.titleid, count(*) as cnt_tc
    from title t
    inner join titlecertifications tc on t.titleid = tc.titleid
    group by t.titleid
)
select p.firstname, t.shortname
from pc
inner join tc on pc.titleid = tc.titleid
inner join person p on pc.personid = p.personid
inner join title t on pc.titleid = t.titleid
where cnt_pc = cnt_tc

SELECT userid 
FROM   (SELECT userid, 
               YEARWEEK(TIMESTAMP)                  AS year_week, 
               COUNT(DISTINCT DAYOFWEEK(TIMESTAMP)) AS check_in_days 
        FROM   checkins 
        WHERE  1 = 1 -- This would be your date range filter 
        GROUP  BY userid, 
                  YEARWEEK(TIMESTAMP) 
        HAVING check_in_days BETWEEN 3 AND 5) AS user_weeks 
GROUP  BY userid 
HAVING COUNT(year_week) = (SELECT COUNT(*) 
                           FROM   year_week 
                           WHERE  1 = 1 -- This would be your date range filter 
                          ); 

DELIMITER $$

CREATE TRIGGER adresse_trigger_insert_check
 BEFORE INSERT ON adresse
 FOR EACH ROW BEGIN
 IF NEW.land IS NULL THEN
  SET NEW.land := 'XY';
 END IF;
END$$

DELIMITER ;

DECLARE @date AS DATETIME
SET @date = '2014-01-01'
SELECT 'SELECT ''' + OBJECT_NAME(object_id) + ''' AS [Table], COUNT(*) AS [Count] FROM [' + OBJECT_NAME(object_id) + '] WHERE [created] <= ''' + CONVERT(VARCHAR, @date, 20) + '''' FROM sys.columns WHERE name = 'created'

insert /*+ IGNORE_ROW_ON_DUPKEY_INDEX(table_name index_name) */
into table_name
select * ...

select sum(row_size) 
from (
  select 
    char_length(column1)+
    char_length(column2)+
    char_length(column3)+
    char_length(column4) ... <-- repeat for all columns
  as row_size 
  from your_table
) as tbl1;

ALTER PROC [dbo].[SPFetchAllDisActiveUser]
(
    @StartRowIndex INT,
    @MaxRows INT
)
AS

BEGIN

SELECT * FROM
(
    SELECT *, ROW_NUMBER() OVER(ORDER BY [User-ID] ASC) AS RowNum 
    FROM [User-Tbl]
    WHERE [Gu-Id] IS NULL
) AS DisActiveUser
WHERE RowNum BETWEEN @StartRowIndex + 1 AND @MaxRows;

END

SELECT t.* FROM comment c
LEFT JOIN read_message rm ON c.id-rm.cid
WHERE c.author!=2 AND rm.User=2 AND c.tid=17 AND rm.Topic=17 AND
(c.Original_Date BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW())
OR (c.last_update BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW())

UPDATE status
SET description = SUBSTRING(description,1,CHARINDEX('abc',description)-1) 
                  + 'def' + 
                  SUBSTRING(description,CHARINDEX('abc',description)+CHAR_LENGTH('abc'),CHAR_LENGTH(description)-CHARINDEX('abc',description))
WHERE name = 'test'

SELECT  * 
FROM   table1 t1
  JOIN table2 t2  ON t1.sid = t2.sid
  JOIN table3 t3 ON t2.referencedid = t3.referencedid
WHERE  // here you can add your criteria if you have

SELECT DISTINCT name from `Student` WHERE `name` REGEXP '[ae]'

select col_1,
       col_2
  from tbl_a A
          inner join
       tbl_b B
          on A.col_1 = B.col_1
             and A.col_2 = B.col_2
          left join
       ( select col_1,col_2 from tbl_c where clo_c_1 <> '1' ) C
          on
             C.col_2 = A.col_2

  SELECT (
    SELECT
      [customer]
     ,( SELECT
          [id] AS [@id],
          [Item] AS [data()]
        FROM @OrderDetail od
        WHERE od.fk_Order = ot.id
        FOR XML PATH('d'),TYPE
      )
    FROM @OrderTbl ot
    FOR XML PATH('c'),TYPE
  ) FOR XML PATH('b'), ROOT('a')

...
WHERE MONTH(MD.MD_DOB) > @StartMonth AND MONTH(MD.MD_DOB) < @EndMonth
OR (MONTH(MD.MD_DOB) = @StartMonth AND DAY(MD.MD_DOB) >= @Startday)
OR (MONTH(MD.MD_DOB) = @EndMonth AND DAY(MD.MD_DOB) <= @Endday)

procedure runproc (p_procname varchar2) is
begin
    execute immediate 'begin ' || p_procname || '; end;';
end;

  select t.candidateid ,  @curRank := @curRank + 1 AS rank, if(@prevote=-1, 0,@prevote-t.num) as sub, @prevote:=t.num as num
    from 
    (
    SELECT    candidateid,
            count(*) as num
    FROM      vote p
    group by candidateid
    ORDER BY  num desc
    ) t, (SELECT @curRank := 0, @prevote:=-1) r

SELECT
  cmsdocument.internaldocid,
  cmsdocument.documentid,
  cmsdocument.versionid,
  cmsdocversion.title,
  string_agg(cmstag.tagname, ',')
FROM 
  public.cmsobjecttag,
  public.cmstag,
  public.cmsdocument,
  public.cmsdocversion,
  public.cmsuser
WHERE 
  cmsobjecttag.tagid = cmstag.tagid AND
  cmsobjecttag.objectid = cmsdocument.internaldocid AND
  cmsdocument.internaldocid = cmsdocversion.internaldocid AND
  cmsdocument.userid = cmsuser.userid AND
  cmsdocversion.state = 'published' AND
  cmsobjecttag.objecttype = '102'
GROUP BY 
  cmsdocument.internaldocid,
  cmsdocument.documentid,
  cmsdocument.versionid,
  cmsdocversion.title

WITH src AS (
  SELECT level id
    FROM dual
 CONNECT BY level <= 5)
SELECT nvl(ent_id, 'Not Found' )
  FROM src
       LEFT OUTER JOIN tc_logs ON (src.id = tc_logs.ent_id)

WITH cte AS 
(
SELECT 
    t.TaskID
    ,t.Title
    ,t.ParentID 
    ,CONVERT(VARCHAR(MAX),'') AS [Path]
FROM 
    tasks.Tasks t
WHERE 
    t.ParentID IS NULL
    AND t.TaskID = @TaskID

UNION ALL

SELECT 
    sub.TaskID 
    ,sub.Title 
    ,sub.ParentID 
    ,cte.[Path] + '->' + CONVERT(VARCHAR(MAX),sub.TaskID) AS [Path]
FROM 
    tasks.Tasks sub
    INNER JOIN cte ON cte.TaskID = sub.ParentID
)

SELECT 
    cte.TaskID
    ,cte.Title
    ,cte.ParentID
    ,CONVERT(VARCHAR(MAX),@TaskID) + cte.[Path] AS [Path]
FROM 
    cte

select date_format(Release, '%d.%m.%Y')
from movies

WITH RECURSIVE list AS (
  SELECT PK, Name
  FROM A
  WHERE PK = 1
  UNION ALL
  SELECT A.PK, A.Name
  FROM list
  JOIN B ON list.PK = B.FK1
  JOIN A ON B.FK2 = A.PK
)
SELECT * FROM list;

select m.*, ms.TotalValue
from MyTable m
inner join (
    select [Order], sum(Price * Quantity) as TotalValue
    from MyTable
    group by [Order]
) ms on m.[Order] = ms.[Order]

select t1.a, min(t2.a), t1.b
from table_1 t1
    inner join table_1 t2 on t2.a > t1.a
group by t1.a, t1.b

with source as (
SELECT adr.nad_nkt_id id1, firmenadr.nad_nkt_id id2 FROM nav_adressen adr,
  nav_kontakte kontakt, nav_kontakte firma, nav_adressen firmenadr WHERE 
    kontakt.nkt_id = adr.nad_nkt_id AND
    firma.nkt_id (+)= kontakt.nkt_nkt_id AND
    firmenadr.nad_id (+)= firma.nkt_id AND
    (firmenadr.nad_strasse like '%needle%' OR
     adr.nad_strasse like '%needle%')
)
select decode(x.l, 1, a.id1, 2, a.id2) as id
  from source a
 cross join (select level as l from dual connect by level <=2) x

SELECT TOP 10 usr.firstname, usr.lastname, count(doc.modifiedBy) AS modified_items, count(doc.createdDate) AS created_items, (count(doc.modifiedBy)) + (count(doc.createdDate)) AS summed_items
FROM document doc
WHERE doc.active = 't' 
GROUP BY usr.firstname, usr.lastname
ORDER BY doc.modified_items DESC

FORTUNE_DB(ADMIN)=> select * from so;
                                                     COL1
--------------------------------------------------------------------------------------------------------------
This is sting one:Y,this is string Two:X,This is string Three:N,This is string four:N,This is string five:X,

FORTUNE_DB(ADMIN)=> select regexp_replace(col1,',[^(:N)]+:N','') from so;
                         REGEXP_REPLACE
-----------------------------------------------------------------
 This is sting one:Y,this is string Two:X,This is string five:X,

merge into
  tester
using (
  select 1 id,'0123456785' employee_phone_number from dual union all
  select 2 id,'0123456786' employee_phone_number from dual) new_values
on (
  tester.id = new_values.id)
when matched then update 
  set employee_phone_number = new_values.employee_phone_number;

SELECT CHR(1) FROM DUAL;

WHERE   person.personstatusuid = @StatusUID 
AND 	person.forename != '' 
AND 	(ISNULL(@Location,'') = '' OR person.Location = @Location)

DECLARE @company_id char(2)
SET @company_id = '02'
EXEC('CREATE TABLE CUSTOMER' + @company_id + ' (id int PRIMARY KEY)')

SELECT 
   T0.C0,
   T1.C0,
   T2.C0,
   CASE
      WHEN T1.C0 IS NULL
      AND T2.C0 IS NULL THEN 1
   END,
   CASE
      WHEN T2.C0 = 'NM' THEN 'New to PHI'
      WHEN T1.C0 IS NOT NULL
      OR T2.C0 IS NOT NULL THEN 'Transferred'
      ELSE 'New to PHI'
   END,
   T0.C1
FROM (
   SELECT DISTINCT
      "Memberships"."MemberNo" AS C0,
      COUNT("Memberships"."MemberNo") AS C1
   FROM "dbo"."Memberships"
   WHERE (
      "Memberships"."IsProspect" = N'N'
   )
   AND (
      (
         "Memberships"."PaidToDate" > "Memberships"."JoinDate"
         OR "Memberships"."HealthTermEntryDate" IS NULL
      )
      AND "Memberships"."JoinDate" BETWEEN '20150701 00:00:00.0' AND '20160630 23:59:59.997'
   )
   GROUP BY 
      "Memberships"."MemberNo"

) T0
LEFT OUTER JOIN (
   SELECT DISTINCT
      "MembershipPlans"."PrevFundID" AS C0,
      "Memberships"."MemberNo" AS C1
   FROM "dbo"."Memberships"
   INNER JOIN "dbo"."MembershipPlans"
   ON (
      "Memberships"."MemberNo" = "MembershipPlans"."MemberNo"
   )
   WHERE (
      "Memberships"."IsProspect" = N'N'
   )
   AND (
      "MembershipPlans"."IsPrevCover" IN (N'Y')
   )

) T1
ON T0.C0 = T1.C1
LEFT OUTER JOIN (
   SELECT DISTINCT
      "MembershipUDPs"."Property" AS C0,
      "MembershipUDPs"."MemberNo" AS C1
   FROM "dbo"."Memberships"
   LEFT OUTER JOIN "dbo"."MembershipUDPs"
   ON (
      "Memberships"."MemberNo" = "MembershipUDPs"."MemberNo"
   )
   WHERE (
      "Memberships"."IsProspect" = N'N'
   )
   AND (
      "MembershipUDPs"."PropertyID" IN (N'TF   ')
      AND "Memberships"."JoinDate" >= '20150608 00:00:00.0'
   )

) T2
ON T0.C0 = T2.C1

SELECT TO_CHAR(CURRENT_TIMESTAMP, 'DD/MON/YYYY');

Select .....
from ....
where (Status = @Status or @Status is null)
and (Created=@Created or @Created is null)
and (Release = @Release or @Release is null)
and (Date = @Date or @Date is null)

 $q = "SELECT * FROM football_1314_beacha_standings ORDER BY pct DESC, win DESC";

SELECT *
FROM information_schema.columns c with (Nolock)

select Location.Lat, Location.Long from GeographyTable

select users.user_id,l.login,p.points from users
inner join (select user_id, count(1) login from login
       group by login) as l on users.user_id=login.user_id
inner join (select user_id, sum(point) as point 
        from point group by user_id ) as p on users.user_id=point.user_id

SELECT  a.pname, b.rank, b.score
FROM    players a
        INNER JOIN player_stats b
            ON a.pid = b.pid
        INNER JOIN
        (
            SELECT  pid, MAX(statdate) statdate
            FROM    player_stats
            GROUP   BY pid
        ) c ON  b.pid = c.pid
                AND b.statdate = c.statdate

CREATE TEMP TABLE mapper (old_val CHAR(5) NOT NULL, new_val CHAR(5) NOT NULL);
...multiple inserts into mapper...
INSERT INTO mapper(old_val, new_val) VALUES('a.1', 'a1');
INSERT INTO mapper(old_val, new_val) VALUES('a-1', 'a1');
INSERT INTO mapper(old_val, new_val) VALUES('b.1', 'b1');
INSERT INTO mapper(old_val, new_val) VALUES('b-1', 'b1');
...etcetera...

UPDATE tbl
   SET title = (SELECT new_val FROM mapper WHERE old_val = tbl.title)
   WHERE title IN (SELECT old_val FROM mapper);

begin

  statement_zero;

  savepoint my_savepoint;

  begin
    -- if either of these fail, then exception section will be executed
    statement_one;
    statement_two;
  exception
     when others then
       rollback to my_savepoint;
  end;

  statement_three;

  commit;

end;

select brand from car
group by brand
having count(*) = (select count(*) from car where brand = 'Ferrari')

SELECT user, MIN(sn) range_start, MAX(sn) range_end
  FROM
(
  SELECT user, sn, @r := IF(@g = user, @r, @r + 1) range_num, @g := user
    FROM table1 CROSS JOIN (SELECT @r := 0, @g := NULL) i
   ORDER BY sn
) q
 GROUP BY user, range_num

import groovy.sql.Sql    
import oracle.jdbc.driver.OracleDriver

def dbServer = context.expand( '${#Project#dbServer}' )
def dbUser = context.expand( '${#Project#dbUser}' )
def dbPass = context.expand( '${#Project#dbPass}' )


def con = Sql.newinstance('dbServer, dbUser,
                              dbPass, "oracle.jdbc.driver.OracleDriver"')

def res = con.rows("select * from table1 where message_in = 'Bang'")

log.info(res[0])

con.close()

assert res[0] != null

SELECT property.property_id,
       bedrooms.value AS bedrooms,
       bathrooms.value AS bathrooms
FROM property,
     attribute AS bedrooms_attr,
     attribute_value AS bedrooms,
     property_attribute AS bedrooms_prop,
     attribute AS bathrooms_attr,
     attribute_value AS bathrooms,
     property_attribute AS bathrooms_prop
WHERE bedrooms_attr.name = 'bedrooms'
  AND bedrooms.attribute_id = bedrooms_attr.attribute_id
  AND bedrooms.attribute_value_id = bedrooms_prop.attribute_value_id
  AND bedrooms_prop.property_id = property.property_id
  AND bedrooms.value = 2
  AND bathrooms_attr.name = 'bathrooms'
  AND bathrooms.attribute_id = bathrooms_attr.attribute_id
  AND bathrooms.attribute_value_id = bathrooms_prop.attribute_value_id
  AND bathrooms_prop.property_id = property.property_id
  AND bathrooms.value = 2

    select pa.appointment_key, p.profile_key as Rep, p2.profile_key as Customer, 
        p.first_name as RepName,p2.first_name as CustomerName
from profile_appointment pa    
join profile_appointment pa2 on pa.appointment_key = pa2.appointment_key
join profile p    on p.profile_key = pa.profile_key    and  p.profile_type_key = '4'
join profile p2   on p2.profile_key = pa2.profile_key   and  p2.profile_type_key = '6'  

UPDATE Table1
SET 
    f2 = T2.f2, 
    f3 = convert(varchar, T2.f3, 101) 
FROM 
    Table1 T1
INNER JOIN 
    Server.DB.dbo.Table2 T2
ON 
    T1.f1 = T2.f1
WHERE 
    T2.f3 = (SELECT MAX(f3) FROM Server.DB.dbo.Table2 WHERE f1 = T1.f1)

SELECT fID_a FROM tbl
GROUP BY fID_a 
HAVING MAX(fID_b)=1
AND MIN(fID_b)=1

COUNT(CASE WHEN Bids.Burned=0 THEN 1 END) AS 'ActiveBids', 
COUNT(CASE WHEN Bids.Burned=1 THEN 1 END) AS 'BurnedBids'

SELECT 
* FROM Table 1
JOIN Table2 2 on 2.ID = Table1.ID
UNION
SELECT 
* FROM Table 1
JOIN Table2 22 on 22.ParentID = Table1.ID

UPDATE PlayerLeague AS l
    JOIN (
        SELECT p.player_id, @i := @i + 1 AS player_position
        FROM (
            SELECT ss.player_id
            FROM PlayerStat AS ss
                JOIN PlayerLeague AS ll
                    ON ss.player_id=ll.player_id
            WHERE ll.league_id=3
            ORDER BY ss.score DESC
        ) AS p, (SELECT @i := 0) AS tmp
    ) AS s ON s.player_id=l.player_id
SET l.player_position = s.player_position

SELECT Category AS 'Category/SubCategory', COUNT(*) AS 'Count'
FROM  Categories
GROUP BY Category

UNION

SELECT SubCategory AS 'Category/SubCategory', COUNT(*) AS 'Count'
FROM  Categories
GROUP BY SubCategory

declare @Foo as Table ( ColA Int, ColB Int );
insert into @Foo ( ColA, ColB ) values ( 1, 1 ), ( 1, 2 ), ( 2, 1 );
select * from @Foo;

select *
  from @Foo
  intersect
  select *
    from ( values ( 2, 1 ) ) as Bar( ColA, ColB );

 def escapeSQLDelimiters(dataToEscape: String) = {
    dataToEscape flatMap { c =>
      c match {
        case '\\' => "\\\\"
        case '\u0000' => "\\0"
        case '\n' => "\\n"
        case '\t' => "\\t"
        case '\r' => "\\r"
        case '\b' => "\\b"
        case '\'' => "\\\'"
        case '\"' => "\\\""
        case _ => c.toString
      }
    }
  }

var result = db.tbl_feesCollection.Max(element => element.VarInvoiceNo);

SELECT   JobCode, designation, SUM(salaryWithIncrement)
FROM     table1
GROUP BY JobCode, designation

SELECT distinct on (parent_id) 
    parent_id
  , version_id
FROM items
ORDER BY parent_id, version_id DESC

DECLARE @ActionNumber varchar(20)='EHPL-DES-SQ-1021'

declare @tmp table
(
    id int identity(1,1),
    item varchar(20)
)

insert into @tmp (item)
select * from dbo.ANOSplit(@ActionNumber,'-')

select * from @tmp where id in (2,3)

reportContext.getHttpServletRequest().getSession().getAttribute("db");

IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE 
id = OBJECT_ID(N'[dbo].[SomeStoredProcedure]') AND 
OBJECTPROPERTY(id,N'IsProcedure') = 1)

EXEC sp_executesql N'CREATE PROCEDURE [dbo].[SomeStoredProcedure] AS

SELECT ''SPROC Template'''

GO

SET ANSI_NULLS ON

GO

SET QUOTED_IDENTIFIER ON

GO

 ALTER PROCEDURE SomeStoredProcedure

SELECT * FROM image WHERE id NOT IN 
    (SELECT image_id FROM user_image WHERE user_id = THE_USER_ID);

INNER JOIN T_CASE CF ON
(
    A.AWESOME_ID = CF.AWESOME_ID    
    // Several more conditions
)
AND
(
        (
            @NEWPARAM = 1 AND
            cy.SOMEFLAG = 0 AND
            CF.SOMEDATE IS NOT NULL
        )
        OR
        (
            @NEWPARAM = 1 AND
            cy.SOMEFLAG = 1 AND
            CF.CASE_TYPE = 1 AND
            CF.SOMEDATE IS NOT NULL
        )
        OR
        (
            @NEWPARAM <> 1 AND
            cy.SOMEFLAG = 0 AND
            CF.SOMEDATE IS NULL
        )
        OR
        (
            @NEWPARAM <> 1 AND
            ((cy.SOMEFLAG = 1 AND CF.CASE_TYPE = 0) OR
             CF.SOMEDATE IS NULL
            )
        )
    )

select x from y
    where (( UPPER(d.Gender) = UPPER(@gender) OR  UPPER(d.Gender) ='EITHER') 
               AND @gender IS NOT NULL ) 
          OR (@gender IS NULL AND 1=1)

CREATE TRIGGER  trTriggerName  ON  tblNames   
 AFTER INSERT  AS  
UPDATE tblNames 
   SET UpFileName = replace(UpFileName,'%20','_') 
FROM tblNames t
JOIN INSERTED i ON t.ID = i.ID

EXEC sp_spaceused 'TableName'

DECLARE @x xml 
DECLARE @strXML varchar(MAX)
SET @x=N'<Employee><Name>Luftwaffe</Name></Employee>'
set @strXML = '<xml version="1.0" encoding="ISO-8859-1"/>' + CONVERT(varchar(MAX),@x)
SELECT @strXML  

;With Ordered as (
    select UserId,ContactType,ContactDetail,LoadDate,
          ROW_NUMBER() OVER (
                PARTITION BY UserID,ContactType
                ORDER BY LoadDate DESC) as rn
    from ContactDetails
)
select * from Ordered where rn = 1

SELECT  DAYNAME(sip_Date) AS DAY,
        COUNT(DISTINCT sip_callid)
FROM    request_line
WHERE DAYNAME(sip_Date) = 'Saturday' 
GROUP BY DAYNAME(sip_Date)

SELECT * FROM Product ORDER BY FIELD(CategoryID, 2, 5) DESC

CREATE TABLE таб1 (id int, name varchar(30)) CHARSET=utf8;

Select Distinct Top 1000000 tblAssets.AssetName,
(Select Case When tblRegistry.Value = '2' Then 'Notify Only'
  When tblRegistry.Value = '3' Then 'Download Notify'
  When tblRegistry.Value = '4' Then 'Scheduled'
  When tblRegistry.Value = '5' Then 'Download and Custom'
  Else tblRegistry.Value End As RegistryValue
From tblAssets As TA Left Join tblRegistry On tblRegistry.AssetID = TA.AssetID
Where tblRegistry.Valuename = 'AUoptions' And TA.AssetID = tblAssets.AssetID)
As AUOption
From tblAssets

WHERE datefieldsubquery = Convert(varchar(50),YEAR(GETDATE()))+'-12-31 23:59:00'

user_id   T1   T2   T3   T4
-------  ---  ---  ---  ---
   1      -2   0    0    0
   1       2   0    0    0
   2       1   0    0    0
   2       2   0    0    0

select sourceIP, sum(sourceBytes) TotalBytes
from flows 
group by sourceIP
having sum(SourceBytes) > 50
order by sum(sourceBytes) desc

select foreign_id 
from your_table
where string in ('house', 'window')
group by foreign_id
having count(distinct string) = 2;

select Distinct Meal from NewTab NT
where not exists 
   (select 1 from NewTab where NeededQty>AvailableQty 
    and NT.Meal = Meal);

select post_id,
       sum(case when ul_key = 'u_like' then ul_value else 0 end) as likes,
       sum(case when ul_key = 'u_dislike' then ul_value else 0 end) as dislikes
from wp_like_dislike_counters
group by post_id;

with todelete as (
      select t.*,
             row_number() over (partition by col1, col2, col3, . . . order by newid()) as seqnum
      from table t
     )
delete from todelete
    where seqnum % 2 = 0;

Dim dbs As DAO.Database
Dim rsTable As DAO.Recordset
Dim rsQuery As DAO.Recordset

Set dbs = CurrentDb

'Open a table-type Recordset
Set rsTable = dbs.OpenRecordset("tblSupeGenNotes", dbOpenDynaset)

'Open a dynaset-type Recordset using a saved query
Set rsQuery = dbs.OpenRecordset("qrySupeGenNotes", dbOpenDynaset)

'update the values vased on the contents of the form controls
rsQuery.Edit
rsQuery![NoteDate] = Me.tbxNoteDate
rsQuery![SupeType] = Me.cbxSupeType
rsQuery![SupeAlerts] = alrt
rsQuery![Note] = Me.tbxNote
rsQuery.Update

'clean up
rsQuery.Close
rsTable.Close
Set rsQuery = Nothing
Set rsTable = Nothing

;WITH d AS 
(
  SELECT TOP (366) d = DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY object_id), '20111231')
  FROM sys.all_objects
)
INSERT dbo.[a table]([Date])
  SELECT d FROM d 
  WHERE d NOT IN (SELECT [Date] FROM dbo.[a table])
  AND d <= DATEADD(DAY, 0-DATEPART(WEEKDAY, GETDATE()), GETDATE());

SELECT i.ItemName, i.CreateDate,
       (uc.LastName + ', ' + uc.FirstName) as [Created By Name], 
       i.CreatedBy, i.LastChanged,
       (ucb.LastName + ', ' + ucb.FirstName) as [Last Changed By Name],
       i.LastChangedBy
FROM Items i LEFT JOIN
     Users uc
     ON i.CreatedBy = uc.UserID LEFT JOIN
     Users ucb
     ON i.LastChangedBy = ucb.UserId
WHERE i.LastChangedBy = 0001;

        PoolingDataSource derbyDataSource1 = new PoolingDataSource();
        derbyDataSource1.setClassName("org.apache.derby.jdbc.EmbeddedXADataSource");
        derbyDataSource1.setUniqueName("derby1");  
        derbyDataSource1.getDriverProperties().setProperty("databaseName", "database1");
        derbyDataSource1.init();

        PoolingDataSource derbyDataSource2= new PoolingDataSource();
        derbyDataSource2.setClassName("org.apache.derby.jdbc.EmbeddedXADataSource");
        derbyDataSource2.setUniqueName("derby2");
        derbyDataSource2.getDriverProperties().setProperty("databaseName", "database2");
        derbyDataSource2.init();

        BitronixTransactionManager btm = TransactionManagerServices.getTransactionManager();

        btm.begin();
        try {
            Connection c1= derbyDataSource1.getConnection();
            Connection c2= derbyDataSource2.getConnection();

            /***Use c1 and c2 to execute statements again their corresponding DBs as usual**/


            btm.commit();
        } catch (SQLException ex) {
            ex.printStackTrace();
            btm.rollback();
        }

LOAD DATA LOCAL INFILE 'CategoryData.txt'
    REPLACE INTO TABLE db.Category(CategoryName)
    LINES STARTING BY '('
    LINES TERMINATED BY ')\n'
    FIELDS TERMINATED BY ','
    SET ID = NULL;

field FILLER,
col1 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\1')",
col2 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\2')",
col3 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\3')",
col4 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\4')",
col5 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\5')",
col6 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\6')"

SELECT TOP 1 MAX(e1.StartDate), COUNT(e2.eventID) FROM event e1
INNER JOIN event e2 
  on e1.StartDate BETWEEN e2.StartDate 
                      AND DATEADD(second,e2.Duration,e2.StartDate)
GROUP BY e1.EventID
ORDER BY COUNT(e2.eventID) DESC

select v1.word as word1, v2.word as word2
from verb v1 join
     verb v2
     on v1.word < v2.word
limit 10;

UPDATE [dbo].[ImageDocuments]
SET [dbo].[ImageDocuments].[OriginalFileName] = d.FileName,
    [dbo].[ImageDocuments].[StorageFileName] = d.RealName
OUTPUT INSERTED.ImageDocumentId
INTO @Ids
FROM [dbo].[ImageDocuments] as fu, 
     [dbo].[Documents] as d
WHERE fu.DocumentID = d.DocumentID;

DELETE FROM Documents
WHERE DocumentID IN (SELECT ImageDocumentId FROM @IDs);

SQL> with t1(Name1, LastName, tPoints, aPoints, sPoints, gPoints, type1) as(
  2  select 'John'  ,  'Johnny',  15,  14,  13,  10,   1  from dual union all
  3  select 'Joe'   ,  'P.'    ,  12,  11,  26,  10,   1  from dual union all
  4  select 'Matt'  ,  'Q.'    ,  11,  26,  37,  44,   2  from dual union all
  5  select 'Sorine',  'P.'    ,  55,  9 ,  8 ,  7,    2  from dual union all
  6  select 'Ali'   ,  'Ahmed' ,  30,  44,  88,  65,   2   from dual
  7  )
  8  select type1
  9       , tpoints
 10       , apoints
 11       , name1
 12       , Lastname
 13    from t1
 14   order by case when type1=1 then tpoints else type1 end desc,
 15            case when type1=2 then apoints else type1 end desc;

     TYPE1    TPOINTS    APOINTS NAME1  LASTNAME
---------- ---------- ---------- ------ --------
         1         15         14 John   Johnny
         1         12         11 Joe    P.
         2         30         44 Ali    Ahmed
         2         11         26 Matt   Q.
         2         55          9 Sorine P.

UPDATE mytable
SET [date] = DATEADD(DAY, 7, [date])
WHERE [date] >= '2014-02-20' AND [date] < '2014-02-21'

CREATE TABLE Example (
    _id INTEGER PRIMARY KEY,
    name TEXT,
    index INTEGER,
    score INTEGER,
    UNIQUE (name, index) ON CONFLICT REPLACE
)

select T2.id,
       coalesce((T1.classement=T2.classement),0)+
       coalesce((T1.aptitude=T2.aptitude),0)+
       coalesce((T1.A=T2.A),0)+
       coalesce((T1.B=T2.B),0)+
       coalesce((T1.C=T2.C),0) match_count
from Temp T1
cross join Temp T2
where T1.id = 1 and T2.id <> 1 
order by 2 desc

select * from Users left outer join School on Users.Schoolid = School.Schoolid

SELECT to_char(d.day, 'YYYY/MM/DD" - "')
    || to_char(d.day + 6, 'YYYY/MM/DD') AS week
     , count(situation ILIKE '%active%' OR NULL) AS activated
     , ...
FROM   (
   SELECT day::date
   FROM   generate_series('2014-08-11'::date
                        , '2014-09-14'::date
                        , '1 week'::interval) day
   ) d
LEFT   JOIN account_details a ON a.date_opened >= d.day 
                             AND a.date_opened <  d.day + 7  -- 7, not 6!
GROUP  BY d.day;

$object_id = 2;

Doctrine::getTable('Tagset')->createQuery('t')
  ->select('t.tag_id, o.id, o.name, COUNT(t.tag_id) AS tag_count')
  ->innerJoin('t.Object o WITH o.id != ?', $object_id)
  ->where('t.tag_id IN (SELECT t.tag_id FROM Tagset t WHERE t.object_id = ?)', $object_id)
  ->groupBy('t.object_id')

select district,
  sum(case when sex ='M' then 1 else 0 end) M,
  sum(case when sex ='F' then 1 else 0 end) F,
  sum(case when sex ='NI' then 1 else 0 end) NI
from table1
group by district
order by district

SELECT  
 i.equip_pk,
 i.request_pk, 
 NVL(MY_ALIAS.EQUIP_ALIAS_ID, 'Nothing'
 FROM tableOne i
 LEFT OUTER JOIN table2 MY_ALIAS ON (i.EQUIP_PK = MY_ALIAS.EQUIP_PK)
 WHERE i.request_pk=:requestPk 

echo.If @intA ^<^> @intB> "C:\output_file.txt"

SELECT EID, SUM(PCNUM) FROM table1
GROUP BY EID;

DECLARE @path NVARCHAR(500) = 'F:\Fruit Seeds-Category Oil\Quality- Fine Seeds';

DECLARE @i  INT = 1;
DECLARE @ix INT = 0;

WHILE @i > 0
BEGIN
    SET @ix = @i;
    SET @i = CHARINDEX('-', @Path, @i + 1);
END

SELECT LEFT(@path, @ix - 1)

-- assume @dbname has the name of the database where getdetails was created
declare @sql nvarchar(4000), @params nvarchar(4000), @dbname sysname
set @dbname = 'test'
set @sql = @dbname + '..getdetails'
set @params = ''
exec sp_executesql @sql, @params

select (case when (1 < 2) then 'True' else 'False' end) as one,
       (case when (1 > 2) then 'True' else 'False' end) as two
from table

INSERT INTO software(Name, Type)
SELECT (CAST(Name as nvarchar), Type)
FROM serials (ProductName, Type)

select round(123.456, 2, 1)

  String hqlQuery =" SELECT message  FROM     p_message  pm WHERE pm.message_id in (SELECT a.scene FROM p_config a INNER JOIN  p_rec_type b  ON a.email_id=b.email_id AND rec_type =:rectype          WHERE a.email_type=:emailTYpe)"; 
    query = session.createQuery(hqlQuery);
    query.setParameter("rectype", 2);
    query.setParameter("emailTYpe", 1);

select prs.id, prs.name, count(*) from Person prs
join(select process_no, id
     from  Responsible res 
     Union all
     select process_no, id
     from  Linked  lin ) a on a.id=prs.id
group by prs.id, prs.name

String filter = "hachiko"
def hero = Hero.createCriteria().list {
    familiar {
        like('name', filter)
    }    
}

select cu.cust_id, cu.cust_name, ci.location
  from cinema ci
  join booking b
    on ci.c_id = b.c_id
  join customer cu
    on b.cust_id = cu.cust_id
 where ci.location <> 'Paris'

SELECT car.name, testresults.testname, isnull(testresults.result, 0) FROM 
cars CROSS JOIN
safetytests
LEFT JOIN testresults on safetytests.testid = testresults.testid AND car.id = testresults.carid

create or replace view state_city_view as
select state_name as name, '' as parent_name 
from state
union all
select city_name || ' ' || population name, state_name as parent_name
from city;

select
    a.ID as "Article-Number", a.Name as "Name"
from
    Articles a
where
    (a.ID = '3264')

declare o CURSOR FAST_FORWARD FOR
select comments from EVENT

declare @comment nvarchar(max)

OPEN o FETCH NEXT FROM o into @comment

while @@FETCH_STATUS = 0
BEGIN
Declare @item nvarchar(750)

declare @tbl Table(Category nvarchar(250), Description nvarchar(250), Quantity nvarchar(250), Value DECIMAL(10,2))

declare c CURSOR FAST_FORWARD FOR
SELECT items FROM dbo.Split(@comment, Char(10))

OPEN c FETCH NEXT FROM c into @item

WHILE @@FETCH_STATUS = 0
BEGIN
    set @item = @item + ':'
    insert into @tbl
    Values (LTRIM(RTRIM(SUBSTRING(@item, 1, CHARINDEX(' - ', @item) - 1))),
            CASE when @item like '%D:%' Then LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('D:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('D:', @item)+2) - CHARINDEX('D:', @item) - 3))) else '' end,
            CASE when @item like '%Q:%' Then LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('Q:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('Q:', @item)+2) - CHARINDEX('Q:', @item) - 3))) else '1' end,
            CASE when @item like '%V:%' Then CONVERT(DECIMAL(10,2),dbo.RemoveNonNumericCharacters(LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('V:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('V:', @item)+2) - CHARINDEX('V:', @item) - 3))))) else 0 end)
    FETCH NEXT FROM c into @item
END
CLOSE c DEALLOCATE c
END
CLOSE o DEALLOCATE o
SELECT * FROM @tbl

WITH RECURSIVE year_table(n) AS (
    SELECT 1000
  UNION ALL
    SELECT n+1 FROM year_table
)
SELECT Id, To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY')
  FROM Feasts
 WHERE To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY') >=
       Date_From
   AND To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY') <= Date_To
   AND YEAR IS NOT NULL
UNION
SELECT Feasts.Id,
       To_Date(DAY || ' ' || MONTH || ' ' || Year_Table.n, 'DD MM YYYY')
  FROM Feasts, Year_Table
 WHERE n >= To_Char(Date_From, 'YYYY')
   AND n <= To_Char(Date_To, 'YYYY')
   AND Feasts.YEAR IS NULL;

 select 'text1' text,
        SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla,        
        SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla,
        SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba        
    from 
    table1
    UNION ALL
    select 'text2' text,
        SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla,        
        SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla,
        SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba        
    from 
    table2
    UNION ALL
    select 'text3' text,
        SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla,        
        SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla,
        SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba        
    from 
    table3

select count(*) from BadWords
where @userName like '%'+theBadWord+'%'

select * from openquery
 ( myLinkedServer
  ,'Select * from mySQLTables where complicated joins/filters')

SET @parentID = parentId;

    <WebMethod()> Public Function LookupItem(ByVal strUPC As String) As DataSet
    Try
        Dim connUPC As New Data.SqlClient.SqlConnection
        Dim cmdUPC As New Data.SqlClient.SqlCommand
        Dim daUPC As New Data.SqlClient.SqlDataAdapter
        Dim dsUPC As DataSet = New DataSet
        Dim ConnectionString As String = "Data Source=localhost\db;Initial Catalog=DB_SQL;Persist Security Info=True;User ID=myID;Password=myPass"
        Dim strSQL As String = "SELECT Inv_Qty.*,PLU.*,PLU.PLU_NUM, PLU.DEPT_NUM From PLU INNER JOIN Inv_Qty ON PLU.PLU_NUM=Inv_Qty.PLU_NUM WHERE ((PLU.PLU_NUM) = '" & strUPC & "');"

        '// Opening the connection
        connUPC.Open()
        cmdUPC.Connection = connUPC
        cmdUPC.CommandText = strSQL

        daUPC.SelectCommand = cmdUPC
        daUPC.Fill(dsUPC)

        connUPC.Close()
        connUPC = Nothing

        Return dsUPC
    Catch ex As Exception

    End Try
End Function

using (
    select 1 as ana_rb, 1 as ana_id,
           'da' as ana_kupanje, 'da' as ana_kosa, 'da' as ana_brijanje,
           'da' as ana_zubi, 'da' as ana_nokti, 'da' as ana_odjeca,
           'da' as ana_koza, 'da' as ana_dek_rizik, 'da' as ana_dek_rizik_gdje,
           'da' as ana_dek_postojeci, 'da' as ana_dek_post_gdje,
           'da' as ana_pokretnost, 'da' as ana_kolica, 'da' as ana_pomagala,
           'veki' as azurirao, getdate() as datumazur
) e

SELECT to_char(o.date_order, 'DD-MM-YYYY') AS date_order
        , sum(o.amount_total) AS amount
FROM public.sale_order o
WHERE EXISTS ( SELECT *
        -- These tables probably have an N:1 relation
        -- to public.sale_order
        -- We don't have to sum them; just check existence.
        FROM public.sale_order_line l
        JOIN public.product_product pp ON pp.id = l.product_id
        JOIN public.product_template pt ON pt.id = pp.product_tmpl_id
        JOIN public.product_category pc ON pc.id = pt.categ_id
        WHERE pc.name = 'Starchi'
        AND l.order_id = o.id
        )
  AND o.order_year = '2015'
  AND o.order_month = 'April'
GROUP BY o.date_order
ORDER BY o.date_order ASC
        ;

SELECT *
FROM    Services
WHERE   Service IN (1, 3)
AND     pay_date > '2014-07-01'
AND     pay_date < '2014-07-30'
AND     NOT EXISTS 
        (   SELECT  1 
            FROM    services AS s2 
            WHERE   s2.Name = s.Name 
            AND     s2.Status = 1 
            AND     s2.Service IN (1, 3)
            AND     s2.pay_date > '2014-07-01'
            AND     s2.pay_date < '2014-07-30'
        );

SELECT SUM(amount)
FROM sales_orders 
WHERE date BETWEEN '2011-03-06' and '2011-04-06' -- not sure what your date is.

select min(value) 
from table
where value <> (
 select min(value) form table
);

with t as (
      select '12:10:08: Dialing12:10:08: Connecting12:10:08: ABC: abc:9433769781$100.88.77.0:878712:10:08: ABCD: 000012:10:09: Agent Initializing12:10:25: On Call12:10:25: Assigned to operator12:10:25: Waiting for Supervisor12:10:30: Waiting for Manager12:11:30: Call Ended12:11:30: Call Not connected.. ' as col
     ),
     cte as (
      select left(t.col, 9 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(t.col, 11, 1000))) as val,
             substring(t.col, 10 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(t.col, 11, 1000)), 1000) as rest
      from t
      where t.col like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %'
      union all
      select (case when rest like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %'
                   then left(rest, 9 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(rest, 11, 1000)))
                   else rest
              end) as val,
             substring(rest, 10 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(rest, 11, 1000)), 1000) as rest
      from cte
      where rest like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %'
     )
select val
from cte;

ALTER PROCEDURE [dbo].[GetSimilarIssues] 
(
 @InputSearch varchar(255)
)
AS
BEGIN
-- SET NOCOUNT ON added to prevent extra result sets from
-- interfering with SELECT statements.
SET NOCOUNT ON;

DECLARE @SearchText varchar(500);

SELECT @SearchText = '"' + @InputSearch + '*"'

SELECT  PostId, Summary, [Description], 
Created
FROM Issue

WHERE FREETEXT (Summary, @SearchText);
END

select AC.category_id, count(*) as num_articles
from categories C
join articles_categories AC on C.id = AC.category_id
join (
  select id from articles where match(name, teaser, plaintext_contents) against ('some text' in boolean mode)
) A_IDS ON A_IDS.id=AC.article_id

group by AC.category_id;

//Your query
$queryliste = "SELECT id, nom, prenom FROM table";

//Initialize pdo connection use your $name, $host, $username and $password
$pdoLink = new PDO("mysql:dbname={$name};host={$host};charset=utf8", $username, $password);

//Prepare statement
$statement = $pdoLink-> prepare($queryliste);
//Execute query
$statement -> execute();

//(1) Fetch rows using PDO::FETCH_ASSOC
$rows = $statement -> fetchAll(PDO::FETCH_ASSOC);
$statement -> closeCursor();
foreach($rows as $row) {
    echo $row['id'];
    echo $row['nom'];
    echo $row['prenom'];
}

//(2) or you can use PDO::FETCH_NUM
$rows = $statement -> fetchAll(PDO::FETCH_NUM);
$statement -> closeCursor();

foreach($rows as list($x, $y, $z)) {
    echo $x;
    echo $y;
    echo $z;
}

//(3) or you can rewrite the last in the same form you are using as 
while((list($x, $y, $z) = $statement->fetch(PDO::FETCH_NUM))) {
    echo $x;
    echo $y;
    echo $z;
}
$statement -> closeCursor();

DECLARE @i int = 1019

SELECT c.id
FROM
  Users c LEFT JOIN offers o  
  ON c.id = o.UserId  
  AND o.ProductId IN (@i)
WHERE
  o.UserId IS NULL
ORDER BY
  c.id

SELECT * 
FROM (SELECT   SUM(pur.purchase_net_invoice_value), par.party_desc
      FROM     purchase pur
      JOIN     party par ON par.party_id = pur.party_id
      GROUP BY par.party_desc
      ORDER BY 1 DESC)
WHERE rownum <= 5;

select Project.MEDIA_F('tv', '06-05-13', 'n') 
from dual;

select
    passenger_no, hr
from
    ride_txn rt,
    (
        select  0 hr union all select  1 union all select  2 union all
        select  3    union all select  4 union all select  5 union all
        select  6    union all select  7 union all select  8 union all 
        select  9    union all select 10 union all select 11 union all
        select 12    union all select 13 union all select 14 union all
        select 15    union all select 16 union all select 17 union all
        select 18    union all select 19 union all select 20 union all
        select 21    union all select 22 union all select 23
    ) hrs
where
    action = 'Board' and
    hrs.hr between
        hour(txn_time) /* could add 3599 seconds to only count top of the hour */
        and
        (
            select min(txt_time) from ride_txn rt2
            where 
                    rt2.passenger_no = rt.passenger_no
                and rt2.txt_time > rt.txt_time and action = 'Deboard'
        )

SELECT
    [Users],
    [Stars]
FROM
    [Table]
WHERE
    [Users] != 'Admin'
    OR [Stars] > 3

select Convert(date, BookedDateTime) as Date, AVG(datediff(minute, BookedDateTime, PickupDateTime)) as AverageTime
    from tablename 
    group by Convert(date, BookedDateTime)  
    order by Convert(date, BookedDateTime) 

SELECT *
FROM (your_UNION_query) AS p
WHERE NOT ( colX = 'TERMINATED'
          AND EXISTS
            ( SELECT *
              FROM (your_UNION_query) AS q
              WHERE q.id = p.id
                AND q.colY = 'ACTIVE'
            )
          )

CREATE PROCEDURE Find_Text_In_SP
@StringToSearch varchar(100) 
AS 
   SET @StringToSearch = '%' +@StringToSearch + '%'
   SELECT Distinct SO.Name
   FROM sysobjects SO (NOLOCK)
   INNER JOIN syscomments SC (NOLOCK) on SO.Id = SC.ID
   AND SO.Type = 'P'
   AND SC.Text LIKE @stringtosearch
   ORDER BY SO.Name
GO

Create or Replace procedure Main

   SAVEPOINT sp_1;
   Call procedure_1();       
   Call procedure_2();

   IF X = true THEN
      ROLLBACK TO sp_1;
   END IF;

END Procedure Main;

BEGIN
  FOR c IN ( SELECT table_name FROM user_tables WHERE table_name LIKE 'EXT_%' )
  LOOP
    EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name;
  END LOOP;
END;

c.site_gb LIKE 'A%'
c.up_dept_cd='A001'

with x as (
  select 'Černický' name from dual union all
  select 'Marián' from dual
)
select convert(name, 'US7ASCII')  
  from x;

conn = database('databasename','username','password');
dbpath = 'C:\Users\______.mdb'; %insert database path
tableName = 'datetime'; %insert tablename here in MSAccess
colname = {'column1'} %column of your tables in MsAccess
date = datestr(now); %the string of date and time
coldata = {date}
insert(conn,tableName,colname,coldata); %will insert the data to the database.
close(conn);

update your_table
set column1 = column1 || column2

SELECT st_category AS cat, st_gender, COUNT(studentPK)
FROM es_preadmission
WHERE st_category IN ('GEN','SC','ST',....,'SGC')
GROUP BY st_category, st_gender
UNION ALL
SELECT st_handi AS cat, st_gender, COUNT(studentPK)
FROM es_preadmission
WHERE st_handi = 'PH'
GROUP BY st_handi, st_gender

exec sp_depends 'view name'

select p.*,
       (select count(*)
        from users u 
        where u.uid not in (select o.uid from orders o where o.productid = p.productid) and 
              u.gender = 'Male'
       ) as NumMales,
       (select count(*)
        from users u 
        where u.uid not in (select o.uid from orders o where o.productid = p.productid) and 
              u.gender = 'Female'
       ) as NumFemales     
from products p ;

SELECT group.id,COUNT(users.username) FROM groups
INNER JOIN users ON users.group_id=groups.id
GROUP BY groups.id

 SELECT name, address FROM customer WHERE status = 'active' and zip = ?

SELECT  *
FROM    A
        INNER JOIN B ON B.AID = A.AID
        INNER JOIN C ON C.BID = B.BID
        INNER JOIN D ON D.AID = A.AID
        INNER JOIN E ON E.DID = D.DID
        INNER JOIN F ON F.EID = E.EID
WHERE   C.Field = F.Field

SQL> create or replace type numbers_nt as table of number
  2  /

Type created.

SQL>
SQL> declare
  2      l_array numbers_nt;
  3  begin
  4      l_array := numbers_nt (7521,7566,7654);
  5      for r in ( select ename
  6                 from emp
  7                 where empno in ( select *
  8                                  from table (l_array)
  9                                 )
 10               )
 11      loop
 12          dbms_output.put_line ( 'employee name = '||r.ename);
 13      end loop;
 14  end;
 15  /
employee name = PADFIELD
employee name = ROBERTSON
employee name = BILLINGTON

PL/SQL procedure successfully completed.

SQL>

BEGIN

  IF(CONDITION)THEN

    htp.init;

    owa_util.redirect_url('f?p=&APP_ID.:10:&APP_SESSION.'); /*Replace 10 with actual Page Number*/

    apex_application.stop_apex_engine;

  ELSE

    htp.init;

    owa_util.redirect_url('f?p=&APP_ID.:20:&APP_SESSION.'); /*Replace 20 with actual Page Number*/

    apex_application.stop_apex_engine;

  END IF;

END;

select t.id4id Id, n1.Name Name, group_concat(n2.name) Groups
from (select t1.actid id4id, t1.postedby id4name, t2.postedby id4groups
        from Activity t1 join Activity t2 on t1.actid = t2.parentid) t join "user" n1 on t.id4name = n1.userid join "User" n2 on t.id4groups = n2.userid
group by id4id

var unAssociatedPages =
    from p in db.Pages
    join mm in db.MainMenus on p.PageID equals mm.MainMenuPageFK into mms
    where !mms.Any()
    select p;

ID  Data   Comes_after_ID
--  -----  --------------
27  Blahh  NULL
54  Blahh  27
57  Blahh  54 
1   Blahh  57

select * 
from user u
inner join hierarchyset h on h.clientid = u.clientid
left outer join linktable l on 
    l.hierarchsetid = h.hierarchsetid
 and u.userId = l.userId)
where l.hierarchsetid is null and l.userId isnull


select dbms_utility.port_string from dual;

SELECT grp.GroupID, grp.GroupNumber, grp.Name, grp.Location, grp.GroupTypeID, grp.DivisionID, 
grp.MasterGroupID, grp.EffectiveDate, grp.TerminationDate, crt.[ContractNumber], pln.[PBPNumber], div.SiteName, src.Name as SourceName 
FROM [Group] grp 
    INNER JOIN [IndividualPlanDemographic] idp ON grp.GroupID = idp.IndividualPlanDemographicID 
    INNER JOIN [Plan] pln ON idp.PlanID = pln.PlanID 
    INNER JOIN [Contract] crt ON pln.ContractID = crt.ContractID 
    --THE GROUP IS NOT REQUIRED TO BE IN A DIVISION RELATIONSHIP
    LEFT OUTER JOIN [Division] div ON grp.DivisionID = div.DivisionID 
    LEFT OUTER JOIN [SourceSystem] src ON div.SourceSystemID = src.SourceSystemID 
WHERE 1 = 1 
AND grp.EffectiveDate = '1/1/2015 12:00:00 AM' AND grp.GroupTypeID = '2' ORDER BY ContractNumber

SELECT * FROM TABLE IF(mytime is null, [sometime],mytime) ORDER BY ...

With Shifts As
  (
    Select 1 As Num
      , Cast('2012-05-01 6:00 AM' As datetime) As ShiftStart
      , DateAdd(hh,12,Cast('2012-05-01 6:00 AM' As datetime)) As ShiftEnd
    Union All
    Select Num + 1, ShiftEnd, DateAdd(hh,12,ShiftEnd)
    From Shifts
    Where ShiftEnd < '2012-05-30'
    )
  , Segments As
    (
    Select event_id
      , Case 
        When Shifts.ShiftStart > event_start Then Shifts.ShiftStart 
        Else event_start
        End As start_split_segment        
      , Case 
        When Shifts.ShiftEnd < event_end Then Shifts.ShiftEnd
        Else event_end
        End As end_split_segment          
      , Count(*) Over ( Partition By E.event_id ) As SegmentCount
    From events As E
      Join Shifts
        On E.event_start <= ShiftEnd
          And E.event_end > ShiftStart
      )
Select E.event_id, E.description, E.event_start, E.event_end
  , S.start_split_segment, S.end_split_segment
  , Case When SegmentCount > 1 Then 1 Else 0 End As is_split
  , NullIf(SegmentCount,1) As split_segments
From Segments As S
  Join events As E
    On E.event_id = S.event_id

SELECT Quote
  FROM Quote q, Users u, Followers f
  WHERE q.user_id = u.id
  AND q.user_id = f.follower
UNION
SELECT Quote
  FROM Quote q, Users u, Followers f
  WHERE q.user_id = u.id
  AND q.user_id <> f.follower

WHERE t.something = 'something' AND
      (t.lastname = 'smith' or t.name <> 'john')

DELETE FROM cities
WHERE city_id NOT IN (SELECT city_id FROM events)

update students
    set highestmark = 5 -- insert new value here
where id = 42-- insert id
and highestmark < 5 -- insert new value here

select sum(case when ts_homepage is not null then 1 else 0 end) as homepage_count,
       sum(case when ts_productpage > ts_homepage then 1 else 0 end) as productpage_count,
       sum(case when ts_checkout > ts.productpage and ts.productpage > ts.homepage then 1 else 0 end) as checkout_count
from (select userid,
             min(case when action = 'homepage' then timestamp end) as ts_homepage,
             min(case when action = 'product page' then timestamp end) as ts_productpage,
             min(case when action = 'checkout' then timestamp end) as ts_checkout
      from table t
      group by userid
     ) t

SELECT listagg (''''||PARAMETER||'''', ',') WITHIN GROUP (ORDER BY RowNumber) AS PARAMETER,
FROM (SELECT trunc((rownum - 1) / 8) as grp, t.*,
             rownum as RowNumber
      FROM SR0_CRTL_SL_OL_PSM_PARAMETER t
     ) t
GROUP BY grp;

^.*\/.*\.[a-zA-Z]{3}$

SELECT SUM (AMOUNT), [Customer No_]
FROM 

(
 select Amount 
          [Fluids Management$Cust_ Ledger    Entry].[Customer No_]
FROM 
        [Fluids Management$Detailed Cust_ Ledg_ Entry]
UNION ALL 
select [Debit Amount] as 'Less then 30 days', 
         [Fluids Management$Cust_ Ledger Entry].[Customer No_]
 FROM [Fluids Management$Detailed Cust_ Ledg_ Entry]
) 

GROUP BY  [Customer No_]

SQL> SELECT * FROM t_data;

        PK START_DATE  END_DATE
---------- ----------- -----------
         1 20/01/2010  20/01/2010
         2 21/01/2010  23/01/2010
         3 24/01/2010  27/01/2010

SQL> SELECT pk, start_date, end_date FROM t_data
  2  MODEL
  3     PARTITION BY (pk)
  4     DIMENSION BY (0 AS i)
  5     MEASURES(start_date, end_date)
  6     RULES
  7     (  start_date[FOR i
  8                   FROM 1 TO end_date[0]-start_date[0]
  9                   INCREMENT 1] = start_date[0] + cv(i),
 10        end_date[ANY] = start_date[CV()] + 1
 11     )
 12  ORDER BY 1,2;

        PK START_DATE  END_DATE
---------- ----------- -----------
         1 20/01/2010  21/01/2010
         2 21/01/2010  22/01/2010
         2 22/01/2010  23/01/2010
         2 23/01/2010  24/01/2010
         3 24/01/2010  25/01/2010
         3 25/01/2010  26/01/2010
         3 26/01/2010  27/01/2010
         3 27/01/2010  28/01/2010

SELECT SUM(C1) AS C1, CASE WHEN C1 = 1 THEN 'other' ELSE device_type END as device_type
FROM (  SELECT  COUNT(*) AS C1,
                device_type 
        FROM stat 
        WHERE stat_date = '2012-02-08' 
        GROUP BY device_type) A
GROUP BY CASE WHEN C1 = 1 THEN 'other' ELSE device_type END

UPDATE TimeRequestedTable
INNER JOIN BlockTimesTable ON BlockTimesTable.EmpID = TimeRequestedTable.EmpID
SET AppointTime = "inputed by user"
WHERE AppointTime BETWEEN startTime and EndTime

select count(distinct UnitId) as Units, count(*) as Pieces
from Piece
where Category = 'A'

set serveroutput on;

UPDATE `table` SET `foo` = 'bar' ORDER BY `timestamp` DESC LIMIT 1;

WHERE EntryDate BETWEEN 
  CASE WHEN Product = 'LTD' THEN @FirstDatetc 
       ELSE DateAdd(blah)
  END 
AND GetDate()-1

CREATE TRIGGER [dbo].[DIENSTLEISTUNG_Update]
ON [dbo].[DIENSTLEISTUNG]
FOR UPDATE
AS
    IF UPDATE(PRICE) 
      ... (do what you need to do if PRICE is updated)...

    IF UPDATE(DESCRIPTION)
      ... (do what you need to do if DESCRIPTION is updated)...

    IF UPDATE(PRIORITY)
      ... (do what you need to do if PRIORITY is updated)...

UPDATE PS_Z_TREND_NOW_TBL a 
  SET STATUS = ( CASE WHEN COUNT(SEC.IS_AW_AUTH_NAME)  > 0 then 'M'
                 ELSE null END )
FROM PS_IS_AW_SECURITY sec 
WHERE sec.IS_AW_AUTH_NAME LIKE '%Manager%'

UPDATE #Table 
SET name = 'Winn-Dixie -' + RIGHT(Name, LEN(NAME) - CHARINDEX('-',Name))
WHERE name LIKE 'Sweetbay%'

with test_data as (
SELECT 184 ID,     'Halifax' text,   'Bnk' tag,     1 ord from dual union all
SELECT 184 ID,     'RBS' text,   'Bnk' tag,     2 ord from dual union all
SELECT 184 ID,     'Natwest' text,   'Bnk' tag,     3 ord from dual union all
SELECT 184 ID,     '32.16' text,   'Amt' tag,     1 ord from dual union all
SELECT 184 ID,     '80.15' text,   'Amt' tag,     2 ord from dual union all
SELECT 184 ID,     '62.54' text,   'Amt' tag,     3 ord from dual
)
select bank_name, amount from test_data
pivot ( max(text) for tag in ('Bnk' as bank_name, 'Amt' as amount) )
order by ord

UPDATE table 
   SET column = REPLACE(column, 'Street', 'St');

    select <...>    
    from A, B, C, (select ID from ...) as e
    where
      A.FK_1 = B.PK and
      A.FK_2 = C.PK and
      A.ID = e.id
union
    select <...>    
    from A, B, C, (select ID from ...) as e
    where
      A.FK_1 = B.PK and
      A.FK_2 = C.PK and
      A.ID = e.ID

count(distinct dlr.id)

SELECT startTime, SUM(duration) as sum
FROM myTable
WHERE startTime = endTime
GROUP BY startTime

INSERT INTO PATIENT_DETAIL  
    SELECT PATIENT_NAME, 
          'DISEASE D', 
          dbms_random.value(1,1000), 
          sysdate, 
          sysdate
    FROM PATIENT_DETAIL

select p.*, min(ps.price)
from products p left join
     (select ps.product_id, ps.store_id, max(created_at) as maxca
      from product_store ps
      group by ps.product_id, ps.store_id
     ) pssum
     on pssum.product_id = p.id left join
     product_store ps
     on ps.product_id = pssum.product_id and
        ps.store_id = pssum.store_id and
        ps.created_at = pssum.maxca
group by p.id;

Me.ComboBox.DataBindings.Add(New Binding("SelectedItem", _
                                      Me.TblBindingSource, "ColumnName", True))

CREATE TRIGGER z_LOGIN2 AFTER UPDATE OF lastsignondttm ON SYSADM.PSOPRDEFN
FOR EACH ROW

BEGIN
  IF (SELECT COUNT(1)
      FROM SYSADM.psroleuser b
      WHERE b.roleuser = NEW.oprid AND (b.rolename = 'FAS Change Admin'
            OR b.rolename = 'PeopleSoft Administrator')) > 0 THEN

  INSERT INTO z_LOGIN VALUES (NEW.oprid,NEW.oprdefndesc,NEW.lastlogondttm);
 END IF;

END;

UPDATE t_b
    SET a_id_fk = COALESCE(
        (SELECT MIN(a_id) FROM t_a WHERE a_id > t_b.a_id_fk),
        (SELECT MIN(a_id) FROM t_a))
    WHERE b_id = :b_id

WITH ovrdValXML AS (
  select xov.id,
         xmlforest(ID as "valueID", S_VAL as "sValue", U_VAL as "uplValue",
                        O_VAL as "oValue", O_IND as "oIndicator", F_VAL as "finalValue",
                        O_RSN as "reason") AS XMLChunk
     from ovrd_val xov)
SELECT xmlelement("genInf", xmlelement("ID", vt.ID),
                       xmlelement("vID", vt.V_ID),
                       xmlelement("vNum", vt.V_NUM),
                       xmlelement("terrDataCode", TERR_CODE.column_value), --data is based on reference table
                       xmlelement("ABValCode", AB_VAL_CD.column_value), --data is based on reference table
                       ...
  FROM V_TAB vt
  JOIN ovrdValXML terr_code ON terr_code = vt.?
                           AND terr_code.id = vt.terr_cd_id
  JOIN ovrdValXML ab_val_cd ON ab_val_cd = vt.?
                           AND ab_val_cd.id = vt.ab_val_cd
 WHERE vt.id = IN_VID;

SELECT T1.*
FROM TABLE1 AS T1
INNER JOIN TABLE2 AS T2
ON T1.MATERIAL = T2.MATERIAL

;WITH data AS
(
SELECT 1 as [value],'2012-03-07' as date
UNION ALL SELECT 1,'2012-03-06'
UNION ALL SELECT 1,'2012-03-05'
UNION ALL SELECT 3,'2012-03-04'
UNION ALL SELECT 4,'2012-03-03'
UNION ALL SELECT 1,'2012-03-02'
)
,data2 AS
(
SELECT 
[Value]
,date
,row_number() OVER (ORDER BY (SELECT NULL)) as row1
FROM data
)
,data3 AS
(
SELECT * 
, row1 - row_number() OVER (ORDER BY [Value]) as row2
from data2
)
SELECT 
MIN([Value]) AS [Value]
,MIN(Date) as Date
FROM data3
GROUP BY [Value] - row2
ORDER BY MIN(row1)

var query = db.Customers;
if (selectID.HasValue)
{
   query = query.Where( c => c.ID > selectID.Value );
}
if (!string.IsNullOrEmpty( nameFilter ))
{
   query = query.Where( c => c.Name.Contains( nameFilter ) );
}

foreach (var customer in query) // now the query is performed
{
 ...
}

SELECT Form_ID, Product_ID, Date, 
       Indicator = Count(*) Over (Partition by Product_ID)
FROM my_database.inv_table
ORDER BY Indicator DESC

USE AdventureWorksLT2012

-- First query using UNION
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 716
UNION
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 727
UNION
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 770

-- Second query using UNION ALL
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 716
UNION ALL
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 727
UNION ALL
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 770

-- Third query using IN
SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID IN(716, 727, 770)

SELECT  a.*
FROM    Table1 a
        LEFT JOIN Table2 b
            ON a.EmployeeID = b.EmployeeID
WHERE   b.EmployeeID IS NULL

SELECT T2.org_id,
       T.item_id
FROM table AS T2
JOIN
    (SELECT item_id,
           SUM(spend) AS total_spend 
    FROM table AS T
    GROUP BY T.item_id
    HAVING COUNT(DISTINCT org_id) < 4) AS T ON T.item_id = T2.item_id
ORDER BY T.total_spend DESC

sql = "SELECT CONVERT(VARCHAR(19), date, 120) as date FROM sales WHERE userid=1"

SELECT Count(*)
FROM
   (
      SELECT ID
      FROM dbo.YourTable
      GROUP BY ID
      HAVING Count(*) >= 2
   ) X
;

--populate tables with sample data
DECLARE @totalRecords int 
SET @totalRecords = 0
DECLARE @currentKey int

WHILE @totalRecords < 500
BEGIN
    SET @totalRecords = @totalRecords + 1

    INSERT INTO dbo.submissions (submissionName, dateSubmitted)
        VALUES ('submission record ' + cast(@totalRecords AS varchar(3)), SYSDATETIME())

    Set @currentKey = Scope_Identity()

    INSERT INTO dbo.submissionItems (fk_submission_id, item)
        VALUES (@currentKey, 'a new record item for submission '+ cast(@totalRecords AS varchar(3)))
END

$query = $_GET['query']; //id I get from the specified item
echo 'the id is: ' . $query; //test purposes

$mysql_handle = mysqli_connect($dbhost, $dbuser, $dbpass) or die("Error connecting to database server");

$sql1 = "SELECT item_stock FROM chat-db.Item WHERE id = '".$query."'";

$results = mysqli_query($mysql_handle, $sql1);

if (!empty($results) && mysqli_num_rows($results) > 0) {
    while($rec = mysqli_fetch_array($results)) {
        echo $rec['item_stock'];
    }
}

select jobid, jobtitle, pay, name
from (
  select j.jobid, j.jobtitle, e.pay, e.name, 
         row_number() over (partition by j.jobid order by e.pay desc) as rn
  from employees e 
    join jobs j on j.jobid = e.job_id
) 
where rn <= 3
order by jobid, jobtitle, pay desc;

select f.friend_userid as userId from friends f where f.userid = 1 
UNION
select f.userid as userId from friends f where f.friend_userid = 1;

;WITH cte AS
(
   SELECT *,
         ROW_NUMBER() OVER (PARTITION BY DocumentID ORDER BY DateCreated DESC) AS rn
   FROM DocumentStatusLogs
)
SELECT *
FROM cte
WHERE rn = 1

CREATE TABLE t1
    (username varchar2(4))
;

CREATE INDEX t1_idx ON t1(lower(username));

SELECT 
ll.ip_address,
ll.when,
cbi.country
FROM last_login ll
LEFT JOIN `country_by_ip` cbi on ll.ip_address > cbi.ip_from 
WHERE ll.ip_address < cbi.ip_to

SELECT  t.*
FROM    t
        INNER JOIN (
          SELECT  ID = MAX(ID)
          FROM    t
          GROUP BY
                  key
        ) tm ON tm.ID = t.ID                  

pR.projectRelationId IN ('$id[ 0 ]', '$id[ 1 ]', '$id[ 2 ]')

SELECT @trans_id=transaction_id FROM sys.dm_tran_current_transaction

UPDATE OrderGroupNew
SET SavedTotal = (
    SELECT SUM(UnitPrice * Quantity)
    FROM OrderItemNew
    WHERE OrderNumber = OrderGroupNew.OrderNumber
) 

declare @maxcount1 float
declare @maxcount0 float

select @maxcount1 = max(count1), @maxcount0 = max(count0)
from 
(SELECT TeamName,Count(DISTINCT CASE WHEN WorkInfo = 1 THEN SlNo end) AS Count1 , 
 Count(DISTINCT CASE WHEN WorkInfo = 0 THEN SlNo end) AS Count0 FROM tableA 
 WHERE (SubmitDate BETWEEN @start AND @end) GROUP BY TeamName) as s

select teamname, count1, count0, 
round((cast((count1 * 100) as float)/@maxcount1),2) as percentage1,
round((cast((count0 * 100) as float)/@maxcount0),2) as percentage0
from 
(SELECT TeamName,Count(DISTINCT CASE WHEN WorkInfo = 1 THEN SlNo end) AS Count1 , 
 Count(DISTINCT CASE WHEN WorkInfo = 0 THEN SlNo end) AS Count0 FROM tableA 
 WHERE (SubmitDate BETWEEN @start AND @end) GROUP BY TeamName) as s

SET @i:=0;
SET @j:=0;

UPDATE t1

RIGHT JOIN (
  SELECT 
     id
     ,IF(@j = 0 ,@j:=1, @j:=@j+1)
     ,IF((@j-1) % 12 = 0, @i:= @i+1, @i)  as i
  FROM t1
  WHERE hDate IS NULL
) idx
on idx.id = t1.id
  SET t1.hDate = CURDATE() + INTERVAL (idx.i)  DAY 

SELECT mobilenumber, COUNT(*)
FROM   (
         SELECT DISTINCT mobilenumber, firstname, lastname
         FROM   YourTable
       ) AS q
GROUP BY
       mobilenumber
HAVING COUNT(*) > 1

DECLARE @DateFrom DATETIME
SET @DateFrom = '2011-01-01'

DECLARE @DateTo DATETIME
SET @DateTo = '2011-01-10'

;WITH DateRanges AS
(
    SELECT @DateFrom AS 'DateValue'
    UNION ALL
    SELECT DATEADD(DAY, 1, DateValue)
    FROM DateRanges
    WHERE DateValue < @DateTo
)
SELECT * FROM DateRanges

string.Replace(";", "CHAR(59)");

select column_name, count(column_name)
from table
group by column_name
having count (column_name) > 1;

select t1.Name state_name, t2.Name Country_name from State_m t1,Country_m t2 where t1.CountryId=t2.CountryId; 

USE intranet

;WITH A AS
(
    SELECT ROW_NUMBER() OVER (ORDER BY id) AS tab_ranking
        , id
    FROM dbo.tabs
    WHERE cms_initials = @user
),
B AS
(
    SELECT DENSE_RANK() OVER (ORDER BY tabs_id) AS tab_sequence
        , tabs_id, widgets_id, sort_column, sort_row
    FROM dbo.columns
    WHERE tabs_id IN (SELECT t.id FROM dbo.tabs t WHERE t.is_default = 1)
)
INSERT INTO dbo.columns (tabs_id, widgets_id, sort_column, sort_row)
SELECT a.id, b.widgets_id, b.sort_column, b.sort_row
FROM A
INNER JOIN B ON B.tab_ranking = A.tab_ranking

SELECT u.*
FROM cpnc_User u JOIN
(
    SELECT firstName, lastName
    FROM cpnc_User
    GROUP BY firstName, lastName
    HAVING COUNT(*) > 1
) X on X.firstName = u.firstName AND x.lastName = u.lastName
ORDER BY u.firstName, u.lastName

update table_name set action=replace(action,'consultation','display');   

UPDATE tbl_profile
SET year_level='3rd'
WHERE users_id IN (
  SELECT users_id
  FROM tbl_usersinfo WHERE full_name = 'captain america');

select replace(col, '$', '')
from <whatever>;

select * from master..spt_values
where 1=1 or (select count(*) from master..sysobjects) > 0

select concat(d.FirstName, ' ', d.LastName) as 'Donor'
     , sum(a.amount) as 'Total Paid'
     , sum(case when a.CompanyId is null then a.amount else 0 end) as 'Pocket' 
from Donor d
join Pledge p on d.DonorId = p.DonorId
join Payment a on p.pledgeId = a.pledgeId
group by d.donorid

create table your_table_name (
  one_row integer not null unique
    default 1 check (one_row = 1),
  version varchar(5) not null unique
);

insert into your_table_name values (1, '0.0.0');

SELECT   col,
         COUNT(dupe_col) AS dupe_cnt
FROM     TABLE
GROUP BY col
HAVING   COUNT(dupe_col) > 1
ORDER BY COUNT(dupe_col) DESC

SELECT name FROM `product` WHERE BINARY `name`  like 'product%'

select a.* from activities a
JOIN (select distinct type FROM activities where type='X' or flag=1) t
ON a.type=t.type;


select a.* from activities a
where type='X'
  or EXISTS(SELECT * FROM activities WHERE type=a.type AND flag=1);


select a.* from activities a
where type='X'
  or type IN (SELECT type FROM activities WHERE flag=1)

coalesce((select 'exists'
          from   veryyugetable vyt
          where  vyt.somenumber = someOtherTable.someNumber
          and    rownum = 1),
         'doesn''t exist') somecolumn

SELECT SUM(AMOUNT) SUM_AMOUNT FROM <table>
WHERE VoucherDt >= DATEADD(MONTH, DATEDIFF(MONTH, 0, CURRENT_TIMESTAMP), 0)
AND VoucherDt < DATEADD(DAY, DATEDIFF(DAY, 0, CURRENT_TIMESTAMP), 1)

$this->getField('id')->calculated(true);

function calculate_id(){
    return 'id_material';
}

SELECT REPLACE(REPLACE(REPLACE(col, CHAR(10), ' '), CHAR(13), ' '), CHAR(9), ' ') AS Col 
FROM Table

select  *
from    (
        select  row_number() over (
                  partition by p_id
                  order by year desc, month desc) as rn
        ,       *
        from    YourTable
        ) as SubQueryAlias
where   rn = 1

 CREATE TABLE ResultSet (Directory varchar(200))

 INSERT INTO ResultSet
 EXEC master.dbo.xp_subdirs 'c:\'

 Select * FROM ResultSet where Directory = 'testing'

DECLARE @LastName NVARCHAR(50) = 'John'
DECLARE @FirstName NVARCHAR(50) = NULL;
DECLARE @ID INT = 1;

UPDATE dbo.UpdateExample
SET LastName = COALESCE(@LastName, LastName), FirstName = COALESCE(@FirstName, FirstName), 
WHERE ID = @ID

UPDATE STOCKA a
JOIN STOCKB b
    ON a.P = b.P
SET a.U =  a.U - ABS(b.U)

select REGEXP_SUBSTR(' EG SUZ SG SIN blabla ', '([A-Z]{2} [A-Z]{3}(\s|$))', 1, 2) from dual;

DECLARE @Location …
DECLARE @SQL varchar(max)
If (@InputVariable = 1)
BEGIN 
        @Location  =  '[DatabaseA].dbo.MyTable'
    END
ELSE
    BEGIN
        @Location  =  '[DatabaseB].dbo.MyTable'
    END

BEGIN
    SET @SQL = 
    'UPDATE '+@Location+
    ' WHERE
    … '
END
EXECUTE (@SQL)

insert into dbo.calculationtable (ID, Server, Datetime, UptimeStatus)
Select ID, SERVER, CheckTime, ResultType
From dbo.sample 
Where CheckTime > (Select max(DateTime) From dbo.calculationtable)
GO

SELECT * 
FROM child 
WHERE id NOT IN (SELECT child_id FROM par1) AND 
      id NOT IN (SELECT child_id FROM par2)

select key,
    max(decode(id_col,1,id_col)) as id_1,max(decode(id_col,1,val)) as val_1,
    max(decode(id_col,2,id_col)) as id_2,max(decode(id_col,2,val)) as val_2,
    max(decode(id_col,3,id_col)) as id_3,max(decode(id_col,3,val)) as val_3
from (
        select key, row_number() over (partition by key order by id) as id_col,id,val
        from your_table
    )
group by key

 SELECT
     start, 
     start + game_duration * INTERVAL '1 SECONDS' AS finish_time 
 FROM "GAME_PLAYED" WHERE id = 123;

select
    i.[INV ITEM Ext ID],
    i.[INV ITEM Description],
    sum(d.[ar orderd qty]) as 'Total Units Sold',
    sum(case when
            d.[ar orderd date] >= '2013-09-16' and
            d.[ar orderd date] < '2013-09-23'
        then d.[ar orderd qty]
        else 0 end) as 'total Units sold 9/16-9/22',
    sum(case when
            d.[ar orderd date] >= '2013-09-23' and
            d.[ar orderd date] < '2013-09-30'
        then d.[ar orderd qty]
        else 0 end) as 'total Units sold 9/23-9/29'
from
    [inv items] i
        inner join
    [ar order detail] d
        on d.[ar orderd item id] = i.[INV ITEM Ext ID]
        inner join
    [ar order] o
        on o.[AR ORDER Document #] = d.[AR ORDERD Document #]
where
    o.[AR ORDER Document #] not like '%Ret%' and
    d.[ar orderd date] > '9/16/2013' and
    d.[AR ORDERD Qty] >= '0'
group by
    i.[INV ITEM Ext ID],
    i.[INV ITEM Description]
order by
    i.[INV ITEM Ext ID];

select city_name
from city
order by (case when city_name=upper(city_name) then 2 else 1 end),
         city_name;

Update table_name
set col1='some_value'
output inserted.* 

SELECT Age,COUNT(user_id) AS "Number of Users"

FROM
(
    SELECT userid,
           YEAR(CURDATE()) - 
           YEAR(STR_TO_DATE(birth_date, '%m/%d/%Y')) - 
           (RIGHT(CURDATE(), 5) < RIGHT(STR_TO_DATE(birth_date, '%m/%d/%Y'), 5)) 
             AS Age
    FROM user
) as Z 
GROUP BY Age

INSERT INTO Movies (Title, Director, Cost, Profits)
SELECT 'Star Wars', name, 50000, 1000000
FROM Directors WHERE name = 'Lucas'

SELECT acc.* 
FROM accounts acc 
JOIN addresses addr ON acc.id = addr.account_id
JOIN alternate_ids ids ON acc.id = ids.account_id
WHERE LOWER(acc.firstname) = LOWER('Sam') 
AND LOWER(addr.name) = LOWER('Street1') 
AND ids.alternate_id_glbl = '5';

Cursor c = ourDbase.query(MyTABLE, columns , null, null, null, null, KEY_SCORE + " DESC");

select distinct on (transponder, country, system) * from some_table
order by transponder, country, system, time desc

SELECT show_table.program, show_table.timebegin
FROM show_table
INNER JOIN (
    SELECT program, MIN(timebegin) AS firsttime
    FROM show_table
    GROUP BY program
) AS groups
ON (show_table.program = groups.program)
ORDER BY groups.firsttime, show_table.program, show_table.timebegin;

SELECT Doc, code, Sum(Qty), ConcatRelated("[Next]","TableName",,,"-") as [Next]
FROM TableName
GROUP BY Doc, code

select COUNT(EmailID) as Count_Mails, CAST(Createddate as DATE)
GROUP BY  cast(createdDate as date)

create view v_table as
    select t.*,
           (startdate <= curdate() then 1 else 0 end) as has_started
    from table t;

SQL> VARIABLE return_code NUMBER
SQL> BEGIN
  2    :return_code := 5;
  3  END;
  4  /

PL/SQL procedure successfully completed.

SQL> EXIT :return_code
Disconnected from Oracle Database 10g Release 10.2.0.4.0 - Production
> echo $?
5

with Permissions as
   (select Id 
    from Surge.Permission  
    where Name in ('Web.Orders:Enable',
                   'App.Orders:Enable',
                   'Web.Orders:View',
                   'App.Orders:View',
                   'Web.Orders:Modify',
                   'App.Orders:Modify',
                   'Web.Orders:View.All',
                  'App.Orders:View.All'
                  )
     )
INSERT INTO Surge.[RolePermission] (DataPartitionId, PermissionId, RoleId)
SELECT DP.Id, p.Id, 2 
FROM Surge.DataPartition as DP
CROSS JOIN Permissions p

select max(case when `rn` = 2 then `value` end) as `Id`,
       max(case when `rn` = 1 then `value` end) as `Name`,
       max(case when `rn` = 3 then `value` end) as `Price`
from (
  select *, 
      @rn:=if(@rn>2,1,@rn+1) rn,
      @row:=if(@rn=1,@row+1,@row) `row`
  from `yourmesseduptable` cross join (select @rn:=0, @row:=0) t
  ) t
group by `row`

DELETE tableA
FROM tableA LEFT JOIN tableB B ON A.id = B.a_id
WHERE B.a_id IS NULL;

<dataSource
    driver="net.sourceforge.jtds.jdbc.Driver"
        url="jdbc:jtds:sqlserver://server/database;useLOBs=false" 
    user="user" 
    password="password" />

SELECT (YEAR(CURDATE())-YEAR(birth)) AS age FROM TABLE_NAME;

UPDATE t
JOIN (
  SELECT MAX(t.id) AS maxid, lat, lon
  FROM t
  JOIN t AS duplicates
  USING (lat, lon)
  GROUP BY lat, lon
  HAVING COUNT(*) > 1
) AS maxima USING (lat, lon)
SET flag = IF(id = maxid, 1, 2);

SELECT * FROM MyTable ORDER BY inet(IP_Address)

SELECT label, MAX(eventdate) AS maxeventdate FROM (
  SELECT parentid, eventdate FROM TABLE1
  UNION ALL 
  SELECT parentid, eventdate FROM TABLE2)
JOIN PARENT ON (id = parentid)
GROUP BY label

SELECT to_char(trunc(request_date),'YYYY-MM-DD HH24:MI:SS') date_time

foreach (var myrow in (from x in that_table select x))
{
    var myChartObject = new ChartObject();
    // populate myChartObject fields from myrow
    // add myChartObject to the actual chart
}

select parent_id
from your_table
group by parent_id
having count(distinct child_gender) = 2

SELECT TO_CHAR(dt,'Mon') 
FROM tb 
ORDER BY dt

declare @fromDate date = null
declare @toDate date = null

select * from Mytable 
where date between coalesce(@fromDate,date) and coalesce(@toDate,date)

with cte as (
   select customer_name, min( id ) as id
   from #table1
   group by customer_name
   having count(*) > 1
)
update #table1 
 set oldID = cte.id
 from cte 
 where #table1.customer_name = cte.customer_name
 and #table1.id != cte.id 

SELECT user_id, max(timestamp)
FROM `log`
GROUP BY user_id
ORDER BY max(timestamp) desc;

DELETE FT, ST
FROM first_table AS FT
JOIN second_table AS ST
ON FT.status = ST.status 
AND ST.final_result = '3'

where phone = replicate(left(phone,1), len(phone))
    and phone is not null

select op.Productid
       , sum(  case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate then 
          1 else 0 end) FirstQty
       , sum(  case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 then 
          1 else 0 end)  SecondQty,
       , Round(Sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate 
                        then op.Price*op.Quantity 
                         else 0 end),0) as FirstProductRevenue 
       , Round(Sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 
                        then op.Price*op.Quantity 
                         else 0 end),0) as SecondProductRevenue 
 from Orderdetails od 
 inner join (select Distinct Orderid,productid,Price,Quantity from Orderproducts)  op on op.Orderid=od.Orderid 
 inner JOIN City ct  ON od.RecipientCityName = ct.CityName 
 INNER JOIN Associates ass ON Ct.AssociateId = ass.AssociateId
 Inner join HomepageRowWiseProducts hr on op.ProductId=hr.Productid 
 where  ( Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate 
       Or Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 )
   and (od.TransactionId IS NOT NULL or ltrim(od.TransactionId) !=  '') 
   and @Rowname=hr.HomepageRow_name and hr.status=1
   Group by op.Productid

;WITH cte(name, Startdate,Enddate)
AS
(  
    SELECT name, Startdate,Enddate FROM your_table
    UNION ALL
    SELECT name, DATEADD(dd, 1,Startdate),Enddate FROM CTE 
    WHERE Startdate < Enddate
)
SELECT * FROM cte ORDER BY name

mysql> create table t (a int not null unique) engine=innodb;
Query OK, 0 rows affected (0.05 sec)

mysql> insert into t (a) values (0) on duplicate key update a=1;
Query OK, 1 row affected (0.00 sec)

mysql> select row_count();
+-------------+
| row_count() |
+-------------+
|           1 |
+-------------+
1 row in set (0.00 sec)

mysql> insert into t (a) values (0) on duplicate key update a=1;
Query OK, 2 rows affected (0.00 sec)

mysql> select row_count();
+-------------+
| row_count() |
+-------------+
|           2 |
+-------------+
1 row in set (0.00 sec)

SELECT
    Table1.*,
    something1Table.setting AS something1,
    something2Table.setting AS something2,
    something3Table.setting AS something3
FROM Table1
JOIN Table2 AS something1Table ON something1Table.table_1_id = Table1.id AND something1Table.value = 'something'
JOIN Table2 AS something2Table ON something2Table.table_1_id = Table1.id AND something2Table.value = 'something2'
JOIN Table2 AS something3Table ON something3Table.table_1_id = Table1.id AND something3Table.value = 'something3'

public IQueryable<Timeline> GetHighlights() {

    var self = from x in Database.Timelines
               where User.Id == x.UserId || User.Id == x.SenderId
               select x;

    var friends = from x in Database.FriendItems.Include("Friend.Timeline")
                  where (User.Id == x.UserId)
                  select x.Friend.Timeline;

    List<Timeline> highlights = new List<Timeline>();
    highlights.AddRange(self);

    friends.ForEach(x => x.ForEach(y => highlights.Add(y)));
    return highlights.AsQueryable().OrderByDescending(s => s.Id);
}

select * 
  from Table
 where ReportNumber in (select max(ReportNumber) 
                          from Table)

Declare @t table(Groups int,Color varchar(50),ColorDesc varchar(50))
insert into @t
select 1 ,'Red',    'The cool name of Red Color' union all
select 1,'Green',  'The cool name of Green Color'  union all
select 2,'Blue',   'The cool name of Blue Color'  union all
select 2,'Yellow', 'The cool name of Yellow Color'  union all
select 2,'Purple', 'The cool name of Purple Color'  union all
select 3,'Pink',   'The cool name of Pink Color'

;with cte as
(
select groups,count(*) cnt from @t group by groups
)

select  distinct b.groups,case when cnt=1 then a.ColorDesc
else stuff((select ',' + color from @t c where c.groups=b.Groups for xml path('') ),1,1,'') end
from  cte b inner join @t a on a.Groups=b.Groups

Without distinct(Test both with lot of data)

Select * from 
(select  ROW_NUMBER() over(partition by b.groups order by b.groups) rn, b.groups,case when cnt=1 then a.ColorDesc
else stuff((select ',' + color from @t c where c.groups=b.Groups for xml path('') ),1,1,'') end colorDesc
from  cte b inner join @t a on a.Groups=b.Groups )t4 where rn=1

select @rownum:=@rownum+1 'rank',  r1.* FROM
    (SELECT  pgid, picfile from pages,
             (SELECT @rownum:=0) AS r2
     where pos= 23 
     order by Rand()  limit 5
   ) AS r1
ORDER BY rank

UPDATE A 
SET A.sequene = B.sequence 
FROM tableA A 
INNER JOIN (SELECT text, ROW_NUMBER() OVER (ORDER BY text) sequence 
            FROM tableA 
           ) AS B ON A.text = B.text

    DECLARE 

    @searchParam Datatype

    BEGIN

    SET @searchParam ='Value to be searched'

    IF EXISTS (SELECT * FROM [TABLENAME] WHERE [SEARCHPARAM]=@searchParam)

    SELECT * FROM [TABLENAME] WHERE [SEARCHPARAM]=@searchParam

    ELSE

    SELECT * FROM [TABLENAME]

    END

    GO

UPDATE tbl2 t
INNER JOIN tbl1 s
 ON(t.transaction_id = s.id)
set t.transaction_id = s.id_trans

select cast(collect(b.column_value) as vector) 
from  table(table_of_vector(
             vector(23, 4, 2222, 22222222), 
             vector(2, 1, 766, 2), 
             vector(2, 1, 5))) a, 
      table(a.column_value) b;

create table SOxx1
(
    col1  char(4),
    col2  char(20) not null
)

create table SOxx2
(
    col1  char(4),
    col2  char(20) not null
)
Go

insert into SOxx1 (col1, col2) VALUES ('ARR ', 'abc')
insert into SOxx2 (col1, col2) VALUES ('ARR ', 'abc')
go

SELECT (ISNULL(a.col1,'') + ISNULL(b.col1,'')) AS WhatEver 
FROM SOxx1 a  
left join SOxx2 b on a.Col2 = b.Col2

-- OUTPUT is 'ARR ARR '

select count(*) as counts
from myTable
where datediff(yyyy,dob,admitdate) between 5 and 10

SELECT *
FROM sampletable s1
INNER JOIN (SELECT count(type) AS iCount,type
        FROM sampletable
        GROUP BY type) s2 ON s2.type = s1.type
ORDER BY s2.iCount DESC, s1.type ASC

select Lastname,count(CASE item WHEN '' THEN NULL ELSE item END) item from info  group by Lastname;

SELECT a.title, a.lat, a.lon, a.alert_content_id, a.date_added, count(r.alert_id) as countRep ,count(i.alert_id) AS countInt 
FROM `alerts` a 
      LEFT JOIN `reply` r ON 
         r.alert_id = a.alerts 
      LEFT JOIN `interactions` i ON 
         i.alert_id = a.alerts 
GROUP BY a.title, a.lat, a.lon, a.alert_content_id, a.date_added

UPDATE reports_attributes 
 Set 
 ConID='78',
 CheckServices='Execute Summary',
 Attribute1='criminality',
 Attribute2='color1',
 Attribute3='education',
 Attribute4='color5',
 Attribute5='employment_check_2',
 Attribute6='color7',
 Attribute7='report_status',
 Attribute8='color9'
WHERE ConID=78 AND ReportType='interim_report'  

DECLARE @MyTableVar table( NewScrapReasonID smallint,
                           Name varchar(50),
                           ModifiedDate datetime);
INSERT Production.ScrapReason (Name, ModifiedDate)  
    OUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate
        INTO @MyTableVar
VALUES (N'Operator error', GETDATE());

UPDATE  tableA a
        INNER JOIN
        (
            SELECT  ID, MAX(Value) max_val
            FROM    tableB
            WHERE   SUB_GROUP IN ('Category 2','Category 3')
            GROUP   BY ID
        ) b ON a.ID = b.ID
SET a.VALUE = b.Max_Val

select string_agg(nm,'+') from(
    select st.name as nm
    from building-step bs
    inner join 
    step st
    on bs.step_id=st.id
    where bs.construction_id=1
    order by bs ASC
); --done by hand, may have small errors

START TRANSACTION;
INSERT INTO player
(facebook_id, first_name, last_name, gold_balance) 
VALUES 
('$userid', '$userfirst_name', '$userlast_name', “100”)

INSERT INTO BALANCE
(facebook_id, first_name, last_name, gold_balance) 
VALUES 
('$userid', '$userfirst_name', '$userlast_name', “100”)"

commit;       

ALTER TABLE PerformanceData ADD CreatedBy VARCHAR(50) NULL 

UPDATE PerformanceData SET CreatedBy = 'NA'

ALTER TABLE PerformanceData ALTER COLUMN CreatedBy VARCHAR(50) NOT NULL

# Read in the data
my @data;
while (<>) {
   chomp;
   push @data, [ split(/\t/, $_, -1) ];
}

# Sort it
@data = sort {
   $a->[0] cmp $b->[0]   # By name
      ||
   $a->[1] <=> $b->[1]   # By quantity
} @data;

# Generate the ids and output the data.
my %counts;
for my $row (@data) {
   my $id = join('.', $row->[0], ++$counts{ $row->[0] });
   push @$row, $id;
   print(join("\t", @$row), "\n");
}

select t21.name, t22.name
from Table1 t1 
inner join Table2 t21 on t1.id_1 = t21.id
inner join Table2 t22 on t1.id_2 = t22.id

INSERT INTO clients_products (client_id, product_id)
SELECT c.ID, p.ID
FROM Clients c
CROSS JOIN Products p
LEFT JOIN clients_products cp
    on c.client_id and p.product_id
WHERE cp.client_id is null and p.product_id is null

SELECT Location, Size, Quantity
FROM (
  SELECT Location, 'Small' as Size, Small as Quantity FROM [table]
), (
  SELECT Location, 'Medium' as Size, Medium as Quantity FROM [table]
), (
  SELECT Location, 'Large' as Size, Large as Quantity FROM [table]
)

  **
  ** REPLACE VALUES IN CPANEL.PW_STAT WITHOUT REBUILDING THE ENTIRE TABLE.
  *;
  data cpanel.pw_stat;

    set redirect_updates;
    modify cpanel.pw_stat key=primary;

    select(_iorc_);  
      when(%sysrc(_sok)) do;
        * MATCHED TRANSACTION DATASET TO MASTER DATASET. REPLACE THE VALUE;
        if date_redirected ne tmp_date_redirected then do;
          date_redirected = tmp_date_redirected;
          replace;
        end;
      end;
      when(%sysrc(_dsenom)) do;
        * NO MATCH. DO NOT ADD OBS OR REPLACE OBS OR DELETE OBS.  RESET ERR AND DO NOTHING.;
        _error_ = 0;
      end;
      otherwise do;
        put 'ERROR: Unexpected value for _IORC_= ' _iorc_;
        put 'Program terminating. DATA step iteration # ' _n_;
        put _all_;
        stop;
      end;
    end;
  run;

select sdo_geom.sdo_distance (a.spatial_data, b.spatial_data, 0.05, 'unit=km')
from st_country_postal_code a, st_country_postal_code b
where a.country_id = '124'
and a.postal_code = UPPER ('V3G1M2')
and b.country_id = '124'
and b.postal_code = UPPER ('V2R0N3');

cri.Add(Restrictions.Like(
            Projections.SqlFunction("concat",
                                    NHibernateUtil.String,
                                    Projections.Constant(","), 
                                    Projections.Property("ServiceCodes"),
                                    Projections.Constant(",")),
        "%,33,%"));

CASE WHEN status = 'N' THEN 'Export to WMS' ELSE ' ' END  AS "Export to WMS"

SELECT  
     case when UserName=lag(UserName) OVER (ORDER BY UserName) 
     then null 
     else UserName end UserName,
     UserEmail, 
     BoardName
FROM 
     YourTable;

WITH TransactionCounts as (
   SELECT
       CustID,
       COUNT(*) AS TransactionCount
   FROM [dbo].[TRANSACTION]
   GROUP BY CustID
)
SELECT TOP 1 CUSTOMER.*, TransactionCount
FROM TransactionCounts
    INNER JOIN CUSTOMER ON CUSTOMER.CustID = TransactionCounts.CustId
ORDER BY TransactionCount DESC

-- alternate to select all if multiple customers are tied for highest count
--WHERE TransactionCount = (SELECT MAX(TransactionCount) FROM TransactionCounts)

SELECT *, GROUP_CONCAT( grade_id ) AS gradeid
  FROM employee_details_table t1
  LEFT JOIN department_table t2
    USING ( dept_no )
  LEFT JOIN relation_table t3
    USING ( emp_no )
  LEFT JOIN grade_table t4
    USING ( grade_id )
  WHERE grade_id IN ('1','2','3')
  GROUP BY t1.emp_no
  HAVING COUNT(DISTINCT grade_id) = 3;

<?php $first_loop = 0; ?>
@foreach($links as $link)
    @if($first_loop == 0)
        <?php 
        $first_loop = 1;
        $current_year = $link->year;
        ?>
        <h3 class="text-uppercase"><a href="{{ url('blog/'.$link->year) }}">{{ $link->year }}</a></h3>
        <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p>
    @else
        @if($current_year == $link->year)
            <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p>
            <?php
            $current_year = $link->year;
            ?>
        @else
            <h3 class="text-uppercase"><a href="{{ url('blog/'.$link->year) }}">{{ $link->year }}</a></h3>
            <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p>
            <?php
            $current_year = $link->year;
            ?>
        @endif
    @endif
@endforeach

SELECT @SearchFilter.value('(/KeywordSearch/SelfEmployed/text())[1]', 'varchar(100)')

SELECT SUBSTRING([description],CHARINDEX('BuildNumber:',[description])+12,
    CHARINDEX(']',[description], CHARINDEX('BuildNumber:',[description]))
    -(CHARINDEX('BuildNumber:',[description])+12))
FROM YOURTABLE

SQL> alter session set nls_timestamp_format = 'YYYY-MM-DD HH24:MI:SSXFF';

Session altered.

SQL> with t as (
  2     select 'Podlaski Oddział Straży Granicznej
  3  Informacja dobowa o zdarzeniach na terenie województwa podlaskiego
  4  w dniu 15.04.2013 r.'
  5         as original_string
  6       from dual)
  7  select to_timestamp(regexp_substr(original_string, '\d\d\.\d\d\.\d\d\d\d'), 'DD.MM.YYYY') as the_timestamp
  8    from t;

THE_TIMESTAMP
---------------------------------------------------------------------------
2013-04-15 00:00:00,000000000

1 row selected.

UPDATE MyTable
SET [Result]= ISNULL([Result],'') + '<Cat>'
WHERE ID IN (3,4);


UPDATE MyTable
SET [Result]= ISNULL([Result],'') + '<Dog>'
WHERE ID IN (4,5);

DELETE FROM WRITTEN_BY WHERE Pub_ID IN (
SELECT Pub_ID FROM PUBLICATION
                   WHERE Pub_Title = 'Introduciton to Database system' )

INSERT INTO WRITTEN_BY 
SELECT Re_Id,Pub_Id
FROM RESEARCHER CROSS JOIN PUBLICATION 
WHERE Re_Name = 'Henry Gordon' OR Re_Name = 'Sarah Paker' 
AND Pub_Title like 'Introduciton to Database system'

SELECT * FROM WRITTEN_BY

SELECT userId,
       SUM(case when TYPE='fine' then amount else 0 end) as totalFine, 
       SUM(amount) AS totalDeposite
FROM trx 
GROUP BY userId

SELECT  c.value
  FROM  tblhosting a INNER JOIN tblcustomfields b
            ON b.relid = a.packageid
        INNER JOIN tblcustomfieldsvalues c
            ON c.fieldid = b.id
 WHERE  a.id = '$id'  AND   
        a.userid = '$userid' AND 
        b.fieldname = 'foo'

SELECT * 
FROM Table1 
ORDER BY Id 
LIMIT 4,1 -- here you provide which row you want to retrieve
          -- 4 indicates from which row start selecting (offset)
          -- 1 - how many rows you want to retrieve
          -- you can change It as you like

 SELECT * 
FROM
(
select *, ROW_NUMBER() over ( partition by projectId order by classType) as seq FROM
(
    Select projectID, classType, sum(Amount) as Total, 
           sum(case when Classyear = 2014 then Amount else 0 end) as CurrentYear, 
           sum(case when ClassYear <2014 then Amount else 0 end) as PriorYear, 
           sum( case when ClassYear > 2014 then Amount else 0 end) as PostYear

    from 
    myTable
    group by ProjectID, classType
) T
Where (T.Total >0 and classType <> 'C') or classType ='C' 
) C
where seq =1

SELECT sum(case when Frequency = 'Monthly' then Amount else 0 end) + 
       sum(case when Frequency = '4 Weekly' then Amount / 2 else 0 end) +
       sum(case when Frequency = 'Fortnightly' then Amount / 3 else 0 end) +
       sum(case when Frequency = 'Weekly' then Amount,0.0) / 5 else 0 end) 
FROM Table
WHERE Id = 1;

SELECT ft.FileNo, pt.Amount, 'True' IsPayment
FROM FileTable ft
JOIN PaymentTable pt ON pt.FK_FileID = ft.FileId
UNION ALL
SELECT ft.FileNo, et.Amount, 'False' IsPayment
FROM FileTable ft
JOIN ExpenseTable et ON et.FK_FileID = ft.FileId

select AH_NAME1 COLLATE DATABASE_DEFAULT from GGIMAIN.SYSADM.BW_AUFTR_KOPF
union
select AH_NAME1 COLLATE DATABASE_DEFAULT from GGI2014.SYSADM.BW_AUFTR_KOPF

Update Backup
set ImageURL =replace(ImageURL,'/s/','/I/')

select attname, format_type(atttypid, atttypmod)
from pg_type
     join pg_class on pg_class.oid = pg_type.typrelid
     join pg_attribute on pg_attribute.attrelid = pg_class.oid
where typname = 'mytype'
order by attnum

"SELECT id FROM MUSIC WHERE id IN ($files)"

SELECT MONTH(DateColumn) AS MonthNumber, COUNT(1) AS Occurances
FROM schema.TableName
GROUP BY MONTH(DateColumn)

CREATE PROCEDURE OntoNewVersion
    @new_title NVARCHAR(100) 
AS 
BEGIN 
 BEGIN TRY
  BEGIN TRANSACTION T1
    DECLARE @versid INT
    INSERT INTO Versions (title) VALUES (@new_title)
    SET @versid = SCOPE_IDENTITY()


    INSERT INTO Questions 
        (qtext,subsection_id,version_id,viewtype)  
    SELECT qtext, subsection_id,@versid,viewtype 
    FROM Questions  
  COMMIT TRANSACTION T1
 END TRY

 BEGIN CATCH
  IF(@@TRANCOUNT>0)
    BEGIN 
        ROLLBACK TRANSACTION T1
    END
  ;THROW    
 END CATCH
END

select 
      a.id,
      a.name,
      ga.earned_epoch,
      ga.offline
   from   
      achievement a 
         LEFT OUTER JOIN gamer_achievement ga 
             ON a.id = ga.achievement_id
            AND a.game_id = ga.game_id
            AND ga.gamer_id = 'fba8fcaa-f57b-44c6-9431-4ab78605b024'
   where
      a.game_id = '1480656849'
   order by 
      convert (a.id, unsigned)

select top 1 userid, count(certificatename) total
from certificates
group by userid -- but not certificatename
order by 2 desc --you can use total or count(certificatname) here

$ db2 connect to sample

   Database Connection Information

 Database server        = DB2/LINUX 9.1.9
 SQL authorization ID   = IDBJORH
 Local database alias   = SAMPLE

$ db2 values current server

1                 
------------------
SAMPLE            

  1 record(s) selected.

select m, pid, s
from (select r.m, r.pid, sum(s) as s,
             row_number() over (partition by m order by sum(s) desc) as seqnum
      from report r
      group by r.m, r.pid
     ) r
where seqnum <= 3
order by m, s desc;

SELECT b.[CUSIP NUMBER],
       b.[ORIGINAL BALANCE],
       b.[ORIGINAL WA MATURITY],
       b. [PASS THRU RATE],
       Monthlypayment,
       Monthlypayment2
FROM   DBO.mbs012013 a
       JOIN dbo.mbs022013 b
         ON a.[CUSIP NUMBER] = b.[CUSIP NUMBER]
       CROSS APPLY (SELECT b.[ORIGINAL BALANCE] * ( ( b.[PASS THRU RATE] / 12 ) * ( 1 + power (( b.[PASS THRU RATE] / 12 ), b.[ORIGINAL WA MATURITY]) ) / ( 1 + ( power (( b.[PASS THRU RATE] / 12 ), b.[ORIGINAL WA MATURITY]) ) ) )) CA(Monthlypayment)
       CROSS APPLY(SELECT 1 + Monthlypayment) CA2(Monthlypayment2) 

SELECT *
FROM SetA
LEFT INNER JOIN SetB
    ON 1 = 1  -- Voila, instant cross join

update test_table set column1=123 where column2 IN(100,200,300)

SELECT * FROM
    (SELECT ParentID, Caption, Name
        FROM #table) AS t
    PIVOT
    (
        MAX(t.Name)
        FOR Caption IN ([Plan], [Content], [Accuracy])
    ) AS pvt

CREATE TABLE dbo.foo (ID int IDENTITY(1,1) PRIMARY KEY, Other1 int, Other2 char(10) DEFAULT 'abcdefghij', Other3 varchar(52) DEFAULT 'abcdefghijklmnopqrstuvwxyz');
GO
INSERT dbo.foo (Other1) VALUES (1);
GO
INSERT dbo.foo (Other1) SELECT Other1 FROM dbo.foo;
GO 20
SELECT COUNT(*) FROM dbo.foo;
GO

-- now enable viewing of execution plans

SELECT * FROM dbo.foo WHERE id = 456789
-- Table 'foo'. Scan count 0, logical reads 3, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
GO
-- double up rows
INSERT dbo.foo (Other1) SELECT Other1 FROM dbo.foo;
GO

SELECT * FROM dbo.foo WHERE id = 456789
-- Table 'foo'. Scan count 0, logical reads 3, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0.
GO

SELECT a.Column1 AS 'Col1',
       a.Column2 AS 'Col2',
       null AS 'Col3',
       a.Column4 AS 'Col4'
FROM TableA AS a
UNION ALL
SELECT b.Column1 AS 'Col1',
       b.Column2 AS 'Col2',
       b.Column3 AS 'Col3',
       null  AS 'Col4'
FROM TableB AS b

UPDATE
  MyTable
SET
  Col1 = CASE WHEN b.Foo = "Bar" THEN LOWER(b.Baz) ELSE "" END,
  Col2 = ISNULL(c.Bling, 0) * 100 / Col3
FROM
  MyTable 
  INNER JOIN MySecondTable AS b ON b.Id = MyTable.SecondId
  LEFT  JOIN ##MyTempTable AS c ON c.Id = b.ThirdId
WHERE
  MyTabe.Col3 > 0
  AND b.Foo NOT IS NULL
  AND MyTable.TheDate > GETDATE() - 10

select 
   uc.id as creator,
   uu.id as updater,
   uo.id as owner,
   a.[name]
from
    asset a
    JOIN
    user uc ON uc.user_pk = a.created_by
    JOIN
    user uu ON uu.user_pk = a.updated_by
    JOIN
    user uo ON uo.user_pk = a.owned_by

CREATE VIEW friends AS
SELECT
    actor, director, film, num_together
FROM(
    SELECT
        a.aid AS actor,
        b.aid AS director,
        a.fid AS film,
        COUNT(*) OVER (PARTITION BY a.aid, b.aid) AS num_together
    FROM
        involved_in a
        INNER JOIN involved_in b ON
            a.fid = b.fid
    WHERE
        a.job IN ('actor', 'actress')
        AND b.job = 'director'
    ) foo
WHERE
    num_together < 'x' -- placeholder for your "limit the rows that appear with count less than x"

WITH AdjustedAdjustments AS (

select
  PersonID,
  Date,
  SubtractAmount/
  EXP(
    SUM(LOG(COALESCE(DivideAmount,1)))
      OVER (
        PARTITION BY PersonID
        ORDER BY Date
        ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
      )
  ) AS AdjustedSubtract,
  DivideAmount
  FROM TblAdj
)

  SELECT
    p.PersonID,
    p.Value/COALESCE(EXP(SUM(LOG(COALESCE(DivideAmount,1)))),1)
      -COALESCE(SUM(a.AdjustedSubtract),0) AS AmountAdjusted
  FROM TblVal AS p
  LEFT OUTER JOIN AdjustedAdjustments AS a
  ON a.PersonID = p.PersonID
  AND a.Date >= p.Date
  GROUP BY p.PersonID, p.Value, p.Date;

SELECT id, title FROM ts_Gallary WHERE (title LIKE '%%%@%%' OR location LIKE '%%%@%%' OR tags LIKE '%%%@%%') AND imageExistStatus = 1;

SELECT 
    bc.id, bc.title, bc.estimateCurrent,
    SUM(TIME_TO_SEC(TIMEDIFF(dateEnding, dateBeginning)))
FROM cases bc
JOIN timesheet ts on ts.`#case` = bc.id
GROUP BY bc.id, bc.title, bc.estimateCurrent

Sub FilterByParameter()
    Dim wb As Workbook
    Dim dataSheet As Worksheet
    Dim parameterSheet As Worksheet
    Dim rng As Range
    Dim filterColumn As Long
    Dim filterValue As String

    Set wb = ThisWorkbook
    ' sheet that contains your table
    Set dataSheet = wb.Sheets("Sheet1")
    ' sheet that contains your parameters
    Set parameterSheet = wb.Sheets("Sheet2")
    ' range that contains your table, hard-coded here
    ' but can easily be set dynamically
    Set rng = dataSheet.Range("A1:F78")

    ' get the column you are searching
    filterColumn = parameterSheet.Range("G1").Value

    ' get the value you want to filter on
    filterValue = parameterSheet.Range("G2").Value

    ' turn off autofilters if set
    dataSheet.AutoFilterMode = False

    ' autofilter using your column and filter
    rng.AutoFilter field:=filterColumn, Criteria1:=filterValue

    ' now you can do whatever you want to with the rows
    ' that remain after the autofilter was applied
End Sub

SELECT film.film_id, film.title, rental.return_date
FROM film
    INNER JOIN inventory ON inventory.film_id = film.film_id
    INNER JOIN rental ON rental.inventory_id = inventory.inventory_id
WHERE rental.return_date BETWEEN '2005-05-29' AND '2005-05-30'
ORDER BY rental.return_date

 UPDATE assoc SET cachedData = NULL
    WHERE EXISTS (SELECT * FROM otherTable 
        WHERE otherTable.Col1 = assoc.Col1 AND otherTable.Col2 = assoc.Col1)

with t as
  (select Emp_num, substr(date_key,1,4) as year, 
    avg(salary) over (partition by Emp_num order by Date_key rows unbounded preceding) as avg_sal,
    avg(bonus) over (partition by Emp_num order by Date_key rows unbounded preceding) as avg_bon,
    row_number() over (partition by Emp_num, substr(date_key,1,4) order by Date_key desc) as R
  from Table1)
select EMP_NUM, YEAR, AVG_SAL, AVG_BON
from t
where R = 1;


EMP_NUM     YEAR    AVG_SAL     AVG_BON
-------------------------------------------
54343       2010    498         50
54343       2011    553.5       62.5
54343       2012    598.2       70

WHERE coalesce(MainTable.RowVersion,'00000000-0000-0000-0000-000000000000') <> coalesce(CloneOfMainTable.RowVersion,'00000000-0000-0000-0000-000000000000')

UPDATE Table_a a
SET qty = qty + b.rn
FROM (
    SELECT id,ROW_NUMBER() OVER (ORDER BY id) rn
    FROM Table_a
    ) b
WHERE a.id = b.id

SELECT itemcode, count(itemcode) 'times purchased', sum(quantity) 'amount purchased'  
FROM `temp_trans` 
WHERE `trans_date` >= '2012-01-08' AND `trans_date` <= '2012-03-23' 
GROUP BY itemcode

var subquery = QueryOver.Of<WorkItem>().Where(w => w.State == state)
                .AndRestrictionOn(w => w.Type).IsLike(type, MatchMode.Exact)
                .SelectList(list => list.SelectGroup(w => w.UserId))
                    .OrderBy(Projections.Count<WorkItem>(x => x.UserId))
                .Desc().Take(1);

var query = CurrentSession.QueryOver<WorkItem>()
              .WithSubquery
              .WhereProperty(p => p.UserId)
              .Eq(subquery);

DECLARE @test DATETIME
SET @test = GETDATE()  -- or any other date

SELECT DATEADD(month, ((YEAR(@test) - 1900) * 12) + MONTH(@test), -1)

Declare @Week Int = 1

While @Week <= 52
Begin
    select count(distinct user_id) as count
    from tracking
    where datepart(wk,login_dt_tm) >= 0 and datepart(wk,login_dt_tm) <= @Week
    Set @Week += 1
End

SELECT InWarehouse.expiry_date, 
t1.active_substance, 
drugs.strength, 
drugs.strength_type, 
drugs.dosage_form, 
drugs.minimum_quantity,
InWarehouse.quantity + InPharmacy.quantity,
InPharmacy.expiry_date
FROM (SELECT InWarehouse.expiry_date, 
      drugs.active_substance, 
      drugs.strength, 
      drugs.strength_type, 
      drugs.dosage_form, 
      drugs.minimum_quantity, 
      NZ(SUM(InWarehouse.quantity),0) AS quant
 FROM drugs 
      LEFT JOIN (SELECT drug_id, 
                        expiry_date, 
                        SUM(in_quant - out_quant) AS quantity 
                FROM warehouse GROUP BY drug_id, expiry_date)  
 AS InWarehouse ON 
      InWarehouse.drug_id = drugs.id
      GROUP BY InWarehouse.expiry_date, 
      drugs.active_substance, 
      drugs.strength, 
      drugs.strength_type, 
      drugs.dosage_form, 
      drugs.minimum_quantity  
) t1
JOIN (  SELECT InPharmacy.expiry_date, 
      drugs.active_substance, 
      drugs.strength, 
      drugs.strength_type, 
      drugs.dosage_form, 
      drugs.minimum_quantity,
      NZ(SUM(InPharmacy.quantity), 0) as quant
 FROM (drugs
 LEFT JOIN (SELECT drug_id, expiry_date, SUM(in_quant - out_quant) as quantity
            FROM pharmacy
            GROUP BY drug_id, expiry_date) as InPharmacy
 ON InPharmacy.drug_id = drugs.id)

 GROUP BY  InPharmacy.expiry_date, 
      drugs.active_substance, 
      drugs.strength, 
      drugs.strength_type, 
      drugs.dosage_form, 
      drugs.minimum_quantity ) t2
 ON t1.active_substance = t2.active_substance

CREATE TABLE Anonymous
(
    ID_Column     SERIAL NOT NULL PRIMARY KEY,
    field1        BOOLEAN NOT NULL,
    field2        BOOLEAN NOT NULL,
    field3        BOOLEAN NOT NULL,
    field4        BOOLEAN NOT NULL,
    field5        CHAR(50),
    CHECK((field4 = 't' AND field5 IS NOT NULL) OR (field4 = 'f' AND field5 IS NULL))
);

SELECT start_dsgn, COUNT(CASE WHEN min_cost_1 <= @cost_1 OR min_cost_2 <= @cost_2 THEN end_dsng END) as Cnt
FROM table
GROUP BY start_dsgn

DECLARE @id INT
DECLARE id_cursor CURSOR FOR 
SELECT id from mytable where color = 'red'

OPEN id_cursor

FETCH NEXT FROM id_cursor 
INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN
    PRINT @id

    FETCH NEXT FROM id_cursor 
    INTO @id
END 
CLOSE id_cursor;
DEALLOCATE id_cursor;

--Generic example:
SELECT *
FROM MY_TABLE
WHERE SOME_FIELD IS NULL;

--Instead of    

SELECT *
FROM MY_TABLE
WHERE SOME_FIELD = NULL;

update tblToUpdate
set columnToUpdate = '0000-0000-0000-' + right(columnToUpdate , 4)

SELECT 
    NAME,
    LISTAGG(STRUCTURE_CODE||'.'||AGE_LIMIT , ',') WITHIN GROUP (ORDER BY STRUCTURE_CODE) AS AGE_LIMIT ,
    LISTAGG(STRUCTURE_CODE||'.'||BIRTHPLACE_LIMIT , ',') WITHIN GROUP (ORDER BY STRUCTURE_CODE) AS BIRTHPLACE_LIMIT                        
FROM "TABLE" GROUP BY NAME

SELECT message_type,
       COUNT(message_type) AS message_type_count,
       SUM(Unread = 1) AS unread_count
FROM Messages 
GROUP BY message_type

EXECUTE IMMEDIATE 'DELETE FROM dept WHERE deptno = :num'
  USING dept_id; 

SELECT o.NAME,
       o.STATE, 
       o.ITEM, 
       case when i.RATE is NULL 
            then ( select rate from item_desc 
                   where item = o.item
                   and coalesce(state,'') =''
                  )
            else i.RATE
            end as RATE
FROM ORDERS o
LEFT JOIN ITEM_DESC i
ON o.ITEM = i.ITEM
AND o.STATE = i.STATE

declare @d1 varchar(10) = CAST(DATEADD(dd,-1,CAST(GETDATE() as Date)) as varchar(10))
declare @d2 varchar(10) = CAST(DATEADD(dd,-2,CAST(GETDATE() as Date)) as varchar(10))
declare @d3 varchar(10) = CAST(DATEADD(dd,-3,CAST(GETDATE() as Date)) as varchar(10))
declare @d4 varchar(10) = CAST(DATEADD(dd,-4,CAST(GETDATE() as Date)) as varchar(10))
declare @d5 varchar(10) = CAST(DATEADD(dd,-5,CAST(GETDATE() as Date)) as varchar(10))
declare @d6 varchar(10) = CAST(DATEADD(dd,-6,CAST(GETDATE() as Date)) as varchar(10))
declare @d7 varchar(10) = CAST(DATEADD(dd,-7,CAST(GETDATE() as Date)) as varchar(10))
declare @SQL varchar(8000)

SET @SQL =
'Select
    *
From
    (
    Select
        unpvt.[Table]
        ,unpvt.value
        ,unpvt.Date
    From
        ORIGINAL_TABLE
        unpivot (
            value
            for [Table] in (Table_1
                ,Table_2
                ,Table_3
                ,...
                ,Table_35
            )
        ) unpvt
    Where
        Date > cast(dateadd(dd,-8,getdate()) as date)
    ) ref
    pivot (sum(ref.value)
        for ref.Date in (
            [' + @d1 + ']
            ,[' + @d2 + ']
            ,[' + @d3 + ']
            ,[' + @d4 + ']
            ,[' + @d5 + ']
            ,[' + @d6 + ']
            ,[' + @d7 + ']
        )
    ) as pvt'

EXEC(@SQL)

namespace MyApplication 
{ 
    public class myWebService : System.Web.Services.WebService 
    { 
        private classEmployee _emp = new classEmployee(); 

        [HttpGet]
        public string GetEmployees() 
        { 
            string EmployeeData = string.Empty; 
            EmployeeData = _emp.GetEmployees(); 
            return EmployeeData; 
        } 
    } 
}

UPDATE Table1 t1 JOIN
(
  SELECT id, @n := @n + 1 rnum
    FROM Table1 CROSS JOIN (SELECT @n := 0) i
   WHERE date IS NULL
   ORDER BY id
) t2 ON t1.id = t2.id CROSS JOIN
(
  SELECT MAX(date) date FROM Table1
) q
   SET t1.date = q.date + INTERVAL t2.rnum DAY

SELECT id,name,LENGTH(TRIM(name)) AS namelength
FROM table1 
GROUP BY id,name
HAVING LENGTH(TRIM(name)) > 3

>sqlcmd -i C:\panels_QA28July11.sql -o C:\PanelsImportResult.txt

select t.*
from (select t.*,
             row_number() over (partition by name, course order by lastupdate desc) as seqnum
      from t
     ) t
where seqnum = 1;

CREATE OR REPLACE FUNCTION to_char(timestamptz) RETURNS text AS
$$
    SELECT to_char($1,'YYYY/MM/DD~HH24:Mi:SS'); -- here your default setting
$$
LANGUAGE SQL;

declare @tab table(
       code int, 
       amount int)

insert into @tab values
    (1,100),
    (1,100),
    (1,100),
    (2,500),
    (2,500),
    (3,1000);

    select code, 
       case when rn=1 then 
           amount 
       else 0 end amount 
    from 
 (select *, 
          row_number()Over(partition by code Order by amount) RN 
      from @tab)t

INSERT INTO final_table (a,b)
SELECT a, b
FROM scratch_table

EXCEPT

SELECT a, b
FROM final_table

DATEADD(DD, DATEDIFF(DD, 0, STARTTIME), 0)  BETWEEN DATEADD(DD, DATEDIFF(DD, 0, <DATE_TIME_PARAMETER>), 0) AND DATEADD(DD, DATEDIFF(DD, 0, <DATE_TIME_PARAMETER>), 0)

select grp,
       ind,
       val
from (
   select grp, 
          ind, 
          val,
          lag(val,1,0::numeric) over (partition by grp order by ind) - val as diff
   from test_table
) t
where diff <> 0;

    SELECT  SUBSTRING_INDEX(SUBSTRING_INDEX(t.keywords, ',', n.n), ',', -1) value , count(*) as counts
    FROM table1 t CROSS JOIN 
   (
   SELECT a.N + b.N * 10 + 1 n
   FROM 
    (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL  SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) a
   ,(SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION  ALL SELECT 9) b

   ORDER BY n
 ) n
 WHERE n.n <= 1 + (LENGTH(t.keywords) - LENGTH(REPLACE(t.keywords, ',', '')))
 group by value

DECLARE @start DATETIME
DECLARE @end DATETIME

SET @start = DATEADD(dd, 0, DATEDIFF(dd, 0, GETUTCDATE()))
SET @end = DATEADD(dd, 1, DATEADD(ms, -3, @start))

SELECT   [ID], Country, MIN(Address), SUM(Price) As TotalPrice
FROM     tblYourTableName
GROUP BY [ID], Country
ORDER BY [ID]

insert into Customers(
  Cust_id, 
  Date,
  Rate,
  Type)

  select Cust_id, 
         Date, -- TODO:Generate required Date from given one
         Rate, -- TODO:Generate required Rate from given one
         Type  -- TODO:Generate required Type from given one
    from Customers 
   where Type = 'm' 

select t1.*, t2.*,
       ((case when t1.id = t2.id then 1 else 0 end) +
        (case when t1.foo = t2.foo then 1 else 0 end) +
        (case when t1.bar = t2.bar then 1 else 0 end) +
        . . .
       ) as NumMatches        
from table t1 join
     table t2
     on t1.id = t2.id or
        t1.foo = t2.foo or
        t1.bar = t2.bar or
        . . .
order by NumMatches desc;

INSERT INTO mytable (id, name) VALUES 
(NULL, :name1),
(NULL, :name2)

insert into tbl_users
select
x.y.value('(account_id)[1]', 'nvarchar(150)') as account_id
,x.y.value('(account_name)[1]', 'nvarchar(350)') as account_name
,x.y.value('(account_name_abbr)[1]', 'nvarchar(150)') as account_name_abbr
,x.y.value('(location/id)[1]', 'int') as location_id
,x.y.value('(cpu)[1]', 'int') as cpu_amount
,x.y.value('(ram)[1]', 'int') as ram_amount
,x.y.value('(disk)[1]', 'int') as disk_amount
from @xml.nodes('//install/client/vlans') as x(y)
declare @tbl_users_id int = scope_identity()

insert tbl_users_vlans([user_id],[vlan])
select @tbl_users_id, x.y.value('data(.)', 'nvarchar(150)')
from @xml.nodes('//install/client/vlans/item') as x(y)

SELECT country_code
     , COUNT(emission_class) AS total
     , SUM(CASE WHEN emission_class = 'E0' THEN 1 ELSE 0 END) AS EURO0
     , SUM(CASE WHEN emission_class = 'E?' THEN 1 ELSE 0 END) AS EURO?
     , ...
FROM DB.CUSTOMER_VEHICLE
GROUP BY country_code;

select MyColumn
from MyTable
order by 
    case IsNumeric(MyColumn) 
        when 1 then Replicate('0', 100 - Len(MyColumn)) + MyColumn
        else MyColumn
    end

SELECT T.ID, T.SEQ, MAX(T.AMOUNT) AMOUNT, D.DS
FROM tbl T
CROSS APPLY
(
    SELECT [DESCRIPTION] + ' '
    FROM tbl B
        WHERE T.ID = B.ID
            AND T.SEQ = B.SEQ
            AND [DESCRIPTION] IS NOT NULL
    FOR XML PATH('')
) D(DS)
GROUP BY ID, SEQ, DS

SELECT LEFT(`delivery_postcode`, 2) as `postcode`
,     count(`delivery_postcode`) as `count`
,     pc.placeCount
FROM `customer_cards` cc
LEFT JOIN  (
               SELECT LEFT(`placePostcode`, 2) as `postcode`, 
               count(`placePostcode`) as `placeCount`
               FROM `RestaurantsForGoogleMaps`
               WHERE `placePostcode` IS NOT NULL
                   AND `placePostcode` <> ''
              GROUP BY `postcode`
           ) pc
       on  pc.postcode = LEFT(cc.delivery_postcode, 2)
WHERE `delivery_postcode` IS NOT NULL
AND `delivery_postcode` <> ''
GROUP BY `postcode`
ORDER BY `count` DESC

UPDATE yourTable 
SET yourTextColumn = CONCAT(yourTextColumn, '<br/>signature blabla<br/>') 
WHERE catid IN (778, 779, 780);

select @max := max( RandomId ) from Products;
update Products set RandomId = @max := @max + Rand() + 1;

SELECT t1.name AS name, t1.car AS car, t1.price AS max_price
    FROM table1 t1
    ORDER BY max_price DESC
    LIMIT 1;

select max(total.id) as id,
                     sum(total.product_qty) as product_qty,
                     total.location_id as location_id,
                     total.date as "date",
                     total.year as year,
                     total.month as month,
                     total.day as day,
                     total.product_id as product_id
                     from (
                       -- From Consumer back to location
                        select -max(id) as id,
                        -sum(product_qty) as product_qty, 
                        location_dest_id as location_id, 
                        "date", year, month, day, product_id
                        from report_stock_move
                        where location_id in (
                            select id
                            from stock_location
                            where "name" = 'Consumers'
                        )
                        and "state" = 'done'
                        group by location_dest_id, "date", year, month, day, product_id

                        union all

                        -- From Location to Consumer
                        select max(id) as id,
                        sum(product_qty) as product_qty, 
                        location_id, "date", year, month, day, product_id
                        from report_stock_move
                        where location_id not in (
                            select id
                            from stock_location
                            where "name" = 'Consumers'
                        )
                        and "state" = 'done'
                        and location_dest_id in (
                            select id
                            from stock_location
                            where "name" = 'Consumers'
                        )
                        group by location_id, "date", year, month, day, product_id
                     ) as total
                     group by location_id, "date", year, month, day, product_id

using System.Data.Objects;

EntityFunctions.AsNonUnicode( myUnicodeParam)

WITH RECURSIVE tree(product_id, name, parentlist) AS (
  SELECT product_id, name, ARRAY[ row_number() OVER (ORDER BY product_id) ]
  FROM tree_products
  WHERE parent_id IS NULL
  UNION
  SELECT tp.product_id, tp.name, array_append(parentlist, row_number() OVER (ORDER BY tp.product_id))
  FROM tree_products tp
  INNER JOIN tree t
  ON (tp.parent_id = t.product_id)
)
SELECT *
FROM tree
ORDER BY parentlist;

DECLARE @str VARCHAR(MAX)='team_name:Brighton|stadium:American Express Community Stadium|max_attendance:30750';
SELECT LEN(@str)-LEN(REPLACE(@str,'|','')) + 1;

SELECT t.line, MIN(t.START), MAX(t.END), t.typ, t.color
FROM dbo.tablename t
GROUP BY t.line, t.typ,  t.color

delete from tbl_test t 
  where t.sta in ('F', 'R') and exists ( 
      select 1 from tbl_test b 
        where b.ser_no = t.ser_no 
          and (sta='L' or (sta<>'L' and b.id<t.id)) )

C+ = C
C+ = CD (by using the third dependency)
C+ = CDB (by using the fourth dependency)

select * 
from [My_Table] t
where [Order] > 0
  and ([Date] between '20150201' and '20150228')
  and not exists ( select *
                   from [My_Table]
                   where [Order] > 0
                     and [User] = t.[User]
                     and [Date] between '20150301' and '20150331')

update item
    set quantity = (select sum(value) from quantities where item.id = quantities.item_id);

select sid
from your_table
group by sid
where (cid=2 and data='john_email')
or (cid=4 and data='ok')
having sum(cid=2)=1 and sum(data='john_email')=1
and sum(cid=4)=1 and sum(data='ok')=1

declare @UNIX_TIME int
select @UNIX_TIME = 1111111111
-- Using dateadd to add seconds to 1970-01-01
select [Datetime from UNIX Time] = dateadd(ss,@UNIX_TIME,'1970-01-01')

SELECT x.*
  FROM things x
  JOIN 
     ( SELECT brand
            , model
            , MAX(effective_from) max_effective_from 
         FROM things 
        WHERE effective_from <= UNIX_TIMESTAMP() 
        GROUP 
           BY brand
            , model
     ) y 
    ON y.brand = x.brand 
   AND y.model = x.model 
   AND y.max_effective_from = x.effective_from;
+------+-------+-------+----------------+-------+
| id   | brand | model | effective_from | price |
+------+-------+-------+----------------+-------+
|    1 | a     | red   |     1402351200 |   100 |
|    2 | b     | red   |     1402351200 |   110 |
|    3 | a     | green |     1402391200 |   120 |
|    7 | b     | green |     1402358200 |   135 |
+------+-------+-------+----------------+-------+

SELECT UNIX_TIMESTAMP();
+------------------+
| UNIX_TIMESTAMP() |
+------------------+
|       1402404432 |
+------------------+

declare @tmp table(driverid nvarchar(10),createddate datetime)

--insert a sample record first
insert into @tmp
select '7x123','2015-6-20'


declare @incomingvalue nvarchar(10) = '7x123';

declare @now datetime = getdate();
declare @threshold datetime = @now - 90;

if exists(select * from @tmp where driverid = @incomingvalue and createddate >= @threshold)
begin
  print 'Already a record on file within 90 days, no action taken';
end
else
begin
  insert into @tmp
  select @incomingvalue, @now
  print 'Nothing on file in last 90 days, record inserted';
end

select * from @tmp

select * from MDSYS.SDO_COORD_REF_SYS sample(1);

SELECT t.id, t.title 
  FROM task AS t
    LEFT JOIN activity AS a ON t.id=a.task_id
  GROUP BY t.id
  ORDER BY COALESCE(MAX(a.createdat), t.createdat) DESC

SELECT Row_Number() Over (order by (select null)) ID, 
    COALESCE(t1.Name,t2.Name) Name, 
    COALESCE(t1.Value,0) T1Value, 
    COALESCE(t2.Value,0) T2Value
FROM databasename.schemaname.table1 t1
    FULL OUTER JOIN databasename.schemaname.table2 t2 ON t1.Name = t2.Name

$dbh = new PDO('mysql:host=localhost;dbname=mydatabase', $user, $pass,
               array( PDO::ATTR_PERSISTENT => true
       ));

SELECT a.id, a.sku 
FROM product AS a 
    INNER JOIN product_stock AS b  ON a.id = b.product_id
WHERE b.in_stock = 1 AND a.type = 'X'
and exists (
    SELECT 'EXISTS'
    FROM product d
        INNER JOIN product_relation AS c ON c.child_id = d.product_id
    WHERE 
        c.product_id = a.product_id
        AND (d.quantity > 0 or d.in_stock = true)

)

UPDATE tableName
SET ImagePath = REPLACE(ImagePath, '/project/images/', '/projects/project-a/images')

SELECT a.US, a.decade, b.total FROM

  (SELECT COUNT(A.Award) AS US, SUBSTRING(CAST(M.Year as char(4)), 0 , 4)  AS Decade
  FROM Movies M, Awards A
  WHERE {SOME WHERE CLAUSE}
  GROUP BY Decade ) AS a

INNER JOIN

  (SELECT COUNT(*) AS Total, SUBSTRING(CAST(A2.Year as char(4)), 0 , 4) AS Decade
  FROM Awards A2
  WHERE {SOME WHERE CLAUSE}
  GROUP BY Decade) AS b

ON a.decade = b.decade

UPDATE test2 t2 
 SET t2.name = (SELECT t1.name 
                 FROM test1 t1 
                WHERE t1.id = t2.mob)

select *
from orders o left join orderdata od on o.orderId=od.orderid

select distinct cr1.movie
from credits as cr1
join credits as cr2
using (movie)
where cr1.person = {person 1 goes here}
and cr2.person = {person 2 goes here}

SELECT t1.*
FROM PlanActual AS t1
INNER JOIN (
   SELECT MIN(Seq) AS minSeq, Phase
   FROM PlanActual
   GROUP BY Phase    
) AS t2 ON t1.Phase = t2.Phase
ORDER BY t2.minSeq     

create table YOUR_TABLE(ID integer, DT datetime);
insert into YOUR_TABLE
    select 2, '02/02/2016 12:00:00' union all
    select 3, '02/05/2016 12:00:00' union all
    select 4, '02/06/2016 12:00:00' union all
    select 5, '02/07/2016 12:00:00' 
;

select 
    ID,
    DT,
    datediff(day, DT, lead(DT) over (order by ID)) as DIFF
from your_table;

select * from myTable
where CHARINDEX(cast(mycol as varchar), @myVar) > 0

UPDATE goals_scored SET goalRank = (
  SELECT count(*) FROM goals_scored AS i WHERE 
    i.numGoalsScored > goals_scored.numGoalsScored AND
    i.gender = goals_scored.gender
) + 1;

update detail_box
set
   name = decode(sn, 2, 'Gita', 3, 'Krish', name),
   date1 = (case when sn = 2 and date2 is null then to_date('2015-10-16', 'YYYY-MM-DD') else date1 end),
   date2 = (case when sn = 3 and date2 is null then to_date('2015-10-16', 'YYYY-MM-DD') else date2 end)

Private Sub cboProject_Change()

    cboPlans.RowSource = "SELECT * FROM tblPlans WHERE ProjectID = " & cboProject.Value
    cboPlans.Requery

End Sub

WITH tokenkeys 
as
(
    select regexp_substr('A set of words from other side','[^ ]+', 1, level) WORDSPLIT from dual
    connect by regexp_substr('A set of words from other side', '[^ ]+', 1, level) is not null
)
select distinct p.* from people p
join tokenkeys on p.name in (tokenkeys.wordsplit)
or UTL_MATCH.EDIT_DISTANCE_SIMILARITY(p.lastname, tokenkeys.wordsplit) > 60

select s.id as id, s.msts as msts, s.action as action from (
  select min(named_struct('msts', msts, 'id', id, 'action', action)) as s
  from A group by id
) t;

SELECT S.*, Su.*
FROM Student AS S
INNER JOIN Student_Subject AS SS
    ON S.StudentID = SS.StudentID
INNER JOIN Subject AS Su
    ON SS.OfferCode = Su.OfferCode

declare @directorId int

select @directorId = DirectorID 
from dbo.tblDirector 
where DirectorName='Steven Spielberg'

select t1.date, case when t3.IDCLIENT is not NULL then t3.value else t2.value end as Value
from Table1 t1 inner join Table2 t2 on t1.IDCLIENT = t2.IDCLIENT inner join
Table3 t3 on t1.IDCLIENT = t3.IDCLIENT

CREATE OR REPLACE PROCEDURE ReverseOf(input IN varchar2) IS
        reverse varchar2(50);
BEGIN
        FOR i in reverse 1..length(input) LOOP
                reverse := reverse||''||substr(input, i, 1);
        END LOOP;
        dbms_output.put_line(reverse);
END;

Select
    user.id,
    all_time.total AS theCount, 
    last_month.total AS theCount2
From users AS user
Left Outer Join 
    (Select Count(id) as total, invited_by_id
     From users
     Group By invited_by_id) as all_time
       On all_time.invited_by_id = user.id
Left Outer Join
    (Select Count(id) as total, invited_by_id
     From users 
     Where signup_date >= NOW() - INTERVAL 30 DAY
     Group By invited_by_id) AS last_month 
       On last_month.invited_by_id = user.id

select * from demo a
where not exists(
select 1 from demo b 
where a.demo_id!=b.demo_id
AND A.S < B.E
AND B.S < A.E)

select a.FORM_JOURNAL_ID, 
       a.COMPANY_ID, 
       a.RETAIL_PRICE as RETAIL, 
       a.WHOLE_SALE_PRICE as WHOLESALE, 
       nvl(b.INDIVIDUALS,0) as INDIVIDUALS, 
       nvl(b.ENTITIES,0) as ENTITIES, 
       nvl(b.COMPLEX,0) as COMPLEX
  from TableA a, TableB b
 where a.FORM_JOURNAL_ID = b.FORM_JOURNAL_ID (+)
   and a.COMPANY_ID = b.COMPANY_ID (+)
union
select b.FORM_JOURNAL_ID, 
       b.COMPANY_ID, 
       nvl(a.RETAIL_PRICE,0) as RETAIL, 
       nvl(a.WHOLE_SALE_PRICE,0) as WHOLESALE, 
       b.INDIVIDUALS, 
       b.ENTITIES, 
       b.COMPLEX
  from TableA a, TableB b
 where b.FORM_JOURNAL_ID = a.FORM_JOURNAL_ID (+)
   and b.COMPANY_ID = a.COMPANY_ID (+);

select post_id, min(topic_id)
    from YourTable
    group by post_id

AND textfield1 LIKE '* value3 *'

order by (case when t1.ordering > t2.number then 1 else 2 end),
         t1.ordering

#define kDatabaseName (@"levelProgress.db")
- (void)checkAndCopyDatabaseIfNeeded
{
    if (!self.databasePath)
    {
        // Database should be present in user sandbox at root.
        self.databasePath = [NSString pathWithComponents:[NSArray arrayWithObjects:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject], kDatabaseName, nil]];
    }

    // Check if the file already copied/exists.
    NSFileManager *fileManager = [NSFileManager defaultManager];
    BOOL success = [fileManager fileExistsAtPath:self.databasePath];

    if(!success)
    {
        // Copy the file from app bundle to user sandbox (Files in app bundle can not be edited).

        NSString *databasePathFromApp = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:kDatabaseName];

#if DEBUG
        BOOL isCopied =
#endif
        [fileManager copyItemAtPath:databasePathFromApp toPath:self.databasePath error:nil];

        NSAssert(isCopied, @"Problem copying database file to user document folder");
    }
}

SELECT COUNT(DISTINCT PoliticianId) AS result
FROM Votes
WHERE UserId = 1010 ;

    select 
        st.name [Table],
        sc.name [Column],
        sep.value [Description]
    from sys.tables st
    inner join sys.columns sc on st.object_id = sc.object_id
    left join sys.extended_properties sep on st.object_id = sep.major_id
                                         and sc.column_id = sep.minor_id
                                         and sep.name = 'MS_Description'
    where st.name = @TableName
    and sc.name = @ColumnName

select
  start_date,
  stop_date_original
from
  dates
where 
  start_date is not null
  and stop_date_original is not null 
  and start_date > str_to_date('10/10/2009','%d/%m/%Y')
  and stop_date_original < str_to_date('24/01/2013','%d/%m/%Y')

SELECT widget,
       max(CASE WHEN rn = 1 THEN a_name ELSE NULL END) a_name1,
       max(CASE WHEN rn = 1 THEN a_value ELSE NULL END) a_value1,
       max(CASE WHEN rn = 2 THEN a_name ELSE NULL END) a_name2,
       max(CASE WHEN rn = 2 THEN a_value ELSE NULL END) a_value2,
       max(CASE WHEN rn = 3 THEN a_name ELSE NULL END) a_name3,
       max(CASE WHEN rn = 3 THEN a_value ELSE NULL END) a_value3,
       max(CASE WHEN rn = 4 THEN a_name ELSE NULL END) a_name4,
       max(CASE WHEN rn = 4 THEN a_value ELSE NULL END) a_value4
  FROM( SELECT widget,
               a_name,
               a_value,
               row_number() over (partition by widget 
                                      order by a_name, a_value) rn
          FROM attrs )
 GROUP BY widget

Select Case Cells(1, 1).Text ' cell A1 contains Y or N

    Case "Y": sWhereClause = " where Med_D = 'Y'"

    Case "N": sWhereClause = " where Med_D in ('Y','N')"

    Case Else: MsgBox "error": Exit Sub

End Select

Debug.Print SQL & sWhereClause ' send this to Access

UPDATE  c
SET     c.Price = c.Quantity * a.Rate
FROM    TableC c
        INNER JOIN TableB b
            ON c.ProductID = b.ProductID
        INNER JOIN TableA a
            ON b.StoreID = a.StoreID
WHERE   c.Price = 0

var query = from table1 in data.Table1s
                join table2 in data.Table2s
                on table1.ID equals table2.ID
    into x            
    select new {
        table1.Shirt,
        Pants = x.Sum(c=>c.Pants) + table1.Pants,
        table1.Shoes
};

SELECT s.SR_Service_RecID
     , sc.Config_RecID
FROM SR_Service s
LEFT JOIN SR_Config sc
     ON sc.SR_Service_RecID = s.SR_Service_RecID
     AND sc.Config_RecID = (
           SELECT TOP 1 Config_RecID
           FROM SR_Config sc2 
           WHERE sc2.SR_Service_RecID = s.SR_Service_RecID
     )

select s = sum(len(firstname) + len(lastname) + len(emailaddress) +
       len(coalesce(LEFT(CategoryNames,LEN(CategoryNames) - 1),'')))
     , r.ClientID 
from Customer r
  cross apply
   (Select cc.description + '|'
    FROM Category cc
    join CustomerCategory c on c.categoryid = cc.categoryid
    WHERE r.customerid = c.customerid
    For XML PATH('')) x (CategoryNames)
group by r.ClientID
order by 1 desc

WHERE YEAR(A.[reimbursementDate]) = YEAR(GETDATE())

SELECT *
FROM
(
  select ACCESSION_PAYMENTS_DAILY_KEY, 
    accession_id, 
    check_num,
    procedure_code,
    paid_amt,
    row_number() over (partition by   accession_id, check_num,procedure_code,paid_amt order by ACCESSION_PAYMENTS_DAILY_KEY) as occurrence
  from      [MILLENNIUM_DW_DEV].[dbo].[F_PAYOR_PAYMENTS_DAILY]         
  where PROCEDURE_CODE is not null
     and PAID_AMT>0
) x
WHERE x.occurrence>1

SELECT [orderId], MAX([datetime])
FROM [table]
GROUP BY [orderId]
ORDER BY MAX([datetime]) DESC

select key, max(ts) from yourTable group by key

$sql = "SELECT DATE_FORMAT(NOW(), '%%Y') - DATE_FORMAT(DOB, '%%Y') - (DATE_FORMAT(NOW(), '00-%%m-%%d') < DATE_FORMAT(DOB, '00-%%m-%%d')) AS age from test where user_name = '%s'";

SELECT a.*
  FROM (
                select s.*, sum(volume) OVER previous_rows as total
                         from stuff s
                         WINDOW previous_rows as
                            (ORDER BY priority desc ROWS between UNBOUNDED PRECEDING and CURRENT ROW)
                         order by priority desc
             ) AS a
where a.total < 1000

UPDATE visits
SET logout_datetime = NOW()
WHERE member_id = 1 AND visit_message = "accept"

select ID,
       Word
from
  (
  select ID,
         Word,
         row_number() over(partition by left(Word, 1) order by Word) as rn
  from YourTable
  ) as T
where rn = 1

WITH inventory_time_in_freezer AS (
SELECT i1.inv_id, SUM(i1.out_time - i1.in_time) as time_in_freezer
FROM inventory_tack i1
WHERE out_time IS NOT NULL
GROUP BY i1.inv_id
)
SELECT i2.inv_id, MAX(i2.in_time) - MIN(i2.in_time) - iif.time_in_freezer
FROM inventory_tack i2
JOIN inventory_time_in_freezer iif ON iif.inv_id = i2.inv_id
GROUP BY i2.inv_id, iif.time_in_freezer

SELECT users.id, roles.id, 
    CASE WHEN usersroles.roles_id IS NULL THEN 0 ELSE 1 END AS has_the_role
FROM users
INNER JOIN roles
LEFT JOIN usersroles ON users.id = usersroles.users_id AND roles.id = usersroles.roles_id

select col2name, sum(col3 + col5)
from (select COL1, COL2 as COL2NAME, sum(COL3A+COL3B) as COL3,
             COL4 as COL4NAME, count(COL5NO) as COL5,
             DENSE_RANK() OVER (ORDER BY COL1) as GROUPID
      from TAB
      group by COL1, COL2, COL4
     ) t
where GROUPID IN (1, 2)
group by col2name;

SELECT username from user_logins WHERE 
  username=? AND password_md5 = md5(?)

SELECT w.adharno,
       w.phone w_phone,
       descrip_w,
       amount_w,
       a.phone a_phone,
       decrip_a,
       amount_a
FROM table_w w
JOIN table_a a ON a.adharno = w.adharno
              AND w.descrip_w = a.decrip_a
              AND (w.phone <> a.phone
                OR w.amount_w <> a.amount_a)

CREATE TABLE userColors (
    userID INT,
    color VARCHAR(16),
    FOREIGN KEY (userID) REFERENCES users(user_id)
);

select survey.worker_id,
   (Select Value from Code where ID = survey.code_number_of_days_id) as No_of_Days,
   (Select Value from Code where ID = survey.code_gender) as Gender,
   Info.Name, 
   (Select Value from Code where ID = Info.code_category_id) as Category,
   (Select Value from Code where ID = Info.code_confirmed_status_id) as Confirmed,
from Survey 
full outer join Info 
on Survey.worker_id = Info.id 

SELECT DISTINCT name FROM items
WHERE something = 'foo'
AND name < (SELECT name FROM items WHERE name = ...)
ORDER BY name DESC
LIMIT 1

select t.id, t.player_name, t.team
from tablename t
join (select team, min(id) as minid from tablename group by team) x
on x.team = t.team and x.minid = t.id

select regexp_matches(page,'[^[[]+(?=\]])','g') from book

UPDATE repName
SET repName.Entered = x
FROM
    GenItems
    INNER JOIN repName
        ON GenItems.Job_Code = repName.Job_Code
WHERE
    repName.repID = x AND GenItems.Item_Name = 'y'

SELECT * FROM information_schema.columns Where TABLE_SCHEMA='test';

CREATE OR REPLACE FUNCTION dblink(text, text)
RETURNS SETOF record AS
  '$libdir/dblink', 'dblink_record'
  LANGUAGE 'c' VOLATILE STRICT
  COST 1
ROWS 1000;
ALTER FUNCTION dblink(text, text) OWNER TO postgres;
GRANT EXECUTE ON FUNCTION dblink(text, text) TO public; -- or whatever

INSERT INTO tbl_B select * from 
 (SELECT * from dblink('hostaddr=localhost port=5432 dbname=db_A user=postgres password=postgres',
'select id, a, b from tbl_A limit 20 '
)
t(
  id integer,
  a integer,
  b integer
)) as q;

DROP TABLE IF EXISTS meetings;
CREATE TABLE IF NOT EXISTS meetings 
( meeting_id int(10) unsigned NOT NULL AUTO_INCREMENT
, meeting_time datetime NOT NULL
, PRIMARY KEY (meeting_id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS meetings_users;
CREATE TABLE IF NOT EXISTS meetings_users 
( user_id int(10) unsigned NOT NULL
, meeting_id int(10) unsigned NOT NULL
, PRIMARY KEY (meeting_id,user_id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

DROP TABLE IF EXISTS users;
CREATE TABLE IF NOT EXISTS users 
( user_id int(10) unsigned NOT NULL AUTO_INCREMENT
, PRIMARY KEY (user_id)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8;

INSERT INTO  users ( user_id ) VALUES (1),(2),(3),(4);

INSERT INTO meetings ( meeting_id, meeting_time ) VALUES 
(1, '2013-01-14 10:00:00'), 
(2, '2013-01-15 10:00:00'), 
(3, '2013-01-16 10:00:00'),
(4, '2013-01-17 10:00:00'),
(5, '2013-01-18 10:00:00'),
(6, '2013-01-19 10:00:00'),
(7, '2013-01-20 10:00:00'),
(8, '2013-01-14 12:00:00');


INSERT INTO meetings_users (meeting_id, user_id ) VALUES 
(1, 1), 
(2, 1),
(2, 3),
(3, 1),
(3, 3),
(4, 2),
(4, 3), 
(5, 2), 
(6, 1),
(1, 8);

SET @dt = '2013-01-15';

SELECT user_id
     , start
     , DATEDIFF(@dt,start)+1 cons
  FROM
     (
       SELECT a.user_id
            , a.meeting_date Start
            , MIN(c.meeting_date) End
        , DATEDIFF(MIN(c.meeting_date),a.meeting_date)  + 1 diff
         FROM (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) a
         LEFT
         JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) b
       ON b.user_id = a.user_id
          AND a.meeting_date = b.meeting_date + INTERVAL 1 DAY
         LEFT
         JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) c
       ON c.user_id = a.user_id
          AND a.meeting_date <= c.meeting_date
         LEFT
         JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) d
           ON d.user_id = a.user_id
          AND c.meeting_date = d.meeting_date - INTERVAL 1 DAY
        WHERE b.meeting_date IS NULL
      AND c.meeting_date IS NOT NULL
          AND d.meeting_date IS NULL
        GROUP
       BY a.user_id
        , a.meeting_date
     ) x
 WHERE @dt BETWEEN start AND end;
 +---------+------------+------+
 | user_id | start      | cons |
 +---------+------------+------+
 |       1 | 2013-01-14 |    2 |
 |       3 | 2013-01-15 |    1 |
 +---------+------------+------+ 

select version
from versions_table
where to_date('<myInputDate>', 'dd.mm.yy') between to_date('from', 'mm.dd.yy') and to_date('to', 'mm.dd.yy');

select musicianID
from musicians m
left join gigs g on g.musicianId = m.musicianID
where g.musicianId is null

SELECT [ID]
     , CASE WHEN MAX(CASE WHEN [Date] IS NULL THEN 1 ELSE 0 END) = 0 THEN MAX([Date]) END
FROM YourTable
GROUP BY [ID]

select purchases.customer_name, purchases.product_name, COUNT(purchases.product_name) from purchases where customer_name "Brian" and product_name like 'Al% GROUP BY purchases.product_name, purchases.customer_name;

UPDATE FROM EmployeeAS e
 LEFT JOIN Department as dept
 ON e.? = dept.?
   AND e.Name = 'Good Employee' 
 SET e.Department = dept.AID

select NVL(MAX(A_COUNT),0) from MYTABLE where VEH_YEAR = '2003';

`foo bar` - is a valid MySQL identifier

foo bar - is not, since foo is the identifier, and bar is ambiguous

update table1
set
    value1 = (select value3 from table2 where id=7)
,   value2 = (select value4 from table2 where id=7)
where id=1

SELECT 
      k.`id`,
      m.`MACHINE`,
      kd.`key` 
FROM 
      KPIs as k,
      MACHINE as m,
      KPIDATA as kd
WHERE 
      k.`id` = SUBSTR(kd.`key`,LOCATE('.',kd.`key`)+1,3)
AND
      m.`MACHINE` = SUBSTR(kd.`key`,LOCATE('.i.',kd.`key`)+3,3)

declare @month varchar(2) = '10',
   @year varchar(4) = '2015',
   @fullWeekCount int;

declare @firstOfTheMonth datetime = @year + '-' + @month + '-1';
declare @daysInMonth int = datediff(day, @firstOfTheMonth, dateadd(month, 1, @firstOfTheMonth))
select @fullWeekCount = (@daysInMonth / 6)

declare @i int = 1,
    @startDate datetime = @firstOfTheMonth,
    @endDate datetime;

declare @dates table (StartDay datetime, EndDay datetime);

while (@i <= @fullWeekCount)
begin

    if (@i = @fullWeekCount)
        set @endDate = @year + '-' + @month + '-' + cast(@daysInMonth as varchar(2));
    else
        set @endDate = dateadd(day, 6, @startDate)

    insert into @dates (StartDay, EndDay)
    values (@startDate, @endDate)

    set @startDate = dateadd(day, 1, @endDate)
    set @i = @i + 1;

end

select * from @dates d

new_val := REPLACE( REPLACE( string_val, ':F:', CHR(10)||'F:' )
                  , ':L:', CHR(10)||'L:' );

UPDATE your_table
   SET comment_author_url = ''
 WHERE comment_author_url = 'http://google.com'

list_replace.setOnItemClickListener(new OnItemClickListener() {
@Override
public void onItemClick(AdapterView<?> Parent,View v, int Position, long id) {

        ContentValues cvs = new ContentValues();

       cvs.put(COLUMN_NAME_READING_MODE, ReadingMode);
       cvs.put(COLUMN_NAME_PASTDATETIME, StartDate);
       cvs.put("EndDateTime", CurrentDateTime);
       cvs.put(COLUMN_NAME_READINGVALUE,Reading);
       SQLiteDatabase db = context.openOrCreateDatabase(DATABASE_NAME,
            Context.MODE_PRIVATE, null);   // add this line
       db.update(TABLE_NAME, cvs, "_Id =" + id, null);

       db.close();

    }
});

UPDATE Lending.ApplicationFee
SET FeeTypeId = 
(
    CASE WHEN t.NewValue  IS NOT NULL THEN 
        (SELECT LookupID FROM tblLookup WHERE LookupType = 'FEE_CODE' AND LookupDesc = t.NewValue)
    ELSE 
        (SELECT LookupID FROM tblLookup WHERE LookupType = 'FEE_CODE' AND LookupCode = 'OTHER')
    END
)
FROM TmpFeesToRules t 
INNER JOIN tblLookup l ON t.NewValue = l.LookupDesc

WITH prep AS (
  SELECT Product + ' Unit' TYPE, Unit Value
  FROM   utilities
  UNION ALL
  SELECT Product + ' BaseUnit' TYPE, BaseUnit Value
  FROM   utilities
)
SELECT [Gas Unit], [Gas BaseUnit]
     , [Oil Unit], [Oil BaseUnit]
     , [Water Unit], [Water BaseUnit]
FROM   (SELECT TYPE, Value
        FROM   prep
       ) a
       PIVOT
       (MAX(Value)
        FOR TYPE IN ([Gas Unit], [Gas BaseUnit]
                   , [Oil Unit], [Oil BaseUnit]
                   , [Water Unit], [Water BaseUnit])
       ) pvt

WHERE (trunc(sysdate) - trunc(\"DATE\"))<=365;

SQL> ed
Wrote file afiedt.buf

  1  declare
  2    cursor cursor_table is
  3     select t.* from kid k, table(k.toys) t where k.name = 'Bob';
  4  begin
  5     for i in cursor_table loop
  6        dbms_output.put_line(i.column_value);
  7     end loop;
  8* end;
SQL> /
truck
ball
doll

PL/SQL procedure successfully completed.

SELECT KB.*, VN.VDescription
FROM Knowledge_Base KB

INNER JOIN 
   (
   select V.[Name] as VDescription, K.Description as KDescription
   FROM vendor, knowledge_base 
   where knowledge_base.description like '%' + vendor.name + '%'
   ) VN
ON KB.Description = VN.KDescription

select t.movieID, sum(t.qty) as totalQuantity from transaction t
group by t.movieId
order by sum(t.qty) desc
limit 10

consumer = get_object_or_404(Consumer, pk=pk)
option = get_object_or_404(Option, pk=option_pk)
consumer.options.add(option)

EXECUTE('SELECT * 
         FROM   Region R 
         WHERE  R.RegionID IN (' + @regions + ')')

;WITH x AS 
(
    SELECT id,bank_code,bank_name,interest_rate,
      rn = ROW_NUMBER() OVER (PARTITION BY bank_code ORDER BY interest_rate DESC)
    FROM dbo.[SAMPLE]
)
SELECT id,bank_code,bank_name,interest_rate
FROM x WHERE rn = 1
ORDER BY interest_rate DESC;

SELECT 
    p.person_id,
    p.first_nm,
    p.last_nm, 
    pu.purchase_dt,
    pr.sku, 
    pr.description,
    COALESCE(ha.address_type_id, sa.address_type_id) AS address_type_id
    CASE WHEN ha.address_type_id IS NOT NULL THEN ha.city_cd ELSE sa.city_cd END AS city_cd, 
    CASE WHEN ha.address_type_id IS NOT NULL THEN ha.state_cd ELSE sa.state_cd END AS state_cd, 
    CASE WHEN ha.address_type_id IS NOT NULL THEN ha.postal_cd ELSE sa.postal_cd END AS postal_cd
FROM 
    person p 
    LEFT JOIN address ha ON p.person_id = ha.person_id AND ha.address_type_id = 1
    LEFT JOIN address sa ON p.person_id = sa.person_id AND sa.address_type_id = 2
    INNER JOIN purchase pu ON pu.person_id = p.person_id
    INNER JOIN product pr ON pr.product_id = pu.product_id

SELECT p.case_number
     , p.full_address
     , s.case_owner_name 'case owner'
     , c.client_name client
     , r.compiled_date
     , r.recommendation
  FROM case_process p
  JOIN staff s
    ON s.case_owner_number = p.case_owner_number
  JOIN client c
    ON c.client_number = p.client_number
  JOIN reporting r
    ON r.case_number = p.case_number
  JOIN (SELECT case_number,MAX(compiled_date) max_compiled_date FROM reporting GROUP BY case_number) x
    ON x.case_number = r.case_number
   AND x.max_compiled_date = r.compiled_date;

 +-------------+---------------+------------+---------+---------------+----------------+
 | case_number | full_address  | case owner | client  | compiled_date | recommendation |
 +-------------+---------------+------------+---------+---------------+----------------+
 |        1000 | 1 high street | Bob        | London  | 2012-12-14    | let            |
 |        1001 | 2 high street | Ken        | Compton | 2013-12-13    | sell           |
 |        1002 | 3 high street | Ken        | Leeds   | 2012-12-14    | sell           |
 +-------------+---------------+------------+---------+---------------+----------------+
 3 rows in set (0.00 sec)

 fiddle of same... http://sqlfiddle.com/#!2/fff224/7

db.stack.aggregate([ {$project:{"treatments._id":1, "treatments.price":1}}, 
{$unwind:"$treatments"},{$match:{"treatments._id":2}},
{$sort:{"treatments.price":-1}}, {$limit:1} ]); 

SELECT id, sumcnt, cnt2
    FROM(
        SELECT id, count(*) as cnt2, sum(cnt) as sumcnt
        FROM (
            SELECT id, kmstand, vacationame, count(*) as cnt
            FROM `db_1`.`table_new` 
            WHERE (vacationame='vacation1'
                OR vacationame='vacation2'
                OR vacationame='vacation3'
                OR vacationame='vacation4')
            GROUP BY id, kmstand, vacationame)T
        GROUP BY id)T
    WHERE (sumcnt/cnt2 = 1)

DELETE FROM MyTable 
    WHERE A NOT IN 
        (SELECT MIN(A) 
         FROM MyTable GROUP BY B, C, D
        );

SELECT
    i.item_id, i.item_name, i.idem_desc,
    p.quantity, p.price
FROM items i
LEFT JOIN item_properties p ON i.item_id = p.fk_item_id
WHERE i.item_id = 191

select count(distinct lot_id,data_file_id) 
  from data_cst 
 where target_name_id=208082 
   and wafer_id=425845;

SELECT data.sPort
FROM 
  ((SELECT (s.server_port + 1) sPort
  FROM pro_servers s
  LEFT JOIN pro_servers sp1 ON sp1.server_port = s.server_port + 1
  WHERE (sp1.server_port IS NULL)
  ORDER BY sPort)

  UNION ALL

  (SELECT s.server_port sPost
  FROM pro_servers s
   GROUP BY s.server_port
   HAVING COUNT(s.server_port) = SUM(s.server_deleted)
  ORDER BY sPort)) AS data
ORDER BY data.sPort
LIMIT 1

EXEC sp_updatestats

SELECT T2C1, T2C2,
CASE WHEN T2C2 = (SELECT T1C2 FROM T1 WHERE (T1C1 = 'A') THEN '1' ELSE '0' END AS SELECTED
FROM T2

select id
from person p 
where exists (
    select 1
    from revenue r 
    where p.id = r.personid
        and case when r.year1 > 0 then 1 else 0 end +
            case when r.year2 > 0 then 1 else 0 end +
            case when r.year3 > 0 then 1 else 0 end +
            case when r.year4 > 0 then 1 else 0 end +
            case when r.year5 > 0 then 1 else 0 end >= 2
)

SELECT  team, SUM(DECODE(IsNew, 'N', 1, 0)), SUM(DECODE(IsNew, 'Y', 1, 0))
FROM    mytable
GROUP BY
        team

INSERT INTO categories (coname)
    SELECT DISTINCT coName
    FROM counties 

SELECT * FROM Your_Table
WHERE app_receipt_date > SYSDATE - (6 * 7);

Select I.Fee
From Item I
WHERE  DATEDIFF(day, GETDATE(), I.DateCreated) < 365

column1 IN (status1, status2, status3, status4, status5) AND 
column2 IN (status1, status2, status3, status4, status5) AND 
column3 IN (status1, status2, status3, status4, status5) AND
column4 IN (status1, status2, status3, status4, status5) AND
column5 IN (status1, status2, status3, status4, status5) AND
column6 IN (status1, status2, status3, status4, status5) 

WITH Tree
AS (
SELECT
    id,
    parent,
    0 AS Level,
    id AS Root,
    hasRights AS HasRights,
    CAST(id AS VARCHAR(MAX)) AS Sort,
    user_id
FROM SourceTable
WHERE parent IS NULL

UNION ALL

SELECT 
    st.id,
    st.parent,
    Level + st.hasRights AS Level,
    st.parent AS Root,
    st.hasRights AS HasRights,
    uh.sort + CASE st.hasRights WHEN 0 THEN '' ELSE '/' + CAST(st.id AS VARCHAR(20)) END AS Sort,
    st.user_id
FROM SourceTable AS st
    JOIN Tree uh ON uh.id = st.parent    
)

SELECT * FROM Tree AS t
    JOIN UserTable AS ut ON  ut.id = t.user_id AND ut.user_id = '141F-4BC6-8934'
ORDER BY Sort

select START_TIME, STOP_TIME,
       max(stop_time) over (order by start_time) as MaxCumStopTime
from t

SELECT
      SUM(columnA1)
    , SUM(columnA2)
    , (
            SELECT
                  SUM(columnB1)
            FROM tableB
            WHERE columnB3 = X
                  AND columnB4 = Y
                  AND columnB5 = Z
      ) as sum_columnB1
FROM tableA
WHERE columnA3 = X
      AND columnA4 = Y
      AND columnA5 = Z
;

 WITH CTE AS (
      SELECT u.ContactName
          ,cu.[User ID]
          ,c.Name
          ,c.ID
          ,cu.[Foreign Table]
          ,count(*) OVER (PARTITION BY c.ID) AS user_in_this_country
      FROM   dbo.Country AS c
      INNER JOIN   dbo.CountryUser AS cu ON c.ID = cu.[Foreign ID]
      INNER JOIN   dbo.UserColder  AS  u ON cu.[User ID] = u.ID
      WHERE EXISTS (
          SELECT *
          FROM   CountryUser AS cu2
          WHERE  cu2.[Foreign ID] = cu.[Foreign ID]
          AND    cu2.[User ID] <> cu.[User ID]
          AND    cu.[Foreign Table] = 'Country')
 )
 SELECT *
 FROM CTE
 WHERE user_in_this_country > 1

UPDATE table1 
   SET table1.Price = table2.price 
   FROM table1  INNER JOIN  table2 ON table1.id = table2.id

SELECT
  a.eID,
  a.eValue,
  t.pID,
  t.pName,
  t.rID,
  t.rValue
FROM tblAlert a
  LEFT JOIN (
    SELECT
      p.pID,
      p.pName,
      p.eID,
      r.rID,
      r.rValue
    FROM tblPatient p
      INNER JOIN (
        SELECT pID, MAX(rID) AS rID
        FROM tblPatientRecords
        GROUP BY pID
      ) pr ON p.pID = pr.pID
      INNER JOIN tblRecords r ON pr.rID = r.rID
  ) t ON a.eID = t.eID

SELECT table_name view_name,
       column_name,
       data_type
  FROM user_tab_columns
 WHERE table_name = <<name of view>>
 ORDER BY column_id

UPDATE attempts
RIGHT JOIN
(
    SELECT id FROM attempts a1
    WHERE NOT EXISTS
    (
        SELECT 0 FROM attempts a2
        WHERE a2.mapID = a1.mapID AND 
            (a2.score > a1.score OR (a2.score = a1.score AND a2.date < a1.date))
    )
) tmp ON tmp.id = attempts.id
SET attempts.isHighestScore = 1;


Database mydb = new EnterpriseLibrary.Data.Sql.SqlDatabase("connection string here");

;with cte (rn, id, inst_id, person_name, email) as (
    select row_number() over (partition by inst_id order by id) rn, * 
    from person
    )

update f
set 
  person1 = cte1.person_name, 
  email1  = cte1.email, 
  person2 = cte2.person_name, 
  email2  = cte2.email
from firm f
left join cte cte1 on f.inst_id = cte1.inst_id and cte1.rn = 1
left join cte cte2 on f.inst_id = cte2.inst_id and cte2.rn = 2

  Create Trigger trig_StopRecipFriendships
  for Insert, Update On Friendships
  As
    If Exists (Select * From Friendships F1
                 Join Friendships F2  
                   On F1.UserA = F2.UserB
                      And F1.UserB = F2.UserA)
     Begin
         Rollback Transaction
         Raiserror ('These Users are already friends', 16,1)
     End

DELETE P1
FROM @Prices P1 join (
  SELECT DISTINCT ProductId
  FROM @Prices 
  WHERE IsSpecialPrice = 1
) P2 on P1.ProductId = P2.ProductId
WHERE P1.IsSpecialPrice = 0

 select dept, min(id) keep (dense_rank last order by days)
from (  SELECT  id ,
            (sum((TO_DATE-FROM_DATE)+1) ) days ,
            dept 
    FROM emp_leave 
    WHERE to_date between ADD_MONTHS(sysdate,-3) 
    AND sysdate group by id,dept) 
group by dept
;

-- do insert

SELECT SCOPE_IDENTITY();

SELECT 'Amount' AS MaxAmount, [Group1], [Group2], [Group3]
  FROM
(SELECT descrip, Amount 
    FROM Table) AS SourceTable
PIVOT
(
Max(Amount)
FOR descrip IN ([Group1], [Group2], [Group3])
) AS PivotTable;

DECLARE @SQL varchar(max)
SET @SQL = 'select * from tableA INNER JOIN tableB on tableA.'+@Input1+' = table B.'
@input2

EXEC (@SQL)

SELECT * FROM
 (
  SELECT (trunc(SYSDATE)-2)                      start_dt -- May 11 --
       , (trunc(SYSDATE)-2)-LEVEL                bus_days -- All bus days before May 11 --
       , to_char((trunc(SYSDATE)-2)-LEVEL, 'DY') wk_day
   FROM DUAL
  CONNECT BY LEVEL <= (trunc(SYSDATE)-2)-((trunc(SYSDATE)-2) - 7) -- May 11-7 days ago=May 4
 )
WHERE wk_day NOT IN ('SAT', 'SUN')
ORDER BY bus_days
/

START_DT    BUS_DAYS    WK_DAY
--------------------------------
5/11/2013    5/6/2013    MON
5/11/2013    5/7/2013    TUE
5/11/2013    5/8/2013    WED
5/11/2013    5/9/2013    THU
5/11/2013    5/10/2013   FRI

update table1
set flag =1
where rowid in ( select t1.rowid
                 FROM table1 t1 
                      INNER JOIN table2 t2 ON t1.emp_id = t2.emp_id 
                 INNER JOIN table3 t3 ON t2.company = t3.company
                 WHERE t1.emp_id = '5632'
                       AND l2.company = '83CP'
                       AND t1.code = 'LIEU'              
               )

CREATE TEMP TABLE tmp AS SELECT * FROM tbl LIMIT 0 -- copy layout, but no data

COPY tmp FROM '/absolute/path/to/file' FORMAT csv;

INSERT INTO tbl
SELECT tmp.*
FROM   tmp
LEFT   JOIN tbl USING (tbl_id)
WHERE  tbl.tbl_id IS NULL;

DROP TABLE tmp; -- else dropped at end of session automatically

db.execSQL("DROP TABLE IF EXISTS TABLENAME");

select docid,
       (case when sum(case when rn_ds <> rn_sd then 1 else 0 end) = 0 then 'Increasing'
             else 'Decreasing'
        end) as SequenceType
from (select d.*,
             row_number() over (partition by docId order by date, state) as rn_ds,
             row_number() over (partition by docId order by state, date) as rn_sd
      from d
     ) d
group by docid;

SELECT
  s.*
FROM STUDENTS s
INNER JOIN StudentMarks m ON s.STUDENTID = m.STUDENTID ;

SELECT
  m.*
FROM STUDENTS s
INNER JOIN StudentMarks m ON s.STUDENTID = m.STUDENTID ;

select top 1 first.*, second.username, third.*
from first 
inner join second on first.id = second.master_id
inner join third on first.id = third.master_id
order by
third.date desc

select eventTime/5,count(*)
from   evalHubSupply
group by eventTime/5

CREATE OR REPLACE TRIGGER XXX
    BEFORE INSERT --<< You need a BEFORE trigger for this to work.
    ON A
    FOR EACH ROW
BEGIN
    :new.val := 'LOL';
END;

declare @tab table(branch varchar(3), day int,  amount float) ;
insert into @tab values
('001',4,300.00),
('001',10,200.12),
('001',30,343.22),
('002',12,423.00),
('005',2,453.21),
('005',12,111.21),
('005',27,321.99);

with month_days as
(select t.number,t1.branch from (select number from master..spt_values where type='P' and number between 1 and 30) t cross join (select distinct branch from @tab)t1) 
select md.branch,number as day,isnull(amount,0) amount from @tab t right join month_days md on  t.day=md.number and t.branch=md.branch;

Select s.Branch, s.Date, s.containers,
       lag(s.Date) over (partition by branch order by date) as prev_Date,
       lag(s.containers) over (partition by branch order by date) as prev_Containers
from shipping s;

SELECT CAST('the quick brown fox jumped over the lazy dog' AS VARCHAR(45))

echo "update contact set email_address='foo@bar.com';" | /path/to/isql --your-favorite-switches

where UserChiamante.UserId not in (select UtenteId from ChiamanteInterno)

select ID, First, Last, Date, Time
from (select t.*,
             row_number() over (partition by id order by date, time) as seqnum
      from test t
     ) t
where seqnum = 1;

CREATE PROC SearchAllTables
(
    @SearchStr nvarchar(100)
)
AS
BEGIN

    CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630))

    SET NOCOUNT ON

    DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110)
    SET  @TableName = ''
    SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''')

    WHILE @TableName IS NOT NULL

    BEGIN
        SET @ColumnName = ''
        SET @TableName = 
        (
            SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME))
            FROM     INFORMATION_SCHEMA.TABLES
            WHERE         TABLE_TYPE = 'BASE TABLE'
                AND    QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName
                AND    OBJECTPROPERTY(
                        OBJECT_ID(
                            QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)
                             ), 'IsMSShipped'
                               ) = 0
        )

        WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL)

        BEGIN
            SET @ColumnName =
            (
                SELECT MIN(QUOTENAME(COLUMN_NAME))
                FROM     INFORMATION_SCHEMA.COLUMNS
                WHERE         TABLE_SCHEMA    = PARSENAME(@TableName, 2)
                    AND    TABLE_NAME    = PARSENAME(@TableName, 1)
                    AND    DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal')
                    AND    QUOTENAME(COLUMN_NAME) > @ColumnName
            )

            IF @ColumnName IS NOT NULL

            BEGIN
                INSERT INTO #Results
                EXEC
                (
                    'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) 
                    FROM ' + @TableName + ' (NOLOCK) ' +
                    ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2
                )
            END
        END    
    END

    SELECT ColumnName, ColumnValue FROM #Results
END

SELECT   REPLACE(SUBSTRING(CreateDate,3,8),'/','') as registerdate, 
FROM TatEstelam.dbo.tblInquiryRealForeigners RL 
LEFT JOIN TatEstelam.dbo.CustomerInfo  CINFO
      ON RL.IdentificationDocumentNumber = CINFO.NationalID
WHERE-- NationalID <> '0001'
IdentificationDocumentNumber <> ''
AND REPLACE(SUBSTRING(CreateDate,3,8),'/','')  BETWEEN '910404' AND '950505'

SELECT   side1, side2, AVG(weight) 
FROM     (SELECT LEAST(to, from) AS side1, GREATEST(to, from) AS side2, weight
          FROM   my_table)
GROUP BY side1, side2

SELECT TOP 1 ID_AdvancedRatePlan
FROM ARDebitDetails
WHERE ID_Hearing = 135878
AND ID_AdvancedRatePlan > 0
ORDER BY ID_ARDebitDetail DESC

CREATE NONCLUSTERED INDEX ix_name ON Members(RelatedMemberId) INCLUDE (MemberId)

SELECT w.resource, watermark value 
FROM 
(
  SELECT 
    PARSENAME(ResourceKey, 1) AS resource, 
    Value as watermark
  FROM 
    MyTable
  WHERE
    Value like '%.watermark'
 ) w 
 JOIN
 (
  SELECT 
    PARSENAME(ResourceKey, 1) AS resource, 
    Value as txt
  FROM 
    MyTable
  WHERE
    Value like '%.text'
 ) t
 on t.resource = w.resource 
 WHERE 
   watermark = txt

select l.*
from logs l
where l.result = 'success-changed' and
      l.timestamp = (select max(l2.timestamp)
                     from logs l2
                     where l2.result = 'success-changed' and
                           date(l2.timestamp) = date(l.timestamp)
                    );

vw                //View
udf              //UserDefineFunction

 1.1) start the **hiveserver** before running the query
 1.2) you have to run two queries
      1.2.1) USE <database_name>
      1.2.2) SHOW TABLES LIKE 'table_name'
      1.2.3) Then you check your result using Result set.

string[] myNewColumns = inputColumn.split(";");

WITH toupdate as (
      SELECT pr.*,
             ROW_NUMBER() OVER (PARTITION BY orderpartyrole 
                                ORDER BY CASE WHEN Remark > '' 
                                              THEN 0
                                              ELSE 1 
                                         END, 
                                         Bold_id DESC) as seqnum
      FROM pricerequest pr
     )
UPDATE toupdate
    SET orderpartyrole = -1
    WHERE seqnum > 1;

SELECT user_password.UserName, user_password.Password, COUNT(*)
FROM user_password
JOIN (SELECT UserName
      FROM user_password
      GROUP BY UserName
      HAVING COUNT(DISTINCT Password) > 1) multiple_passwords
  ON multiple_passwords.UserName = user_password.UserName
GROUP BY user_password.UserName, user_password.Password
ORDER BY user_password.UserName

SELECT
    dept_id,
    dept_name
FROM
(
    SELECT
        d.dept_id,
        d.dept_name,
        0   AS entity_type_ordinal
    FROM
        department   d

    UNION ALL

    SELECT
        d.dept_id,
        e.employee_name,
        1    AS entity_type_ordinal
    FROM
        department   d
    INNER JOIN
        employee     e
            ON  e.dept_id = d.dept_id
)
   dept_and_emp
ORDER BY
   dept_id,
   entity_type_ordinal,
   dept_name

SELECT x.value from form_data x, form_data y
WHERE x.form_id=1 and x.field_id=1 and y.form_id=and y.field_id=1
GROUP BY x.value
HAVING SUM(SIGN(1-SIGN(y.value-x.value))) = (COUNT(*)+1)/2;

WITH Temp AS (
  SELECT
      emp.EMpID   
     ,emp.DepID
     ,COUNT(OrderId) nb_order
     ,ROW_NUMBER() OVER(PARTITION BY emp.DepID ORDER BY COUNT(OrderId) DESC) Ordre
  FROM
     Order ord
  INNER JOIN
     Employee emp
        ON emp.EmpID = ord.EmpID
GROUP BY  
   emp.EMpID
  ,emp.DepID)


SELECT *
FROM Temp
WHERE Ordre = 1

WITH some_data AS(
    select a.*,
           trunc( trunc( add_months( "DATE", 1 ), 'MM' ) - "DATE" ) 
                        As days_to_end_of_month,
           trunc( add_months( "DATE", 1 ), 'MM' ) 
                        As start_of_next_month
    from amounts a
), some_other_data AS (
      SELECT some_data.*,
             CASE WHEN days_to_end_of_month >= 6 THEN Amount
                  ELSE ( SELECT some_data.amount * "Cumulative Weight" FROM Weights w
                         WHERE some_data.days_to_end_of_month = DayNum )
             END as new_Amount
      FROM some_data
)
SELECT Item, "DATE", New_Amount as amount
FROM some_other_data
UNION ALL
SELECT Item, start_of_next_month, amount-new_amount
FROM some_other_data
WHERE days_to_end_of_month < 6
ORDER BY "DATE"
;

DECLARE @Id int
DECLARE @ForeignKey int

DECLARE C CURSOR FOR SELECT Id FROM TableA

OPEN C

FETCH NEXT FROM C INTO @Id

WHILE @@FETCH_STATUS = 0
BEGIN
    INSERT INTO TableB VALUES (value1)
    SET @ForeignKey = SCOPE_IDENTITY()

    UPDATE TableA
    SET ForeignKey = @ForeignKey
    WHERE Id = @Id

    FETCH NEXT FROM C INTO @Id
END

CLOSE C
DEALLOCATE C

SELECT 
connections.id,
connections.Source_Name,
connections.Source_port,
src.systype SourceType,
connections.Destination_Name,
connections.Destination_Port,
tgt.systype DestinationType
FROM connections 
LEFT JOIN equipment src on connections.system_name_source=src.system_name 
LEFT JOIN equipment tgt on connections.system_name_dest=tgt.system_name 

SELECT  @a:=@a+1 serial_number, 
        marks 
FROM    student_marks,
        (SELECT @a:= 0) AS a;

CREATE TABLE employee (
    id NUMBER PRIMARY KEY,
    -- other details...
);

CREATE TABLE attendance (
    employee_id NOT NULL REFERENCES employee(id),
    attendance_date DATE NOT NULL,
    PRIMARY_KEY(employee_id, attendance_date)
);

string schemaFilePath = filePath + "\\" + "Schema.ini";
StreamWriter writer = new StreamWriter(schemaFilePath, false);
writer.WriteLine("[" + fileName + "]");
writer.WriteLine("Format=TabDelimited");
writer.Close();

UPDATE person SET dollars = GREATEST(0, dollars-20) WHERE id=1

select
    xmlelement(name "Customer",
        xmlelement(name "Name", name),
        orders, payments
    ) as the_xml
from
    customers
    left join (
        select c_id as id,
        xmlelement(name "Orders",
            xmlagg(xmlelement(name "Order",
                xmlelement(name "id", id),                    
                xmlelement(name "date", date),
                xmlelement(name "content", content)
                )
            )
        ) as orders
        from orders
        group by c_id
    ) o using (id)
    left join (
        select c_id as id,
        xmlelement(name "Payments",                          
            xmlagg(xmlelement(name "Payment",
                xmlelement(name "id", id),                        
                xmlelement(name "date", date),
                xmlelement(name "amount", amount)
                )
            )
        ) as payments
        from payments
        group by c_id
    ) p using (id)

INSERT INTO table_name (col1, col2, col3)
SELECT col1, col2, col3
FROM table_x
WHERE col1='A'
AND col2 in ('1G','2F','3Q')
AND col3 ='B'

SELECT book_customer.firstname, book_customer.lastname, 
TO_CHAR(book_order.orderdate,'MM/DD/YYYY') AS "Order Date" -- Comma removed here
  FROM book_customer, book_order, order_items, books, publisher
    WHERE (book_customer.customerid = book_order.customerid) 
      AND (book_order.orderid = order_items.orderid)
      AND (order_items.bookid = books.bookid)
      AND (books.pubid = publisher.pubid)
      AND (publisher.publishername = 'printing with us');

SELECT City, COUNT(CustomerID) as CustomersPerCity
FROM Customers
GROUP BY City

-- The user can make as many comments as they like
Table_review { 
    User ID 
    Game ID
    Feedback ID
}    

Table_feedback {
    Feedback ID
    Comments
    TimeStamp
}

-- Now users can comment on what other users think 
-- but only to one level of nesting
Table_feedback_comments {
    Feedback ID
    User ID
    Comment
    TimeStamp
}

-- a user can only rate a game once, but they can change their rating over time
-- For example more content was added and the user likes this 
-- and wants to reflect that in their rating
Table_rating {
    Game ID
    User ID
    Rating
}

Table_user { 
    User ID 
    User name
    User email
    Comment -- something that describes the user
}

-- Even if you have only one game you can still store it in the database
Table_game {
    Game ID
    Game Name
    -- other columns used to represent a game
}

SELECT  o.CustomerID, null emptyColumn, o.ShipFirstName, 
        case when o.ShipCountry = 'United States' then 'US'
        when o.ShipCountry = 'Canada' then 'CA'
        end,
        c.EmailAddress
FROM Orders o, Customers c
WHERE o.CustomerID = c.CustomerID

SELECT pc.product_code,
       COUNT(*) as count,
       sum(o.monthly_base_charge) as "Monthly Fee"
FROM orders o join
     product_catalog pc
     on pc.product_catalog_id = o.product_catalog_id
GROUP BY pc.product_code
ORDER BY count DESC;

SELECT Name, Color
FROM TableA
WHERE NOT EXISTS (
SELECT 1 FROM TableB
WHERE TableA.Name = TableB.Name 
AND TableA.Color = TableB.Color)

select count(*) as count from users WHERE ( 3959 * acos( cos( radians( 37.774929 ) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians( -122.419418 ) ) + sin( radians( 37.774929 ) ) * sin( radians( lat ) ) ) ) < 150

least(case when price > 0 then price else 999999 end,
      case when price_double > 0 then price_double else 999999 end,
      case when price_triple > 0 then price_triple else 999999  end,
      case when price_quad > 0 then price_quad else 999999 end
     )

var edmxNS = XNamespace.Get(@"http://schemas.microsoft.com/ado/2007/06/edmx");
var schemaNS = XNamespace.Get(@"http://schemas.microsoft.com/ado/2006/04/edm");

var xd = XDocument.Load(@"{path}\Model.edmx");

var fields =
    from e in xd
        .Elements(edmxNS + "Edmx")
        .Elements(edmxNS + "Runtime")
        .Elements(edmxNS + "ConceptualModels")
        .Elements(schemaNS + "Schema")
        .Elements(schemaNS + "EntityType")
    from p in e
        .Elements(schemaNS + "Property")
    select new
    {
        Entity = e.Attribute("Name").Value,
        Member = p.Attribute("Name").Value,
        Type = p.Attribute("Type").Value,
        Nullable = bool.Parse(p.Attribute("Nullable").Value),
    };

SELECT DATEDIFF(MILLISECOND, DateFrom, DateTo)

SELECT SUM(cred), status, censusDate, ssn 
FROM
    (SELECT sac.cred, s.status, 
          (SELECT NVL (csl.census_dates, tl.census_dates) 
             FROM  schema.sections cs,  schema.sections_ls csl,  schema.terms tl 
            WHERE cs.course_sections_id = csl.course_sections_id(+)AND csl.pos(+) = 1 AND cs.term = tl.terms_id 
              AND tl.pos = 1 AND cs.course_sections_id = cs2.course_sections_id AND ROWNUM = 1)AS censusDate, 
          (SELECT NVL (p.ssn, 'xxx-xx-xxxx') FROM   schema.person p 
            WHERE p.id = sac.person_id) AS ssn, 
           //schema.person_name(sac.person_id, 'FML') as fml, 
           //schema.person_name(sac.person_id, 'LF') as lf 
     FROM  schema.student_acad_cred sac JOIN  schema.statuses s 
       ON s.student_acad_cred_id = sac.student_acad_cred_id 
     JOIN  schema.terms tl ON sac.term = tl.terms_id 
     JOIN  schema.student_course_sec scs ON sac.student_course_sec = scs.student_course_sec_id 
     JOIN  schema.course_sections cs2 ON scs.course_section = cs2.course_sections_id 
     JOIN  schema.terms t ON tl.terms_id = t.terms_id 
    WHERE sac.person_id = '1111111111' 
      AND (s.status IN ('A', 'N') OR (s.status = 'D' AND final_grade IS NOT NULL)) 
      AND s.pos = '1'AND tl.pos = '1' AND tl.terms_id = 'spring')
GROUP BY status, censusDate, ssn;

from u in context.aspnet_Users 
join m in context.aspnet_Membership on u.UserId equals m.UserId select new { u.UserName, m.IsApproved};

select LocationName, count(*) num_reservations
  from reservation
 where month(PickUpDateTime) = 2 --This can be parameterized if needed
 group by LocationName
 order by num_reservations desc

SELECT  a.proID,
        GROUP_CONCAT(b.domainID) domainId,
        GROUP_CONCAT(b.domainName) domainName
FROM    projects a
        LEFT JOIN domain b
            ON a.domainID = b.domainID
GROUP BY a.proID

Select *
from mydb
Where IsNumeric(sku) = 0x1

Data$bins <- sapply(Data$Name, function(n)
    paste(as.integer(agrepl(n, Data$Name, max.distance = 2)), collapse=""))
Data$Group <- as.integer(as.factor(Data$bins))

#    State Zipcode             Name        bins Group
# 1     IL   60693   THISISTHEFIRST 11100000000     4
# 2     IL   60693     TISISTHEFIRS 11100000000     4
# 3     OH   45271   THISISTHEFIRST 11100000000     4
# 4     CA   94085  THISISTHESECOND 00011100000     3
# 5     CA   94085  THISISTHESECOND 00011100000     3
# 6     CA   94085 THISISTHESECCOND 00011100000     3
# 7     SC   29645   THISISTHETHIRD 00000011100     2
# 8     SC   29645   THISISTHETHIRD 00000011100     2
# 9     SC   29645   THISISTHETHIRD 00000011100     2
# 10    SC   29645  THISISTHEFOURTH 00000000011     1
# 11    SC   29645    ISISTHEFOURTH 00000000011     1

UPDATE your_table
SET Update_Flag = 1            // this assumes the flag is an integer value
WHERE (column1 = "xxx")        // if it's a string do SET Update_Flag = "True"
OR (column2 = "xxx")
OR (column3 = "xxx")

TRANSFORM Sum(tbl_timesheet_hours.[work_order_hours]) AS SumOfwork_order_hours
SELECT tbl_timesheet_hours.[work_order_no], Sum(tbl_timesheet_hours.[work_order_hours]) AS     [Total Of work_order_hours]
FROM tbl_timesheet_hours
GROUP BY tbl_timesheet_hours.[work_order_no]
ORDER BY Format([work_order_date],'ddd')
PIVOT Format([work_order_date],'ddd') In ("Mon","Tue","Wed","Thu","Fri","Sat","Sun");

SELECT 
 * 
FROM 
  CLASSES 
JOIN 
  SUBJECTS_PER_CLASS 
ON 
  CLASSES.ID = SUBJECTS_PER_CLASS.class_id
JOIN 
  Subjects 
ON 
  Subjects.id = SUBJECTS_PER_CLASS.mat_id

select field1, field2, value, 
       100.0 * value / SUM(value) OVER(PARTITION BY 1) 
                      /* the SUM gets the total for the whole dataset. If actually 
                         have groups, yous should do PARTITION BY GroupField 
                       */
from yourtable

AND location_ns = 'Marriott\\256 Hotel & Convention Centre'

Cursor c = db.query(TABLE_NAME,columns,COLUMN_order + "=? OR " + COLUMN_order + "=?", new String[]{"0", "1"}, null, null, COLUMN_ID);



SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, R.layout.list_item, c, 
               new String[] {COLUMN_ID,COLUMN_NAME,COLUMN_order}, new int[] {R.id.list_item_text_id,R.id.list_item_text_main,R.id.list_item_text_sub}, 0);

    ListView list = (ListView) findViewById(R.id.list_poet_name);
    list.setAdapter(adapter);

SELECT a.PLANT_NO "PlantNumber", 
       SUM(CASE WHEN a.REC_STATUS_CD = 'RR' THEN -a.KW_CTR_REDELIVERED_HV 
                ELSE a.KW_CTR_REDELIVERED_HV END) "KeepWholeResidueMMBtu", 
       SUM(a.ETH_APPLIED_POP_PCT + a.ISO_APPLIED_POP_PCT  + 
           (CASE WHEN a.PLANT_NO = '002' THEN a.ALTLIQ_APPLIED_POP_PCT ELSE 0 END)
          )/100 "NGLPOPPaymentPercent"
FROM GAS_STMT a 
INNER JOIN SETTLE_SUMMARY c
   ON CASE WHEN SUBSTR(a.TRNX_ID,1,1) = '-' 
           THEN SUBSTR(a.TRNX_ID, 2, LENGTH(a.TRNX_ID)) 
           ELSE CAST(a.TRNX_ID AS VARCHAR2(100)) 
      END = c.TRNX_ID
  AND a.MTR_NO||a.MTR_SFX = c.MTR_NO||c.MTR_SFX
LEFT JOIN (SELECT MTR_NO,MTR_SFX,TRNX_ID,REC_STATUS_CD,MAX(ACCT_DT) ACCT_DT
           FROM GAS_STMT
           WHERE REC_STATUS_CD = 'RR'
           GROUP BY MTR_NO, MTR_SFX, TRNX_ID, REC_STATUS_CD
           HAVING COUNT(TRNX_ID) > 1) b
   ON a.MTR_NO = b.MTR_NO 
  AND a.TRNX_ID = b.TRNX_ID 
  AND a.REC_STATUS_CD = b.REC_STATUS_CD 
  AND a.ACCT_DT = b.ACCT_DT
WHERE TO_CHAR(a.PROD_DT, 'YYYY')  >= TO_CHAR(ADD_MONTHS(SYSDATE, -36), 'YYYY') 
  AND a.STATUS_UNIT_TM_CD = 'M' 
  AND b.MTR_NO IS NULL
GROUP BY a.PLANT_NO
ORDER BY a.PLANT_NO

scope :by_type, ->(type){ where(type: type).limit(5) }

def self.foo
  Ticket.by_type('a') + Ticket.by_type('b') + Ticket.by_type('c')
end

select top 1 with ties MySubId, Count(MySubId) as MySubIdCount
from MyTable
group by MuSubId
order by 2 desc

SELECT 
    *, count_t1 + count_t2 as count_all
FROM
    (SELECT d_id, COUNT(content) as count_t1 FROM TableA GROUP BY d_id) t1
    LEFT JOIN
    (SELECT d_id, COUNT(dif_content) as count_t2 FROM TableB GROUP BY d_id) t2
    ON t1.d_id = t2.d_id;

select ..., sum(manhours) - coalesce(Leavetaken, 0) as calc

CREATE TABLE [Comment](
   CommentId int PRIMARY KEY IDENTITY(1,1),
   UserId int Not NULL,
   ArticleId int NOT NULL ,
   FOREIGN KEY(UserId) references [User](UserId),
   FOREIGN KEY(ArticleId) references [Article](ArticleId) ON DELETE CASCADE
)

select b.Title
from Book b join
     Author a
     on b.BookID = a.BookID join
     Writer w
     on w.AuthId = a.AuthId join
     Publisher p
     on w.PubId = p.PubId
where p.Country like 'Australia'
group by b.Title, b.BookID
having count(*) >= 2;

select * from #test
order by
case when test like 'The %' then substring(test, 5, 8000) else test end

SELECT * FROM Table1 CROSS JOIN Table2

100XX
1000XX
101XX 

SELECT A.PRODUCTCODE, A.STOCKLEVEL, SUM(A.QUANTITY)
FROM PRODUCT A 
INNER JOIN PRODLINE B ON A.PRODUCTCODE=B.PRODCODE
GROUP BY A.PRODUCTCODE

select "i.  Category       " + "Number" + char(13)+char(10) +
"ii.  -----------------------------------" + char(13)+char(10) +
"iii. High:            " + cast((select count(1)
                                 from tabData
                                 where  advance > 10000) as varchar) + char(13)+char(10) +
"iv. Low:            " + cast((select count(1)
                               from tabData
                               where  advance >= 5000  
                               and advance <= 10000) as varchar) + char(13)+char(10) +
"v.  Moderate:    " + cast((select count(1)
                            from tabData
                            where advance < 5000) as varchar) + char(13)+char(10) +
"vi. N/A              " + cast((select count(1)
                                from tabData
                                where  advance is null) as varchar)

CREATE PROCEDURE name
(
@arg1 as type1,
@arg2 as type2
)

AS
DECLARE @value1 as type1

     SELECT @value1=x from tabley WHERE <something>

    INSERT INTO Table(x,y,z) VALUES(@arg1,@arg2,@value1)

select
(SELECT "count"(*) as val1 from tab1) - (SELECT "count"(*) as val2 from tab2)

Option Compare Database
Option Explicit

Public Function Func32(HardwareType As String) As Variant
    Dim cdb As DAO.Database, qdf As DAO.QueryDef, rst As DAO.Recordset
    Dim sql As String

    Set cdb = CurrentDb
    sql = ""
    sql = sql & "PARAMETERS prmHardwareType TEXT(255);"
    sql = sql & "SELECT * FROM Table1 WHERE Hardware_Type=[prmHardwareType]"
    Set qdf = cdb.CreateQueryDef("", sql)

    ' assign the PK argument as the query parameter and open it as a Recordset
    qdf!prmHardwareType = HardwareType
    Set rst = qdf.OpenRecordset(dbOpenSnapshot)

    ' do your calculations and assign the return value to the function name
    Func32 = rst!Field1 + rst!Field2 + rst!Field3

    rst.Close
    Set rst = Nothing
    Set qdf = Nothing
    Set cdb = Nothing
End Function

Private Function qdefSQL() As Boolean
    Dim db As Database
    Dim qdef As QueryDef
    Dim sSQL As String
    Dim iqdef As Integer

    Set db = CurrentDb
    For iqdef = 0 To db.QueryDefs.count - 1
        Set qdef = db.QueryDefs(iqdef)
        sSQL = qdef.SQL
        If InStr(sSQL, "target") > 0 Then
            Debug.Print qdef.Name
        End If
    Next

    qdefSQL = True
End Function

SELECT ((col1+col2+col3)/col4) as value
FROM ((SELECT col1, col2, col3, col4
       FROM table1
      ) UNION ALL
      (SELECT col1, col2, col3, col4
       FROM table2
      )
     ) t
HAVING value > 4 and value < 5

select * from your_table
where year(Start_Date) = year(curdate())
and month(Start_Date) = month(curdate())
and end_date <= curdate() + interval 30 day

WITH Cte AS(
    SELECT name,
        rn = ROW_NUMBER() OVER(ORDER BY name) + ((ROW_NUMBER() OVER(ORDER BY name) - 1) / 5)
    FROM table1
    UNION ALL
    SELECT name,
        rn = ROW_NUMBER() OVER(ORDER BY name) * 6
    FROM table2
)
SELECT name FROM Cte ORDER BY rn

SELECT p1.ID,
       ( SELECT NAME + ' and ' 
           FROM YourTable  p2
          WHERE p2.ID = p1.ID
          ORDER BY NAME
            FOR XML PATH('') ) AS Name,
        sum(Amount)
      FROM YourTable p1
      GROUP BY ID ;

select
    wpg.ID as id1,
    min(wr.ID) as id2
from
    Table1 wpg
    inner join Table2 wp on wp.WpgId = wpg.ID
    inner join Table3 wr on wr.WpId = wp.ID
group by
    wpg.ID

select * from all_constraints where table_name = 'REGISTRATION';

select  n
from    YourTable
group by
        n
having  count(*) = 1

DECLARE @KeywordList varchar(max) //This can be a SP param

CREATE TABLE #Keywords(varchar(10) keyword NOT NULL); 

DECLARE @Keyword varchar(10), @Pos int

SET @KeywordList= LTRIM(RTRIM(@KeywordList))+ ','
SET @Pos = CHARINDEX(',', @KeywordList, 1)

--Parse varchar and split IDs by comma into temp table
IF REPLACE(@KeywordList, ',', '') <> ''
BEGIN
    WHILE @Pos > 0
    BEGIN
        SET @Keyword= LTRIM(RTRIM(LEFT(@KeywordList, @Pos - 1)))
        IF @Keyword <> ''
        BEGIN
            INSERT INTO #Keywords(ID) VALUES (@Keyword) 
        END
        SET @KeywordList = RIGHT(@KeywordList, LEN(@KeywordList) - @Pos)
        SET @Pos = CHARINDEX(',', @KeywordList, 1)

    END
END 

--Return a count of all rows
SELECT @TotalRows = COUNT(Keyword) FROM #Keywords; 

    --Now process data from #Keywords as required

select distinct M.mtitel as Attribute
from merkmale as M
where M.MID in (
    select A.MID 
    from aREl_Adr_Merk as A 
    where A.AdrID in (252674,247354)
)

select person, abs(DATE_PART('epoch', p1 - p2) 
from (select person,
             MAX(case when product = 'football' then purchase_time end) as p1,
             MAX(case when product = 'basketball' then purchase_time end) as p2
      from mytable
      group by person
     ) p
where p1 is not null and p2 is not null

SELECT DISTINCT
    a.id,
    b.value AS SIGN_UP,
    c.value AS FIRST_NAME,
    d.value AS STREET
FROM tbl a
LEFT JOIN tbl b ON a.id = b.id AND b.field_name = 'sign_up'
LEFT JOIN tbl c ON a.id = c.id AND c.field_name = 'first_name'
LEFT JOIN tbl d ON a.id = d.id AND d.field_name = 'street'

# not tested...
library(ggplot2)
# all on one plot
ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD,color=CONGESTION_ZONE))
#four plots
ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD)) +
   facet_wrap(~CONGESTION_ZONE)

# coloring beased on day_type
ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD, color=DAY_TYPE_CD))+
  facet_wrap(~CONGESTION_ZONE)

SELECT *
FROM TABLE
WHERE ID NOT IN
(SELECT ID FROM TABLE WHERE KEY = 'LATLNG')

DECLARE @Start date = '2013-06-03'
DECLARE @End date = '2013-06-10'

;WITH Dates AS 
(
    SELECT @Start AS [Date]
    UNION ALL
    SELECT DATEADD(DAY, 1, [Date])
    FROM Dates
    WHERE [Date] < @End
)

SELECT [Date] 
FROM Dates
OPTION (MAXRECURSION 0)

CREATE NONCLUSTERED INDEX ix_p
    ON tblProductRegistration (RegistrationDate, ProductID)
GO
CREATE NONCLUSTERED INDEX ix_d
    ON tblDealerDistributionDetails (model, DealerCode) INCLUDE (BarCode, BarCode2)
GO

SELECT DealerCode, COUNT_BIG(*) AS [Activated]
FROM tblDealerDistributionDetails d
WHERE model = 'Olvio L12'
    AND EXISTS(
        SELECT *
        FROM tblProductRegistration r
        WHERE r.RegistrationDate BETWEEN '20160301' AND '20160302'
            AND r.ProductID IN (d.BarCode, d.BarCode2)
    )
GROUP BY DealerCode
--OPTION(RECOMPILE)

COLUMN_NAME  position(1:14)  CHAR "STRIP_NONNUMERIC(:LAST_NAME)",

var results = from rs in db.ratesSchedule
              join ud in db.userdetails on 
                  new { rs.sid, rs.tabletype } equals 
                  new { ud.sid, tabletype = "d" }

SELECT
  *
FROM
  table1
INNER JOIN
  table2
    ON  table1.id    = table2.id
    AND table1.name <> table2.name

SELECT stocks.*
FROM stocks
WHERE part_id IN (
    SELECT part_id
    FROM
        parts ON parts.id = stocks.part_id
        INNER JOIN features ON features.part_id = parts.id
        INNER JOIN feature_titles ON feature_titles.id = features.feature_title_id 
    WHERE
            parts.category_id = 20 AND stocks.manufacturer_id = 4
        AND (
                feature_titles.title = 'Title One' AND features.value = '0.1'
            OR  feature_titles.title = 'Title Two' AND features.value = '7 MAX'
        )
    GROUP BY parts.id
    HAVING COUNT(features.id) = 2
)

select Table1.id, Table1.Name, Table1.idObject, Table2.City, Table3.State
from Table1 
join Table2 ON Table1.idObject = case 
                 when Table1.Name='abc' then Table2.idLineItem
                 when Table1.Name='def' then Table2.idOrder
                 else Table2.idSupplier
               end
join Table3 on Table2.idAdv=Table3.idAdv
group by Table1.id, Table1.idObject;

SELECT
td = [Status],'',
td = [Number],'',
td = CONVERT(varchar(25), [Date], 21),'',
td = [Error Message]
FROM [Views].dbo.Errors   
ORDER BY Date

substring(articletext, 
          patindex('/images/imgs/', articletext) + length('/images/imgs/'), 
          patindex('" alt') - (patindex('/images/imgs/', articletext) + length('/images/imgs/')))

ALTER TABLE `invoices`.`invoices`
    CHANGE `DateTime` `DateTime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

select  Location
        ,sum(case when [Month]  = 'January'  then value else 0 end)  as January
        ,sum(case when [Month]  = 'February' then value else 0 end)  as February
        ,sum(case when [Month]  = 'March'    then value else 0 end)  as March
        ,sum(case when [Month] in ( 'January', 'February', 'March')
                                             then value else 0 end) as Q1
        ...
        -- Repeat months...
        ...
        ,sum(value) as AllMonthTotal
from    myTempTable
group by Location

-- UNION to get rowwise total
union
select  'TOTAL'
        ,sum(case when [Month]  = 'January'  then value else 0 end)  as January
        ,sum(case when [Month]  = 'February' then value else 0 end)  as February
        ,sum(case when [Month]  = 'March'    then value else 0 end)  as March
        ,sum(case when [Month] in ( 'January', 'February', 'March')
                                             then value else 0 end) as Q1
        ...
        -- Repeat months...
        ...
        ,sum(value) as AllMonthTotal
from    myTempTable

Select ...
From WorkOrder As W
Where Exists    (
                Select 1
                From WorkOrder As W1
                    And W1.CustomerId = W.CustomerId    
                    And DatePart( dw, W1.TimeWindowStart ) <> DatePart( dw, W.TimeWindowStart )
                )

db2 "create table test ( x int, y clob(1M) )"
db2 "insert into test (x,y) values (1,cast('The string to find is CEMENTO, how do we do that?')"
db2 "insert into test (x,y) values (2,cast('The string to find is CEMENT, how do we do that?' as clob))"

db2 "select x, DBMS_LOB.INSTR(y, 'CEMENTO', 1) from test where DBMS_LOB.INSTR(y, 'CEMENTO', 1) > 0"

X           2          
----------- -----------
          1          23

  1 record(s) selected.

select array_agg(console_id) as consoles from archive_sessions where tournament_id = 14817

WHERE Month(DateOfSession) = " & me.cboSelectMonth

select * from 
(
  select * from your_table
  where some_conditions
  limit 1000
) 
as some_aliases
order by rand()
limit 4;

DECLARE @AssessmentID INT;

CREATE TABLE #AssessmentIDs (AssessmentID INT);

INSERT #AssessmentIDs (AssessmentID)

SELECT AssessmentID FROM Assessments WHERE EpisodeID = @EpisodeID;

WHILE (SELECT COUNT(*) FROM #AssessmentIDs WHERE AssesmnentID = @AssessmentID) > 0
BEGIN
    SELECT @AssessmentID = TOP 1 AssessmentID FROM #AssessmentIDs

    EXEC DeleteAssessment @AssessmentID

    DELETE #AssessmentIDs WHERE AssessmentID = @AssessmentID
END;

update tablename t
    set gender = (case when gender = 'm' then 'f'
                       when gender = 'f' then 'm'
                       else gender
                  end);

DECLARE @tbl VARCHAR(60), @sql VARCHAR(8000)

SET @tbl = 'tblData' -- change for the table                     

SELECT @sql = 'SELECT '
              + STUFF(
                         (
                           SELECT      ', ' + ColumnName + ' as ' + ColumnLabel
                           FROM       columnOrder
                           ORDER BY Position
                           FOR XML PATH('')
                         )
                      , 1, 1, ''
                     )
              + ' FROM '
              + @tbl


--SELECT @sql
EXEC (@sql)

SELECT title, COUNT(art) AS art_count
FROM table1
GROUP BY art 
HAVING art_count >= (select count(*) * X / 100 from table1)

SELECT id, username

FROM user

LEFT JOIN (
    SELECT DISTINCT user2_id AS blockee_id
    FROM blocked_user
    WHERE user1_id = :current_user_id
) this_user_blocked
ON user.id = this_user_blocked.blockee_id

LEFT JOIN (
    SELECT DISTINCT user1_id AS blocker_id
    FROM blocked_user
    WHERE user2_id = :current_user_id
) blocked_this_user
ON user.id = blocked_this_user.blocker_id

WHERE this_user_blocked.blockee_id IS NULL
AND blocked_this_user.blocker_id IS NULL

WITH CategoryTree AS
        (
        SELECT  *, 0 AS Generation    
        FROM    dbo.Category
        WHERE   CategoryName = 'Animation'
        UNION ALL
        SELECT  Cat.*, Generation + 1    
        FROM    CategoryTree
        JOIN    dbo.Category AS Cat
        ON      Cat.Id = CategoryTree.CategoryMaster
        )
SELECT  *
FROM    CategoryTree

select e.id,per.id,t.status 
from employee e 
join person per on e.personId=per.id 
left join training t on e.id=t.employeeId
    and t.courseId = ?

SELECT 'Person.Contact' as "@name",
(SELECT 
    (SELECT * from (SELECT 'FirstName' as [@name], [FirstName] as [*]
    union all
    SELECT 'LastName' as [@name], [LastName] as [*]) y
    for xml path('field'), TYPE)
from Person.Contact for XML path, TYPE)
for XML path('entity'), root('querydata')

SELECT   m.id muppet_id,
         m.name,
         p.id phone_id,
         p.phone,
         p.valid
FROM      muppet m
         FULL OUTER JOIN
            phone p
         ON (M.ID = P.MUPPET_ID)
WHERE
         P.VALID = 'Y' or P.MUPPET_ID is null;

CREATE PROCEDURE spData4 (@Year smallint)
AS
BEGIN

 CREATE TABLE #temp1 (RegionName NVARCHAR(50), TotalSitesVisited INT, TotalViolations INT)
 CREATE TABLE #temp2 (RegionName NVARCHAR(50), TotalSiteVisits INT)
 CREATE TABLE #temp3 (RegionName NVARCHAR(50), TotalBadSites INT)

 INSERT INTO #temp1 EXEC spData1 @Year
 INSERT INTO #temp2 EXEC spData2 @Year
 INSERT INTO #temp3 EXEC spData3 @Year

 SELECT 
  COALESCE(t1.RegionName, t2.RegionName, t3.RegionName) RegionName
  ,TotalSitesVisited,TotalViolations,TotalSiteVisits,TotalBadSites 
 FROM #temp1 t1
 FULL JOIN #temp2 t2 ON t1.RegionName = t2.RegionName 
 FULL JOIN #temp3 t3 ON t1.RegionName = t3.RegionName OR t2.RegionName = t3.RegionName

END 

1: Remove properties from the model.
2: Run 'Enable-Migrations' in package manage console.
3: Next Run 'Add-Migration "MigrationsName"'. if any case it is showing 'The project  tesproject failed to build then build project again.
4: Now run 'Update-Database' 

select concat('alter table ',  table_name, ' modify column ', column_name, ' VARCHAR(40)') from information_schema.columns  
where table_schema='yourdb' and table_name='table1' 
and column_name NOT IN('col1','col2','col3')

List<A> aList = dataTable.AsEnumerable()
    .GroupBy(row => row.Field<int>("A_Id"))
    .Select(grp => new A {
        Id = grp.Key,
        Name = grp.First().Field<DateTime>("A_Date"),
        Bs = grp.Select(m => new B { Id = m.Field<int>("B_Id"), Name = m.Field<string>("B_Name") }).ToList(),
    })
    .ToList()

db.execSQL("DELETE FROM SQLITE_SEQUENCE WHERE NAME = '" + name_of_the_table + "'");

select "t"."trip_id",
       "c"."service_id",
       "start_s"."stop_name" as "departure_stop",
       "start_st"."departure_time",
       "end_s"."stop_name" as "arrival_stop",
       "end_st"."arrival_time",
       "end_st"."departure_time" as "end_departure",
       "last_st"."arrival_time" as "last_arrival",
       "last_s"."stop_name" as "last_stop"
from "trips" as "t"
    inner join "calendar" as "c" on "t"."service_id" = "c"."service_id"
    inner join "routes" as "r" on "t"."route_id" = "r"."route_id" 
    inner join "stop_times" as "start_st" on "t"."trip_id" = "start_st"."trip_id" 
    inner join "stops" as "start_s" on "start_st"."stop_id" = "start_s"."stop_id" 
    inner join "stop_times" as "end_st" on "t"."trip_id" = "end_st"."trip_id" 
    inner join "stops" as "end_s" on "end_st"."stop_id" = "end_s"."stop_id" 
    inner join "stop_times" as "last_st" on "t"."trip_id" = "last_st"."trip_id" 
    inner join "stops" as "last_s" on "last_st"."stop_id" = "last_s"."stop_id" 
where "start_s"."stop_id" = '245' -- my data's stop id
    and "end_s"."stop_id" = '762' -- my data's stop id
    and "last_st"."stop_sequence" = (select max("stop_sequence") from "stop_times" where "t"."trip_id" = "trip_id")
    and start_st.departure_time < end_st.arrival_time
order by arrival_time asc

DECLARE @TempTable TABLE
(
    id int NOT NULL,
    PRIMARY KEY
    (
        id
    )
)

SELECT  *
FROM    pledger
WHERE   dcno <> 1 OR pledger.etype <> 'sale'

SELECT a.*
FROM tableName a 
     INNER JOIN
     (
        SELECT ITEMID , MAX(DATEPHYSICAL) max_date
        FROM tableName 
        GROUP BY ITEMID 
     ) b ON a.ITEMID  = b.ITEMID AND a.DATEPHYSICAL = b.max_date

val results: List[(Int, Int, String)] = 
  SQL("SELECT t.id, t.field1, t.field2 from table1 t WHERE t.field1 = {param1}")
    .on("param1" -> param1)()
    .as(int("t.id") ~ int("t.field1") ~ get[Option[String]]("t.field2") map(flatten) *)
    .toList 

DECLARE @myString NVARCHAR(MAX) = '{local.txt_concept_id} != "" & {local.txt_ICD_code} != "" & 
{local.txt_diagnosis_uniq_id} != "" & {local.txt_ICD_desc} != ""&
{FIND( {local.txt_ICD_code} , "asp", 0 )}!=-1&
{LEN( {local.txt_diagnosis_uniq_id})}';

SELECT T2.X.value('.', 'varchar(50)')
FROM 
(SELECT CAST(REPLACE(REPLACE((SELECT @myString FOR XML PATH('')), '{', '<X>'), '}', '</X>') AS XML).query('.')) AS T1(X)
CROSS APPLY T1.X.nodes('/X/text()') AS T2(X);

SELECT *
FROM table
ORDER BY LENGTH(column) - LENGTH(REPLACE(column, ' ', ''))

SELECT name, code 
FROM new n
WHERE NOT EXISTS(SELECT * FROM current c 
                 WHERE c.name = n.name OR c.code = n.code)

IsLocate as (case when locates is not null then 'Y' else 'N' end),
IsAdjustment as (case when shares is not null then 'Y' else 'N' end),

SELECT c.* 
     , COALESCE(t1.Value, t2.Value,t3.Value) AS Value
     , COALESCE(t1.Date, t2.Date,t3.Date) AS Date
  FROM Common c
  LEFT JOIN Table1 t1 ON c.tableid = t1.[id]
   AND [Table] = 'table1'
  LEFT JOIN Table2 t2 ON c.tableid = t2.[id]
   AND [Table] = 'table2'
  LEFT JOIN Table2 t3 ON c.tableid = t3.[id]
   AND [Table] = 'table3'
ORDER BY ID;

select *
  from test
where
  model_number in (
    select model_number
      from test
  group by model_number
    having count(distinct description) > 1)

SELECT
    thing_type,
    thing_id,
    parent_id
FROM
    Sample_Table T1
WHERE
    thing_type = 'Desired Type' AND
    thing_id NOT IN (
            SELECT parent_id
            FROM Sample_Table T2
            WHERE T2.thing_type = 'Desired Type'
    )

SQL> with test (DATE_, USERID, DOMAIN, VALUE)
  2  as (
  3   select '03/16/2016',     1001     ,'ASIA'      ,10 from dual union all
  4   select '03/16/2016',     1001     ,'EUROPE'    ,20 from dual union all
  5   select '03/16/2016',     1002     ,'ASIA'      ,20 from dual union all
  6   select '03/17/2016',     1001     ,'ASIA'      ,20 from dual union all
  7   select '03/17/2016',     1002     ,'EUROPE'    ,10 from dual
  8  )
  9  SELECT *
 10  FROM   (select *
 11          from test)
 12  PIVOT ( sum(value) FOR (domain) IN ('ASIA', 'EUROPE'))
 13  ORDER BY 1, 2;

DATE_          USERID     'ASIA'   'EUROPE'
---------- ---------- ---------- ----------
03/16/2016       1001         10         20
03/16/2016       1002         20
03/17/2016       1001         20
03/17/2016       1002                    10

SELECT q.ColA as "Next Repricing", q.ColA as "Balloon Date" FROM
(select acct, name, address,
case when pterm||' '||ptermc = '0' then date(digits(matdt7)) 
when pterm||' '||ptermc = '1 D' then curdate() 
when pterm||' '||ptermc = '1 M' then date(digits(prevd7))+30 day
when pterm||' '||ptermc = '3 M' then date(digits(prevd7))+90 day
when pterm||' '||ptermc = '6 M' then date(digits(prevd7))+180 day
when pterm||' '||ptermc = '12 M' then date(digits(prevd7))+365 day
else null end as ColA, ...) As q

Select Count(*)
From Product
where active = 'true'

 SELECT a.artist, a.title, a.imgurl, a.id, MAX(i.price), MIN(i.price)
   FROM albums    AS a
   JOIN inventory AS i ON a.id = i.albumId
--WHERE ...conditions on artist or album...
  GROUP BY a.artist, a.title, a.imgurl, a.id

With 
    Numbers As 
    (
    Select Row_Number() Over ( Order By C1.object_id ) As Value
    From sys.columns As C1
        Cross Join sys.columns As C2
    )
    , ProposedSequences As
    (
    Select  NTRIId
        , Row_Number() Over ( Order By NTRIId ) As Sequence
    From Table
    Where NTRITCode = 'PROPOSED'
    Group By NTRIId
    )
    , CurrentSequences As
    (
    Select RID, NTRITCode, NTRIId, Parameter, Usage, Rate
        , Numbers.Value As Sequence
    From Table
        Cross Join Numbers
    Where NTRITCode = 'Current'
        And Numbers.Value <= (Select Max(Sequence) From ProposedSequence)
    )
Select Sequence, RID, NTRITCode, NTRIId, Parameter, Usage, Rate
From CurrentSequences
Union All
Select PS.Sequence, T.RID, T.NTRITCode, T.NTRIId, T.Parameter, T.Usage, T.Rate
From ProposedSequences As PS
    Join Table As T
        On T.NTRIId = PS.NTRIId
Order By PS.Sequence, T.NTRITCode

SELECT "username" FROM user

SELECT column_name + ' ' + DATA_TYPE + COALESCE('(' + CASE
                                                        WHEN DATA_TYPE = 'XML' THEN NULL
                                                        WHEN CHARACTER_MAXIMUM_LENGTH = -1 THEN 'max'
                                                        ELSE Cast(CHARACTER_MAXIMUM_LENGTH AS VARCHAR(5))
                                                      END + ')', '(' + Cast(NUMERIC_PRECISION AS NVARCHAR(5)) + ',' + Cast(NUMERIC_SCALE AS NVARCHAR(5)) + ')', '') + ' ' + CASE IS_NULLABLE
                                                                                                                                                                              WHEN 'YES' THEN 'NULL'
                                                                                                                                                                              ELSE 'NOT NULL'
                                                                                                                                                                            END + COALESCE(' DEFAULT' + COLUMN_DEFAULT, '')
FROM   INFORMATION_SCHEMA.Columns
WHERE  table_name = 'mytable'

select x.a, c.b
from (
  select 'v1' as a union all
  select 'v2' as a union all
  select 'v3' as a
) x
left outer join c on c.a = x.a

WITH cte 
     AS (SELECT RN=Row_number() over(PARTITION BY a.Car_Name ORDER BY (SELECT NULL)), 
                a.car_name, 
                a.color, 
                a.size, 
                b.part_number 
         FROM   table1 
                INNER JOIN table2 
                        ON a.car_name = b.car_name) 
SELECT car_name=CASE WHEN rn = 1 THEN car_name ELSE NULL END, 
       color=CASE WHEN rn = 1 THEN color ELSE NULL END, 
       size=CASE WHEN rn = 1 THEN size ELSE NULL END, 
       part_number 
FROM   cte 

select e.*,
       max(photoname) as photoname, max(docname) as docname)
from estates e join
     ((select p.estateid, p.photoname, NULL as docname, (@rnp := @rnp + 1) as seqnum
       from photos p cross join
            (select @rnp := 0) params
       where p.estateid = 1
      ) union all
      (select d.estateid, NULL, d.docname, (@rnd := @rnd + 1) as seqnum
       from documents d cross join
            (select @rnd := 0) params
       where d.estateid = 1
      )
     ) dp
     on dp.estateid = e.estateid
group by e.stateid, dp.seqnum
order by e.stateid, dp.seqnum;

SELECT id, consumption, IF(@s=@s:=id, @s2:=@s2+consumption, @s2:=consumption) AS total
FROM temp_reading, (SELECT @s:=0, @s2:=0);

 select * from emp_history where emp_no in (select * from table(your pipelined function))

UPDATE t
SET ID = (SELECT MIN(ID) FROM t AS t2 WHERE t.Num = t2.Num)

select  
CONVERT(DATE,FormUpdated) FormUpdated,
DATENAME(dw, CONVERT(DATE,FormUpdated)),
SUM(CASE WHEN TrackingStatus = 'ViewRates' THEN 1 ELSE 0 END) c_ViewRates,
SUM(CASE WHEN TrackingStatus = 'Complete' THEN 1 ELSE 0 END) c_Complete,
SUM(CASE WHEN TrackingStatus = 'SaveforLater' THEN 1 ELSE 0 END) c_SaveforLater 
from Sales
where FormUpdated <= GETDATE()
AND FormUpdated >= DATEADD(D,-8,GetDate())
group by  CONVERT(DATE,FormUpdated)
order by  CONVERT(DATE,FormUpdated) desc

select  max(dateofstat)
from dhg.statistics
where assetid in
(
  select /*+ parallel(relatedasset,4) */ assetid
  from dhg.relatedasset 
  group by assetid
  having 
    max( case when assetid in (191759.0, 3.0, 5.0, 98.0, 99.0) 
                or linkid in (3232.0, 1049.0, 1057.0, 1067.0, 102.0, 1032.0, 104.0, 105.0, 1051.0) 
         then 1 else 0 end ) = 1
  and
    max( case when assetid in (192106.0, 1014.0, 10302.0)
                or linkid in (210.0, 737.0, 126.0, 1053.0, 1054.0, 119.0, 3133.0) 
         then 1 else 0 end ) = 0
);

ALTER PROCEDURE dbo.BCP_Text_File
    @table    NVARCHAR(255),  
    @filename VARCHAR(100)  
AS
BEGIN
  SET NOCOUNT ON;

  IF OBJECT_ID(@table) IS NOT NULL
  BEGIN
    DECLARE 
        @sql NVARCHAR(MAX), 
        @cols NVARCHAR(MAX) = N'';

    SELECT @cols += ',' + name
      FROM sys.columns
      WHERE [object_id] = OBJECT_ID(@table)
      ORDER BY column_id;

    SELECT @cols = STUFF(@cols, 1, 1, '');

    SET @sql = N'EXEC master..xp_cmdshell ''bcp "SELECT ''''' 
        + REPLACE(@cols, ',', ''''',''''') + ''''' UNION ALL SELECT ' 
        + 'RTRIM(' + REPLACE(@cols, ',', '),RTRIM(') + ') FROM ' 
        + DB_NAME() + '..' + @table + '" queryout "' + @filename + '" -c''';  

    EXEC sp_executesql @sql;
  END
  ELSE
  BEGIN
    SELECT 'The table '+@table+' does not exist in the database';
  END
END
GO

SELECT  *
FROM    mytable
WHERE   DATE(registration_date) BETWEEN @startDate AND @endDate
        AND EXISTS
        (
        SELECT  NULL
        FROM    dbo.split(',', COALESCE(@affiliateId, @channel))
        WHERE   value = CASE WHEN @affiliateId IS NULL THEN channel ELSE affiliateId END
        )
        AND EXISTS
        (
        SELECT  NULL
        FROM    dbo.split(',', @channel)
        WHERE   value = registration_channel
        )

SELECT COALESCE(csv.functionCC,t.functionCC) AS functionCC 
from #b as t
LEFT outer JOIN WR_16h_vs_MVA_16h_csv as csv
on t.PROBE_ID = csv.PROBE_ID;

 select p.user_id as user_id, p.pictures_count, p.likes_count, l.likers_count
 from (select p.user_id, count(*) as pictures_count, sum(likes) as likes_count
       from pictures p
       group by p.user_id
      ) p left join
      (select p.user_id, count(distinct l.user_id) as likers_count
       from pictures p left join
            likers l
            on p.wall_id = l.wall_id and p.picture_id = l.picture_id
       group by p.user_id
      ) l
      on p.user_id = l.user_id;

SELECT col FROM tbl WHERE INSTR(REVERSE('123456'), REVERSE(col))=1;

SELECT d.adst , min(d.total) mttl
FROM   (SELECT a.date              adate, 
               b.date              bdate, 
               a.price + b.price   total, 
               ( b.date - a.date ) days, 
               a.dst               adst 
    FROM   flights a 
           JOIN flights b 
             ON a.dst = b.dst 
    ORDER  BY total) d 
group by adst order by mttl;

SELECT u.Userid, u.Name, MAX(S.Salary)
FROM Usertable u
LEFT JOIN Salarytable s ON u.Userid = s.userid
GROUP BY u.userid, u.name

SELECT party_code, 1 + ROW_NUMBER() OVER (ORDER BY party_code) AS [serial number]
FROM myTable
ORDER BY party_code

<?xml version="1.0" encoding="utf-8"?>
<languages>
  <language name="SCLEX_MYSQL">
    <!-- This is the base language setting. It's usually not directly used, but provides values shared by
         more specialized MySQL versions. -->

    <!-- Lexer properties -->
    <property name="fold" value="1" />
    <property name="fold.compact" value="0" />
    <property name="fold.comment" value="1" />
    ...
    <style id="1" fore-color="#A0A0A0" /> <!-- SCE_MYSQL_COMMENT -->
    <style id="2" fore-color="#A0A0A0" /> <!-- SCE_MYSQL_COMMENTLINE -->
    ...
  </language>
  ...
</languages>

SELECT DISTINCT
  p.*,
  m.MemberID,
  m.FirstName + ' ' + m.LastName AS ProjectManager
FROM
  Project p
INNER JOIN
  Iterations i
ON
  p.ProjectID = i.ProjectID
INNER JOIN
  ProjectIterationMember pim1
ON
  i.ProjectIterationId = pim1.ProjectIterationID
INNER JOIN
  Member m
ON
  pim1.ProjectIterationMemberID = m.MemberID
AND
  m.CompanyRole = 'Project Manager'
INNER JOIN
  ProjectIterationMember pim2
ON
  i.ProjectIterationId = pim2.ProjectIterationID
AND
  pim2.ProjectIterationMemberID = ?
WHERE
  p.CompanyID = ?
ORDER BY
  p.StartDate DESC

CREATE TABLE Loan
(
      LoanID       INTEGER NOT NULL PRIMARY KEY
    , BranchID     INTEGER NOT NULL               CONSTRAINT tl_fk_branchid  REFERENCES Branch(BranchID) ON DELETE CASCADE
    , LoanNumber   CHAR(20) NOT NULL              CONSTRAINT tl_u_loannumber UNIQUE 
                       -- right padded to length of 20 with blanks 
    , LoanType     VARCHAR2(30) NOT NULL
    , Amount       Number(*,4) NOT NULL     
                       -- cf. http://stackoverflow.com/a/29014422, changed per @BobJarvis' comment
    , ModifiedDate DATE DEFAULT SYSDATE
);

1997-12-31 23:59:59.999,kishore
2014-12-31 23:59:59.999999,manish

create table mytable_tmp(mytime string,myname string)
row format delimited
fields terminated by ',';

load data local inpath 'input.txt'
overwrite into table mytable_tmp;



create table mytable(myname string,mytimestamp string)
PARTITIONED BY (mydate string)
row format delimited
fields terminated by ',';


SET hive.exec.dynamic.partition = true;
SET hive.exec.dynamic.partition.mode = nonstrict;

INSERT OVERWRITE TABLE mytable PARTITION(mydate) 
SELECT myname,mytime,to_date(mytime) from  mytable_tmp;


select * from mytable where mydate='2014-12-31';



manish  2014-12-31 23:59:59.999999  2014-12-31

select pt.*,
       row_number() over (partition by code order by code) as Position
from PositionTest pt

select  t.name As TriggerName, 
        ss.name As SchemaName, 
        so2.name As TableName
from    sys.triggers t
Join    sysobjects so
        On  t.object_id = so.id
Join    sysobjects so2
        On  so.parent_obj = so2.id
Join    sys.schemas ss
        On  so2.uid = ss.schema_id
Where   t.name = 'NAME'

select classes, id, value,
       sum(value) over (partition by classes order by id) as cumesum
from t;

SELECT ...
FROM MyTable
WHERE Id < (SELECT MAX(Id) FROM MyTable)

SELECT calendar_date
FROM (SELECT calendar_date, ROW_NUMBER() OVER(ORDER BY calendar_date DESC) as rownum
      FROM Calendar
      WHERE calendar_date < CURRENT_DATE
            AND business_day = 'Y') c
WHERE ROW_NUM = 3

SELECT a.Employee_ID, a.Accept_International_Assignment, a.Plan_Year
FROM  dbo.v_sc08_CD_Employee_Availabilities a
INNER JOIN (SELECT Employee_ID, MAX(Plan_Year) maxPlanYear
            from dbo.v_sc08_CD_Employee_Availabilities
            GROUP BY Employee_ID) m
   ON a.Plan_Year = m.maxPlanYear AND a.Employee_ID = m.Employee_ID

SELECT Avg(Value), Max(Value), Min(Value) FROM tableName

{
"stuffA": 415125,
"OnSwitch" : {"A" , "C"},
"OffSwitch" : {"C"}
}

INSERT INTO Table2 (CUSTOMER_ID, MERCHANT_ID, col1, col2, etc...)
SELECT t3.ID, t4.ID, t1.col1, t2.col2, etc..
FROM Table1 t1 
INNER JOIN Table3 t3 ON t1.CUSTOMER = t3.CUSTOMER_DESC
INNER JOIN Table4 t4 ON t1.MERCHANT = t4.MERCHANT_DESC

DECLARE @date DATETIME = GETDATE()
WHILE @date > DATEADD(year,-1,GETDATE())
BEGIN
    --do marvelous things
    SET @date = DATEADD(MONTH,-1,@date)
END

procedure TCustForm.yourQueryCalcField(DataSet : TDataset);
begin
  DataSet.FieldByName('Cost').AsCurrency :=  
        DataSet.FieldByName('Price').AsCurrency* 
        DataSet.FieldByName('Quantity').AsInteger;
end;

SELECT t1.*
FROM table_name t1
WHERE NOT EXISTS (select 1 from tablename t2
                  where t2.project = t1.project
                    and t2.report_date < t1.report_date
                    and t2.percentage_complete = 100)

UPDATE SPORTS
   SET matchup = REPLACE(matchup, 'Manchester United', 'Man Utd')

SELECT * 
FROM table2 
WHERE obj2.param1 IN (
    SELECT obj1.param1 
    FROM table1 
    WHERE... 
    GROUP BY obj1.param1
    HAVING COUNT(*) = 1
)

INSERT INTO [Vendor List] ([Vendor Number], [Vendor Name])
SELECT nv.[Vendor Number], nv.[Vendor Name]
FROM 2_Onbase_NewVendors nv LEFT JOIN [Vendor List] vl ON nv.[Vendor Number] = vl.[Vendor Number]
WHERE vl.[Vendor Number] IS NULL

SET @player_ID = 0;                  -- <<== the playerID
SELECT  a.*, b.*, 'player' Status         -- this is the first part of the union
FROM    game a                            -- which gets all the game of
        INNER JOIN game_player b          -- the selected player and its info
            ON a.id_game = b.id_game
WHERE   id_player = @player_ID 
UNION ALL
SELECT  d.*, c.*, 'opponent' status
FROM    game_player c
        INNER JOIN
        (
            SELECT  a.*
            FROM    game aa
                    INNER JOIN game_player bb
                        ON aa.id_game = bb.id_game
            WHERE   bb.id_player = @player_ID
        ) d ON c.id_game = d.id_game AND c.id_player <> @player_ID
ORDER   BY id_game, status

select item 
from data,generate_series(0,1000) 
where generate_series<qty order by item; 

SELECT * FROM `articles` WHERE `body` REGEXP '[[:<:]][acgj]'

SELECT  * FROM (select user_id, prod_and_ts.product_id as product_id,
regex_replace(prod_and_ts.timestamps, "#\\d*", "")  as timestamps FROM table2 LATERAL VIEW
explode(purchased_item) exploded_table as prod_and_ts) prod_and_ts;

SELECT
  BookID, Price, ISBN, Pages
FROM
(
  SELECT BookID, Key, Value FROM yourTable
)
  AS SourceTable
PIVOT
(
  SUM(Value) FOR Key IN (Price, ISBN, Pages)
)
  AS PivotTable
ORDER BY
  BookID

select /* index_ffs (a [name of index]) */
       id, rowid 
  from a
 where id is not null
 order by id, rowid;

@newnumber = number.find(:all, :conditions => ["id = ?", @dictionary.id], :select => "number * 2 as newnumber")

@newnumber = number.all(:conditions=>"id='#{@dictionary.id}'",:select=>"number * 2 as newnumber")

select USERNAME from ACCESSACTIVITY where UPPER(LOCATION)=UPPER('remote-PC')and DATE(TIMESTAMP) = STR_TO_DATE('28-05-2016 ','%d-%m-%Y')

SELECT inv_nr, 
       inv_date, 
       inv_customer 
FROM   invoice i 
WHERE  NOT EXISTS(SELECT 1 
                  FROM   cancel_invoice c 
                  WHERE  c.inv_nr = i.inv_nr) 

SELECT AR.* 
FROM stats3_last_join AR
INNER JOIN (SELECt max(value) mv, uuid 
            FROM stats3_last_Join
            GROUP BY uuid) MaxOnly
 on MaxOnly.mv= AR.Value
and MaxOnly.uuid = AR.Uuid

SELECT tblMyFriends.FriendID,
       tblMyFriends.GroupID,
       tblMessages.MyMessage,
       MAX(tblMessages.MyTime)
FROM tblMyFriends
LEFT JOIN tblMessages
       ON COALESCE(tblMyFriends.FriendID, tblMyFriends.GroupID) =
          COALESCE(tblMessages.FriendID,  tblMessages.GroupID)
GROUP BY tblMyFriends.FriendID,
         tblMyFriends.GroupID

public void TreeView_Droped (object sender, RoutedEventArgs e)
{
    //Do some work
    UpdateMyDataSource(sender, e, [another_fields_you_need]);
}

SELECT
a.ORDER_NO,
a.RELEASE_NO,
a.SEQUENCE_NO,
b.C_OPERATION_SEQUENCE as OP_SEQ,
b.OPERATION_NO,
b.OP_ID,
NVL(c.GUIDELINE_TEXT,'Nothing to see, move along') AS GUIDELINE_TEXT

SELECT
  employee.pin,
  CASE WHEN gender='M' THEN CONCAT_WS(' ', 'Mister', employee.titel, person.fname)
       WHEN gender='W' THEN CONCAT_WS(' ', 'Mrs', employee.titel, person.fname)
  END AS salutation
FROM
  person INNER JOIN employee
  ON person.pin=employee.pin
ORDER BY pin

db.execute("UPDATE ...")
if db.affected_rows == 0:
    db.execute("INSERT ...")

select T1.* from table t1 LEFT JOIN table t2 
ON t1.type = t2.type and t1.created < t2.created
where t2.id is null

select 'Table' AS object_type, table_name
from all_tables
where owner = '<owner>'
UNION ALL
select 'View' AS object_type, view_name
from all_views
where owner = '<owner>'
order by table_name;

this.ReportViewer1.ShowToolBar = false;

CREATE PROCEDURE ProcName
    @chklname bit,
    @chkfname bit,
    @chkcity bit,
    @chkmobile bit
AS
BEGIN
SET NOCOUNT ON;

    --Only execute the statement if at least one of the checkboxes are set
    if @chklname = 1 or @chkfname = 1 or @chkcity =1 or @chkmobile =1 
        begin
        declare @sqlcommand nvarchar(max) 


        set @sqlcommand = N'Select '

        if @chklname = 1
            set @sqlcommand += N'FirstName '

        if @chkfname = 1
        begin
            if len(@sqlcommand) > 1
                set @sqlcommand += N','
            set @sqlcommand += N'LastName '
        end
        if @chkcity = 1
        begin
            if len(@sqlcommand) > 1
                set @sqlcommand += N','
            set @sqlcommand += N'City '
        end
        if @chkmobile = 1
        begin
            if len(@sqlcommand) > 1
                set @sqlcommand += N','
            set @sqlcommand += N'Mobile '
        end

        set @sqlcommand += N' FROM table1'

        exec sp_executesql @statement = @sqlcommand

    end
END
GO

UPDATE U SET U.Units = U.Units + CI.ItemUnits
    FROM @CurrentItems CI INNER JOIN U ON U.UId=CI.ItemId;

SELECT ID, WeeklyAvg, MonthlyAvg
FROM
(
SELECT ID, WeeklyAvg, MonthlyAvg,
     ROW_NUMBER() OVER (PARTITION BY ID ORDER BY ID) RowNum
     FROM {table}
) A
WHERE RowNum = 1

Declare @s varchar(100) = '/ABCDEF/ABCDEF/ABC/8921/154535'
select REVERSE(SUBSTRING(REVERSE(@s),0,CHARINDEX('/',REVERSE(@s))))

SELECT Room_Type, COUNT(*) AS NumarRezervari
FROM   dbo.Reservation re
JOIN   dbo.Room ro ON ro.RoomID = re.RoomID
JOIN   dbo.Room_Type rt ON rt.Room_Type_ID = ro.Room_Type_ID
WHERE  MONTH(re.Data_Check_in) = 5
GROUP  BY Room_Type

source ~/.bashrc

INSERT INTO MyTable (col1, col2)
SELECT 'foo' AS col1, *
FROM OPENROWSET(BULK N'c:\foo.bin', SINGLE_BLOB) AS col2

SELECT *
FROM   x
WHERE  name IN ('Jon', 'Peter', 'Paul')

create table #table (name varchar(30),[order] varchar(10),id varchar(3))

DECLARE @name varchar(30), @id int
DECLARE curs_Fp CURSOR FOR

SELECT  c.name, c.id FROM customer c 

OPEN curs_Fp
FETCH NEXT FROM curs_Fp INTO  @name, @id

    WHILE @@FETCH_STATUS = 0 
BEGIN

        insert into #table 
        SELECT @name, @id ,''

        insert into #table 
        SELECT  '',o.[order],o.id FROM ORDER o where  o.id = @id

FETCH NEXT FROM curs_Fp INTO  @name, @id
END

CLOSE curs_Fp
DEALLOCATE curs_Fp

select * from #table
drop table #table

public class PricingTablePackages
{
    public int ID { get; set; }

    public int PricingTableID { get; set; }

    public virtual PricingTable PricingTable { get; set; }

    public string Title { get; set; }

    public decimal Price { get; set; }

    public decimal PricePerTime { get; set; }

    public string Info { get; set; }

    public bool Flag { get; set; }

    public string Link { get; set; }
}

public class PricingTablePackagesFeatures
{
    public int ID { get; set; }

    public int PricingTableID { get; set; }

    public virtual PricingTable PricingTable { get; set; }

    public string Feature { get; set; }

    public string Value { get; set; }

    public string MoreInfo { get; set; }
}

public class PricingTable
{
    public int ID { get; set; }

    public string Name { get; set; }

    public int ServiceID { get; set; }

    public virtual Service Service { get; set; } // if there is a Service class

    public string Style { get; set; }
}

WITH daily_count AS  -- temp table to store daily counts 
(
         SELECT   parking_meter_id,
                  COUNT(*)                  AS cnt,
                  to_char(start,'YYYYMMDD') AS day
         FROM     parking_transactions
         WHERE    start >= now() - interval '3 month' -- last three months
         AND      to_char(start,'D') = to_char(now(),'D') -- same weekday
         AND      to_char(now(),'HH24MISS') BETWEEN to_char(start,'HH24MISS') AND to_char(stop,'HH24MISS') -- same time
         GROUP BY parking_meter_id,
                  to_char(start,'YYYYMMDD') -- group by parking meter id and day
), avg_count_minus_today AS -- temp table to store avg count minus today 
(
         SELECT   parking_meter_id,
                  AVG(cnt) AS avg_count
         FROM     daily_count
         WHERE    day < to_char(now(),'YYYYMMDD') -- but not today
         GROUP BY parking_meter_id 
)
SELECT     a.parking_meter_id,
           a.avg_count, --avg count minus today
           d.cnt AS today_count
FROM       avg_count_minus_today a
INNER JOIN daily_count d
ON         a.parking_meter_id= d.parking_meter_id AND d.day=to_char(now(),'YYYYMMDD'); --today in daily count

create table #t (col1 real, col2 real, col3 real)
select checksum(*) from #t
if @@rowcount = 0
    print 'All values are NULL'
else
    print 'Non-NULL value(s) found'
drop table #t

DECLARE @Columns NVARCHAR(MAX)='', @Query NVARCHAR(MAX)=''
DECLARE @CastColumns NVARCHAR(MAX)=''

SELECT  @Columns = @Columns + QUOTENAME(COLUMN_NAME) + ',',
        @CastColumns = @CastColumns+CASE WHEN data_type <> 'float' THEN
        'CAST('+QUOTENAME(COLUMN_NAME)+' AS FLOAT) AS '+QUOTENAME(COLUMN_NAME) ELSE
        QUOTENAME(COLUMN_NAME) END+','
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'YourTable' 
ORDER BY ORDINAL_POSITION

SET @Columns = LEFT(@Columns,LEN(@Columns)-1)
SET @CastColumns = LEFT(@CastColumns,LEN(@CastColumns)-1)

SET @Query = '
SELECT ROW_NUMBER() OVER(ORDER BY CO.Ordinal_Position) Id, ColumnName, Value
FROM (SELECT '+@CastColumns+' FROM YourTable) AS P
UNPIVOT(value FOR ColumnName IN ('+@Columns+')) AS UC
JOIN (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ''YourTable'') CO
ON ColumnName = CO.COLUMN_NAME
'

INSERT INTO @TTABLE
EXEC sp_executesql @Query

SELECT price_est.sau_price_avg
INTO _est_price
FROM price_est
WHERE
  (price_est.neighbourhood_id = _neighbourhood_id OR price_est.neighbourhood_id IS NULL) AND
  price_est.district_id = _district_id AND
  price_est.municipality_id = _municipality_id AND
  price_est.county_id = _county_id
ORDER BY price_est.neighbourhood_id NULLS LAST
LIMIT 1;


with
 subquery1 as (select /*big query*/ ),
 subquery2 as (select /*big query*/ )
select *
from ...
     join subquery1
where foo in (select foo from subquery2)

select sku, catalogname, getdate()
from
(
select sku, catalogname, categoryname, parentOID
from uswebdb.commerce.catalogproducts
union all
select sku, catalogname, categoryname, parentOID
from ukwebdb.commerce.catalogproducts
) F
where (F.CategoryName is not null or F.ParentOID = 113)
and (F.sku not like '%[a-z]%')

SELECT  
        AssetID_1, AssetID_2,
        ((psum - (sum1 * sum2 / n)) / sqrt((sum1sq - sum1*sum1 / n) * (sum2sq - sum2*sum2 / n))) AS [Correlation Coefficient],
        n
FROM
        (SELECT 
                n1.AssetClass_ID AS AssetID_1,
                n2.AssetClass_ID AS AssetID_2,
                SUM(n1.RunResults_Value) AS sum1,
                SUM(n2.RunResults_Value) AS sum2,
                SUM(n1.RunResults_Value * n1.RunResults_Value) AS sum1sq,
                SUM(n2.RunResults_Value * n2.RunResults_Value) AS sum2sq,
                SUM(n1.RunResults_Value * n2.RunResults_Value) AS psum,
                COUNT(*) AS n
        FROM
                dbo.tbl_RunResults AS n1
                LEFT JOIN dbo.tbl_RunResults AS n2 ON n1.Simulation_ID = n2.Simulation_ID
        WHERE   

                n1.AssetClass_ID  < n2.AssetClass_ID AND
                n1.series_ID = 2332 AND
                n2.series_ID = 2332

    GROUP BY
        n1.AssetClass_ID, n2.AssetClass_ID) AS step1
ORDER BY
        AssetID_1

DECLARE @id int;
SET @id = (select top(1) id from [table] where [x] = 0 order by id desc);

select * from [table] where id = @id;
update [table] set [x] = 20 where id = @id;

my $rs = My::Schema->resultset('Students') #
    ->search({
        status => 6,
        grad_date => { 'between' => [ $start_dt, $end_dt ] },
    });

my $num_grads    = $rs->count();
my $num_employed = $rs->search({ employment_status => 1 })->count();

select somevalue1,somevalue2,somevalue3,value1_t1,value2_t1,cast(null as int) as value2_t2,cast(null as int) as value3_t2
from table1
union all
select somevalue1,somevalue2,somevalue3,null,null,value2_t2,value3_t2
from table2

select *
from (select row_number() over (ORDER BY cars.CarId) as Row, *
    from cars
    ) temp
where Row between 20 and 29

select item_id , title , description , sum(votes) as totalVotes from items 
    left join votes on
    items.item_id = votes.item_id
    group by votes.item_id
    order by item_id desc

Select count(*) as rows,
    month(create_datetime) as month, 
    year(create_datetime) as year
FROM      [table_name]
WHERE     year(create_datetime) BETWEEN 1999 AND 2014
GROUP BY  month(create_datetime), year(create_datetime)

SELECT Product
FROM ProductWeek
GROUP BY Product
HAVING COUNT(*) = (SELECT COUNT(*) from (SELECT distinct weekending from ProductWeek ) as t);

Select type1,type2,code,Max(Amt) Over(PARTITION BY Code) AS MaxAmt
from Table1

tblMember
memberID
memberName

tblEvent
eventID
eventType
eventDate

tblAttendance
memberID
eventID

select t1.*
from your_table t1
join
(
  select entity, department, max(Code_count) as Code_count 
  from your_table
  group by entity, department
) t2 on t1.entity = t2.entity 
    and t1.department = t2.department 
    and t1.Code_count = t2.Code_count 

jdbc:macromedia:oracle:TNSNamesFile=C:\\Oracle\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora; TNSServerName=tnsentry

Select  e.*
From    employee    e
Where Not Exists
(
    Select  1
    From    employee_roles  r
    Where   r.employee_id = e.employee_id
    And     r.role_id = 5330
)

SELECT 'abc' AS C1, 
        1 AS NO 
   FROM DUAL
UNION 
SELECT c1 AS C1, 
       2 AS NO 
   FROM t2 
ORDER BY NO;

Mid([X], InStr([X], "\") + 1)

INSERT INTO tForeignLanguage ([Name]) VALUES (N'Араб')

select tablename, count(*)
from (select 'table1' as tablename, someid
      from table1
      union all
      select 'table2' as tablename, someid
      from table2
     ) t
where someid in ('1815972751', '1815751159', '1815752967', '1815756079')
group by tablename;

Select *
from tbl_Events
where startDate <= @end AND @start <= EndDate

DECLARE @TEMP_TBL TABLE (COL1 INT, COL2 VARCHAR(100))

INSERT INTO @TEMP_TBL
select ID, NAME FROM TB1

with virtualTable as(
   SELECT
    ...
   FROM [...]

   UNION

   SELECT
    ...
   FROM [...]
) 
select vt1.field,
       vt2.field
from   virtualTable vt1 join virtualTable vt2 on vt1.someField = vt2.otherField

CREATE TABLE TableName
(
    UID INT AUTO_INCREMENT PRIMARY KEY,
    -- other columns...
)

SELECT o.Id, o.attrib1, o.attrib2 FROM table1 o
JOIN (
  SELECT DISTINCT Id FROM table1, table2, table3 WHERE ...
) T1
ON o.id = T1.Id

SELECT DISTINCT releases.* 
FROM releases
INNER JOIN artist_love ON  releases.all_artists LIKE CONCAT('%',artist_love.artist,'%')
AND artist_love.user =  'Quickinho'
INNER JOIN label_love ON label_love.label = releases.label_no_country
AND label_love.user =  'Quickinho'
left join charts_extended on charts_extended.release_id=label_love=releases.id and charts_extended.artist =  'Quickinho'
where charts_extended.release_id is null
ORDER BY releases.date DESC 
LIMIT 0 , 102

SELECT  workingDate as [date], openTime as [Start], COALESCE(breakStart, closeTime) as [End]
FROM    workingSchedule
        LEFT JOIN (
            SELECT  breakDate,  breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM
            FROM    breakTable
        ) as firstBreak ON workingSchedule.workingDate = firstBreak.breakDate AND firstBreak.ROWNUM = 1
UNION
SELECT  breakStart.breakDate, breakStart.breakEnd, coalesce(breakEnd.breakStart, endTime.closeTime)
FROM    (
            SELECT  breakDate,  breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM
            FROM    breakTable
        ) as breakStart
        LEFT JOIN (
            SELECT  breakDate,  breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM
            FROM    breakTable
        ) as breakEnd ON breakStart.breakDate = breakEnd.breakDate AND breakStart.ROWNUM = breakEnd.ROWNUM - 1
        LEFT JOIN (
            SELECT  workingDate, closeTime
            FROM    workingSchedule
        ) AS endTime ON breakStart.breakDate = endTime.workingDate

DECLARE @t TABLE (AMID INT, Entry VARCHAR(100))
INSERT @t 
VALUES
(       1000                   ,'MARS'),
(       1001                   ,'JUPITER'),
(       1002                   ,'SATURN'),
(       1003                   ,'VENUS'),
(       1003                   ,'SATURN'),
(       1004                   ,'NEPTUNE'),
(       1004                   ,'SATURN'),
(       1005                   ,'JUPITER'),
(       1005                   ,'MARS')

;WITH a AS(
    SELECT  *,
            ROW_NUMBER() OVER (PARTITION BY AMID ORDER BY 
                CASE Entry 
                    WHEN 'VENUS' THEN 0
                    WHEN 'MARS' THEN 1
                    WHEN 'JUPITER' THEN 2
                    WHEN 'SATURN' THEN 3
                    WHEN 'NEPTUNE' THEN 4
                END) num
    FROM    @t
)

SELECT  AMID, Entry
FROM    a
WHERE   num = 1

;WITH CTE
AS
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY tblB.[No] ORDER BY tblB.[Date]) AS RowNbr,
        tblB.*
    FROM
        B AS tblB
)
SELECT
    *
FROM
    A AS tblA
    LEFT JOIN CTE
        ON tblA.No=CTE.No
        AND CTE.RowNbr=1

SELECT 
    my_Group,
    my_sum, 
    my_sum/my_total as my_Percent 
FROM(
    SELECT 
        categories.cat AS my_Group, 
        SUM(atual) AS my_sum
    FROM `table1` 
    INNER JOIN categories ON table1.category_id=categories.id
    GROUP BY categoria
) as t
LEFT JOIN 
    (
        SELECT 
            SUM(atual) as my_total
        FROM `table1`
    ) as t1

select t.visitty, t.specialty, t.doctors
from table t join
     (select specialty, sum(doctors) as numdoctors
      from table t
      group by specialty
     ) tsum
     on t.specialty = tsum.specialty
order by tsum.doctors desc, tsum.specialty, t.doctors desc;

CREATE VIEW T4 AS 
SELECT T1.a, T3.d
FROM T1 
JOIN T2 ON T1.b = T2.b
JOIN T3 ON T2.c = T3.c

regexp_replace(yourValue,'(XX)0([0-4])(*)', '\1\2\3')

select book_num, t.booktype, x.avgcost, bookcost, x.avgcost-bookcost
from tablename t join 
(select booktype, avg(bookcost) as avgcost from tablename group by booktype) x
on t.booktype = x.booktype 

select (case when count(*) = count(a.DateTimeChangedUtc) and
                  count(*) = count(b.DateTimeChangedUTC)
             then SUM(DATEDIFF(SECOND, a.DateTimeChangedUtc, b.DateTimeChangedUTC)) 
        end) AS TimeSpentSeconds

create table tmp (a int primary key, b int)
GO

create trigger tr_insupd_tmp on tmp
instead of insert, update
as
    if not exists(select * from deleted)
        -- Process Insert
        insert into tmp
            select a, 1
            from inserted
    else
        -- Process Update
        update tmp
            set b = 2
        from tmp t
        inner join inserted i on t.a = i.a
GO

select t1.[Fiscal Year],t1.Value,(t1.[Fiscal Year]-1) [previous_year],t2.Value [previous_value]
from  
(  select [Fiscal Year], sum([value]) value
  from [table1] 
  group by [Fiscal Year] 
)t1
LEFT JOIN
(  
select [Fiscal Year], sum([value]) value
  from [table1] 
  group by [Fiscal Year] 
)t2
ON t1.[Fiscal Year]=t2.[Fiscal Year]+1

select t.*,
       count(*) over (partition by EmpId) as Count
from table t;

SELECT username, email FROM users WHERE (username LIKE '%bla%' or username like '%bla2%' or username like '%bla3%') AND last_visit > '2013-05-15 00:00:00'";

SELECT null as Status,
sum(IIF(layer='key info',1,0)) AS [Key Info],
sum(IIF(layer='approaches',1,0)) AS [Approaches],
sum(IIF(layer='research',1,0)) AS [Research]
FROM resources
WHERE (literacy OR numeracy OR poverty)

UNION

SELECT [copyright status],
sum(IIF(layer='key info',1,0)) AS [Key Info],
sum(IIF(layer='approaches',1,0)) AS [Approaches],
sum(IIF(layer='research',1,0)) AS [Research]
FROM resources
WHERE (literacy OR numeracy OR poverty)
GROUP BY [copyright status]

UNION

SELECT [lw status],
sum(IIF(layer='key info',1,0)) AS [Key Info],
sum(IIF(layer='approaches',1,0)) AS [Approaches],
sum(IIF(layer='research',1,0)) AS [Research]
FROM resources
WHERE (literacy OR numeracy OR poverty) AND [lw status] = 'In Reserve'
GROUP BY [lw status]

UNION

SELECT [lw status],
sum(IIF(layer='key info',1,0)) AS [Key Info],
sum(IIF(layer='approaches',1,0)) AS [Approaches],
sum(IIF(layer='research',1,0)) AS [Research]
FROM resources
WHERE (literacy OR numeracy OR poverty) AND [lw status] = 'Published'
GROUP BY [lw status];

CREATE PROC #bar
AS
SELECT * FROM sys.objects
EXEC ('SELECT * FROM sys.objects')
GO

CREATE PROC #foo
AS
SET ROWCOUNT 1

EXEC #bar
GO

SET ROWCOUNT 4
EXEC #foo /*Returns 2 resultsets with 1 row*/
EXEC #bar /*Returns 2 resultsets with 4 rows*/

DROP PROC #foo
DROP PROC #bar

SELECT  
    M.*, Data.* 
FROM [Measure] M 
CROSS APPLY
     (SELECT TOP 1 EV.* FROM [Event] E JOIN EventValues EV ON E.EventID = EV.EventID  
     WHERE M.Time >= E.Time ORDER BY E.Time DESC) AS Data
ORDER BY M.Distance 

SET DATEFIRST 7;

DECLARE @Date DATETIME = '20120101';
DECLARE @Dates TABLE 
(   Date DATE, MonthNum INT, 
    MonthName VARCHAR(15), 
    DayNum INT, 
    MonthStart DATE, 
    Day VARCHAR(2)
);

WITH Dates AS
(   SELECT  [Date] = DATEADD(DAY, ROW_NUMBER() OVER(ORDER BY Object_ID) - 8, @Date)
    FROM    sys.All_Objects
)
INSERT @Dates (Date, MonthNum, MonthName, DayNum, MonthStart, Day)
SELECT  Date,
        [MonthNum] = DATEPART(MONTH, Date),
        [MonthName] = LEFT(DATENAME(MONTH, Date), 3), 
        [DayNum] = DATEPART(WEEKDAY, Date),
        [MonthStart] = DATEADD(MONTH, DATEDIFF(MONTH, 0, d1.Date), 0),
        [Day] = CONVERT(VARCHAR(2), DATEPART(DAY, Date))
FROM    Dates d1
WHERE   Date < DATEADD(YEAR, 1, @Date);

WITH Calendar AS
(   SELECT  MonthName, 
            MonthNum, 
            [Identifier] = CONVERT(VARCHAR(1),  DayNum) + 
                            CONVERT(VARCHAR(1),  Occurance), 
            [Day]
    FROM    @Dates d1
            CROSS APPLY
            (   SELECT  [Occurance] = COUNT(*) 
                FROM    @Dates d2
                WHERE   d2.Date >= DATEADD(DAY, 1 - DATEPART(WEEKDAY, d1.MonthStart), d1.MonthStart) 
                AND     d2.Date <= d1.Date
                AND     d1.DayNum = d2.DayNum
            ) o
    WHERE   d1.Date >= @Date
    UNION ALL
    SELECT  [MonthName] = LEFT(DATENAME(MONTH, '2012' + 
                                                RIGHT('0' + CONVERT(VARCHAR(2), MonthNumber), 2) + 
                                                '01'), 3), 
            MonthNumber, 
            [ID] = DayNumber + Occurance, 
            [Day] = ''
    FROM    (VALUES ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7')) AS d (DayNumber)
            CROSS JOIN (VALUES ('1'), ('2'), ('3'), ('4'), ('5'), ('6')) AS o (Occurance)
            CROSS JOIN (VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12)) AS m (MonthNumber)
)
SELECT  [MonthName],
        [Sun] = [11], [Mon] = [21], [Tues] = [31], [Wed] = [41], [Thu] = [51], [Friday] = [61], [Sat] = [71],
        [Sun] = [12], [Mon] = [22], [Tues] = [32], [Wed] = [42], [Thu] = [52], [Friday] = [62], [Sat] = [72],
        [Sun] = [13], [Mon] = [23], [Tues] = [33], [Wed] = [43], [Thu] = [53], [Friday] = [63], [Sat] = [73],
        [Sun] = [14], [Mon] = [24], [Tues] = [34], [Wed] = [44], [Thu] = [54], [Friday] = [64], [Sat] = [74],
        [Sun] = [15], [Mon] = [25], [Tues] = [35], [Wed] = [45], [Thu] = [55], [Friday] = [65], [Sat] = [75],
        [Sun] = [16], [Mon] = [26], [Tues] = [36], [Wed] = [46], [Thu] = [56], [Friday] = [66], [Sat] = [76]
FROM    Calendar
        PIVOT
        (   MAX([Day])
            FOR [Identifier] IN
            (   [11], [21], [31], [41], [51], [61], [71],
                [12], [22], [32], [42], [52], [62], [72],
                [13], [23], [33], [43], [53], [63], [73],
                [14], [24], [34], [44], [54], [64], [74],
                [15], [25], [35], [45], [55], [65], [75],
                [16], [26], [36], [46], [56], [66], [76]
            )
        ) AS pvt
ORDER BY MonthNum;

CREATE FUNCTION dbo.CostAtDate ( @costdate AS datetime , @product AS int )
RETURNS table
AS
Return (
  Select Top 1
    BASE_InventoryCostLogDetail.AverageCostAfter
  From
    BASE_InventoryCostLogDetail
  Where
    CreatedDttm < @costdate And CreatedDttm > DATEADD(month,-1,@costDate) And
    ProdId = @product
  Order By
    CreatedDttm Desc)

SELECT 
   REPLACE(REPLACE(REPLACE(`phone`, '-', ''), ' ', ''),'"','') AS `phone_number`
  FROM `table`;

INSERT INTO table_name( id , name )
SELECT  id, name FROM temp_table;

TRUNCATE TABLE temp_table;

SELECT a.*, b.column1, b.column2, ...
FROM Table_1 a JOIN Table_2 b on a.ID=b.ID

UNION

SELECT a.*, '' AS column1, '' AS column2, ...
FROM Table_1 a 
WHERE a.ID NOT IN 
     (SELECT a.ID FROM Table_1 a JOIN Table_2 b on a.ID=b.ID);

select MONTH(DATE) As "Month"
from DW******.SL****
Group By MONTH(DATE)
Order by MONTH(DATE)

SELECT id , GREATEST(field1, field2) max_val ,
CASE WHEN field1 >= field2  THEN 2 ELSE 3 END col_idx
FROM my_table

tbl_name (name_id, name)
tbl_location (locaiton_id, location)
tbl_name_location (name_id, location_id)

SELECT s.userid,
    'Sell' as type,
    s.ProductId, 
    s.ProductName, 
    s.ProductPrice 
FROM Sell s
WHERE UserId = 1
UNION ALL
SELECT p.userid,
    'Purchase' as type,
    p.ProductId, 
    p.ProductName, 
    p.ProductPrice
FROM Purchase P
WHERE UserId = 1

SELECT Document.* 
FROM Document 
INNER JOIN DocumentField ON Document.DocumentKey = DocumentField.DocumentKey 
WHERE  (DocTypeKey IS NOT NULL) 
AND Document.DocumentKey IN (
    SELECT DocumentKey FROM DocumentField WHERE FieldId = '1' AND FieldValue  LIKE 'PO1%' 
    INTERSECT 
    SELECT DocumentKey FROM DocumentField WHERE FieldId = '2' AND FieldValue  LIKE 'INV1%'
) 

    SELECT CASE WHEN COALESCE(A1,0)<>1 AND COALESCE(A2,0)<>1 AND COALESCE(A3,0)<>1 
            AND COALESCE(A4,0)<>1 AND COALESCE(A5,0)<>1 THEN 1 ELSE '' END A
        , CASE WHEN COALESCE(A1,0)<>2 AND COALESCE(A2,0)<>2 AND COALESCE(A3,0)<>2 
            AND COALESCE(A4,0)<>2 AND COALESCE(A5,0)<>2 THEN 2 ELSE '' END B
        , CASE WHEN COALESCE(A1,0)<>3 AND COALESCE(A2,0)<>3 AND COALESCE(A3,0)<>3 
            AND COALESCE(A4,0)<>3 AND COALESCE(A5,0)<>3 THEN 3 ELSE '' END C
        , CASE WHEN COALESCE(A1,0)<>4 AND COALESCE(A2,0)<>4 AND COALESCE(A3,0)<>4 
            AND COALESCE(A4,0)<>4 AND COALESCE(A5,0)<>4 THEN 4 ELSE '' END D
        , CASE WHEN COALESCE(A1,0)<>5 AND COALESCE(A2,0)<>5 AND COALESCE(A3,0)<>5 
            AND COALESCE(A4,0)<>5 AND COALESCE(A5,0)<>5 THEN 5 ELSE '' END E
    FROM NumTest 
    WHERE COALESCE(A1,0)+COALESCE(A2,0)+COALESCE(A3,0)+COALESCE(A4,0)+COALESCE(A5,0)<>15

SELECT a.id, a.shipmentNo, a.status, a.date 
FROM (SELECT a.id, a.shipmentNo, a.status, a.date 
      FROM shipment a ORDER BY a.shipmentNo, FIELD(a.status, 'S', 'I')
      WHERE a.date = '2013-12-12'
      ) A
GROUP BY a.shipmentNo

SELECT l.*
FROM listings l
LEFT JOIN addresses a_l ON a_l.addressable_id = l.id
  AND a_l.addressable_type = "App\\Listing"
  AND a_l.suburb = "Melbourne"
LEFT JOIN addresses a_u ON a_u.addressable_id = l.user_id
  AND a_u.addressable_type = "App\\User"
  AND a_u.suburb = "Melbourne"
WHERE a_l.id IS NOT NULL OR a_u.id IS NOT NULL

 (case when left(str1, 10) = left(str2, 10) then 10
       when left(str1, 9) = left(str2, 9) then 9
       ...
       when left(str1, 1) = left(str2, 1) then 1
       else 0
   end)

create table #T (s varchar(128)) 
declare @T table (s varchar(128)) 
insert into #T select 'old value #' 
insert into @T select 'old value @' 
begin transaction 
     update #T set s='new value #' 
     update @T set s='new value @' 
rollback transaction 
select * from #T 
select * from @T 

SELECT *
FROM ( .... ) YourQuery
WHERE Disponible='Si';

select brand_name, count(*) AS num 
from (select SUBSTRING_INDEX(new_name, ':', 1) as brand_name 
from table 
WHERE date<='".$american_today."' AND date>= '".$two_weeks_ago."' 
GROUP BY day(date), products_id) 
as brands  group by brand_name ORDER BY num DESC LIMIT 5

SELECT ids.id 
FROM (SELECT 2 AS id
      UNION
      SELECT 3
      UNION
      SELECT 4) AS ids
LEFT OUTER JOIN products 
 ON ids.id = products.id 
WHERE products.id IS NULL

SELECT 
    [TableName] = so.name, 
    [RowCount] = MAX(si.rows) 
FROM 
    sysobjects so, 
    sysindexes si 
WHERE 
    so.xtype = 'U' 
    AND 
    si.id = OBJECT_ID(so.name) 
GROUP BY 
    so.name 
ORDER BY 
    2 DESC

SELECT  a.*, c.*    -- <<== select the columns you want to display
FROM    Users a
        INNER JOIN UserTagLink b
            ON a.UserID = b.UserID
        INNER JOIN Tags c
            ON b.TagID = c.TagID

select *
from (
    SELECT
        pictures.id,
        ts_rank_cd(to_tsvector('english', pictures.title), 
        to_tsquery('small dog')) AS score
    FROM pictures
) s
WHERE score > 0
ORDER BY score DESC

insert into table1(col1, col2, col3)
    select 1, col2, 0
    from <your other query here>;

Delete From StudentTb 
Where StudentType in (1, 2) 
and StudentI in
(
select StudentI
from StudentTb
except 
Select StudentI From StudentLog    
)

SELECT Tot = ISNULL(Val1, 0) + ISNULL(Val2, 0)
FROM Table

SELECT * 
FROM Table_1 AS t1
LEFT OUTER JOIN Table_2 AS t2
ON t1.firstname = t2.firstname
AND t1.lastname = t2.lastname
WHERE t2.firstname IS NULL AND t2.lastname IS NULL

.Parameters.Add(New OracleParameter("vinspectiondatetime", OracleClient.OracleType.DateTime)).Value = new DateTime(2010, 2, 5, 11, 46, 0)

SELECT CASE WHEN rn=1 THEN cnt END cnt, order_name, status
FROM
(
SELECT count(*) OVER (PARTITION BY status) cnt,
  ROW_NUMBER() OVER (PARTITION BY status ORDER BY order_name) rn,
  order_name,status
FROM input_table
)

SELECT p.id,
       p.name,
       group_concat(DISTINCT cat.name separator ',') as categories
FROM places p
   LEFT JOIN places_categories_rel rel ON p.id=rel.place_id
   LEFT JOIN categories cat ON cat.id=rel.category_id
WHERE EXISTS (
   SELECT 1
   FROM places_categories_rel pcr 
       JOIN categories c ON c.id=pcr.category_id
   WHERE name = 'Lounge'  AND p.id=pcr.place_id
)
GROUP BY p.id

SELECT SELECT MAX(t1.ID)
  ,STUFF( (SELECT ','+Info3 FROM temp t
           WHERE t.Rank=A.RankFOR XML PATH(''))  ,  1 , 1 , '' )
FROM temp A
GROUP BY A.Rank

SELECT id, p_id, offer FROM offers 
WHERE p_id = 1 order by offer desc limit 1

SELECT * FROM my_table ORDER BY id DESC LIMIT 10;

ORDER BY rand()*pow(<probability-field-name>,<n>)

;WITH x AS 
(
  SELECT ID,NAME,[LAST NAME],PHONE,STATE,
    ROW_NUMBER() OVER (PARTITION BY NAME,[LAST NAME],PHONE ORDER BY ID DESC) 
  FROM dbo.YourTable
)
UPDATE x SET STATE = CASE rn WHEN 1 THEN NULL ELSE 'DUPE' END;

Convert MMM dd yyyy HH:MM[AM|PM] to dd/MM/yyyy hh:mm:ss
Declare @Date VARCHAR(20) = 'Jan 27 2015 12:05AM'

SELECT CONVERT(VARCHAR(10), CONVERT(DATETIME, @Date),103)
          + ' ' + CONVERT(VARCHAR(8), CONVERT(DATETIME, @Date),108)


    Result:    27/01/2015 00:05:00

 set serveroutput on;
 declare
   XML CLOB;
   XML_DOCUMENT DBMS_XMLDOM.DOMDOCUMENT;
   XML_NODE DBMS_XMLDOM.DOMNODE;
 begin
   XML := '
   <ROOT>
     <A>
       <B>2</B>
       <C>3</C>
       <D>
         <E>12</E>
       </D>
       <F/>
       <G/>
     </A> 
   </ROOT>
   ';

   XML_DOCUMENT := DBMS_XMLDOM.NEWDOMDOCUMENT(XML);
   XML_NODE := DBMS_XMLDOM.MAKENODE(XML_DOCUMENT);
   XML_NODE := DBMS_XSLPROCESSOR.SELECTSINGLENODE(XML_NODE,'ROOT/A/B/text()');
   IF(DBMS_XMLDOM.ISNULL(XML_NODE) = FALSE)
   THEN
     dbms_output.put_line(DBMS_XMLDOM.GETNODEVALUE(XML_NODE));
   END IF;
 end;

SELECT k.name AS hicompany, count( * ) AS howmany
FROM people p
JOIN hicompany k ON p.id= k.id
GROUP BY name
ORDER BY COUNT(*) DESC

select
  t1.*,
  t2.dispatcher_id,
  t2.dispatcher_score,
  t2.dispatcher_score - t1.score as delta_score
from
(
  select 
    dispatcher_id,
    dispatcher_score,
    final_indx,
    rank() over (partition by final_indx order by dispatcher_score desc) as rnk
  from table2
) t2
join table1 t1 on t1.res_score_id = t2.final_indx
where t2.rnk = 1;

CREATE TABLE STUDENT
(ID NUMBER(9),
STUDENT_NAME VARCHAR2(500), 
CONSTRAINT PK_STUDENT PRIMARY KEY(ID));
--------
CREATE TABLE ATTENDANCE_TYPE
(ID NUMBER(9),
AT_DESCRIPTION VARCHAR2(250),
CONSTRAINT PK_ATTENDANCE_TYPE PRIMARY KEY(ID))
------------------------
CREATE TABLE ATTENDANCE(
ID NUMBER(9),
STUDENT_ID NUMBER(9),
ATTENDANCE_DAY DATE,
ATTENDANCE_TYPE_ID NUMBER(9),
CONSTRAINT PK_ATTENDANCE PRIMARY KEY(ID),
CONSTRAINT FK_ATTENDANCE_TYPE
FOREIGN KEY (ATTENDANCE_TYPE_ID) REFERENCES ATTENDANCE_TYPE(ID),
CONSTRAINT FK_STUDENT
FOREIGN KEY (STUDENT_ID) REFERENCES STUDENT(ID));

--this gets the number of students late in Jan, Feb and March 1st this year
SELECT COUNT(*)
FROM student s JOIN attendance att
ON s.ID = att.student_id
WHERE att.attendance_type_id = 2
AND att.attendance_day BETWEEN TO_DATE('01-JAN-2016', 'DD-MON-YYYY') AND TO_DATE('01-MAR-2016', 'DD-MON-YYYY');

SELECT A.item_ID, A.item_name
FROM A
LEFT JOIN B ON A.item_ID = B.item_ID
WHERE (B.option_ID=34 AND B.option_value BETWEEN 1000 AND 2000)
      OR (B.option_ID=12 AND B.option_value BETWEEN 0 AND 4000)
GROUP BY A.item_ID
HAVING COUNT(A.item_ID) >= 2

select t.*,
       (case when min(NumEmployees) over (partition by grp) =
                  max(NumEmployees) over (partition by grp)
             then 1
             else 0
        end) as DerivedField
from table t;

SELECT a,b,c, min(d)
FROM myTable
GROUP BY a,b,c
ORDER BY a,b,c

select comp_id, app_id, cnt
from (select t.*, row_number() over (partition by app_id order by cnt desc) as seqnum
      from (SELECT COMP_ID, APP_ID, count(*) as cnt
            FROM APP_ACCT_VIEW
            GROUP BY COMP_ID, APP_ID
           ) t
     ) t
where seqnum = 1

SELECT (case when count(*) = count(oran*deger)
             then SUM(oran*deger/100)
        end)
FROM @tablo;

select sector_id, count(distinct resort_id) as NumResorts,
       count(distinct country_id) as NumCountries
from resorts
group by sector_id;

SELECT name,
       (SELECT SUM(WarengruppeVK.netto)
        FROM Kunde
        JOIN PbsRow ON Kunde.PK = PbsRow.kunde
        JOIN WarengruppeVK ON PbsRow.PK = WarengruppeVK.pbsrow
        WHERE Kunde.admitarbeiter = Adm.PK
          AND PbsRow.jahr = 2012
       ) AS vj_netto,
       (SELECT SUM(PbsRow.sollfracht)
        FROM Kunde
        JOIN PbsRow ON Kunde.PK = PbsRow.kunde
        WHERE Kunde.admitarbeiter = Adm.PK
          AND PbsRow.jahr = 2012
       ) AS vj_sollfracht
       (SELECT SUM(WarengruppeVK.netto)
        FROM Kunde
        JOIN PbsRow ON Kunde.PK = PbsRow.kunde
        JOIN WarengruppeVK ON PbsRow.PK = WarengruppeVK.pbsrow
        WHERE Kunde.admitarbeiter = Adm.PK
          AND PbsRow.jahr = 2013
       ) AS j_netto,
       (SELECT SUM(PbsRow.sollfracht)
        FROM Kunde
        JOIN PbsRow ON Kunde.PK = PbsRow.kunde
        WHERE Kunde.admitarbeiter = Adm.PK
          AND PbsRow.jahr = 2013
       ) AS j_sollfracht
FROM Adm

tblPhone(Phone_Type_ID, Phone_Type_Name, Phone_Type_Min_Price, Phone_Type_Max_Price)

;WITH T AS 
(
SELECT *, 
       MAX(NULLIF(Column2,'')) OVER (PARTITION BY Column1) AS C2
FROM YourTable
)
UPDATE T
SET Column2 = C2
WHERE Column2 IS NULL OR Column2 = '';

DECLARE @docIds VARCHAR(MAX)

SELECT @docIds = STUFF((
    SELECT ',' + CONVERT(VARCHAR(50), docUid)
    FROM dbo.Document
    FOR XML PATH(''), TYPE).value('.', 'VARCHAR(MAX)'), 1, 1, '')

SELECT @docIds, LEN(@docIds)

select 'apples' as productName, count(*) from fruit where apples  = '1'
union
select 'oranges', count(*) from fruit where oranges = '1'
union
select 'kiwis', count(*) from fruit where kiwis   = '1'

CREATE TEMPORARY table IF NOT EXISTS tbl  
(   
    REF_REQ_ID int AUTO_INCREMENT PRIMARY KEY,
    FunctionalArea varchar(200),
    Industry varchar(200)
);

TRUNCATE TABLE tbl;

INSERT INTO tbl
SELECT 1, 'IT Jobs', 'IT related Jobs' UNION ALL
SELECT 2, 'HR Jobs', NULL UNION ALL
SELECT 3, NULL, 'HR related Jobs' UNION ALL
SELECT 4, NULL, 'IT related Jobs' UNION ALL
SELECT 5, NULL, NULL UNION ALL
SELECT 6, 'IT Jobs', 'IT related Jobs' UNION ALL
SELECT 7, 'HR Jobs', NULL UNION ALL
SELECT 8, NULL, 'HR related Jobs' UNION ALL
SELECT 9, 'HR Jobs', NULL;

CREATE TEMPORARY table IF NOT EXISTS tbl_industry
(   
    REF_REQ_ID int,
    Industry varchar(200)
);

TRUNCATE TABLE tbl_industry;

INSERT INTO tbl_industry
SELECT 
    REF_REQ_ID,
    Industry 
FROM tbl
WHERE Industry IS NOT NULL;


SELECT 
    JobTitle As JobTitle,
    COUNT(REF_REQ_ID) As NoOfJobs
FROM    
    (SELECT 
        FunctionalArea As JobTitle,
        REF_REQ_ID
    FROM tbl
    UNION 
    SELECT 
        Industry As JobTitle,
        REF_REQ_ID
    FROM tbl_industry)t
WHERE JobTitle IS NOT NULL
GROUP BY JobTitle
ORDER BY NoOfJobs desc

select * from oc_user , oc_groups ORDER BY gid, uidS

SELECT B.* 
FROM SO_total_days2 A
INNER JOIN SO_total_days2 B ON B.monthnumber = A.monthnumber + 360
WHERE A.from_date =  '2010-01-01'

from_date   to_date     days_in_month monthnumber
1980-01-01  1980-01-31  31    1
1980-02-01  1980-02-29  29    2
1980-03-03  1980-03-31  31    3
...
1981-01-01  1981-01-31  31    13
1981-12-01  1981-12-31  31    24
...
1985-01-01  1985-01-31  31    49
1985-12-01  1985-12-31  31    60

SELECT Col1, Col2, EventType, DateTime 
FROM theTable A
WHERE DateTime > 

(SELECT  MAX(DateTime)
FROM    theTable SUB
WHERE   EventType = 3
AND SUB.COL1 = A.COL1
AND SUB.COL2 = A.COL2)

SELECT TOP 1 * 
FROM tblHistory a
INNER JOIN 
   (SELECT Unit Number, Max([Date]) as MaxDate 
    FROM tblHistory
    GROUP BY Unit Number) b
on a.[Unit Number] = b.[Unit Number]
and a.[Date] = b.MaxDate

SELECT period, 'Truck' AS NameOfVehicle, Truck AS Value FROM vehicle
UNION ALL
SELECT period, 'Car', Car FROM vehicle
UNION ALL
SELECT period, 'Boat', Boat FROM vehicle

   $where = '';
    $sql= "SELECT  * FROM   maklumatakaun 
            LEFT JOIN detailakaun ON maklumatakaun.id = detailakaun.id 
            LEFT JOIN maklumatbilakaun ON maklumatakaun.NoAkaun = maklumatbilakaun.NoAkaun 
            LEFT JOIN kodjenisakaun ON detailakaun.KodJenisAkaun = kodjenisakaun.KodJenisAkaun
            LEFT JOIN kodlokasi ON detailakaun.KodLokasi = kodlokasi.KodLokasi
            LEFT JOIN kodkategori ON maklumatakaun.KodKategori = kodkategori.KodKategori        
            LEFT JOIN koddaerah ON maklumatakaun.KodDaerah = koddaerah.KodDaerah
            WHERE maklumatakaun.KodKategori = '$KodKategori' 
            AND detailakaun.KodJenisAkaun = '$KodJenisAkaun'
            AND maklumatbilakaun.BulanBil = '$BulanBil' 
            AND maklumatbilakaun.TahunBil ='$TahunBil' 
            ".mysql_real_escape_string($where)."
            GROUP BY maklumatakaun. NoAkaun ";



if($KodDaerah != 'all'){
  $where .= "AND maklumatakaun.KodDaerah = '$KodDaerah' "; //Add your where statement here
  //Whatever you want to do
}

WHERE LEVENSHTEIN(Field_A, Field_B) < 4;

AverageMarks: (CourseworkMarks+ExaminationMarks)/2

  SELECT t.category_id,
         MIN(t.date) AS first_date,
         CASE 
           WHEN MAX(t.date) = MIN(t.date) THEN NULL 
           ELSE MAX(t.date)
         END AS last_date
    FROM TABLE t
GROUP BY t.category_id, t.client_id

select rp.NameEN, rd.NameDefault,
       (select COUNT(NameEN)
        from [OTOP].[Custom].[tblRefProvince]
       ) as district
from [OTOP].[Custom].[tblRefProvince] rp inner join
     [OTOP].[Custom].[tblRefDistrict] rd
     on rp.ID = rd.ProvinceID;

obj = MyModel.objects.get(pk=1)
obj.pk = None
obj.save()

  SELECT * FROM booking 
  WHERE rid = '5' 
   AND active = '1'
   AND ('2010-10-01' BETWEEN datefrom AND dateto - INTERVAL 1 DAY 
    OR '2010-10-09' BETWEEN datefrom + INTERVAL 1 DAY AND dateto 
    OR datefrom BETWEEN '2010-10-01' AND '2010-10-09' - INTERVAL 1 DAY) 
   LIMIT 0 , 30

select t.*, cumepaid / cumeqty as avg_cost
from (select t.*,
             (select SUM(qty) from t t2 where t2.item_id = t.item_id and t2.purch_id <= t.purch_id
             ) as cumeqty,
             (select SUM(qty*unit_price) from t t2 where t2.item_id = t.item_id and t2.purch_id <= t.purch_id
             ) as cumepaid
      from t
     ) t

osql -Sdb -Uautosys -Pdata_load -ddms -Q"EXEC dbo.sp @start_time = '%mydate%' "

    Select a.Col1, a.Col2, b.Col1, b.Col2, c.Col1
    from [Table A] a
    inner join [Table C] c
        on c.key1= a.key1
    inner join [Table B] b
        on b.key1 = a.key1
    inner join [Table D] d
        ON  b.key3 = d.key1
    where c.key2 = 'static value' 
        and b.key2 = 'static value'
        and right(b.key4,1) in ('static value 1', 'static value 2')
        and substring(b.key4, 1, len(b.key4)-1) = c.key1
   group by a.Col1, a.Col2, b.Col1, b.Col2, c.Col1

INSERT INTO tags
('name', 'slug')
VALUES('Category X','category_x')
ON DUPLICATE KEY UPDATE
'slug' = 'category_x'

SELECT invited_by_id, COUNT(*) AS invited_count FROM table GROUP BY invited_by_id

select top 1 
  a, b, c, d 
from 
  Products 
where
  CodDep IN (10,12,12,13,26,27,32,34,248442,259741)
order by 
  LastUpdate

WITH    q AS
        (
        SELECT  startId, endId
        FROM    ranges
        UNION ALL
        SELECT  startId + 1, endId
        FROM    q
        WHERE   startId < endId
        )
SELECT  startId
FROM    q
OPTION  (MAXRECURSION 0)

<?php
    // copy your string of ids into this variable
    $input = "'123', '234r', '345', '456xyz'";
    // modify next line to get your desired filename
    $filename = 'insert.sql'
    // modify next line to your table name
    $insert_statement = "INSERT INTO your_table_name (id, status) VALUES \n" .
         '(' . implode(", 'discard')\n(", explode(', ', $input)) . ", 'discard');\n"; 
    file_put_contents($filename, $insert_statement);
?>  

UPDATE tblDocs
SET 
  Active = CASE WHEN DocLocation = 'something' THEN 1 ELSE 0 END,
  DocID = CASE WHEN DocLocation = 'something' THEN NULL ELSE DocID END

<cfoutput query="getEmpsByDept" group="Department">
  <cfset empCount = 0>
  <cfoutput>
    <cfset empCount++>
  </cfoutput>
  <tr>
    <td><b>#Ucase(getEmpsByDept.Department)# #empCount# Employees</b></td>
  </tr>
  <cfoutput>
    <tr>
      <td>&nbsp;&nbsp; #TRIM(getEmpsByDept.First)#&nbsp;#TRIM(getEmpsByDept.Last)#</td>
    </tr>
  </cfoutput> 
  <tr>
    <td height="0">&nbsp;</td>
  </tr>
</cfoutput>

select t1.*, t2.* from t1 
 left outer join t2 on t2.id=t1.id 
WHERE flag = 1 OR t2.id IS NOT NULL

create table business (
  id int not null auto_increment primary key,
  name varchar(255)
);

create table open_hour_range (
  id int not null auto_increment primary key,
  business_id int,
  day_of_week tinyint, /* 0-6 */
  open_time time,
  close_time time,
  foreign key(business_id) references business(id)
);

CREATE OR REPLACE PROCEDURE PROC_CREATE_ROLES IS
BEGIN
  EXECUTE IMMEDIATE 'CREATE ROLE ADMIN_STAFF';

  EXECUTE IMMEDIATE 'GRANT SELECT ON BLAH TO ADMIN_STAFF';
  EXECUTE IMMEDIATE 'GRANT SELECT, UPDATE ON BLORT TO ADMIN_STAFF';
  EXECUTE IMMEDIATE 'GRANT SELECT, INSERT, UPDATE ON YADA TO ADMIN_STAFF';

  EXECUTE IMMEDIATE 'GRANT ADMIN_STAFF TO USER1, USER2, USER3';
END PROC_CREATE_ROLES;

SELECT SUM(SALES_AMOUNT)SALES,
YEAR,
MONTH,
CATAGORY_ID,
TO_CHAR(SALES_PERSON_ID) SALES_PERSON_ID,
ITEM_TYPE_ID
FROM APEX_FINAL
    where sales_amount is not null
     and catagory_id is not null
GROUP BY (YEAR,MONTH,CATAGORY_ID,SALES_PERSON_ID,ITEM_TYPE_ID)

union all

SELECT SUM(SALES_AMOUNT)SALES,
YEAR,
MONTH,
CATAGORY_ID,
'all others' SALES_PERSON_ID,
ITEM_TYPE_ID
FROM APEX_FINAL
    where sales_amount is not null
    and sales_person_id is null 
GROUP BY (YEAR,MONTH,CATAGORY_ID,SALES_PERSON_ID,ITEM_TYPE_ID)

SELECT      [group], [code] , COUNT(1) as CNT
FROM        YourTableName
GROUP BY    [group], [code] 
HAVING      COUNT(1) > 1
ORDER BY CNT;

SET [File] = cast(b.Header as text) + CHAR(13) + CHAR(10) + d.Detail + c.Trailer + CHAR(13) + CHAR(10) + CHAR(26)

Select *
From table
Where (@Column = 'name' and name is null) or
      (@Column = 'surname' and surname is null) or
      (@Column = 'name and surname' and surname is null and name is null)

CREATE TABLE my_table (
    col1 VARCHAR(10),
    col2 VARCHAR(20),
    expiration_date DATE,
    is_expired AS CASE WHEN expiration_date > GETDATE() THEN 1 ELSE 0 END
);

>>ssh user@your_website.com
>>Enter password: your_password
>>mysqldump -u [uname] -p[pass] [dbname] > [backupfile.sql]    

select group_concat(lev0) from 
(select concat_ws(',',lev2,group_concat(lev3)) as lev0 from 
(SELECT  t2.id as lev2, 
t3.id as lev3, 
t4.id as lev4
FROM menus AS t1
LEFT JOIN menus AS t2 ON t2.parent_id = t1.id
LEFT JOIN menus AS t3 ON t3.parent_id = t2.id
LEFT JOIN menus AS t4 ON t4.parent_id = t3.id
WHERE t1.id = '2') t0 group by lev2) t;

string createSql = "CREATE VIRTUAL TABLE TweetFts USING FTS3(TweetId, Title, Description)";

string insertSql = "INSERT INTO TweetFts (TweetId, Title, Description) 
     SELECT TweetId, Title, Description FROM Tweet";

string sql = @"select TweetId from TweetFts where Title match '" + allWords + "'";
sql += " union ";
sql += @"select TweetId from TweetFts where Description match '" + allWords + "'";
sql += " union ";
sql += @"select TweetId from TweetFts where Title match '""" + exactMatch + @"""'";
sql += " union ";
sql += @"select TweetId from TweetFts where Description match '""" + exactMatch + @"""'";

SET HEADING OFF
SET PAGESIZE 0
SET LONG 90000
SET FEEDBACK OFF
SET ECHO OFF
SPOOL P:\other\file_name.sql

SELECT DBMS_METADATA.get_ddl ('TABLE', table_name) || ';' FROM user_tables;

SPOOL OFF

SELECT InitCap( your_column )
  FROM your_table

CREATE QUEUE ExpenseQueue
    WITH STATUS=ON,
    ACTIVATION (
        PROCEDURE_NAME = expense_procedure,
        MAX_QUEUE_READERS = 5,
        EXECUTE AS 'ExpenseUser' ) ;

SELECT * FROM TABLE WHERE FIELD LIKE '%&%'

EXECUTE msdb.dbo.sysmail_delete_account_sp
EXECUTE msdb.dbo.sysmail_delete_profile_sp

EXECUTE msdb.dbo.sysmail_add_account_sp
EXECUTE msdb.dbo.sysmail_add_profile_sp
EXECUTE msdb.dbo.sysmail_add_profileaccount_sp

using (SqlConnection conn = new SqlConnection(@"Persist Security Info=False;Integrated Security=true;Initial Catalog=myTestDb;server=(local)"))
{
    SqlCommand addvalues = new SqlCommand(@"INSERT INTO customer (id,name,age,occupation) VALUES (@id,@name,@age,@occupation)", conn);
    addvalues.Parameters.AddWithValue("@bla", "bla");
    addvalues.Connection.Open();
    addvalues.ExecuteNonQuery();
    addvalues.Connection.Close();
}

SELECT t.PhoneNumber1, t.PhoneNumber2, 
   t1.SomeOtherFieldForPhone1, t2.someOtherFieldForPhone2
FROM Table1 t
JOIN Table2 t1 ON t1.PhoneNumber = t.PhoneNumber1
JOIN Table2 t2 ON t2.PhoneNumber = t.PhoneNumber2

     ALTER TRIGGER [dbo].[tid2]
     ON [dbo].[tblPrac2]
     AFTER INSERT
     AS
     declare @nid int;

     set @nid = ( select MAX(TicketID) from [tblPrac2] );

     if(@nid is null)
     begin
         set @nid = 1;
     end
     else
         set @nid = @nid + 1;

update tblPrac2 set TicketID = @nid where ID in (select ID from inserted)

select  cake
from    caketable c
where   not exists
        (
        select  *
        from    icingtable i
        where   i.cake = c.cake
                and i.consumed = '1'
        )
        and not exists
        (
        select  *
        from    sprinkletable s
        where   s.cake = c.cake
                and s.consumed = '1'
        )

DELETE From test WHERE Col1 IN(
SELECT Col1 FROM test 
GROUP BY Col1
HAVING COUNT(1) > 1)
AND Col2 = '1'

CREATE TABLE `swap_test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `x` varchar(255) DEFAULT NULL,
  `y` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

INSERT INTO `swap_test` VALUES ('1', 'a', '10');
INSERT INTO `swap_test` VALUES ('2', NULL, '20');
INSERT INTO `swap_test` VALUES ('3', 'c', NULL);

SELECT PersonID,    
       DateKey,
       [C/L],
       [C/L_New] = ISNULL([C/L], (SELECT TOP 1 t2.[C/L]
                                  FROM dbo.TableName t2
                                  WHERE t2.PersonID = t.PersonID
                                  AND   t2.DateKey <= t.DateKey
                                  AND   t2.[C/L] IS NOT NULL
                                  ORDER BY DateKey DESC))
FROM dbo.TableName t
Order By PersonID, DateKey

SELECT
   i1.id AS id1,
   NULL AS id2,
   NULL AS id3,
   i1.amount
FROM
   items i1
UNION ALL
SELECT
   i1.id AS id1,
   i2.id AS id2,
   i3.id AS id3,
   i1.amount + i2.amount AS total
FROM
   items i1,
   items i2
WHERE
   i1.amount + i2.amount = 30 AND
   i1.id <> i2.id AND
   i1.id <> i3.id
UNION ALL
SELECT
   i1.id AS id1,
   i2.id AS id2,
   i3.id AS id3,
   i1.amount + i2.amount + i3.amount AS total
FROM
   items i1,
   items i2,
   items i3
WHERE
   i1.amount + i2.amount + i3.amount = 30 AND
   i1.id <> i2.id AND
   i1.id <> i3.id AND
   i2.id <> i3.id

SELECT D.ID 
FROM Data D
WHERE  NOT EXISTS(SELECT 1 
                  FROM Data WHERE D.ID = CXL)

insert into master.schema.employee (id, name)
select case when id = 1 then 201 else id end, name
from northwind.schema.employee

SELECT  [author]
        ,[pubDate]
        ,MAX([dateadded])
 FROM   [Feeds].[dbo].[socialPosts]
 WHERE  CAST(FLOOR(CAST(dateadded AS float)) AS datetime) >  dateadd(day,datediff(day, 0, getdate()-2), 0)  
        AND CAST(FLOOR(CAST(dateadded AS float)) AS datetime) < dateadd(day,datediff(day, 0, getDate()), 0)
 GROUP BY 
        [author]
        , [pubdate]

SELECT Table1.Numbers, Table1.Name
FROM Table1 
WHERE NOT EXISTS(
    SELECT 1 FROM Table2 
    WHERE Table1.Numbers=Table2.Numbers
)

SELECT CourseCode FROM Course WHERE CourseName='?'

UNION ALL

SELECT 'Not Applicable'
WHERE NOT EXISTS (
    SELECT CourseCode FROM Course WHERE CourseName='?'
)

SELECT employees.eno, employees.ename, SUM(parts.price * odetails.qty) as TotalSales
FROM test.employees
INNER JOIN test.orders
ON empoyee.eno = orders.eno
INNER JOIN test.odetails
ON orders.ono = odetails.ono
INNER JOIN test.parts
ON odetails.pno = parts.pno
GROUP BY employees.eno, employees.ename

SELECT TB_USER.ID, TB_QUESTION.ID AS "Q_ID" FROM TB_USER, TB_QUESTION
minus
SELECT ID_USER, ID_QUESTION FROM tb_answer

SELECT *
FROM mytable
WHERE left(Telephone,3) = '765'

SELECT ID, CASE WHEN nvl(doc_after,'') <> '' THEN doc_after ELSE doc_before END AS doc
, CASE WHEN nvl(doc_after) <> '' THEN 'doc_after' ELSE 'doc_before' END AS camefrom
FROM yourtable

insert into my_table
select
   --<number of columns you want
   -- use dbms_random if you would like> 
from
   dba_objects a,
   dba_objects b
where
   rownum<=20000;

sql_query = "<prefix>"
sql_query += "?, " * 69
sql_query += "?)<suffix>"

CREATE OR REPLACE FUNCTION f_x (p_id IN NUMBER) RETURN BOOLEAN IS
BEGIN
   RETURN TRUE;
END f_x;

CREATE OR REPLACE PROCEDURE p_x (i_id IN NUMBER, o_val OUT BOOLEAN) IS
BEGIN
  o_val := f_x(i_id);
END p_x;

select coalesce(t1.day, t2.day) "day",
  coalesce(t1.acount, 0) acount,
  coalesce(t2.bcount, 0) bcount
from table1 t1
full outer join table2 t2
  on t1.day = t2.day;

SELECT [SIGNAL NAME], CAST(SAMPLETIME AS DATE) AS SAMPLEDATE, MAX(VALUE)-MIN(VALUE) As Diff_Value
FROM Table1
GROUP BY CAST(SAMPLETIME AS DATE),[SIGNAL NAME]

  SELECT 42 AS [@tag],
         (SELECT content AS [*]  FROM #test T FOR XML PATH(''), TYPE) AS [*]
 FOR XML PATH('root')

select a.*,b.MedianWeight,c.MedianLength from (
    SELECT speciesID, min(catchLength) MinLength, max(catchLength) MaxLength, avg(catchLength) AvegrageLength, isnull(STDEV(catchLength),0) StDevLength
    , min(catchWeight) MinWeight, max(catchWeight) MaxWeight, avg(catchWeight) AvegrageWeight, isnull(STDEV(catchWeight),0) StDevWeight
    from  #Catchestemp c
    group by speciesID
) a
join (
    select speciesID, avg(catchWeight) MedianWeight from (
        select speciesID,
            catchWeight,
            ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchWeight ASC, id ASC) AS RowAsc,
            ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchWeight DESC, id DESC) AS RowDesc
        from #Catchestemp
    ) x
    WHERE RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1)
    group by speciesID
) b on a.speciesID = b.speciesID
join (
    select speciesID, avg(catchLength) MedianLength from (
        select speciesID,
            catchLength,
            ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchLength ASC, id ASC) AS RowAsc,
            ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchLength DESC, id DESC) AS RowDesc
        from #Catchestemp
    ) x
    WHERE RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1)
    group by speciesID
) c on a.speciesID = c.speciesID

SELECT column0, column2, table.column1, columncount
FROM table 
    INNER JOIN (SELECT column1, COUNT(column1) columncount
                FROM table
                WHERE column1> 0
                GROUP BY column1 HAVING COUNT(column1) > 1) t2 ON table.column1 = t2.column1

SELECT  CustomerID
FROM    Customers AS C
WHERE   EXISTS ( SELECT 1 -- no need for a columns list since you only check for existance
    FROM (SELECT TOP 12 DueDate, PaymentDate -- no need for all the columns, only the ones you use
          FROM      Payments as P
          WHERE     P.CustomerID = C.CustomerID
          ORDER BY PaymentDate
         ) AS First12Payments
        WHERE  DATEDIFF(MONTH, First12Payments.DueDate, First12Payments.PaymentDate) > 3 

--Declare UserId and CpyId
declare @UserId int = 100001
declare @CpyID int = 1;

--Select all possible results and rank
WITH subryUnion 
AS (

--Select hits by CpyId, Rank 1
SELECT *, 
    1 AS Ranking,
    'Hit by CpyId' Descr
FROM tbl_Entity_Column_Details
WHERE CpyId = @CpyId

UNION ALL

--Select hits by User_Id, Rank 2
SELECT *, 
    2 AS Ranking,
    'Hit by User_Id' Descr
FROM tbl_Entity_Column_Details
WHERE User_Id = @UserId

UNION ALL

--Select no hits by CpyID or User_Id, Rank 3
SELECT *,
    3 AS Ranking,
    'Not hit by CpyId or User_Id' Descr
FROM tbl_Entity_Column_Details
WHERE COALESCE(CpyId,User_Id) IS NULL

)

SELECT *
FROM subryUnion
--Show only the minimum ranked results
WHERE Ranking = (SELECT MIN(Ranking) FROM subryUnion)

select LTRIM(RTRIM(FIELD_ONE)) + LTRIM(RTRIM(FIELD_TWO)) + LTRIM(RTRIM(FIELD_THREE))
FROM copyfrom

convert(datetime,'24/05/2012 09:56:06',103)

ORDER BY `products`.`product_category_id` DESC ,`naam` ASC

GROUP BY GROUPING SETS ((o.VendorNo, LEFT(HVI.EncodeData, 3), pto.PrintBatch, pto.PickBit),
                        (o.VendorNo, LEFT(HVI.EncodeData, 3)),
                        (o.VendorNo)
                       )

SELECT *, GROUP_CONCAT(item_category) AS item_categories
FROM (`dev_pages`)
LEFT JOIN `dev_items_to_categories` ON `dev_items_to_categories`.`item_id` = `dev_pages`.`page_id` AND `item_category` =  '16'
WHERE deleted_time IS NULL
AND `page_type` =  'blog'
GROUP BY dev_pages.page_id
ORDER BY `page_title` ASC

select t1.vm_name, 
       t2.object_id as vm_id,
       t1.host_name,
       t3.object_id as host_id
from table1 t1
       join table2 t2 on t1.vm_name = t2.object_name
       join table2 t3 on t1.host_name = t3.object_name
order by t1.vm_name

select departmentname,
  [1] status1,
  [2] status2,
  [3] status3
from
(
  select d.departmentname, e.empid, e.workstatus
  from dbo.department d
  left join dbo.employee e
    on d.deptid = e.deptid
) d
pivot
(
  count(empid)
  for workstatus in ([1],[2],[3])
) piv;

select client_ID, status_id, from_date, to_date, 
       sum(start_of_group) over (order by client_ID, from_date) + 1 rank
  from (SELECT c.client_ID, c.status_id, c.from_date, c.to_date,
               case when lag(c.client_ID, 1, c.client_ID) over (order by c.client_ID, c.from_date) = c.client_ID 
                     and lag(c.status_id, 1, c.status_id) over (order by c.client_ID, c.from_date) = c.status_id
                    then 0 else 1 end start_of_group
          FROM client c)
 order by client_ID, from_date

SQL> SET SERVEROUTPUT ON
SQL> DECLARE
  2    TYPE t_tab IS TABLE OF NUMBER;
  3    l_tab1 t_tab := t_tab(1,1,3,3,5,5);
  4  BEGIN
  5    l_tab1 := l_tab1 MULTISET INTERSECT DISTINCT l_tab1;
  6    FOR i IN l_tab1.first .. l_tab1.last
  7    LOOP
  8      DBMS_OUTPUT.put_line('Distinct values are '||l_tab1(i));
  9    END LOOP;
 10  END;
 11  /
Distinct values are 1
Distinct values are 3
Distinct values are 5

PL/SQL procedure successfully completed.

ALTER TRIGGER [ATrigger] ON [dbo].[A]
FOR INSERT, UPDATE, DELETE
AS
   -- those are true INSERTs - the (ID) as primary key is *not* present in the "Deleted" table
   INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus])
      SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'N', getDate(), 0
      FROM inserted 
      WHERE (id) NOT IN (SELECT DISTINCT (id) FROM DELETED)

   -- those are true DELETEs - the (ID) as primary key is *not* present in the "Inserted" table
   INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus])
      SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'Y', getDate(), 0
      FROM deleted
      WHERE (id) NOT IN (SELECT DISTINCT (id) FROM INSERTED)

   -- those are the UPDATEs - the (ID) as primary key is present in both the "Inserted" and "Deleted" table
   INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus])
      SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'N', getDate(), 0
      FROM Inserted i
      INNER JOIN Deleted d on i.ID = d.ID

SELECT username, loginstart, loginend, SUM(data1) as TotData1, SUM(data2) as TotData2, SUM(data3) as TotData3
FROM YourTable
GROUP BY username, loginstart, loginend

SELECT o1.object_name, r1.object_name, o2.object_name
FROM   edge e
JOIN   object o1 ON o1.id = e.arg1
JOIN   object  r ON  r.id = e.relation
JOIN   object o2 ON o2.id = e.arg2;

SQL> select regexp_replace('éaéABcdEF', '([a-zA-Z])', '' ) problems from dual;

PROBLEMS
--------
éé

$mresult = mysql_query("
  SELECT * FROM books 
  WHERE GoodName LIKE '%$title%' AND GroupCode IN (" . implode(",", $array_of_cat) . ")");

Update  lm_Artikel A 
        INNER JOIN  lm_Schwellwert S 
            ON A.Typ = S.Typ  
SET     A.Status = 'NOK'
WHERE   A.Bestand < S.Schwellwert 

WITH CTE AS
( 
   SELECT
       ROW_NUMBER() OVER (PARTITION BY ID  ORDER BY Seq DESC) AS RN
       , ID, Age
   FROM 
       Persons
)
SELECT ID, Age 
FROM CTE
WHERE RN = 1

select id,b,c from tablename 
inner join
(
select id, count(A) as CountDuplicates
from TableName as base group by A,id having (count(A) > 1) 
)d on tablename.id= d.id

SELECT [Origin], [Destination], 
       (ABS(SUM(CASE WHEN [DeliveryWeek] = 2 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 1 THEN 1 ELSE 0 END)) +
        ABS(SUM(CASE WHEN [DeliveryWeek] = 3 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 2 THEN 1 ELSE 0 END)) +
        ABS(SUM(CASE WHEN [DeliveryWeek] = 4 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 3 THEN 1 ELSE 0 END))
       ) / 3

CREATE INDEX email_index ON emaildata(emailaddress) USING BTREE;

SELECT *
FROM
(
    SELECT  RIC.CarrierName,
            L.LoadGuid,
            RIC.RateIQCarrierid,
            RIRD.Cost,
            --Partition says look at each carrier as a group, then number them in order of cost lowest to highest.
            ROW_NUMBER() OVER (PARTITION BY RIC.CarrierName ORDER BY Cost) rank_num
    FROM tblLoads L 
    INNER JOIN  RateIQRecord RIR 
                ON L.LoadGuid = RIR.LoadGuId 
    INNER JOIN  RateIQCarrier RIC 
                ON RIR.RateIQRecordID = RIC.RateIQRecordID
    INNER JOIN  RateIQRateDetail RIRD 
                ON RIC.RateIQRecordID = RIRD.RateIQRecordID

                --Don't do it this way
                --AND CAST(L.CreatedDate AS Datetime)  Between '03/3/2014' and '03/3/2014 23:59:59.997'

                --Try this instead
                AND CAST(L.CreatedDate AS DATE) = '03/03/2014'
) A
--Only grab the lowest number aka first of row number
WHERE A.rank_num = 1

create procedure dbo.test

as

begin 

create table #temp (
name varchar(100) ,
id int
)

insert #temp
select name ,
       id 
from master..sysobjects

update #temp

set name='ALL Same'

from #temp

select * from #temp

drop table #temp

end
go

Select Y.S - X.S As Sum from
(select sum(qteMv) S from mouventDeStock where typemv=1 and codemv = 'ART_18') Y,
(select sum(qteMv) S from mouventDeStock where typemv=0 and codemv = 'ART_18') X;

select *
from gpaTable
where gpa in (
  select distinct gpa
  from gpaTable
  order by gpa desc
  limit 2
)

UPDATE contents c 
JOIN (
  SELECT what, AVG(rating) rating, COUNT(rating) ratingsCount
  FROM ratings WHERE what = ? GROUP BY what
) r
  ON c.id = r.what
SET c.rating = r.rating, c.ratingsCount = r.ratingsCount

SELECT p.p1, p.p2
FROM Likes p
    INNER JOIN Likes p2 ON 
        p.p1=p2.p2 AND 
        p.p2=p2.p1 AND 
        p.p1<p2.p1

create table yourtable(RowID int, Layout varchar(200))
INSERT yourtable VALUES (1,'hello,world,welcome,to,tsql')
INSERT yourtable VALUES (2,'welcome,to,stackoverflow')


;WITH SplitSting AS
(
    SELECT
        RowID,LEFT(Layout,CHARINDEX(',',Layout)-1) AS Part
            ,RIGHT(Layout,LEN(Layout)-CHARINDEX(',',Layout)) AS Remainder
        FROM YourTable
        WHERE Layout IS NOT NULL AND CHARINDEX(',',Layout)>0
    UNION ALL
    SELECT
        RowID,LEFT(Remainder,CHARINDEX(',',Remainder)-1)
            ,RIGHT(Remainder,LEN(Remainder)-CHARINDEX(',',Remainder))
        FROM SplitSting
        WHERE Remainder IS NOT NULL AND CHARINDEX(',',Remainder)>0
    UNION ALL
    SELECT
        RowID,Remainder,null
        FROM SplitSting
        WHERE Remainder IS NOT NULL AND CHARINDEX(',',Remainder)=0
)
SELECT part FROM SplitSting ORDER BY RowID

select date, 
       price,
       @total := @total + price as total
from (select date, price
      from your_table
      order by date) x
CROSS JOIN (select @total := 0) r

SELECT * FROM table WHERE 10 = ANY (values);

INSERT INTO gender
(sex, date) VALUES (
'male are allowed \\ female are not allowed',
"2012-10-06")

select SrNo,Name, Amount , 
case when ApplyTax = 'Yes' then Amount*0.20
else 0
end as Tax
from tablename  

CREATE VIEW myOrderedTable
AS
SELECT ID, ClientID, Designation, Contact, Tag, Email
FROM tableName;

update table t join
       (select s.*, @rn := @rn + 1 as FakeServerNumber, NumServers
        from servers s cross join
             (select count(*) as NumServers, @rn := -1
              from servers
              where isup = 'isup'
             ) const
        where s.isup = 'isup'
       ) s 
       on t.primary_key % s.NumServer = s.rn
    set t.server_id = s.server_id
    where t.server_id is null;

CREATE NONCLUSTERED INDEX <index name> ON _T_VENTAS_DIARIAS (Año, Semana, Dia_Calendario);

SELECT
    XMLELEMENT ("MAIN_TAG", XMLAGG (XMLCONCAT (l_head_xml, l_pos_xml)))
    INTO l_complete_xml
FROM
    (SELECT DUMMY FROM DUAL CONNECT BY LEVEL <= 2);

data data;
input name1 $ c1 c2 c3;
datalines4;
a 1 2 3
a 1 2 3
b 1 2 3
b 1 2 3
;;;;
run;

%macro test(k=);
  PROC SQL;
   CREATE TABLE WORK.data1 AS 
   SELECT t1.name1 

%do i=1 %to &k.;
   , SUM(C&i.) AS C&i.
%END;

  FROM WORK.data t1
  GROUP BY t1.name1;
QUIT;

%mend test;
%test(k=3);

SELECT 
  c.month,
  coalesce(a.mycount,0),
  coalesce(b.totalPhones,0),
  coalesce(b.newphones,0)
FROM
  (SELECT monthStart as month FROM TestGB
   UNION
   SELECT monthEnd as month FROM TestGB) c 
LEFT OUTER JOIN 
  (SELECT
   monthStart as month,
   count(distinct obild) as mycount,
   from TestGB
   group by monthStart) a on a.month = c.month
LEFT OUTER JOIN 
  (SELECT
   monthStart as month,
   sum(newPhones) as newPhones,
   sum(totalPhones) as totalPhones
   from TestGB
   group by monthEnd) b ON b.month = c.month

SELECT row1,
       row2, 
       string_agg(row3, ',') as row3
FROM your_table
GROUP BY row1,
         row2

UPDATE <table>
SET PRICE = IIF([TYPE] IN ("A1","A3", "A4"); [Price]*1,05; [Price]*1,065)

SELECT t1.number
FROM t1
INNER JOIN t2
ON t1.number = t2.number

SELECT ... FROM tickets t
INNER JOIN ticket_text_fields f ON t.id=f.ticket_id
WHERE f.textfield_id IN (7, 8, 9, ...)
UNION ALL
SELECT ... FROM tickets t
INNER JOIN ticket_date_fields d ON t.id=d.ticket_id
WHERE d.datafield_id IN (434, 435, 436, ...)

SELECT *
FROM table1
INNER JOIN table2 ...
INNER JOIN table3 ...
INNER JOIN table4 ...
WHERE NOT ( ( table1.Value IS NULL) AND 
            ( table2.Value IS NULL) AND
            ( table3.Value IS NULL) AND
            ( table4.Value IS NULL)
          )

with recursive tree (userid, siblingid) as
(
   select userid, 
          siblingid
   from users
   where userId = 1
   union all 
   select c.userid,
          c.siblingid
   from users c
     join tree p on p.userid c.siblingId
)
select *
from tree;

declare
    v_columns varchar2(255);
    v_select varchar2(2000);
    v_result sys_refcursor;
begin

    v_columns := 'rownum';

    IF p_plant_cd = 1 THEN
       v_columns := v_columns || ',p_plant_cd';
    END IF;

    IF p_global_duns_nbr = 1 THEN
       v_columns := v_columns || ',p_global_duns_nbr';
    END IF;

    IF p_global_duns_nbr = 1 THEN
       v_columns := v_columns || ',p_global_duns_nbr';
    END IF;

        IF p_matrl_grp = 1 THEN
       v_columns := v_columns || ',p_matrl_grp';
    END IF;

    IF p_mrp = 1 THEN
       v_columns := v_columns || ',p_mrp';
    END IF; 



    v_select := 'SELECT ' || v_columns || ' FROM table';

    open v_result for v_select;




end;

;WITH top_cte AS
(
  SELECT *, ROW_NUMBER() OVER(PARTITION BY Company ORDER BY Revenue DESC) AS [Rank]
  FROM table
)
SELECT *
FROM top_cte
WHERE [Rank] <= 6

select 
   count(eo.equal_opps_id) as 'Age 40 - 49' 
  ,DateAdd(yy,-49,getDate()) as LesserDate
  ,DateAdd(yy,-39,getDate()) as GreaterDate
from 
  dbo.app_equal_opps eo, dbo.app_status s 
where 
  eo.date_of_birth > DateAdd(yy,-49,getDate()) 
  and eo.date_of_birth < DateAdd(yy,-39,getDate()) 
  and eo.application_id = s.status_id 
  and s.job_reference_number = '33211016' 
  and s.submitted = 1 

SELECT name 
  FROM sqlite_master
 WHERE type = 'table'
   AND name LIKE '%your_table_name%'

SELECT [PostingID]
      ,[EmployerID]
      ,[JobTitle]                  
      ,MIN(pin.[IndustryID])         
FROM [Posting] p
INNER JOIN [City] c
  ON p.CityID = c.CityID
LEFT OUTER JOIN PostingIndustry pin
  ON p.PostingID = pin.PostingID
WHERE (c.CityID = @CityId OR @CityId IS NULL) 
  AND (p.StateProvinceID = @StateProvinceId OR @StateProvinceId IS NULL) 
  AND (pin.IndustryID = @IndustryId OR @IndustryId IS NULL) 
  AND 
  (
     (p.[Description] LIKE '%' + @Keyword + '%' OR @Keyword IS NULL) 
     OR (p.[JobTitle] LIKE '%' + @Keyword + '%'  OR @Keyword IS NULL)
  ) 
  AND p.StreetAddress IS NOT NULL 
  AND p.ShowOnMap = 1
GROUP BY [PostingID],[EmployerID],[JobTitle] 

select p.firstname, p.lastname, 
   p.location, p.uid, 
   case when f.A is null then 1
   else 2
       end as type
from profile as p
left join favorites as f
 on p.uid = f.B and f.A = 'myid'
where p.firstname like 'mich%' or p.lastname like 'mich%'

select customers.ssn, certs.cert_num, certs.cert_start, certs.cert_finish
from customers INNER JOIN
     certs
     ON certs.ssn = customers.ssn
group by customers.ssn
having sum(case when certs.cert_finish < Date_ADD(now(), INTERVAL 14 DAY) and 
                     certs.cert_finish > now()
                then 1 else 0
           end) > 0 and  -- has soon to expire certicate
       sum(case when certs.cert_finish > Date_ADD(now(), INTERVAL 14 DAY)
                then 1 else 0
           end) = 0      -- has no certificate that will expire later

 SELECT 
    di.DocName as DocumentName, 
    di.Uploadfile as FileUploaded, 
    d.DepType as Department, 
    di.UploadedBy as UploadedBy, 
    at.ApproveType as Status,
    u.Email as UserEmail
FROM dbo.DocumentInfo di 
       INNER JOIN dbo.Approval a 
       ON di.DocID = a.DocID 
       INNER JOIN dbo.ApproveType at
       ON a.ApproveID =  at.ApproveID 
       INNER JOIN dbo.Userss u
       ON u.UserId = di.UserId 
       INNER JOIN dbo.Department d 
       ON di.DepID = d.DepID
       INNER JOIN dbo.DocType  dct
       ON di.DocTypeID = dct.DocTypeID
where di.DepID= @DepID

Use [MyDatabase]
GO

UPDATE PEOPLE
  SET ID_STATE = 5
WHERE ID_STATE IN (SELECT ID_STATE FROM STATE_PEOPLE
                   WHERE labelStatePeople = 'strange'
                    and ID_STATE IS NOT NULL)

SELECT STUDENT_ID, BOOK_TITLE, TERM
  FROM ASSIGNMENTS
  WHERE STUDENT_ID IN
   (SELECT DISTINCT STUDENT_ID FROM ASSIGNMENTS WHERE TERM = 2012)
  ORDER BY STUDENT_ID, TERM DESC

DECLARE @ParentID INT = 1

DECLARE @Widgets AS XML = 
N'<Widgets>
    <Widget>
        <WidgetID />
        <StartDate />
        <EndDate />
        <Details>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>4</SomeID>             
                <SomeData/>
            </WidgetDetailItem>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>323</SomeID>             
                <SomeData/>
            </WidgetDetailItem>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>1</SomeID>            
                <SomeData/>
            </WidgetDetailItem>
        </Details>
    </Widget>
    <Widget>
        <WidgetID>10</WidgetID>
        <StartDate>January 1, 2015</StartDate>
        <EndDate />
        <Details>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>4</SomeID>         
                <SomeData/>
            </WidgetDetailItem>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>99</SomeID>         
                <SomeData/>
            </WidgetDetailItem>
            <WidgetDetailItem>
                <WidgetDetailItemID></WidgetDetailItemID>
                <WidgetID/>
                <SomeID>6</SomeID>            
                <SomeData/>
            </WidgetDetailItem>
        </Details>
    </Widget>
</Widgets>';

--Used to hold the pseudoID -> WidgetID relationship for inserting the details
DECLARE @WidgetIds AS TABLE ([Action] varchar(10), PseudoID INT, WidgetID INT);

; 
--Use a CTE of the subset of data to be more performant. If we just went straight to the 
--merge we'd be operating on the entire table and that can have some major performance hits
WITH T AS (
              SELECT 
                     w.* 
              FROM
                     [dbo].[Widget] as w 
              WHERE
                     w.[ParentID] = @ParentID
)
MERGE INTO T 
USING (
        SELECT
            --Generate a pseudoid based on the order of the Widget elements so that we have some way of 
            --linking the detail records to the master
            row_number() OVER(ORDER BY PROPERTYFEED.P) PseudoID,
            'WidgetID' = P.value('WidgetID[1]', 'INT'),
            'ParentID' = @ParentID,
            'StartDate' = P.value('StartDate[1]', 'DATETIME'),
            'EndDate' = P.value('EndDate[1]', 'DATETIME')
        FROM
            @Widgets.nodes('/Widgets/Widget') PROPERTYFEED(P)
    ) 
    AS xmlIn
    (
           [PseudoID],
        [WidgetID],
        [ParentID],
        [StartDate],
        [EndDate]
    )
    ON
        T.[WidgetID] = xmlIn.[WidgetID]
    WHEN
        NOT MATCHED
    THEN
        INSERT 
        (
            [ParentID],
            [StartDate],
            [EndDate]
        ) 
        VALUES
        (
            xmlIn.[ParentID],
            xmlIn.[StartDate],
            xmlIn.[EndDate]
        )
    WHEN
        MATCHED AND (
            (T.[StartDate] <> xmlIn.[StartDate]) OR 
            (T.[EndDate] <> xmlIn.[EndDate]))
    THEN
        UPDATE SET
            T.[StartDate] = xmlIn.[StartDate],
            T.[EndDate] = xmlIn.[EndDate]
    WHEN
        NOT MATCHED BY SOURCE AND T.[DeletedDate] IS NULL 
    THEN
        UPDATE SET
            T.[DeletedDate] = GETDATE()         
OUTPUT  $action, xmlIn.PseudoID, INSERTED.WidgetID INTO @WidgetIds

;

--This is some magic to generate a temp table of numbers from 1 to COUNT(Widget)
--This is so we can reference the parent Widget row in the same order as the pseudoid generated above
--http://stackoverflow.com/a/1134379/4375845
;WITH Total(TotalWidgets) AS (SELECT COUNT(1) TotalWidgets FROM @Widgets.nodes('/Widgets/Widget') PROPERTYFEED(P))
       , Numbers(Num) as (
              SELECT 1 AS Num
              UNION ALL 
              SELECT Num+1 
              FROM Numbers
              JOIN Total t ON 1 = 1
              WHERE Num < t.TotalWidgets )
INSERT INTO WidgetDetailItem (WidgetID,SomeID,SomeData)
SELECT 
       w.WidgetID
       ,Details.SomeID
       ,Details.SomeData
FROM 
    (SELECT 
        P.value('WidgetDetailItemID[1]','int')  WidgetDetailItemID           
        , P.value('SomeID[1]','int') SomeID
        , P.value('SomeData[1]','varchar(5)') SomeData
        , n.Num AS PsuedoID
    FROM Numbers n
    --This is what gives us our pseudo ID to link to the row_number() function from the first merge statement
    CROSS APPLY @Widgets.nodes('/Widgets/Widget[sql:column("n.Num")]/Details/WidgetDetailItem') AS M(P)
    ) Details
JOIN @WidgetIds w on Details.PsuedoID = w.PseudoID
WHERE w.Action = 'INSERT' --We only want inserts by your spec

SELECT * FROM Widget;
SELECT * FROM WidgetDetailItem;

    SELECT i.investment_type as investmentType,COUNT(*) as investmentCount FROM investment i,vertical v 
    WHERE v.vertical_name  =i.investment_type AND v.type='STR' AND i.status_funding ='o' 
    group by i.investment_type order by investmentCount desc
    limit 6
UNION
    SELECT "others" as investmentType, SUM(othersInvestmentCount) as investmentCount FROM (
        SELECT COUNT(*) as othersInvestmentCount FROM investment i,vertical v 
        WHERE v.vertical_name  =i.investment_type AND v.type='STR' AND i.status_funding ='o' 
        group by i.investment_type order by investmentCount desc
        limit 6, 4294967296
    )

SELECT name,
Case WHEN Table1.tag = 'Y'
 then CODES.Desc
 ELSE 'Other String'
 END as description
FROM TABLE1
join CODES on TABLE1.code = CODES.code

UPDATE library
SET key = key + 1
WHERE value = 'e_book';

SELECT m.MapName, SEC_TO_TIME(TRUNCATE(t.Time,3)) AS Time, t.PlayerID, u.name
FROM times t INNER JOIN
     maps m
     ON t.MapID = m.MapID INNER JOIN
     (SELECT t.MapId, MIN(t.time) as time
      FROM times t
      GROUP BY t.MapId
     ) tmin
     ON tmin.MapId = t.MapId and tmin.time = t.time INNER JOIN
     Users u
     ON t.PlayerId = u.PlayerId

Article
-------
ArticleID int PK

Article_Tags
------------
ArticleTagID int PK
ArticleID int FK
TagId int FK

Tag
---
TagId int identity(1,1) PK
TagText varchar(50)

SELECT RPAD(numcol::text, 3, '0'), -- Zero-pads to the right up to the length of 3
       LPAD(numcol::text, 3, '0'), -- Zero-pads to the left up to the length of 3
FROM   my_table

<img src="/content/u/10234/abcde.img" width="300" height="200">

SELECT *
FROM ticket
WHERE hour(time) >= 18;

UPDATE tableB SET
   PRIMARYKEYCOLUMN = tableA.PRIMARYKEYCOLUMN
FROM tableA
WHERE
   tableA.OLDPRIMARYKEYCOLUMN = tableB.PRIMARYKEYCOLUMN

Create TRIGGER [dbo].[DeleteUser]

ON dbo.ParentTable

INSTEAD OF DELETE

AS 

BEGIN

    SET NOCOUNT ON;

 declare @Search varchar(200)

 select @Search=d.Id from deleted as d   

Declare @tablevar table(Id  nvarchar(200),ColName  nvarchar(200))

--FindStringAndReturnCols return the name of columns And Id's of rows that have value

insert into @tablevar(Id,ColName) exec FindStringAndReturnCols @Search

declare @Id nvarchar(200), @ColName nvarchar(200),@SqlQuery as nvarchar(max)

Declare c Cursor For Select Id,ColName From @tablevar

Open c

Fetch  c into @Id,@ColName


While @@Fetch_Status=0

 Begin

 set  @SqlQuery=''

 set @SqlQuery= 'update ChildTable set '+ @ColName +' = null where Id like N''%'+@Id+'%'''

   exec (@SqlQuery)

   Fetch  c into @Id,@ColName
End

delete from Parent where Id=@Search

Close c

Deallocate c

END

SELECT section, question, answer, COUNT(*) AS count
FROM table 
WHERE academicYear = ??? AND testNo = ???
GROUP BY section, question, answer

SELECT 
      USERNAME
    , DATE_CREATED 
FROM 
(
  SELECT 
       USERNAME
    ,  DATE_CREATED
    ,  COUNT( *) over ( PARTITION by USERNAME, TRUNC( DATE_CREATED, 'DD') ) cnt
  FROM THE_TABLE
)
WHERE cnt > 1
;

SELECT SUM(bytes) AS total_bytes, stamp_updated 
FROM acct 
WHERE stamp_updated BETWEEN datetime('now', 'localtime','-7 hours') AND datetime('now', 'localtime') 
GROUP BY ip_src 
ORDER BY total_bytes DESC limit 10;

Property
-------------------
Property ID
Owner ID
Location (unknown? Beach?)
Address
Weekly Rate
Property Type
No of Rooms
Kitchen (Yay, Nay)



Owner
-------------------
Owner ID
Address

SELECT
    Worker.Name,
    BoxSize.Name,
    SUM(CASE WHEN BoxColor.id=0 THEN 1 ELSE 0 END) AS BoxColor_0,
    SUM(CASE WHEN BoxColor.id=1 THEN 1 ELSE 0 END) AS BoxColor_1,
    SUM(CASE WHEN BoxColor.id=2 THEN 1 ELSE 0 END) AS BoxColor_2    
FROM
    Worker
    JOIN Box
        ON Worker.ID=Box.ID_Worker
    JOIN Item
        ON Item.ID_box=Box.ID
    JOIN BoxColor
        ON BoxColor.ID=Item.ID_BoxColor
    JOIN BoxSize
        ON BoxSize.ID=Item.ID_BoxSize
GROUP BY
    Worker.Name,
    BoxSize.Name

with linkT (parent_code, child_code) as 
(select 'A1','B1' from dual union all
 select 'A1','B2' from dual union all
 select 'B1','C1' from dual union all
 select 'B1','C2' from dual union all
 select 'B2','C3' from dual union all
 select 'B3','C3' from dual union all
 select 'C3','D1' from dual union all
 select 'E1','F1' from dual ),
T1 as (
select parent_code, child_code, 0 Dir from linkT
union all 
select child_code, parent_code, 1 Dir from linkT )
select distinct 
       decode(dir, 0, parent_code, child_code) as Parent_code,
       decode(dir, 0, child_code, parent_code) as Child_Code
from (
select parent_code, child_code, dir
from T1 x
start with x.child_code='A1'
connect by nocycle prior x.parent_code=x.child_code ) 
order by 1,2  

SELECT regions.region, projectTypes.projectType,
       (SELECT count(*) FROM projects
        WHERE projects.typeID = projectTypes.id
          AND projects.regionID = regions.id) as totalCount
FROM regions, projectTypes

UPDATE p
    SET column1 = t.column1
from <dbname>.<schema>.mytable p
join <TestLinkedServerName>.<dbname>.<schema>.mytable t
    on p.<id> = t.<id>

;with cte as
(select 
 ColA,
 ColB, 
 case when ColA < ColB then ColA else ColB end as ColC, 
 case when ColA > ColB then ColA else ColB end as ColD
from yourtable)
select 
ColC as ColA,
ColD as ColB,
count(1) as Count
from cte
group by ColC, ColD
order by ColC, ColD

BEGIN TRANSACTION;
INSERT INTO Persons(Name) VALUES(...);

INSERT INTO PhoneNumbers(PersonForeignKey, Number) 
VALUES(last_insert_rowid(), 'number 1');

INSERT INTO PhoneNumbers(PersonForeignKey, Number) 
SELECT PersonForeignKey, 'number 2' 
FROM PhoneNumbers where PhonePrimaryKey = last_insert_rowid();

INSERT INTO PhoneNumbers(PersonForeignKey, Number) 
SELECT PersonForeignKey, 'number 3' 
FROM PhoneNumbers where PhonePrimaryKey = last_insert_rowid();

END TRANSACTION;

where find_in_set(id, ?)

Update Products 
Set ProductName = 'Shoes' 
WHERE ProductID IN (1,2,3,4,5,6,7,8) 

INSERT INTO SERVICEPAYANT 
            (TYPE_FLUX, 
             DELAI) 
SELECT 161, 
       '9999' 
FROM   dual  
WHERE  NOT EXISTS (SELECT 1 
                   FROM   SERVICEPAYANT 
                   WHERE  TYPE_FLUX = 161 
                          AND DELAI = '9999') 

select user_name, status, sum(calls) as calls
from table
where status in ('cars', 'bikes', 'skates')
group by user_name, status

SELECT  a.*,b.*,z.*
FROM    tbl_event a
        left JOIN (SELECT type_person FROM tbl_event WHERE id_animal = 1) as b
            ON a.type_person = b.type_person
        left JOIN tbl_animal z
            ON   z.id_animal = a.id_animal 
        WHERE z.id_animal = 1;

select count(*)
from
(
    select CustomerId
    from Retail
    where Itemset in (30,31)
    group by CustomerId
    having count(distinct Itemset) = 2   -- this guarantees that CustomerId have at least one 30 and at least one 31 in column Itemset 
) T

CREATE TABLE Customer
 (
   CustomerId     int  not null identity(1,1)
    constraint PK_Customer
     primary key clustered
   ,(...)
 )

CREATE TABLE UserAccount
 (
   UserAccountId  int  not null
    constraint PK_UserAccount
     primary key clustered
    constraint FK_UserAccount__Customer
     foreign key references Customer (CustomerId)
   ,(...)
 )

SELECT DATE_FORMAT(myDateColumn, '%Y-%m'), COUNT(*)
FROM myTable
GROUP BY DATE_FORMAT(myDateColumn, '%Y-%m')
ORDER BY 1

SELECT  distinct *
FROM    jobs
START   WITH ( city, title ) IN 
     ( SELECT city, title
       FROM   people
       WHERE  name IN ( 'Bill', 'Jim', 'Jane' )
     )
CONNECT BY PRIOR parent_title = title;

select location, sum(qty) as total
from (select case when Location in ('Location A','Location B') then Location
             else 'Container' end as location,
             qty from tablename)
group by location

select t.*
from table t
where (t.id - t.seq) = (select t2.id - t2.seq
                        from table t2
                        where t2.type = 'C' and
                              t2.acct = '2345' and
                              t2.date = '6/5/2014'
                       ) and
      t.type is null;

SELECT
    d.id,
    d.district_name,
    (SELECT COUNT(b.id) FROM blocks b WHERE b.district_id = d.id) total_block,
    (SELECT COUNT(p.id) FROM panchayats p WHERE p.district_id = d.id) gp_total,
    (SELECT COUNT(v.id) FROM villages v WHERE v.district_id = d.id) vi_total,
    (SELECT COUNT(h.id) FROM habitations h WHERE h.district_id = d.id) h_total
FROM districts d

select p.propertynum, p.branchnum, p.area, p.city, p.postcode, p.prop_type, p.rooms,
       b.area, b.city, coalesce(i.NumInspected, 0)
from yr_property p join
     yr_branch b
     on p.branchnum = b.branchnum left outer join
     (select propertynum, count(*) as NumInspected
      from yr_inspection i
      group by propertynum
     ) i
     on i.propertynum = p.propertynum;

select count(1) from teams where UserId = 100

DECLARE @theDate varchar(60)
SET @theDate = '''2010-01-01'' AND ''2010-08-31 23:59:59'''

DECLARE @SQL VARCHAR(MAX)  
SET @SQL = 'SELECT AdministratorCode, 
                   SUM(Total) as theTotal, 
                   SUM(WOD.Quantity) as theQty, 
                   AVG(Total) as avgTotal, 
                  (SELECT SUM(tblWOD.Amount)
                     FROM tblWOD
                     JOIN tblWO on tblWOD.OrderID = tblWO.ID
                    WHERE tblWO.Approved = ''1''
                      AND tblWO.AdministratorCode = tblWO.AdministratorCode
                      AND tblWO.OrderDate BETWEEN '+ @theDate +')'

EXEC(@SQL)

SQLiteDatabase db;
// initialize the db
SQLiteStatement statement = null;
try {
    db.compileStatement("select max(_id) from table");
    int max = statement.simpleQueryForLong();
} catch (SQLException e) {
    // handle
} finally {
    if (statement != null) {
        statement.close();
    }
}

SELECT ID_PROJECT FROM PROJECTS p1 WHERE (select balance from ...) > 0;

SELECT m.memo, 
    (SELECT TOP 1 x.id
     FROM checking x
     WHERE x.memo = m.memo
     ORDER BY x.id) as ID
FROM checking m
GROUP BY m.memo

schedule    day
 1           1
 1           3
 1           7

SELECT MAX(field) FROM table WHERE field < (SELECT MAX(field) FROM table)

SELECT mc.CampaignId, c.CampaignTitle
FROM MallCampaign mc 
where mallid in (SELECT FavoriteItemId AS FavoriteMalls
                 FROM Favorite
                 WHERE UserId = @UserId AND FavoriteItemType=1
                ) and
      brandId in (SELECT FavoriteItemId AS FavoriteBrands
                  FROM Favorite
                  WHERE UserId = @UserId AND FavoriteItemType=3
                 ) and
      sectorid in (SELECT FavoriteItemId AS FavoriteSectors
                   FROM Favorite
                   WHERE UserId = @UserId AND FavoriteItemType=2 
                  )

SELECT Col, COUNT(*) AS TOT
FROM (
    SELECT ColumnA AS Col FROM table
    UNION ALL
    SELECT ColumnB FROM table
    UNION ALL
    SELECT ColumnC FROM table
) AS A
GROUP BY Col

SELECT ... From ... WHERE date > add_months(sysdate, -6)

INSERT INTO new_tbl
SELECT * FROM old_tbl;

SELECT p.id as productid, p.some_column1, p.some_column2,
       pp.id  as ProductPropertiesId, pp.name
FROM `Products` p JOIN `ProductProperties` pp
    ON p.id = pp.product_id

IF OBJECT_ID('tmpEmployees_Test', 'U') IS NOT NULL DROP TABLE tmpEmployees_Test;
CREATE TABLE tmpEmployees_Test (EmployeeID INT, EmployeeName VARCHAR(255));
INSERT tmpEmployees_Test (EmployeeID, EmployeeName)
VALUES (1, 'Doe, Jane'), (2, 'Doe, John'), (3, 'Guy, Some');


IF OBJECT_ID('tmpOrders_Test', 'U') IS NOT NULL DROP TABLE tmpOrders_Test;
CREATE TABLE tmpOrders_Test (EmployeeID INT, Customer VARCHAR(255), Date DATE, OrderType VARCHAR(255));
INSERT tmpOrders_Test (EmployeeID, Customer, Date, OrderType)
VALUES (1, 'Fake Customer', '2016-05-14', 'New')
        , (2, 'Some Company', '2016-05-13', 'Change')
        , (3, 'Stuff Inc.', '2016-05-14', 'New')
        , (3, 'Cool Things', '2016-05-12', 'Change')
        , (3, 'Amazing Things', '2016-05-12', 'Change');


DECLARE @columns NVARCHAR(MAX), @sql NVARCHAR(MAX);
SET @columns = N'';
SELECT @columns += N', p.' + QUOTENAME(Name) 
  FROM (SELECT distinct CONVERT(nvarchar(30) , p.Date , 101) as Name FROM dbo.tmpOrders_Test AS p where [Date] > GETDATE()-7
  ) AS x;
-- Kept it for formatting Purpose
DECLARE @columns1 NVARCHAR(MAX)
SET @columns1 = N'';
SELECT @columns1 += N', ISNULL(p.' + QUOTENAME(Name) + ',''/'') AS ' + QUOTENAME(Name) 
  FROM (SELECT distinct CONVERT(nvarchar(30) , p.Date , 101) as Name FROM dbo.tmpOrders_Test AS p where [Date] > GETDATE()-7
  ) AS x;


SET @sql = N'
SELECT EmployeeName, Count(*) as Total  ' +  @columns1  + '
FROM
(
    SELECT  EmployeeID, EmployeeName' + ''+ @columns1 + '' + '
    FROM
    (
      SELECT    o.employeeID,EmployeeName, CAST(COUNT(case WHEN OrderType = ''New'' then 1  end) as varchar(5)) + ''/'' + 
                CAST(COUNT(case WHEN OrderType = ''Change'' then 1  end) as varchar(5)) as OrderType, CONVERT(nvarchar(30) , p.Date , 101) as Date
       FROM     dbo.tmpOrders_Test AS p
                    INNER JOIN dbo.tmpEmployees_Test AS o
                     ON p.EmployeeID = o.EmployeeID
       GROUP BY EmployeeName, Date, o.employeeID
    ) AS j
    PIVOT
    (
      Max(OrderType) FOR Date IN ('
      + STUFF(REPLACE(@columns, ', p.[', ',['), 1, 1, '')
      + ')
    ) AS p) as p JOIN tmpOrders_Test as m on p.employeeID = m.employeeID
where [Date] > GETDATE()-7
GROUP BY EmployeeName ' + @columns + '
';

PRINT @sql;
EXEC sp_executesql @sql;

UPDATE playerRegSeason s
INNER JOIN players p ON s.playerID = p.playerID
SET s.NewPlayerID =  p.NewPlayerID

         (SELECT * 
          FROM information_schema.COLUMNS 
          WHERE 
              TABLE_SCHEMA = 'dashboard'
-----------------------------^ --------^
          AND TABLE_NAME = '".$this->table_name."'
---------------------------^ --------------------^
          AND COLUMN_NAME = 'timestamp')
----------------------------^ --------^

SELECT * FROM Claims AS c
WHERE EXISTS (
    SELECT * FROM Edits AS e1
    WHERE c.ClaimID = e1.ClaimID 
    AND e1.RuleId=205)
AND NOT EXISTS (
    SELECT * FROM Edits AS e2
    WHERE c.ClaimID = e2.ClaimID
    AND e2.RuleId=913)

SELECT  *
FROM    mytable m
WHERE   (ts, id) <
        (
        SELECT  ts, id
        FROM    mytable mi
        WHERE   mi.id = :myid
        )
ORDER BY
        ts DESC, id DESC
LIMIT 50

SELECT e.id, e.name, e.description,
       (SELECT count(*)  FROM day d WHERE d.event_id = e.id) AS days 
FROM event e;

 create or replace view DeptInfo as
 SELECT q1.dnumber, 
        q1.dname, 
        q1.AvgSal,
        q2.MaxSal,
        q3.MinSal
 FROM (SELECT dnumber, dname, AVG(salary) as AvgSal 
       FROM department, employee
       GROUP BY dnumber, dname) q1, 
      (SELECT dnumber, dname, MAX(salary) as MaxSal 
       FROM department, employee
       GROUP BY dnumber, dname) q2, 
      (SELECT dnumber, dname, MIN(salary) as MinSal 
       FROM department, employee
       GROUP BY dnumber, dname) q3
 WHERE q1.dnumber = q2.dnumber AND
       q2.dnumber = q3.dnumber AND
       q1.dname = q2.dname AND
       q2.dname = q3.name

WITH CTE AS (CARD, PRIORITY, SALE_CD, ROW_NUM)
AS
(
  SELECT CARD
         , PRIORITY
         , SALE_CD
         , ROW_NUMBER() OVER(PARTITION BY SALE_CD ORDER BY PRIORITY ASC) AS ROW_NUM
  FROM PAYMENT
)

SELECT
    main_data.id,
    main_data.dt,
    main_data.seq_num,
    main_data.sale_amt,
    main_data.sale_cd,
    promo.promo_cd,
    CTE.card,
    CTE.priority
FROM
    main_data
INNER JOIN promo
    ON promo.id = main_data.id
    AND main_data.dt >= promo.start_dt
    AND main_data.dt <= promo_end_dt
INNER JOIN CTE CTE
    ON CTE.sale_cd = main_data.sale_cd
    AND CTE.card = main_data.card
WHERE 
    main_data.dt BETWEEN '2013-10-12' AND '2013-10-12'
    AND CTE.ROW_NUM = '1'

select   DISTINCT E_reg.applicant_id,
             E_REG.L_NAME, 
             E_REG.F_NAME, 
             E_REG.B_DATE,
            E_REG.REG_DATE,
 from    E_REG join
         TRANSACTION
         on E_REG.ID=TRANSACTION.PAR_ID
  where TRANSACTION.BEGIN_DATE BETWEEN to_date ('01-APR-2012')AND to_date('30-JUN-               2012')
and  (e_reg.applicant_id NOT IN
              (select applicant_id
                   from w_reg
                  where reg_date <'01-JUL-2012' 
                   and exit_date is NULL or exit_date >='01-APR-2012'
or  e_reg.applicant_id NOT IN
              (select applicant_id
                   from t_reg
                  where reg_date <'01-JUL-2012' 
                   and exit_date is NULL or exit_date>='01-APR-2012')
or  e_reg.applicant_id NOT IN
              (select applicant_id
                   from r_reg
                  where reg_date <'01-JUL-2012' 
                     and o_attend IS NOT NULL
                   and term_date is NULL or term_date >='01-APR-2012')
   )

SELECT
    A.*,
    B.*,
    C.*,
    D.*,
    GET_E(A."PK"),
    GET_F(A."PK"),
    GET_G(A."PK")
FROM
    A
LEFT OUTER JOIN B ON
    A."PK" = B."FK"
LEFT OUTER JOIN C ON
    A."PK" = C."FK"
LEFT OUTER JOIN D ON
    A."FK" = D."PK"
WHERE A.PK = ####

protected HqlTreeNode VisitNhMax(NhMaxExpression expression)
{
    return _hqlTreeBuilder.Cast(
        _hqlTreeBuilder.Max(
            VisitExpression(expression.Expression).AsExpression()), 
            expression.Type);
}

while($row = mysqli_fetch_array($result))
{
 echo '<tr><td><a href="'.$row['link'].'">'.$row['Title'].'</a></td></tr>';
}

    INSERT INTO [GT_INVESTMENT] 
    ([ID],[SEQN],[OrgSQENNo], OrgPaymentDate, InvestAmnt, InvestmentDate)


    SELECT [ID],@NEW_SEQN , CASE [OrgSQENNo] WHEN 0 THEN @SEQN ELSE [OrgSQENNo] END , OrgPaymentDate, (InvestAmnt+TotalInterest), MatDate
    FROM [GT_INVESTMENT]
    WHERE SEQN = @SEQN

sudo gem install ibm_db <<heredoc
  1
heredoc

SELECT OrderID
FROM dbo.FooTable
ORDER BY CAST(OrderID AS VARCHAR(255)) 

Select empSal from Emp_Master where empID = '&1';    -- not &2
exit

select * 
from orders
where extract(month from order_date) in (3,4,5);


OFFSET { integer_constant | offset_row_count_expression } { ROW | ROWS }
[
  FETCH { FIRST | NEXT } {integer_constant | fetch_row_count_expression } { ROW | ROWS } ONLY
]

UPDATE categories 
SET categories_image = 'bearings.jpg' 
WHERE categories_id IN (
  SELECT categories_id 
  FROM categories_description 
  WHERE categories_name = 'Bearings'
)

create or replace function random_str(v_length number) return varchar2 is
    my_str varchar2(4000);
begin
    for i in 1..v_length loop
        my_str := my_str || dbms_random.string(
            case when dbms_random.value(0, 1) < 0.5 then 'l' else 'x' end, 1);
    end loop;
    return my_str;
end;
/

select random_str(30) from dual;

RANDOM_STR(30)
--------------------------------------------------------------------------------
pAAHjlh49oZ2xuRqVatd0m1Pv8XuGs

WITH RECURSIVE months(m) AS (
  SELECT strftime('%Y-%m', 'now')
  UNION ALL
  SELECT strftime('%Y-%m', m || '-01', '-1 month')
  FROM months
  LIMIT 5
)
SELECT m FROM months;

Public Sub MIAB1290()

    Dim lastB&, k&, e, f, z, v, w, vErr, r As Range

    With [a2]
        Set r = .Resize(.Item(.Parent.Rows.Count - .Row + 1, 5).End(xlUp).Row - .Row + 1, .Item(, .Parent.Columns.Count - .Column + 1).End(xlToLeft).Column - .Column + 1)
        lastB = .Item(.Parent.Rows.Count - .Row + 1, 2).End(xlUp).Row - .Row + 1
    End With

    With r
        .Worksheet.Sort.SortFields.Clear
        .Sort Key1:=.Item(1, 2), Order1:=1, Key2:=.Item(1, 2), Order2:=1, Header:=xlYes
        v = .Value2
    End With

    ReDim w(1 To UBound(v), 1 To 1)
    vErr = CVErr(xlErrNA)

    For k = 2 To UBound(v)
        e = v(k, 5)
        f = v(k, 6)
        w(k, 1) = vErr
        z = BSearch(v, 2, e, 1, lastB)
        If z Then
            Do While v(z, 2) = e
                If Abs(v(z, 3) - f) <= 3 Then
                    w(k, 1) = v(z, 1)
                    Exit Do
                End If
                z = z + 1
                If z > UBound(v) Then Exit Do
            Loop
        End If
    Next

    r(1, 8).Resize(r.Rows.Count) = w

End Sub


Private Function BSearch(vA, col&, vVal, ByVal first&, ByVal last&)
    Dim k&, middle&
    While last >= first
        middle = (last + first) / 2
        Select Case True
            Case vVal < vA(middle, col)
                last = middle - 1
            Case vVal > vA(middle, col)
                first = middle + 1
            Case Else
                k = middle - 1
                Do While vA(k, col) = vA(middle, col)
                    k = k - 1
                    If k > last Then Exit Do
                Loop
                BSearch = k + 1
                Exit Function
        End Select
    Wend
    BSearch = 0
End Function

update Dash set
    Analysts = 
    stuff(
         (
             select ', ' + P.NameLast
             from dbo.Item as I
                 inner join dbo.Assignment as A on A.ItemId = I.ItemId
                 inner join dbo.Person as P on P.PersonId = A.PersonId
             where I.ItemId = D.DPItem and P.RoleId in (3, 4)
             for xml path(''), type
         ).value('.', 'nvarchar(max)')
    , 1, 2, '')
from dbo.Dash as D

SELECT GROUP_CONCAT(i SEPARATOR '|')
  FROM (  SELECT i
            FROM (  SELECT i
                      FROM integers
                     WHERE i BETWEEN 1 AND 50
                  ORDER BY RAND()
                     LIMIT 5) sort_these_five
        ORDER BY i) concat_these_five;

select 
  (select top 1 Name from Period where StartDate < DateModified order by StartDate desc),
  a.OldValue,  
  a.NewValue  
from Audit a

SELECT COUNT(DISTINCT User_Id) FROM (
  SELECT   User_Id
  FROM     t1
  GROUP BY User_Id, Action_Type
  HAVING   COUNT(*) > 1
) t

SELECT col1,
       col2,
       MIN(grp) AS source_group
FROM   (SELECT 1 AS grp,
               col1,
               col2
        FROM   t1
        UNION ALL
        SELECT 2 AS grp,
               col1,
               col2
        FROM   t2) AS t
GROUP  BY col1,
          col2
ORDER  BY MIN(grp),
          col1  

select DATEADD(dd, DATEDIFF(dd, 0, COL),0) from TABLE

select * from table_name 
  order by 
        date desc, 
        case when new='true' then 1 else 0 end desc

type t_id_table is table OF other_table.id%type index by binary_integer;
v_table t_id_table;

-- fill the table
select id
bulk collect into v_table
from other_table 
where abc in ('&val1','&val2','&val3');     

-- then at a later stage...    

select *
from some_table st
,    table(cast(v_table AS t_id_table)) idt
where st.id = idt.id;

select date_posted, count(*)
from (select date_posted from article union all
      select date_posted from blogposts) v
group by date_posted

UPDATE table SET FieldA = CONCAT(IFNULL(FieldB,'No Value'), ' - arbitrary string')

IF EXISTS (SELECT 1 FROM people WHERE person_id = my_person_id) THEN
  -- do something
END IF;

select
   replace(replace(img_name, '.png', ''), '.jpg', '') as name
from image
group by replace(replace(img_name, '.png', ''), '.jpg', '')
having count(*) = 3

SELECT 
       col1,
       SUM(A) TotalA,
       SUM(B) TotalB
FROM 
(
       select col1, 
              CASE WHEN col2 = 1 THEN col3 ELSE 0 END A,
              CASE WHEN col2 = 2 THEN col3 ELSE 0 END B
       from  tabella
) t
GROUP BY Col1

create unique index idx_tbl_col2_col3 on (col2, col3)

DECLARE @TotalHours VARCHAR(5) = '44:43'


SELECT CAST(CAST(AvgMinutes AS INT)/60 AS VARCHAR) + ':'
        + CAST(CAST(AvgMinutes AS INT)%60 AS VARCHAR)
FROM (
        SELECT CEILING((CAST(LEFT(@TotalHours,CHARINDEX(':',@TotalHours) - 1) AS INT ) * 60 
           + CAST(RIGHT(@TotalHours,LEN(@TotalHours) - CHARINDEX(':',@TotalHours)) AS INT ))/5.0) AvgMinutes
     ) AS TotalMinutes

INSERT INTO Table_C (SELECT null, Table_A.item, Table_B.color, null FROM 
Table_A CROSS JOIN Table_B);

SELECT * 
FROM   (SELECT id, itemcount, version, 
               ROW_NUMBER() OVER (ORDER BY version DESC, itemcount DESC) AS rn
        FROM   (SELECT id, SUM(itemcount) as itemcount, version 
                FROM ARTICLE_COUNTER_STATISTICS_m 
                WHERE id != '0' 
                GROUP BY id, version
               )
        )
WHERE  rn BETWEEN 3 AND 20 -- just an example

select sa.name as "Sender Account"
from security_account sa
join spot s on sa.id = s.provider_account_id
where s.format = 'SD'
except
select sa.name as "Sender Account"
from security_account sa
join spot s on sa.id = s.provider_account_id
where s.format <> 'SD'

SELECT *
FROM `job` 
WHERE c_name = 'John doe'
AND (customer_ref LIKE '%do%'
OR order_details LIKE '%do%')

package com.MyPackage;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

public class AnyDBAdapter {

private static final String TAG = "AnyDBAdapter";
private DatabaseHelper mDbHelper;
private static SQLiteDatabase mDb;

//make sure this matches the 
//package com.MyPackage;
//at the top of this file
private static String DB_PATH = "/data/data/com.MyPackage/databases/";

//make sure this matches your database name in your assets folder
// my database file does not have an extension on it 
// if yours does
// add the extention
private static final String DATABASE_NAME = "data";

//Im using an sqlite3 database, I have no clue if this makes a difference or not
private static final int DATABASE_VERSION = 3;

private final Context adapterContext;

public AnyDBAdapter(Context context) {
    this.adapterContext = context;
}

public AnyDBAdapter open() throws SQLException {
    mDbHelper = new DatabaseHelper(adapterContext);

    try {
        mDbHelper.createDataBase();
    } catch (IOException ioe) {
        throw new Error("Unable to create database");
    }

    try {
        mDbHelper.openDataBase();
    } catch (SQLException sqle) {
        throw sqle;
    }
    return this;
}
//Usage from outside
// AnyDBAdapter dba = new AnyDBAdapter(contextObject); //in my case contextObject is a  map
// dba.open();
// Cursor c = dba.ExampleSelect("Rawr!");
// contextObject.startManagingCursor(c);
// String s1 = "", s2 = "";
// if(c.moveToFirst())
// do {
//  s1 = c.getString(0);
//  s2 = c.getString(1);
//  } while (c.moveToNext());
// dba.close();
public Cursor ExampleSelect(string myVariable)
{
    String query = "SELECT locale, ? FROM android_metadata";
    return mDb.rawQuery(query, new String[]{myVariable});
}

//Usage
// AnyDBAdatper dba = new AnyDBAdapter(contextObjecT);
// dba.open();
// dba.ExampleCommand("en-CA", "en-GB");
// dba.close();
public void ExampleCommand(String myVariable1, String myVariable2)
{
    String command = "INSERT INTO android_metadata (locale) SELECT ? UNION ALL SELECT  ?";
    mDb.execSQL(command, new String[]{ myVariable1, myVariable2});
}

public void close() {
    mDbHelper.close();
}

private static class DatabaseHelper extends SQLiteOpenHelper {

    Context helperContext;

    DatabaseHelper(Context context) {
        super(context, DATABASE_NAME, null, DATABASE_VERSION);
        helperContext = context;
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        Log.w(TAG, "Upgrading database!!!!!");
        //db.execSQL("");
        onCreate(db);
    }

    public void createDataBase() throws IOException {
        boolean dbExist = checkDataBase();
        if (dbExist) {
        } else {

            //make sure your database has this table already created in it
            //this does not actually work here
            /*
             * db.execSQL("CREATE TABLE IF NOT EXISTS \"android_metadata\" (\"locale\"     TEXT DEFAULT 'en_US')"
             * );
             * db.execSQL("INSERT INTO \"android_metadata\" VALUES ('en_US')"
             * );
             */
            this.getReadableDatabase();
            try {
                copyDataBase();
            } catch (IOException e) {
                throw new Error("Error copying database");
            }
        }
    }

    public SQLiteDatabase getDatabase() {
        String myPath = DB_PATH + DATABASE_NAME;
        return SQLiteDatabase.openDatabase(myPath, null,
                SQLiteDatabase.OPEN_READONLY);
    }

    private boolean checkDataBase() {
        SQLiteDatabase checkDB = null;
        try {
            String myPath = DB_PATH + DATABASE_NAME;
            checkDB = SQLiteDatabase.openDatabase(myPath, null,
                    SQLiteDatabase.OPEN_READONLY);
        } catch (SQLiteException e) {
        }
        if (checkDB != null) {
            checkDB.close();
        }
        return checkDB != null ? true : false;
    }

    private void copyDataBase() throws IOException {

        // Open your local db as the input stream
        InputStream myInput = helperContext.getAssets().open(DATABASE_NAME);

        // Path to the just created empty db
        String outFileName = DB_PATH + DATABASE_NAME;

        // Open the empty db as the output stream
        OutputStream myOutput = new FileOutputStream(outFileName);

        // transfer bytes from the inputfile to the outputfile
        byte[] buffer = new byte[1024];
        int length;
        while ((length = myInput.read(buffer)) > 0) {
            myOutput.write(buffer, 0, length);
        }

        // Close the streams
        myOutput.flush();
        myOutput.close();
        myInput.close();
    }

    public void openDataBase() throws SQLException {
        // Open the database
        String myPath = DB_PATH + DATABASE_NAME;
        mDb = SQLiteDatabase.openDatabase(myPath, null,
                SQLiteDatabase.OPEN_READWRITE);
    }

    @Override
    public synchronized void close() {

        if (mDb != null)
            mDb.close();

        super.close();

    }
}

}

SELECT t.src
     , t.title
     , t.maker
     , t.partnum
     , t.price
  FROM (
         SELECT '[data]'         AS `src`
              , d1.title         AS `title`
              , d1.maker         AS `maker`
              , d1.partnum       AS `partnum`
              , d1.price         AS `price`
              , d1.partnum       AS `product`
           FROM data d1
          WHERE d1.sysn = ?

          UNION ALL

         SELECT '[cross]'
              , c2.title
              , c2.maker
              , c2.partnum
              , c2.price
              , c2.product
           FROM cross c2
           JOIN data d2
             ON d2.partnum = c2.product
          WHERE d2.sysn = ?
       )
 ORDER BY t.product DESC, t.src DESC, t.price ASC

select
  m.id, m.datecolumn, m.note
from
  (select max(datecolumn) datecolumn, id
   from mytable
   group by id) sub
inner join mytable m on m.id = sub.id and m.datecolumn= sub.datecolumn

select pallet_id,
    case 
        when count(case when product_group not in ('LAMINAAT','ACCESSORIE') then 1 end) > 0 then ''
        when count(distinct product_group) > 1 then 'Mix'
        when count(case when product_group = 'LAMINAAT' then 1 end) > 0 then 'LAM'
        else 'ACC'
    end as label
from mytable
group by pallet_id

SELECT p FROM BlogRegionBundle:Post p LEFT JOIN p.tags t WHERE t.id = :blogId AND p.state = :state AND p.deleted = 0 AND :user NOT MEMBER OF p.views

NODE
id

NODE_POST
id pk fk node(id)
title
body

NODE_COMMENT 
id pk fk node(id) 
body 
post_id fk node_post(id) 
parent_comment_id fk node_comment(id)

INSERT INTO Client_First_Name VALUES(SELECT Client_Name LIKE '% %' THEN LEFT(Client_Name, Charindex(' ', Client_Name) - 1));

INSERT INTO Client_Surname VALUES(SELECT Client_Name LIKE '% %' THEN RIGHT(Client_Name, Charindex(' ', Reverse(Client_Name)) - 1));

Using a SQL query
SELECT 
  nspname,         -- schema name
  defaclobjtype,   -- object type
  defaclacl        -- default access privileges
FROM pg_default_acl a JOIN pg_namespace b ON a.defaclnamespace=b.oid;

<?php 
$dates = array(
     '2014-07-26',
     '2014-08-04'
);
$this->db->from('tblName');
$this->db->where('id','007');

// first variant
foreach($dates as $date){
$this->db->where('doj !=',$date);
}

// or second variant
$this->db->where_not_in('doj',$dates); // <- seems to be better

// finally get result
$result = $this->db->get();

if($result->num_rows()){
     var_dump($result->result_array());
} else {
     echo 'no rows found';
}
// check query
echo $this->db->last_query();

?>

select 'Current' As TimePeriod,
sum(case when CPT_ORIGINATED > SUBDATE(DATE(NOW()),30) THEN 1 else 0
    end) as CountOfThings,
from `cpt-prod`
where CPT_STATE <> 'Closed'
UNION ALL
SELECT 'Past1' AS TimePeriod,
sum(case when CPT_ORIGINATED > SUBDATE(DATE(NOW()),60) AND CPT_ORIGINATED < SUBDATE(DATE(NOW()),30) THEN 1 else     0
    end) as CountOfThings,
from `cpt-prod`
where CPT_STATE <> 'Closed'

OPEN V_CF_CURSOR FOR SELECT COUNT(*) FROM "VPA"."Employee"; -- returns 1 row
FETCH V_CF_CURSOR INTO CF_ROWCOUNT;

WHERE (pc.IsBusinessDay IS NULL AND ac.IsBusinessDay = 0)
OR pc.IsBusinessDay = 0

if @SelectFlag = 1
  select name, Address, salary, CreatedBy from employee
else
if @UpdateFlag = 1
  select name, Address, salary from employee    

SELECT * FROM financials WHERE date >= NOW() - INTERVAL 30 DAY



var conn = {
  host     : '127.0.0.1',
  user     : 'user',
  password : 'pass',
  charset  : 'utf8'
};

// connect without database selected
var knex = require('knex')({ client: 'mysql', connection: conn});

knex.raw('CREATE DATABASE my_database')
  .then(function(){
    knex.destroy();
    
    // connect with database selected
    conn.database = 'my_database';
    knex = require('knex')({ client: 'mysql', connection: conn});

    knex.schema.createTable('my_table', function (table) {
      table.string('my_field');
    })
    .then(function() {
      knex.destroy();
    });
  });
 SELECT ImpFile, DATEADD(hh, DATEDIFF(hh, 0, ImpDate), 0)
 FROM nol_artikula_izmaina

SELECT 
    a.name, 
    b.office, 
    c.firm, 
    d.status
FROM 
    job a
JOIN depts b ON a.office = b.ref
JOIN firms c ON b.firm  = c.ref
JOIN statuses d ON a.status = d.ref

with start_grp as (
  select dt, user_id, programme,
         case when dt - lag(dt,1) over (partition by user_id order by dt) 
                   > interval '0 day 2:00:00'
              then 1
              else 0
         end grp_start
  from binge
  ),
assign_grp as (
  select dt, user_id, programme,
  sum(grp_start) over (partition by user_id order by dt) grp
  from start_grp)
select user_id, grp as binge, max(dt) - min(dt) as binge_length
from assign_grp
group by user_id, grp
having count(programme) > 1

select column1
from the_table
where column2 in ('Doc1', 'Doc2', 'Doc3')
group by column1
having count(distinct column2) = 3;

SELECT Col1, 
        Col2, 
        Col3 
FROM(
    SELECT 
        Col1, 
        Col2, 
        Col3, 
        ROW_NUMBER() OVER (PARTITION BY Col1 ORDER BY Col1, Col2, Col3) RNum
    FROM YourTable 
)X WHERE RNum<=5

UPDATE       userprofileplus
SET                mobile = 9199225533
WHERE        (mobile is null and userid = 5) and (Id IN
                             (SELECT        TOP (1) Id
                               FROM            userprofileplus AS userprofileplus_1
                               WHERE        (mobile IS NULL) AND (UserId = 5)))

select 
    g.*
    , home.team_name as home_team_name
    , road.team_name as road_team_name
from Games g
    inner join Teams home on home.tid = g.home_team_id
    inner join Teams road on road.tid = g.road_team_id
where g.home_team_id = 1
    or g.road_team_id = 1

Private Sub txtFileName_AfterUpdate()
    If Not IsNull(txtFileName) Then
        txtFileName = Trim$(txtFileName)
        If Not Right$(txtFileName, 4) = ".zip" Then
            txtFileName = txtFileName & ".zip"
        End If
    End If
End Sub

WITH all_items AS (
    SELECT
          t1.import_id
        , t1.import_at
        , t2.item_id
        , t2.item_url
        , t2.item_name
        , t2.item_description
        , ROW_NUMBER() OVER(PARTITION BY item_url ORDER BY t1.import_at DESC) AS item_url_rank 
    FROM dbo.table1 AS t1
    JOIN dbo.table1 AS t2 ON
        t2.import_id = t1.import_id
    )
SELECT 
          t1.import_id
        , import_at
        , item_id
        , item_url
        , item_name
        , item_description
WHERE 
    item_url_rank = 1;

SELECT DISTINCT PosterID
FROM table1 x
WHERE PostingDate BETWEEN '2012-05-01' AND '2012-06-30'
AND posterID NOT IN (SELECT PosterID
  FROM table1 y
  WHERE PostingDate > '2012-07-01' AND x.CategoryID = y.CategoryID);  

SELECT  TO_CHAR(696585242087, '99G999G999G9999', 'NLS_NUMERIC_CHARACTERS=",."')
FROM    dual

Select I_Ftn, I_Col, count(c.i_id_num) cnt 
From DSCL_ALL.W_CALENDER c 
Where c.UNIT_CODE= '01' 
AND c.i_g_vill = '45'
and c.i_g_code = '1'
and c.survey_year = '2012-2013'
and not exists (select 1 from w_mill_pur m where m.unit_code = c.unit_code and m.m_vill = c.i_g_vill and m.m_grow = c.i_g_code and m.m_indent = c.i_number)  
Group By I_Ftn, I_Col
ORDER BY I_ftn, I_col)

SELECT currency, SUM(total1) AS total FROM
(
SELECT currency_a AS currency, SUM(a_amount)  AS total1 FROM table1
GROUP BY currency_a
UNION ALL
SELECT currency_b, SUM(b_amount) AS total2 FROM table1
GROUP BY currency_b
UNION ALL
SELECT currency_c, SUM(c_amount) AS total2 FROM table1
GROUP BY currency_c
) T
GROUP BY currency

select (case when min(name) = max(name) then max(name)
             else thegroup
        end) as name,
       sum(balance) as balance
from theRecords r
group by thegroup;

sqlplus x/x@orcl <sql.txt

SELECT COUNT(Dispute_Reference_no) AS reg_inc
FROM   mytable 
WHERE  reasoncd in ('b2', 'b3') AND
       ((DATENAME(weekday, GETDATE()) = 'monday' AND 
         datecreated = dbo.fn_getdateonly(GETDATE()-3)) OR
        (DATENAME(weekday, GETDATE()) = 'tuesday' AND 
         datecreated BETWEEN dbo.fn_getdateonly(GETDATE()-3) AND 
                             dbo.fn_getdateonly(GETDATE())) OR
        (atecreated = dbo.fn_getdateonly(GETDATE()-1)
       )

;WITH cte AS 
( SELECT StaffId, FirstWeekEnding AS WeekEnding
  FROM STAFF
  UNION ALL
  SELECT StaffId, DATEADD(D, 7, WeekEnding) FROM cte
  WHERE DATEADD(D, 7, WeekEnding) <= GETDATE()
)
SELECT StaffId, WeekEnding
FROM cte LEFT JOIN Header ON cte.StaffId = Header.StaffId AND cte.WeekEnding = Header.WeekEnding
WHERE Header.WeekEnding IS NULL
OPTION (MAXRECURSION 32767)

SELECT  TO_CHAR ( TO_DATE ( SUBSTR (regexp_replace(file_name, '[A-Z][a-z]', '')
                           , INSTR (regexp_replace(file_name, '[A-Z][a-z]', '') , '_', -1, 2)+ 1, 8), 'YYYYMMDD'), 'DD-MM-YYYY')
  FROM dual;

WITH temp_roles 
  as (     
      SELECT *
        FROM role_
       WHERE name IN ('User', 'Owner', 'Portal Content Reviewer', 
                      'Community Owner', 'Administrator')
      UNION
      SELECT <values>
        FROM dual
     )

ORDER BY Min([Transaction Date]) DESC
ORDER BY 4 DESC

create table albums (
    album_id integer primary key,
    -- other fields...
);

create table special_offers (
    album_id integer primary key references albums(album_id),
    -- other fields...
);

select s.col1, s.col2, ... s.colN, 
max(s.col1) over (partition by s.col2, ... ),
min(s.col1) over (partition by s.col2, ... )
from stuff as s;

declare
    @Questions varchar(max),
    @SQLQuery varchar(max)

create table #OutputTable
    (
    refID int,
    SessionID int,
    QuestionID varchar(50),
    AnswerValue varchar(50)
    )
insert into #OutputTable
    values
        (9000,205545715,'[4907]','Good morning'),
        (12251,205543469,'[10576:16307]','3'),
        (12255,205543469,'[10907:17001]','4'),
        (13157,205543703,'[10576:16307]','3'),
        (14387,205543493,'[10907:17001]','2'),
        (14389,205543493,'[10911:17007]','3')

set @Questions = (STUFF((SELECT distinct ',' + cast(i.QuestionID as varchar(20))          
    FROM #OutputTable i
    FOR XML PATH(''), TYPE).value('.','VARCHAR(max)'), 1, 1, ''))

set @SQLQuery = '
    select SessionID,'+ @Questions +'
    from    (
            select
                SessionID,
                replace(replace(QuestionID,''['',''''),'']'','''') QuestionID,
                AnswerValue
            from #OutputTable
            ) p 
        PIVOT (
              max(Answervalue)
              FOR p.QuestionID IN ('+ @Questions +')
              ) as pvt
    order by SessionID desc'

exec(@SQLQuery)

select (case when value between 0 and 20 then '0-20'
             when value between 21 and 45 then '21-45'
             when value between 46 and 100 then '46-100'
             else 'other'
        end) as range,
       count(*)
from RandomValueTable
group by (case when value between 0 and 20 then '0-20'
               when value between 21 and 45 then '21-45'
               when value between 46 and 100 then '46-100'
               else 'other'
          end);

SELECT a.student_id, s.name, COUNT(a.subject_id) as taken_subjects
FROM assignments a
INNER JOIN students s ON a.student_id = s.id
GROUP BY a.student_id, s.name
HAVING COUNT(a.subject_id) = (SELECT COUNT(*) FROM assignments GROUP BY student_id LIMIT 1)

ALTER FUNCTION dbo.CalcMinsInHour(@start DATETIME, @end DATETIME, @hour INTEGER)
RETURNS INTEGER 
AS
BEGIN
    DECLARE @StartOfHour DATETIME
    DECLARE @EndOfHour DATETIME
    SELECT @StartOfHour = DATEADD(hh, @hour, CAST(CAST(@start AS DATE) AS DATETIME))
    IF NOT (@StartOfHour BETWEEN @start and @end)
        SET @StartOfHour = DATEADD(hh, @hour, CAST(CAST(@end AS DATE) AS DATETIME))

    SELECT @EndOfHour = DATEADD(hh, 1, @StartOfHour)

RETURN
(
SELECT 
    CASE WHEN @EndOfHour < @start OR @StartOfHour > @end THEN 0 ELSE
        DATEDIFF(mi,
            CASE WHEN @StartOfHour <= @start THEN @start ELSE @StartOfHour END,
            CASE WHEN @EndOfHour > @end THEN @end ELSE @EndOfHour END)  
    END
)
END

create table Editions (
    EditionsId int not null identity(1, 1) primary key,
    JournalId varchar(10) references Publications(JournalId),
    EditionName varchar(255),
    . . .
)

Select ID as Num, 
       (select Count(*) from TASK t where t.ID = o.ID) as Total 
from ORDER o;

Id
TaskId
PersonId
MonthYearKey
MonthYearValue

db.collection.find({"string_list" : {$all:["large","world","hello"]}, "string_list": {$size: 3}});

SELECT (left(convert(char(11), date, 107), 3) + " " +
right(convert(char(11), date, 107), 2)) as date from 
(
    select date from yourtable 
    group by date 
    order by year(date) asc, month(date)asc
) as a    

SELECT CASE
  WHEN fourthlevel.case_type IN ('Complaint')
  THEN
     (SELECT cast(COUNT(*) as varchar2(255))
        FROM work_days1
       WHERE     work_days1.business_date > fourthlevel.cdate
             AND work_days1.business_date <=
                    COALESCE (fourthlevel.close_date, SYSDATE))
  WHEN fourthlevel.case_type IN ('Enquiry')
  THEN
     (SELECT cast(COUNT(*) as varchar2(255))
        FROM work_days1
       WHERE     work_days1.business_date > fourthlevel.create_date
             AND work_days1.business_date <=
                    COALESCE (fourthlevel.close_date, SYSDATE))
  WHEN fourthlevel.case_status = 'Cancelled'
  THEN
     'N/A'
END AS sla_days
FROM fourthlevel

Select case when firstcity = '008' then secondcity else firstcity end 'City',
       Distance,Roadname,Roadstatus
from   table
where (firstcity= '008' or secondcity ='008')

SELECT A.Date, 
       SUM(CASE WHEN A.Methos = 'A' THEN A.Count ELSE 0 END) AS 'A', 
       SUM(CASE WHEN A.Methos = 'B' THEN A.Count ELSE 0 END) AS 'B', 
       SUM(CASE WHEN A.Methos = 'C' THEN A.Count ELSE 0 END) AS 'C', 
       SUM(CASE WHEN A.Methos = 'D' THEN A.Count ELSE 0 END) AS 'D', 
       SUM(CASE WHEN A.Methos = 'E' THEN A.Count ELSE 0 END) AS 'E', 
       SUM(CASE WHEN A.Methos = 'F' THEN A.Count ELSE 0 END) AS 'F', 
       SUM(CASE WHEN A.Methos = 'G' THEN A.Count ELSE 0 END) AS 'G', 
       SUM(CASE WHEN A.Methos = 'H' THEN A.Count ELSE 0 END) AS 'H'
FROM tableA A 
GROUP BY A.Date

if (ds.Tables.Count > 0) {
  ds.Tables[ds.Tables.Count - 1].TableName = "name";
}

DECLARE @sql1 VARCHAR(4000) = ''
DECLARE @sql2 VARCHAR(4000) = ''
DECLARE @sql3 VARCHAR(4000) = ''

SELECT @sql1 =
'SELECT 
    Id
    , Team
'

SELECT @sql2 = @sql2 +
'   , MAX(CASE WHEN RN = ' + CONVERT(VARCHAR(10), RN) + ' THEN Players END) AS ['  + CONVERT(VARCHAR(10), RN) + ']' + CHAR(10)
FROM(
    SELECT DISTINCT
        RN = ROW_NUMBER() OVER(PARTITION BY Id, Team ORDER BY (SELECT NULL))
    FROM Tbl
)t
ORDER BY RN

SELECT @sql3 =
'FROM(
    SELECT *,
        RN = ROW_NUMBER() OVER(PARTITION BY Id, Team ORDER BY (SELECT NULL))
    FROM Tbl
)t
GROUP BY
Id, Team'

PRINT (@sql1 + @sql2 + @sql3)
EXEC (@sql1 + @sql2 + @sql3)

 public boolean Exists(String link) {
           Cursor cursor = ourDatabase.rawQuery("select 1 from fav where link='"+link+"'",new String[] {});
           boolean exists = (cursor.getCount() > 0);
           cursor.close();
           return exists;
        }

CREATE TYPE my_dates AS TABLE OF DATE;
/

SELECT d.column_value AS Date_Of_Concern, count(Player_Id) AS Retained
  FROM Player
  JOIN TABLE (my_dates(to_date('2012-sep-03', 'yyyy-mon-dd'),
                       to_date('2012-sep-04', 'yyyy-mon-dd'),
                       to_date('2012-sep-05', 'yyyy-mon-dd'))) d
          ON d.column_value - trunc(Init_Dtime) BETWEEN 0 AND 7
 GROUP BY d.column_value

create table dbo.Products (
    ProductCode char(10) not null primary key,
    ProductName nvarchar(50) not null,
    ProductDescription nvarchar(100) not null,
    -- other columns
)

create table dbo.ProductsTranslations (
    ProductCode char(10) not null,
    LanguageCode char(2) not null,
    ProductName nvarchar(50) not null,
    ProductDescription nvarchar(100) not null,
    -- other translations
    constraint FK1 foreign key (ProductCode)
        references dbo.Products (ProductCode),
    constraint FK2 foreign key (LanguageCode)
        references dbo.Languages (LanguageCode),
    constraint PK primary key (ProductCode, LanguageCode)
)

Select 
    (Select Count (*) from tso_skf_nomeas_in60days_v) 
    / 
    (Select Count (*) from tso_skf_recent_meas) as perc
from dual

with cte as (
    select p.productcategory, p.ProductSubCategory, COUNT(*) cnt, 
        ROW_NUMBER() over (partition by p.productcategory order by count(*) desc) rn 
    from products p 
        join sales s on p.ProductSubCategory = s.ProductSubCategory
    group by p.productcategory, p.ProductSubCategory
    )
select * 
from cte 
where rn = 1

Declare @Date date = '2015-05-02'
While DATENAME(WEEKDAY,@Date) <> 'Thursday'
    begin
    Set @Date = DATEADD(dd, -1,@Date)
    end
Select @Date

SELECT
    DIM_DRUG_NAME_SHORT.Drug_Name_Short AS 'Med_Name_Short'
    , SUM(Baseline.Doses) as 'DOT'
    , Day(Baseline.Dispense_Date) as 'd_Date'
FROM    
    FACT_AMS_Baseline_Report Baseline
    INNER JOIN DIM_DRUG_NAME_SHORT ON Baseline.Med_Name_ID = DIM_DRUG_NAME_SHORT.Drug_Name_Long
    INNER JOIN DIM_Date tDate ON Baseline.Dispense_Date = tDate.Date

WHERE
    Baseline.Encounter = '00000001/01'

GROUP BY
    DIM_DRUG_NAME_SHORT.Drug_Name_Short
    , Baseline.Dispense_Date

Order By
    Drug_Name_Short

SELECT year_born as year, count(*) as numridersborn  
FROM Riders 
GROUP BY year_born 
ORDER BY year_born;

lstResults.RowSource = "select EmpId from tblTesting where Empid = " & Me.txtSearchEmpId.Value

select r.ID, m.MATERIALID, m.LOT, sum(ms.AMMOUNT) as aantal,
       sum(m.NETPRICE )as prijs, sum(ms.AMMOUNT * m.NETPRICE) as Total
from rc_recall r inner join
     RC_RECALLMATSTORE ms
     on r.ID = ms.RECALLID inner join
     RC_RECALLMATERIAL m
     ON ms.RECALLID = m.RECALLID and ms.LINE = m.LINE 
where r.ID = '2015073' and d.LANG = 'FR'
group by r.ID, m.MATERIALID, m.LOT;

select * from dbo.ONE where LastLogin is NULL and  
                            datediff(ss,regdate,GetDate())<30

;with cte AS (SELECT *,COUNT(*) OVER(PARTITION BY Country,Category) CT
                      ,CASE WHEN Category IS NOT NULL THEN DENSE_RANK() OVER (ORDER BY Country) END Rank_
              FROM Table1)
SELECT Country
      ,State
      ,Category
      ,CASE WHEN CT > 1 AND Rank_ IS NOT NULL THEN DENSE_Rank() OVER(ORDER BY Rank_ DESC) END AS Group_
FROM cte
ORDER BY Country DESC,State

SELECT c.id, 
  c.name 
FROM customers c
WHERE not exists (select customer_id
                  from modulemembers m
                  where c.id = m.customer_id)
order by c.name

WHERE ProductID NOT IN (
  SELECT ProductID FROM ProductCustomerLevel 
  WHERE CustomerLevelID=9
)

SELECT Username, COUNT(DISTINCT(Date)) AS UniqueDaysAppeared
FROM Occurrences
GROUP BY Username

select A.transactionNumber,
A.DealNumber,     
C.GroupLookup AS [Group]
from TableOne A    
inner join TableTwo B     
on A.transactionNumber = B.tranNumber     
inner join TableThree C
on C.Group = A.Group
where B.ID = 111111  

# get all rows with distinct (unique) hashes from Remote and create a list of hashes.
remote_hash_list = [item.hash for item in Remote.query.distinct(Remote.hash).all()]

# Now get all Local items that hash is not in remote hashes list
local_items = Local.query.filter(Local.hash.notin_(remote_hash_list)).all()

select 
     customer.customer_num, customer.fname, 
     isnull(sum(items.total_price),0) amountSpent
from customer
    left join orders
        on customer.customer_num = orders.customer_num
    left join items
        on orders.order_num = items.order_num 
       and items.manu_code like 'HRO'
group by customer.customer_num, customer.fname

BEGIN

SET NOCOUNT ON;

SELECT    Top 20 A.imgID,
            COUNT(*) OVER() AS volume,
            (
                SELECT      B.commentID,
                            COUNT(*) OVER() AS volume
                FROM        MOC_ImgComments B
                WHERE       B.imgID = A.imgID
                FOR XML PATH(''), ELEMENTS, TYPE
            )
FROM        MOC_ImgComments A
ORDER BY    volume desc, A.imgID
FOR XML PATH('images'), ELEMENTS, TYPE, ROOT('ranks')   
group by A.imgID
END

SELECT *, ROW_NUMBER() OVER (ORDER BY somefield) rownum
FROM table;

SELECT something*1.0/total FROM somewhere

UPDATE table_name
   SET column1_name = round(column1_name, 2 ),
       column2_name = round(column2_name, 2 ),
       ...
       columnN_name = round(columnN_name, 2 )

;With OrgChart as        
(        
  SELECT id,id as BaseID
  FROM employee WHERE Active=1
  UNION ALL 
  SELECT e.ID, g.BaseID as BaseID         
  FROM employee e 
  JOIN OrgChart g on e.supervisorid=g.id
  WHERE e.Active=0
), ForUpd as
(SELECT ID,BASEID FROM OrgChart WHERE ID<>BAseID)

 UPDATE A SET empid = B.baseID
 FROM component A
 JOIN ForUpd B ON A.empid = B.id

select * from  sampleTable
             where 
             status = 'A' 
             and SUBSTR(some_code_column, 1, 4)  = 9999

create table re (country varchar2(10),reg varchar2(100));

insert into re values ('us','^[0-9]{3}-[0-9]{2}-[0-9]{4}$');

select 
   case when regexp_like('987-65-4321' ,reg) 
      then 'Match Found' 
      else 'No Match Found' 
   end as output 
from re
where country = 'us';

Match Found

    SELECT month(u.`userRegistredDate`),
sum(CASE WHEN u.`userTypeID`=1 THEN 1 ELSE 0 END) AS agent,
sum(CASE WHEN u.`userTypeID`=2 THEN 1 ELSE 0 END) AS individuals,
sum(CASE WHEN u.`userTypeID`=3 THEN 1 ELSE 0 END) AS builders,
sum(CASE WHEN u.`userTypeID`=4 THEN 1 ELSE 0 END) AS real_estate_companies,
 u.`userRegistredDate` AS 'timestamp',m.month
FROM (
SELECT 'January' AS
MONTH
UNION SELECT 'February' AS
MONTH
UNION SELECT 'March' AS
MONTH
UNION SELECT 'April' AS
MONTH
UNION SELECT 'May' AS
MONTH
UNION SELECT 'June' AS
MONTH
UNION SELECT 'July' AS
MONTH
UNION SELECT 'August' AS
MONTH
UNION SELECT 'September' AS
MONTH
UNION SELECT 'October' AS
MONTH
UNION SELECT 'November' AS
MONTH
UNION SELECT 'December' AS
MONTH
) AS m
left join `dp_users` AS u  ON m.month = MONTHNAME(u.`userRegistredDate`) and u.`userRegistredDate` < Now( )
AND u.`userRegistredDate` > DATE_ADD( Now( ) , INTERVAL -12 MONTH )
LEFT JOIN `dp_user_types` AS ut ON u.`userTypeID` = ut.`type_id`

GROUP BY  m.month
order by FIELD(m.month,'July','August','September','October','November','December','January','February','March','April','May','June')

SELECT FixHours, AddHours, CalculatedValue
FROM tbl
WHERE FixHours = 0
OR AddHours = 0

UNION

SELECT FixHours, 0, CalculatedValue
FROM tbl
WHERE FixHours <> 0
AND AddHours <> 0

UNION

SELECT 0, AddHours, CalculatedValue
FROM tbl
WHERE FixHours <> 0
AND AddHours <> 0

select @one := 1 as one, 2 * @one as two;

SELECT CST_ID,
   SUM(CASE WHEN Type='SH' THEN 1 ELSE 0 END) as SH,     
   SUM(CASE WHEN Type='KA' THEN 1 ELSE 0 END) as KA,
   SUM(CASE WHEN Type='EF' THEN 1 ELSE 0 END) as EF,
   SUM(CASE WHEN Type='SC' THEN 1 ELSE 0 END) as SC,
   SUM(CASE WHEN Type='KA' THEN 1 ELSE 0 END) as KA,
   SUM(CASE WHEN Type='NO' THEN 1 ELSE 0 END) as NO,
   SUM(CASE WHEN Type='WE' THEN 1 ELSE 0 END) as WE,
   SUM(CASE WHEN Type='TH' THEN 1 ELSE 0 END) as TH,
   SUM(CASE WHEN Type='BV' THEN 1 ELSE 0 END) as BV

FROM
(
  SELECT CST_ID,TRC_TYPE as Type FROM T
   UNION ALL
  SELECT CST_ID,COLL_TYPE as Type FROM T
) T1
GROUP BY CST_ID

DELETE
FROM code_sum_country
WHERE code in
 (SELECT code
  FROM code_sum_country
  GROUP BY code
  HAVING COUNT (code) > 1) 
AND country NOT IN
 (SELECT MIN(country)
  FROM code_sum_country
  GROUP BY code
  HAVING COUNT (code) > 1)

SELECT
     T1.id,
     T1.business_key,
     T1.result
FROM
     dbo.My_Table T1
LEFT OUTER JOIN dbo.My_Table T2 ON
     T2.business_key = T1.business_key AND
     T2.id > T1.id
WHERE
     T2.id IS NULL

SELECT DISTINCT SUBCASE_ID FROM YOUR_TABLE 
WHERE SUBCASE_ID NOT IN (SELECT SUBCASE_ID FROM YOUR_TABLE where ACTIVITY='Closed')

SELECT a.`date`, count(*) cnt, a.ip 
FROM fwlog a
JOIN (SELECT ip, count(*) today_count
      FROM fwlog 
      where `date` = date(now()) 
      group by ip) t
  ON a.ip = t.ip and t.today_count > 100
GROUP BY a.ip, a.date
ORDER BY t.today_count DESC, a.ip, a.`date` DESC

update t
set t.ID = r.ID
FROM (Select Min(ID) as ID,Cat1 From Records group by cat1) r 
INNER JOIN #Records t ON r.Cat1 = t.cat1 
Where t.cat1 is not null

declare
    v_sql varchar2(32767) := 'select 1 column1, 2 column2 from dual';
    v_cursor_id integer;
    v_col_cnt integer;
    v_columns dbms_sql.desc_tab;
begin
    v_cursor_id := dbms_sql.open_cursor;
    dbms_sql.parse(v_cursor_id, v_sql, dbms_sql.native);
    dbms_sql.describe_columns(v_cursor_id, v_col_cnt, v_columns);

    for i in 1 .. v_columns.count loop
        dbms_output.put_line(v_columns(i).col_name);
    end loop;

    dbms_sql.close_cursor(v_cursor_id);
exception when others then
    dbms_sql.close_cursor(v_cursor_id);
    raise;
end;
/

Output:
COLUMN1
COLUMN2

UPDATE webform_submitted_data as a, webform_submitted_data as b 
SET a.data = b.data WHERE a.sid = b.sid AND a.cid = 64 AND b.cid = 56

SELECT IFNULL((SELECT _id FROM empty_table LIMIT 1), 1)

ALTER proc [dbo].[prcAdvanceSearchUser] @username varchar(50) 
as 
begin 

select *,1 as tag from userdetails 
where vname like @username + '%' 

Union

select *,2 as tag from userdetails 
where vemail like @username + '%'

Union

select *,3 as tag from userdetails 
where vpassword like @username +'%'

order by tag

end

select s.uid ,
s.scenid,
group_concat(distinct b.badgeid) badges,
group_concat(distinct w.warningid)  `warnings`,
s.score,
s.attempts
from tblUserScenScores s
join tblUserWarnings w on(s.uid = w.uid and s.scenid = w.scenid)
join tblUserBadges b  on(s.uid = b.uid and s.scenid = b.scenid)
group by s.uid ,s.scenid

POST /service/$batch HTTP/1.1 
Host: host 
OData-Version: 4.0
Content-Type: multipart/mixed;boundary=batch_36522ad7-fc75-4b56-8c71-56071383e77b

--batch_36522ad7-fc75-4b56-8c71-56071383e77b
Content-Type: multipart/mixed;boundary=changeset_77162fcd-b8da-41ac-a9f8-9357efbbd

--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd
Content-Type: application/http 
Content-Transfer-Encoding: binary 
Content-ID: 1 

POST /service/Customers HTTP/1.1 
Host: host  
Content-Type: application/atom+xml;type=entry 
Content-Length: ### 

<AtomPub representation of a new Customer>
--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd
Content-Type: application/http 
Content-Transfer-Encoding: binary 
Content-ID: 2

POST $1/Orders HTTP/1.1 
Host: host 
Content-Type: application/atom+xml;type=entry 
Content-Length: ### 

<AtomPub representation of a new Order>
--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd--
--batch_36522ad7-fc75-4b56-8c71-56071383e77b--

# Microsoft Developer Studio Project File - Database Project
Begin DataProject = "Database Project"
   MSDTVersion = "80"
   SccProjectName = "SAK"
   SccLocalPath = "SAK"
   SccAuxPath = "SAK"
   SccProvider = "SAK"
 Begin Folder = "Changes"
      Script = "Create users table.sql"
 End
End

DECLARE @version_group int

select @version_group = version_replace from (you're missing this from your query) where id=@sid

Select 
  in_date, 
  Sum (case when item_code = item1 then 1 else 0 end) item1,
  Sum (case when item_code = item2 then 1 else 0 end) item2
From tbl
Group by in_date

SELECT MIN(ID), FileName
FROM YourTable
GROUP BY FileName

 SET @row := -1;
 UPDATE chart
 SET indx = @row := @row + 1
 WHERE report = 2
 ORDER BY indx

bcp AdventureWorks2012.Sales.Currency out Currency.dat -T -c -SServer1
bcp AdventureWorks2012.Sales.Currency in Currency.dat -T -c -SServer2

select *
from cards c
left join 
(
  select *
  from schedules s
  join users u on s.UserID = u.ID
  where u.ID = 1
) x on c.ID = x.CardID

Update T1
Set T1.EndDate = T2.StartDate
From [Table] T1
Inner Join [Table] T2 on T1.Id = T2.Id - 1

SQL Fiddle DEMO
SELECT class,
      SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) `M`,
      SUM(CASE WHEN gender = 'F' THEN 1 ELSE 0 END) `F`,
      COUNT(1) Total
FROM Table1
GROUP BY class

$db->select()
->from(array('a' => 'my_table'), array())
->join(array('b' => 'my_table'), 'b.Sender = a.Recipient', array('Recipient'))
->where('a.Sender = ?', $id)

MERGE INTO [Episode] AS T 
USING (
    SELECT [E], [1], [2], [3], [4] 
    FROM 
        ( 
             SELECT [E], [I], ROW_NUMBER() 
               OVER (PARTITION BY [E] ORDER BY [O]) AS rn
             FROM [ICD] 
        ) AS p
    PIVOT 
    (
       MAX([I]) 
       FOR rn IN ([1], [2], [3], [4])) AS p2
    ) AS S
ON T.[Epinum] = S.[E] 
WHEN MATCHED THEN
    UPDATE SET [DX1] = S.[1], [DX2] = S.[2], [DX3] = S.[3], [DX4] = S.[4];

SELECT c.city, t.time_slot 
FROM cities c
LEFT JOIN city_date d on d.city_id = c.id 
LEFT JOIN city_time t on t.city_date_id = d.city_id AND t.city_date_id = '1'

SELECT  DATEPART(YEAR,f_downloadtimestamp) as var_Year, 
        DATEPART(MONTH,f_downloadtimestamp) as var_Month,
        DATEPART(DAY,f_downloadtimestamp) as var_Day,
        COUNT(DISTINCT f_downloadIPaddress) Total_Downloads,
        COUNT(DISTINCT CASE WHEN f_product = 'Product A' 
                           THEN f_downloadIPaddress END) Downloads_Prod_A,
        COUNT(DISTINCT CASE WHEN f_product = 'Product B' 
                           THEN f_downloadIPaddress END) Downloads_Prod_B
FROM tb_downloads
GROUP BY DATEPART(YEAR,f_downloadtimestamp),
         DATEPART(MONTH,f_downloadtimestamp),
         DATEPART(DAY,f_downloadtimestamp)
ORDER BY var_Year desc, var_Month desc, var_Day DESC

,DECODE(IS_COMPLETED,'Y','<a href="f?p=&APP_ID.:1:&SESSION.::::P1_FILE_NAME:' || FAC_FILE.NAME ||'">View Detail</a>','N','') AS 'Detail'

select * 
from orders
where to_char(OrderDate,'MM') = to_char(add_months(sysdate,-1),'MM')

WHERE ...
  AND FIND_IN_SET(group_user.group_id, '64,66,63') > 0

select acc_yr, dev_age, state,
       (case when dev_age > 12 then rev12 else revenue end) as revenue, loss
from (select l.acc_yr, l.dev_age, l.state, r.revenue, l.loss,
             max(case when l.dev_age = 12 then r.revenue end) over (partition by l.acc_yr, l.state) as rev12
      from loss l left join
           revenue r
           on l.acc_yr = r.acc_yr and l.dev_age = r.dev_age and l.state = dev.state
     ) lr;

CREATE TABLE page (
  domain_name text,
  domain_suffix text,
  page_url text,
  page_title text,
  page_descr text,
  page_updated timestamp,      
  PRIMARY KEY ((domain_suffix, domain_name), page_updated)
);

SELECT Data_CardCustomer.Code,
    Isnull(Data_ActionPriceList.Price1 ,0) As price1,
    Isnull(Data_ActionPriceList.Price2 ,0) As price2, 
    Isnull(Data_ActionPriceList.Price3 ,0) As price3 
FROM Data_CardCustomer 
left join Data_ActionPriceList on Data_ActionPriceList.CustomerId=Data_CardCustomer.CustomerId and StockId=10005

SESSION 1                                  SESSION 2
--------------------------------           --------------------------------------
SELECT count(*) FROM test;
=> 10
                                           INSERT INTO test VALUES ('x');

SELECT count(*) FROM test;
=> 10 with read committed/serializable
=> 11 with read uncommited (dirty read)
                                           COMMIT;

SELECT count(*) FROM test;
=> 10 with serializable
=> 11 with read uncommitted/read committed

SELECT B.Book_ID
     , B.Book_Title
     , group_concat(A.Author_name order by ABP.Prec Desc separator ', ') as Authors
FROM Author_Book_Percent ABP
INNER JOIN AUTHORS A
  on ABP.Author_ID = A.Author_ID
INNER JOIN BOOKS B
  on ABP.Book_ID = B.Book_ID
GROUP BY B.Book_ID, B.Book_Title

select 'DROP TRIGGER ' || rdb$trigger_name || ';' from rdb$triggers
  where (rdb$system_flag = 0 or rdb$system_flag is null)

set delimiter //

create procedure iskanje(in naziv varchar(10))

BEGIN
    SELECT A.ime, A.opis, B.kategorija
    FROM file as A, cathegory as B
    WHERE A.ime LIKE concat('%',naziv,'%')
       OR A.opis LIKE concat('%',naziv,'%')
       OR B.kategorija LIKE concat('%',naziv,'%');
END//

set delimiter ;

Dim adapter As New SqlDataAdapter(cmd)
Dim ds As New DataSet
adapter.Fill(ds)

lsbDestination.DataTextField = "Company"
lsbDestination.DataValueField = "CustomerId"
lsbDestination.DataSource = ds.Tables(0)
lsbDestination.DataBind()

SELECT *
FROM posts p
WHERE NOT EXISTS(
    SELECT 1
    FROM comments c
    WHERE c.comment_date >= 'deadline'
    AND p.post_id = c.post_id
)

SELECT to_char(rs.cr_date, 'MM/DD/YYYY') as "Date",
       sum(case when rs.s_method Like '%RTS%' then 1 else 0 end) as "RTS Returned Orders"
FROM return_sku rs join
     order_sku os
     on os.ord_sku_id = rs.ord_sku_id
WHERE trunc(created_date) = trunc(SYSDATE)
GROUP BY to_char(rs.cr_date, 'MM/DD/YYYY');

<c:forEach var="row" items="${recordset.rows}">
  <tr>
    <td><c:out value="${row.INSEE_COMMUNE}"/></td>
    <td><c:out value="${row.NOM_COMMUNE_MIN}"/></td>
    <td><c:out value="${row.NOM_CC}"/></td>
  </tr>
</c:forEach>

UPDATE myTable old
  JOIN myTable new USING (id)
SET    new.start_year = old.end_year,
       new.end_year = old.start_year
WHERE  old.start_year > old.end_year

UPDATE YourTable set StateCol = replace(StateCol,'.','')

CREATE OR REPLACE FUNCTION test( p_test text[] )
  RETURNS void AS
$BODY$
BEGIN
  SELECT id FROM unnest( p_test ) AS id;
END;
$BODY$
  LANGUAGE plpgsql IMMUTABLE
  COST 1;

with 
count_table as (
     select 1001 device_id,  4 quantity from dual union all
     select 1002 device_id, 20 quantity from dual union all
     select 1003 device_id,  1 quantity from dual 
),
device_table as (
     select 1001 id, 'Yes'     wifi, 'No'       email, 'No'  bluetooth from dual union all
     select 1002 id, 'Yes'     wifi, 'Yes'      email, 'No'  bluetooth from dual union all
     select 1003 id, 'Unknown' wifi, 'Unknown'  email, 'Yes' bluetooth from dual 
)
----------------------------------------
select * from (
      select
        feature,
        yes_no_unknown,
        sum(quantity)  quantity
      from 
         count_table  c join 
         device_table d on c.device_id = d.id
      unpivot  ( yes_no_unknown
                 for feature in (wifi, email, bluetooth)
      ) 
      group by 
      feature,
      yes_no_unknown
)  
pivot ( sum (quantity)
        -- only this line I have changed  ..
        for featur in ('WIFI' as Wifi, 'EMAIL' as Email, 'BLUETOOTH' as Bluetooth)
);

select 
  a.Id,
  a.Answer1, 
  a.Answer2, 
  a.Answer3, 
  a.Answer4,
  TopAnswers.*
from AnswerTable a
outer apply (
  select top 1 Answer, count(*) as cnt
  from (
    select Answer1 as Answer from AnswerTable where Id = a.Id
    union all
    select Answer2 from AnswerTable where Id = a.Id
    union all
    select Answer3 from AnswerTable where Id = a.Id
    union all
    select Answer4 from AnswerTable where Id = a.Id
  ) x
  group by Answer
  order by count(*) desc, Answer asc
) TopAnswers

select (case when ref like 'FA%' then 'FA' else 'OTHER' end) as grp,
       sum(ETILIQUIDO) as total
from pn where FDATA between #1# and #2#
group by (case when ref like 'FA%' then 'FA' else 'OTHER' end);

Private Sub TotalMonthlyEnquiries_Click()

    DoCmd.OpenForm "frmQuery2", acFormDS

    Forms!frmQuery2.Filter = "Format([DateOfEnquiry], ""mmmm"") = '" & Me![Month] & "'"
    Forms!frmQuery2.FilterOn = True

End Sub

INSERT INTO sys.book 
SELECT * FROM syste.mytable
WHERE column1 = valueThatYouWantInTableBook

SELECT id, first_name, last_name 
FROM users 
WHERE (first_name LIKE 'jo%' OR last_name like 'jo%')

INSERT  Table2
        (Produce, Cust1_Totals, Cust2_Totals, Cust3_Totals)
SELECT  Fruit
,       SUM(case when Customer_ID = 1 then quantity end)
,       SUM(case when Customer_ID = 2 then quantity end)
,       SUM(case when Customer_ID = 3 then quantity end)
FROM    Table1
WHERE   Customer_ID IN (1,2,3)
GROUP BY 
        Fruit

select Id
from tbl
group by Id
having max(case when Code='a' then 0 else 1 end) = 0

SELECT   context, SUM(file_size) AS size 
FROM     content_resource
GROUP BY context
HAVING   SUM(file_size) > 5000000000

SELECT    ([Address Line 1] + ', ' + [Address Line 2] + ', ' + [Address Line 3] + ', ' 
          + Town + ', ' + Region + ', ' + Postcode) AS Address
FROM      TableName

select 0, sum(iif(coffee = 0, 1, 0)) as coffee, sum(iif(tea = 0, 1, 0)) as tea,
       sum(iif(water = 0, 1, 0)) as water, sum(iif(hot_choc = 0, 1, 0)) as hot_choc
from drinks d
union all
select 1, sum(iif(coffee = 1, 1, 0)) as coffee, sum(iif(tea = 1, 1, 0)) as tea,
       sum(iif(water = 1, 1, 0)) as water, sum(iif(hot_choc = 1, 1, 0)) as hot_choc
from drinks d
union all
select 2, sum(iif(coffee = 2, 1, 0)) as coffee, sum(iif(tea = 2, 1, 0)) as tea,
       sum(iif(water = 2, 1, 0)) as water, sum(iif(hot_choc = 2, 1, 0)) as hot_choc
from drinks d;

SELECT *
FROM (
    SELECT people.*,
        IF(gender=0, @mr:=@mr+1, @fr:=@fr+1) AS rank
    FROM people, (SELECT @mr:=0, @fr:=0) initvars
) tmp
ORDER BY rank ASC, gender ASC;

with ValidNumbers as (
     select 1 as begin_num, 10 as end_num from dual union all
     select 11, 20 from dual union all
     select 21, 30 from dual union all
     select 55, 70 from dual
    )
select v_begin, v_end,
       sum(1 + (case when v_end >= vn.end_num then vn.end_num else v_end end) -
           (case when v_begin >= vn.begin_num then v_begin else vn.begin_num end)
          ) as SumInRecords,
       max(1 + v_end - v_begin) as TheRange,
       (case when sum(1 + (case when v_end >= vn.end_num then vn.end_num else v_end end) -
                      (case when v_begin >= vn.begin_num then v_begin else vn.begin_num end)
                     ) =
                   max(1 + v_end - v_begin)
             then 'All' else 'Missing'
         end)
from ValidNumbers vn cross join
     (select 2 as v_begin, 8 as v_end from dual union all
      select 2, 18 from dual union all
      select 2, 28 from dual union all
      select 2, 38 from dual
     ) const
where v_begin <= vn.end_num and
      v_end >= vn.begin_num
group by v_begin, v_end;

create table a(line string) row format delimited fields terminated by '\A';

create view b as
select
regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 1) as col1,
regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 2) as col2,
regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 3) as col3,
regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 4) as col4,
regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 5) as col5,
split(regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 6), '\;') as rest
from a;

declare @totalProfitAndLoss decimal(18,0); --I'd go for BIGINT here unless you're sure you need 18 digits
declare @resultTable table (
    Particular varchar(100),
    Amount decimal(18,0),
    Particular2 varchar(100),
    Amount2 decimal(18,0));
insert into @resultTable exec ssspAccProfitAndLoss
select @totalProfitAndLoss = sum(Amount1) from @resultTable

+------------+---------------------------------+
    | SourceValue| DestinationValue After execution|
    +------------+---------------------------------+
    | 0.579      | 0.579                           |
    | 0.637      | 0.637                           |
    | 0.503      | 0.503                           |
    +------------+---------------------------------+

to_char(date_column, 'dd/mm/yyyy')

SET NOCOUNT ON;

DECLARE @sql NVARCHAR(MAX) = N'';

SELECT @sql += ' UNION ALL 
    SELECT [name] = ''' + QUOTENAME(name) + ''', 
    catalog_name = name COLLATE Latin1_General_CI_AI,
    is_importing
  FROM ' + QUOTENAME(name) + '.sys.fulltext_catalogs'
  FROM sys.databases WHERE database_id > 4;

SET @sql = 'SELECT [database] = d.name, 
    s.catalog_name,
    s.is_importing
FROM sys.databases AS d 
LEFT OUTER JOIN (' + STUFF(@sql, 1, 10, '') + ') AS s 
ON QUOTENAME(d.name) = s.name
WHERE d.database_id > 4;';

CREATE TABLE #temp(db SYSNAME, catalog_name NVARCHAR(255), is_importing BIT);

INSERT #temp EXEC sp_executesql @sql;

DECLARE @db SYSNAME, @catalog_name NVARCHAR(255), @is_importing BIT;

DECLARE c CURSOR LOCAL STATIC FORWARD_ONLY READ_ONLY
FOR SELECT db, catalog_name, is_importing FROM #temp;

OPEN c;

FETCH NEXT FROM c INTO @db, @catalog_name, @is_importing;

WHILE @@FETCH_STATUS = 0
BEGIN
    IF @catalog_name IS NULL
    BEGIN
        PRINT 'No catalogs for ' + @db;
    END
    ELSE
    BEGIN
        IF @is_importing = 1
        BEGIN
            PRINT 'Do something to ' + @db 
                + '(importing)';
        END
        ELSE
        BEGIN
            PRINT @db + ' is not importing.';
        END
    END
    FETCH NEXT FROM c INTO @db, @catalog_name, @is_importing;
END

CLOSE c;
DEALLOCATE c;

DROP TABLE #temp;

for e in Entry.objects.all():
    print e.headline

select (case when su1.id is not null and su2.id is not null then 'BOTH'
             when su1.id is not null then 'TYPE1'
             when su2.id is not null then 'TYPE2'
             else 'Neither'
        end)
from (select 999 as user_id from dual) u left join
     sub_user_1 su1
     on su1.id = u.user_id left join
     sub_user_2 su2
     on su2.id = u.user_id

select EOMonth(weeks), sum(month_summ)
from ((select weeks, year(weeks) as yy, month(weeks) as mm,
              (case when day(weeks) >= 7 then summ
                    else summ * day(weeks) / 7.0
               end) as month_summ
       from #old o
      ) union all
      (select dateadd(month, -1, weeks) as weeks,
              year(dateadd(month, -1, weeks)) as yy,
              month(dateadd(month, -1, weeks)) as mm,
              summ * (1 - day(weeks) / 7.0)
       from #old o
       where day(weeks) < 7
      )
     )
group by EOMonth(weeks);

SELECT @Average = 
   case
   when convert(int, @hour) <> 0 then convert(varchar(9), convert(int, @hour)) + ':'
   else ''
   end +   
   right('00' + convert(decimal(10,0), convert(decimal(18,2), @Mns)), 2) + ':' +
   right('00' + CONVERT(decimal(10,0), convert(varchar(10), @second)), 6)

SELECT   YearCreated, COUNT(*)
FROM     (SELECT    UserId, DATEPART(year, MIN(DateCreated)) AS YearCreated
          FROM      users
          GROUP BY  UserId) t
GROUP BY YearCreated

SELECT
  t.ID,
  count(case when A between 2 and 4 then ID end),
  AVG(case when B between 19 and 40 then B end),
  COUNT(case when C between 12 and 14 then id end)
FROM t
GROUP BY ID
UNION
select
  'Overall',
  count(case when A between 2 and 4 then ID end),
  AVG(case when B between 19 and 40 then B end),
  COUNT(case when C between 12 and 14 then id end)
FROM t

try
{
    // Create the TransactionScope to execute the commands, guaranteeing
    // that both commands can commit or roll back as a single unit of work.
    using (TransactionScope scope = new TransactionScope())
    {
        using (SqlConnection connection1 = new SqlConnection(connectString1))
        {
            // Opening the connection automatically enlists it in the 
            // TransactionScope as a lightweight transaction.
            connection1.Open();


           // Call sql stored procedure(SP1) to generate a reference Number                 

           SqlCommand command1 = new SqlCommand(commandText1, connection1);
           returnValue = command1.ExecuteScalar();


          //Begin loop. loop count would be number of records that are in a collection 
              //Insert records to database using another stored procedure(SP2) using the 
              //reference number generated in the previous step 
          //End Loop 

        }
        // The Complete method commits the transaction. If an exception has been thrown,
        // Complete is not  called and the transaction is rolled back.
        scope.Complete();
    }
}
catch (TransactionAbortedException ex)
{
    writer.WriteLine("TransactionAbortedException Message: {0}", ex.Message);
}

Use XML path for this.

select (select BandName+',' from BandMaster where BandId<100 for xml path('')) as NewColumnName

Try this

DELIMITER $$

CREATE PROCEDURE ABC()
BEGIN
  CREATE TEMPORARY TABLE tmpEnt SELECT 1;
END$$

CREATE PROCEDURE XYZ()
BEGIN
  INSERT INTO tmpEnt VALUES (100);
END$$

DELIMITER ;

CALL ABC; -- it will create temp. table
CALL XYZ; -- it will insert one more record into temp. table

SELECT * FROM tmpEnt;
+-----+
| 1   |
+-----+
|   1 |
| 100 |
+-----+

SELECT url,row_number FROM(
     SELECT url,row_number() OVER (PARTITION BY domain) FROM website
     WHERE domain IN
    (SELECT DISTINCT domain FROM link)  
) AS links 
WHERE row_number <= 10
LIMIT 25

select [Your column list] from tableA A
inner join tableB B
on A.EANno = B.EANno

union all

select [Your column list] from tableB B
where B.EANno not in (select distinct EANno from tableA)

select t1.*,t2.team as opponent, t2.group as opponentgroup, t2.country as opponent country
from table t1 inner join table t2 on t1.country<>t2.country and t1.group<>t2.group

CREATE OR REPLACE PROCEDURE TST_SMS_IN
(
--P_MSISDN NUMBER,
P_MOBILE_NO varchar2, 
P_SMS_BODY VARCHAR2,
p_IN_ID    INTEGER
)
IS

V_SYSTEM_DATE DATE;
V_YEAR NUMBER;
V_YEAR_SYSTEM NUMBER;
V_TABLE_NAME VARCHAR2(100) :='';
V_SQL VARCHAR2(1000) :='';
V_ERROR_MESSAGE VARCHAR2(1000) :='';

P_AVG NUMBER;
V_CREATED_BY NUMBER;

BEGIN
     INSERT INTO SMS_IN(IN_ID,MOBILE_NO,SMS_BODY,STATUS,USERS,REMARKS,IN_TIME) VALUES
     (SMS_IN_SEQ.NEXTVAL,P_MOBILE_NO,P_SMS_BODY,0,'gp','TEST',sysdate);

     p_IN_ID := SMS_IN_SEQ.CURRVAL;

     COMMIT;

END TST_SMS_IN;

SELECT * FROM table1 where ID in (SELECT min(ID) FROM table1 WHERE ID > 12)

ALTER TABLE DEPARTAMENTOS 
    ADD CONSTRAINT FK_DEPT_EMP FOREIGN KEY (numDirect) 
    REFERENCES EMPLEADOS(numEmpl)
    DEFERRABLE INITIALLY DEFERRED
    ;
ALTER TABLE EMPLEADOS 
    ADD CONSTRAINT FK_EMP_DEPT FOREIGN KEY (numDept) 
    REFERENCES DEPARTAMENTOS(numDept)
    DEFERRABLE INITIALLY DEFERRED
    ;

SET NOCOUNT ON
GO

    DECLARE @DataSource TABLE
    (
        [IssueDependencyId] BIGINT IDENTITY(1,1) NOT NULL,
        [IssueId] BIGINT NOT NULL,
        [DependsOnIssueId] BIGINT NOT NULL
    )

    INSERT INTO @DataSource ( [IssueId], [DependsOnIssueId])
    VALUES   (48, 0)
            ,(49, 48)
            ,(50, 48)
            ,(51, 48)
            ,(55, 48)
            ,(56, 48)
            ,(52, 49)
            ,(52, 50)
            ,(52, 51)
            ,(53, 52)
            ,(57, 54)
            ,(54, 55)
            ,(57, 56)

    ;WITH DataSource ([IssueId], [DependsOnIssueId], [Start_Point], [End_Point]) AS 
    (
        SELECT AnchorMebemr.[IssueId]
              ,AnchorMebemr.[DependsOnIssueId]
              ,0
              ,10
        FROM @DataSource AS AnchorMebemr
        WHERE AnchorMebemr.[IssueId] = 48
        UNION ALL
        SELECT RecursiveMebemer.[IssueId]
              ,RecursiveMebemer.[DependsOnIssueId]
              ,DS.[End_Point]
              ,DS.[End_Point] + 10
        FROM @DataSource AS RecursiveMebemer 
        INNER JOIN DataSource DS
            ON RecursiveMebemer.[DependsOnIssueId] = DS.[IssueId]

    )
    SELECT DISTINCT DS.[IssueId]
                   ,DS.[DependsOnIssueId]
                   ,DS.[Start_Point]
                   ,DS.[End_Point]
    FROM DataSource DS
    ORDER BY DS.[IssueId]
            ,DS.[DependsOnIssueId]

SET NOCOUNT OFF
GO

SELECT SUM(o.duration) / 60.00 AS duration
FROM dbo.tbl_chatMessages t1
  OUTER APPLY (
               SELECT TOP 1 
                 CASE WHEN DATEDIFF(second, t2.messageTime, t1.messageTime) > 600
                      THEN 0 
                      ELSE DATEDIFF(second, t2.messageTime, t1.messageTime) END
               FROM dbo.tbl_chatMessages t2
               WHERE t1.messageTime > t2.messageTime
               ORDER BY t2.messageTime DESC
               ) o(duration)

for (i in 1:1000) {
  tmp.ids <- ids[((i - 1) * 100 + 1) : (i * 100)]
  query <- paste0("SELECT * FROM myTable WHERE idvar IN (", 
                     paste0(tmp.ids, collapse = ", "),
                  ")")
  dbSendquery(con, query)
  fetch results, etc..
}

SELECT  *
        , COUNT(UserID) OVER(PARTITION BY UserID) AS 'Total'
FROM    TBL1 1  
        INNER JOIN TBL2 2 On 2.FK = 1.FK
        INNER JOIN TBL3 3 On 3.PK = 2.PK INNER JOIN TBL4 4 On 4.PK = 3.PK 
        LEFT OUTER JOIN TBL5 5 ON 4.PK = 5.PK 
WHERE   1.Date_Time_In BETWEEN '2010-11-15 12:00:00' AND '2010-11-30 12:00:00'
ORDER BY 
        4.Column, 3.Column, 3.Column2, 1.Date_Time_In DESC

CREATE table #msg(id integer, type integer, msg nvarchar(max), ts datetime)

INSERT INTO #msg VALUES (1, 2, 'user msg 1',     '2011-11-01 16:00')
INSERT INTO #msg VALUES (2, 2, 'user msg 2',     '2011-11-01 16:01')
INSERT INTO #msg VALUES (3, 1, 'operator msg 1', '2011-11-01 16:02')
INSERT INTO #msg VALUES (4, 1, 'operator msg 2', '2011-11-01 16:03')
INSERT INTO #msg VALUES (5, 1, 'operator msg 3', '2011-11-01 16:04')
INSERT INTO #msg VALUES (6, 2, 'user msg 3',     '2011-11-01 16:05')
INSERT INTO #msg VALUES (7, 2, 'user msg 4',     '2011-11-01 16:06')

;WITH
   o AS (
  SELECT id, ts, msg
  FROM   #msg
  WHERE  type = 1
  )
  ,u AS (
  SELECT id, ts, msg, (SELECT TOP 1 id FROM o
                       WHERE  o.ts <= x.ts ORDER BY ts DESC) AS o_id
  FROM   #msg x
  WHERE  type = 2
  )
SELECT o.msg, (SELECT u.msg + ',' FROM u WHERE  u.o_id = o.id
               ORDER  BY u.ts, u.id FOR XML PATH('')) AS u_msg
FROM   o
ORDER  BY o.ts

UPDATE A
SET
A.Balance = @Balance
, @PreBalance = @Balance
, @Balance = ( CASE WHEN (@Balance IS NULL OR @AccountType <> A.AccountType)
                    THEN 
                        CASE WHEN A.Balance - A.Due >= 0
                            THEN A.Balance
                            ELSE A.Balance + A.Due
                        END
                    ELSE 
                        CASE WHEN @Balance - A.Due >= 0 AND (@Flag = 1 OR @AccountNO <> A.AccountNO)
                              THEN @Balance
                              ELSE @Balance + A.Due
                         END
                END) - A.Due
, A.FLAG = @Flag
, @AccountNO = CASE WHEN A.Flag = 0 THEN A.AccountNO ELSE 'NoDueFoundForAcc' END
, @Flag = CASE WHEN @AccountType = A.AccountType 
                THEN 
                    CASE WHEN @PreBalance = @Balance 
                            THEN 0 
                            ELSE 1 
                        END
                ELSE 
                    CASE WHEN A.Balance - A.Due >= 0
                            THEN 1
                            ELSE 0 
                        END
                END
, @AccountType = A.AccountType
FROM #tempTable A

SELECT * FROM #tempTable A WHERE A.Flag = 1

CREATE TRIGGER [dbo].[TRIG_MyTable]
ON [dbo].[MyTable]
AFTER INSERT, UPDATE

AS 

DECLARE @INS int, @DEL int

SELECT @INS = COUNT(*) FROM INSERTED
SELECT @DEL = COUNT(*) FROM DELETED

IF @INS > 0 AND @DEL > 0 
BEGIN

    -- a record got updated, so log accordingly.

    INSERT INTO MyLogTable
    SELECT 'New Values', getdate() FROM INSERTED

    INSERT INTO MyLogTable
    SELECT 'Old Values', getdate() FROM DELETED

END

ELSE 
BEGIN

    -- a new record was inserted.

    INSERT INTO MyLogTable
    SELECT 'Insert', getdate() FROM INSERTED

END

Select min(ID), Name, min(value)
From yourtable
Group by  name

insert into DiscussionParticipation (User_id, Discussion_id) (

    select a.User_id as User_id, d.id as Discussion_id
    from Discussion d
    inner join Activity a on (a.id = d.Activity_id)

    union

    select r.User_id as User_id, d.id as Discussion_id
    from Discussion d
    inner join Response r on (r.Activity_id = d.Activity_id)

);

with location_code as (
select 'ASDFSFD' loc_code, 555555 zipcode from dual
union all select 'OUIXVCX', 555555 from dual
union all select '2KLJSDF', 555555 from dual
union all select '887CSD', 555555 from dual
)
select rtrim (xmlagg (xmlelement (e, loc_code || ',')).extract ('//text()'), ',') 
from location_code where zipcode = 555555;

select Parent,
max(case when Child='Color' then Value End) 'Color',
max(case when Child='Height' then Value End) 'Height',
max(case when Child='Width' then Value End) 'Width',
max(case when Child='Length' then Value End) 'Length'
from yourtable
group by Parent

SELECT id, chapter_id, question, answer 
FROM (SELECT IF(@chapterId=@chapterId:=chapter_id, @id:=@id+1, @id:=0) queNo, id, chapter_id, question, answer 
      FROM `questions`, (SELECT @chapterId:=0, @id:=0) AS A 
      WHERE `chapter_id` IN (19, 20, 21, 22, 23)
      ORDER BY `chapter_id`
     ) AS A 
WHERE queNo < 10

SUM(Totals) AS "Week Day Count"

WHERE ISNULL(Code4,SomeInteger)=SomeInteger

columnID
columnId
columnIDAlternative
columnIdAlternative
RASCScore
RascScore

column_id
column_id_alternative
rasc_score

SELECT *
  FROM table
 WHERE LOWER(A) = 'x'
   AND LOWER(B) IN ('w', 'y', 'z')

SELECT type, car_numbers, AVG(price) AS average_price
FROM (SELECT type_id, type, SUM(car_numbers) AS car_numbers
      FROM table1
      GROUP BY type_id) AS t1
JOIN table2 AS t2 ON t1.type_id = t2.type_id
GROUP BY type

CREATE EVENT DO_INSERT_OP
ON SCHEDULE
AT CURRENT_TIMESTAMP + INTERVAL 1 SECOND
DO INSERT INTO mytable (name,surname)
VALUES ('john','john');

select
    c.caseNo,
    max(e.eventDate) as eventDate
from
    cases c
    inner join events e on
        c.id = e.caseid
group by
    c.caseNo

select p.id, p.text, c.id, c.parent, c.feature
from Parents p
left join (select c1.id, c1.parent, c1.feature
             from Childs c1
             join (select p1.id, max(c2.feature) maxFeature
                     from Parents p1
                left join Childs c2 on p1.id = c2.parent
            group by p1.id) cf on c1.parent = cf.id 
                              and c1.feature = cf.maxFeature) c
on p.id = c.parent

DELIMITER //

CREATE FUNCTION STRINGDECODE(str TEXT CHARSET utf8)
RETURNS text CHARSET utf8 DETERMINISTIC
BEGIN
declare pos int;
declare escape char(6) charset utf8;
declare unescape char(3) charset utf8;
set pos = locate('\\u', str);
while pos > 0 do
    set escape = substring(str, pos, 6);
    set unescape = char(conv(substring(escape,3),16,10) using ucs2);
    set str = replace(str, escape, unescape);
    set pos = locate('\\u', str, pos+1);
end while;
return str;
END//

DELIMITER ;

SELECT MIN(time) time, status
  FROM
(
  SELECT time, status,
         @n := @n + 1 rnum,
         @g := IF(status = @s, @g + 1, 1) rnum2,
         @s := status
    FROM table1 CROSS JOIN (SELECT @n := 0, @g := 0, @s := NULL) i
   ORDER BY time 
) q
 GROUP BY rnum - rnum2

@PrePersist
void makeCreationTimestamp() {
 createdAt = System.currentTimeMillis();
}

SELECT name,gender from (
    SELECT name,gender,
           row_number() OVER(PARTITION BY gender ORDER BY name ASC) as rnk
    FROM YourTable)
WHERE rnk = 1

CREATE OR REPLACE TRIGGER trigger_name
BEFORE INSERT ON TABLE_NAME
FOR EACH ROW BEGIN 
   IF :new.NAME = 'Bob' then
      :new.VALUE := :new.VALUE + (:new.VALUE*0.25) ;
  END IF; 
END; 
/

select year,
count(distinct case when `Genre` = 'hip hop' then 1 end) as hiphop,
count(distinct case when `Genre` = 'pop-dance' then 1 end) as popdance
from tbl
group by year

select 
center_id, month_id, sales_amt,
(
sales_amt + 
lead (sales_amt,1,0) over (PARTITION BY center_id ORDER BY month_id desc) +
  lead (sales_amt,2,0) over (PARTITION BY center_id ORDER BY month_id desc) +
  lead (sales_amt,3,0) over (PARTITION BY center_id ORDER BY month_id desc)
) sales_4_month
from Sales

SELECT
PLSSUPostcode  
,case when CHARINDEX(' ', PLSSUPostcode) > 0 
 then SUBSTRING(PLSSUPostcode, 1, CHARINDEX(' ', PLSSUPostcode))
else PLSSUPostcode end AS PCode
FROM 
TblPostcodes

SELECT CASE 
           WHEN CAST(tDate as DATE) < CAST(GETDATE() as date) -- if older then Today
           THEN DATEADD(dd,-1,CAST(GETDATE() as date))        -- assgin yesterday's date
           ELSE CAST(tDate as date)                           -- use the date
       END as tDate, 
       SUM(tDuration-ISNULL(tDone,0)) as tToDo FROM tTable 

    WHERE .....conditions.....

    GROUP BY CASE 
           WHEN CAST(tDate as DATE) < CAST(GETDATE() as date) -- if older then Today
           THEN DATEADD(dd,-1,CAST(GETDATE() as date))        -- assgin yesterday's date
           ELSE CAST(tDate as date)                           -- use the date
       END   
    ORDER BY tDate

UPDATE test SET name = INSERT(name, LENGTH(name), 0, '_');

-- BAD! DO NOT DO THIS! --
insert customer (email, count) 
select 'foo@example.com', 0
where not exists (
      select 1 from customer
      where email = 'foo@example.com'
)

column = Production.t171.label('3harm')
column.quote = True
session.query(column)

select m.maker, t.type
from (select distinct maker from product) m cross join
     (select distinct type from product) t;

@Query("from table t where t.propertyOne in :param1 and (t.propertyTwo like :param2 or t.propertyThree like :param3 or t.propertyFour like :param4)")
List<Table> findByParams(@Param("param1") List<String> param1, @Param("param2") String param2, @Param("param3") String param3, @Param("param4") String param4);

SELECT * FROM table_a  WHERE CURDATE() <= date_created 

PLAYER_ATTEMPTS_TB::Game_Level

 SELECT CL.CompanyName, count([IncentiveId]) 
 FROM AdminInvoices
 INNER JOIN (select distinct AdminId, CompanyId from AdminClientSystem) as ACS
 ON AdminInvoices.AdminId = ACS.AdminId
 INNER JOIN ClientData
 ON ACS.CompanyId= ClientData.CompanyId
 GROUP BY CL.CompanyName
 ORDER BY CL.CompanyName ASC

INSERT INTO SecondTable
SELECT id, A, B, C
FROM CurrentTable

INSERT INTO ThirdTable
SELECT id, D, E
FROM CurrentTable

SQL> set long 5000
SQL> var c clob
SQL>
SQL> declare
  2      ctx dbms_xmlgen.ctxhandle;
  3  begin
  4      ctx := dbms_xmlgen.newcontext('select * from emp where deptno = 10');
  5      -- set EMPTY_TAG  flag
  6      dbms_xmlgen.SETNULLHANDLING (ctx, 2);
  7      :c := dbms_xmlgen.getxml(ctx);
  8  end;
  9  /

PL/SQL procedure successfully completed.

SQL>
SQL> print c

C
--------------------------------------------------------------------------------
<?xml version="1.0"?>
<ROWSET>
 <ROW>
  <EMPNO>7782</EMPNO>
  <ENAME>BOEHMER</ENAME>
  <JOB>MANAGER</JOB>
  <MGR>7839</MGR>
  <HIREDATE>09-JUN-81</HIREDATE>
  <SAL>2450</SAL>
  <COMM/>
  <DEPTNO>10</DEPTNO>
  <LEAVE_DATE/>
 </ROW>
 <ROW>
  <EMPNO>7839</EMPNO>
  <ENAME>SCHNEIDER</ENAME>
  <JOB>PRESIDENT</JOB>
  <MGR/>
  <HIREDATE>17-NOV-81</HIREDATE>
  <SAL>5000</SAL>
  <COMM/>
  <DEPTNO>10</DEPTNO>
  <LEAVE_DATE/>
 </ROW>
 <ROW>
  <EMPNO>8070</EMPNO>
  <ENAME>DUGGAN</ENAME>
  <JOB>SALES</JOB>
  <MGR>7782</MGR>
  <HIREDATE>19-NOV-09</HIREDATE>
  <SAL>2500</SAL>
  <COMM/>
  <DEPTNO>10</DEPTNO>
  <LEAVE_DATE/>
 </ROW>
</ROWSET>


SQL>

UPDATE your_table t1 -- Your table goes here
SET [Column3] = rand()
FROM your_table t2 -- and here
WHERE (t1.[Column1] = t2.[Column1] AND t1.[Column2] = t2.[Column2]) OR
    (t1.[Column1] = t2.[Column2] AND t1.[Column2] = t2.[Column1])

select convert(decimal(10,2),sum(balance)/100.0) as Balance   
from member

SELECT l.img_id, l.img_name, 
 (SELECT COUNT(*) FROM tbl_comments c WHERE i.img_id = c.img_id ) AS comment_count,
 (SELECT COUNT(*) FROM tbl_vote v WHERE i.img_id = v.img_id ) AS vote_count
FROM tbl_images i 

select e.*
from events e
where exists (select 1
              from events e2
              where e2.name = e.name and
                    year(e2.DateOfAttendence) = 2002
             );

CREATE TABLE Owner (
  ownerID int not null primary key indentity(1,0),
  FirstName varchar(255),
  LastName varchar(255),
  /* other fields here */
)
GO
CREATE TABLE Car
  carID int not null primary key identity(1,0),
  ownerID int not null references Owner(ownerID),
  /* other fields go here */
GO

/* a convenience, read only view to replace your old CAR OWNER table */
CREATE VIEW Car_Owner AS
  SELECT c.*, o.FirstName, o.LastName FROM Car c INNER JOIN Owner o ON c.ownerID = o.ownerID

SELECT   userID, game_level, SUM(score), x.avg
FROM     my_table JOIN (
           SELECT   AVG(CASE WHEN (@rank := (CASE
                      WHEN t.userID     = @userID
                       AND t.game_level = @gamelevel
                      THEN @rank + 1
                      ELSE 0
                    END) < 20 THEN score END)   AS avg,
                    @userID     := userID     AS userID,
                    @game_level := game_level AS game_level
           FROM     my_table,
                    (SELECT @rank := @userID := @game_level := NULL) init
           ORDER BY userID, game_level, date_of_attempt DESC
         ) x USING (userID, game_level)
GROUP BY userID, game_level

WITH t AS (
  SELECT
    Client,
    Task,
    Hours,
    ROW_NUMBER() OVER(PARTITION BY Client,Task,Date ORDER BY Date) rn,
    DATEPART(dw,date) DayOfWeek
  FROM MyTable
)
SELECT Client, Task, [1] Sun, [2] Mon, [3] Tues, [4] Wed, [5] Thu, [6] Fri, [7] Sat
FROM t
PIVOT(SUM(Hours) FOR DayOfWeek IN ([1],[2],[3],[4],[5],[6],[7])) p

select distinct owner
from all_tables
where table_name = 'mytable'

select e.name
from employee e
where
    -- Projects in department
    exists (
        select *
        from 
            workon w
            join project p
                on w.pid = p.pid
                and p.did = e.did
        where w.empid = e.empid
    )
    -- Projects out of department
    and exists (
        select *
        from 
            workon w
            join project p
                on w.pid = p.pid
                and p.did != e.did
        where w.empid = e.empid
    )

SELECT e.ID, e.firstName, e.lastName,ee.firstName, ee.lastName from employees e
JOIN employees ee
ON e.reportsTo=ee.ID

select distinct id, department 
from tbl

select day2,count(*), group_concat(id)
    from resultater
    group by day
    having count(*)>1;

select pm.post_id
from post_meta pm
where pm.key = 'coolness'
order by pm.value + 0;

strSQL = "SELECT tblCases.CaseNumber, tblCasesClients.ClientID" 
strSQL = strSQL & " FROM tblCases"
strSQL = strSQL & " LEFT JOIN tblCasesClients ON (tblCases.AgencyID = tblCasesClients.AgencyID)"
strSQL = strSQL & " AND (tblCases.CaseNumber = tblCasesClients.CaseNumber)"
strSQL = strSQL & " WHERE (((tblCases.CaseNumber) Like '*" & [Forms]![frmCaseSearch]![txtCaseFilter] & "*')" 

If Not IsNull([Forms]![frmCaseSearch]![cboClients]) Then
    strSQL = strSQL & " AND ((tblCasesClients.ClientID)=([Forms]![frmCaseSearch]![cboClients])))"
Else 
    strSQL = strSQL & ")"
End If

strSQL = strSQL & " ORDER BY tblCases.CaseNumber;"

Forms!frmCaseSearch!lstCases.RowSource = strSQL

 alter table university
      add constraint uni_name_uk unique (name_of_university);

SQL> SELECT rawtohex('Ý') FROM dual;

RAWTOHEX('Ý')
--------------
C39D

SELECT COLUMN1 FROM MYTABLE WHERE (COLUMN1 != 'A' OR COLUMN1 IS NULL)

    SQLiteDatabase db = sqlHelper.getWritableDatabase(); // get a writable database here
    db.beginTransaction();

    try {
        for (int insertQuery : listOfQueries) {  // loop through your records 
            db.insert(...);
        }

        db.setTransactionSuccessful();
    }
    finally {
        db.endTransaction();
    }

    db.close();

;WITH CTE AS (
select  case
            WHEN @Weight <= BP   then minimum
            when @Weight < value then Normal
            when @Weight >= value AND  @weight <= Q then Price
            WHEN @weight >= Value AND  @Weight >  Q then Price
        end as 'Price'
from    Waybill.RoutePrices inner join Waybill.RoutePriceQ on Waybill.RoutePrices.Id = Waybill.RoutePriceQ.RoutePriceId
where   RouteFrom = @from and routeTo = @to
)
SELECT TOP 1 *
FROM CTE 
ORDER BY Price

GROUP BY  t1.NumberID, t1.Copies, t1.NameStreet

Function FCN_QClip(strQRY As String) As String

     qds = CurrentDb.QueryDefs(strQRY).SQL

     FCN_QClip = qds

End Function

Declare @Resolution int = 3 -- resolution in hours

Select
    DateAdd(Hour, 
        DateDiff(Hour, 0, datetime) / @Resolution * @Resolution, -- integer arithmetic
        0) as bucket,
    Sum(values)
From
    table
Group By
    DateAdd(Hour, 
        DateDiff(Hour, 0, datetime) / @Resolution * @Resolution, -- integer arithmetic
        0)
Order By
    bucket

WHERE (INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Apple') > 0
      OR
      INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Park') > 0
      OR
      INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Shores') > 0)

delete games from games inner join 
    (select  min(id) minid, date, time,
             hometeam_id, awayteam_id, locationcity, locationstate
     from games 
     group by date, time, hometeam_id, 
              awayteam_id, locationcity, locationstate
     having count(1) > 1) as duplicates
   on (duplicates.date = games.date
   and duplicates.time = games.time
   and duplicates.hometeam_id = games.hometeam_id
   and duplicates.awayteam_id = games.awayteam_id
   and duplicates.locationcity = games.locationcity
   and duplicates.locationstate = games.locationstate
   and duplicates.minid <> games.id)

SELECT DISTINCT t1.Ebeln, t2.Ebelp, t1.Ekorg, t2.belnr, t3.netpr FROM TABLE1 t1
RIGHT JOIN TABLE2 t2 ON t1.EBELN = t2.EBELN
FULL JOIN table3 t3 ON t2.belnr = t3.belnr

select tmp.id, tmp.email, tmp.date_val, min(tmp.timestamp) from (
    select 
        id, 
        email, 
        timestamp, 
        date_format(from_unixtime(timestamp), '%e %b %Y') as date_val
    from email_table
) as tmp  
group by tmp.email, tmp.date_val

SELECT  timestamp, badge_id
FROM    mytable
GROUP BY
        timestamp, badge_id
HAVING  COUNT(*) > 1

UPDATE noeuds INNER JOIN 
(SELECT noeuds.* FROM noeuds WHERE (((noeuds.LONG_CABLE)=" 1") AND (noeuds.DELETED=" "))) a ON noeuds.n_amount = a.n_amount
SET noeuds.insee_com = a.insee_com, noeuds.rivoli = a.rivoli, noeuds.num_voie = a.num_voie

SELECT date, time, custom_id, Number
FROM traffic t
WHERE CONCAT(date, ' ', time) BETWEEN '01/06/2014 00:00' AND '01/10/2014 23:00'
AND Number = 
(SELECT MAX(CAST(Number as smallint)) FROM traffic WHERE t.date = date and t.custom_id = custom_id)
ORDER BY date, CAST(Number as smallint) DESC, custom_id

SELECT words, count(*), group_concat(idtag) as tags
FROM (SELECT idTag, GROUP_CONCAT(idWord order by position ASC SEPARATOR ' ') AS words
      FROM tTagWord
      GROUP BY idTag
     ) t
GROUP BY words
HAVING count(*) > 1;

Insert into child (`CASE`,`LASTNAME`,`FIRSTNAME`,`GENDER`,
                   `DOB`,`SSN`,`RACE`,`STREET`,`STREET2`,`CITY`,
                   `STATE`,`ZIP`,`PHONE`,`WORKPHONE`,`CELLPHONE`,
                   `PARENT NAME`,`GR`,`ADMITDATE`,`DISCHDATE`,
                   `WRK`,`WFIRSTNAME`,`WRKPHONE`)
VALUES ('null', 'Sivanesh', 'Jashawn', 'Male', '2002-03-08', 
        '206-80-2175', 'African American', '1689 Crucible Street', 
        'null', 'Pittsburgh', 'PA', '15210', '(412)458-3788', 
        'null', '(412)377-6079', 'Latel Williams', '2nd', '2010-03-17',
        'null', 'null', 'Addison', '(412)594-2545')
ON DUPLICATE KEY UPDATE 
        LASTNAME = 'Sivanesh',
        FIRSTNAME= 'Jashawn',...

Select * 
FROM test_table 
WHERE user_id = value 
AND date_added = (select max(date_added) 
   from test_table 
   where user_id = value)
SELECT
    cashier.cashier_name,
    COALESCE(gross_amount, 0) AS gross_amount,
    (CASE WHEN item.other_discount_type = 'PATRONAGE_CASH' THEN COALESCE(item.other_discount_amount, 0) ELSE 0 END) AS other_discount_amount,
    COALESCE(item.net_of_discount_amount, 0) AS net_of_discount_amount
FROM item_tbl item
    INNER JOIN (Select receipt_no, Max(payment_dt) payment_dt from payment_tbl Group By receipt_no) payment ON item.receipt_no = payment.receipt_no
    LEFT JOIN cashier_tbl cashier ON cashier.id = item.cashier_id
WHERE 
    AND date(payment.payment_dt) = to_date('31 May 2016', 'dd Mon YYYY')

Select item_descr, [shop1], [Shop2]
from 
(
  Select item_descr, shop_id, times
  from [Order]  
)p
pivot 
(
  sum(times)
  for shop_id in ([shop1], [Shop2])
)pvt;

select t.*
from t
group by val1
having count(*) = 1;

// fetch liferay's session factory
SessionFactory sessionFactory = (SessionFactory) PortalBeanLocatorUtil.locate("liferaySessionFactory");

Session session = null;

try {
    // open session using liferay's session factory
    session = sessionFactory.openSession();

    // fetches the query string from the default.xml
    String sql = CustomSQLUtil.get(FIND_ONLY_ACTIVE_SITES);

    SQLQuery sqlQuery = session.createSQLQuery(sql);

    // use portal class loader, since this is portal entity
    sqlQuery.addEntity("Group_", PortalClassLoaderUtil.getClassLoader().loadClass("com.liferay.portal.model.impl.GroupImpl"));

    return (List<Group>) QueryUtil.list(sqlQuery, getDialect(), 0, QueryUtil.ALL_POS);
}
catch (Exception e) {
    throw new SystemException(e);
}
finally {
    sessionFactory.closeSession(session); // edited as per the comment on this answer
    // closeSession(session);
}

SELECT o.OwnerName, i.Id, i.ItemName
FROM Items AS i
JOIN Owners AS o 
ON o.Id = i.OwnerId

FOR tbl IN (SELECT owner, table_name
              FROM dba_tables
             WHERE table_name = 'MYTABLE')
LOOP
  EXECUTE IMMEDIATE 'update ' || tbl.owner || '.' || tbl.table_name ||
                    '  set field1 = ''N'', ' ||
                    '      field2 = null ';
END LOOP;

select machine_id, (lastend - start_time) as down_time
from (select pt.*,
             lag(end_time, 1) over (partition by machine_id order by end_time) as lastend
      from process_time pt
     ) pt
where lastend is not null

function view( $id ) {
   // ....
   $this->Model->updateAll( 
       array( 'Model.viewcount', 'Model.viewcount + 1' ),
       array( 'Model.id', $id )
   );
}

CREATE INDEX idx_partial ON othertable (m_id)
WHERE (col1 is not null and col2 is not null and col3 is not null);

SELECT t1.Team, t1.Sprint,g.wh-SUM(t2.WorkHours)
 FROM tbl t1 JOIN tbl t2 ON t1.Team = t2.Team AND t2.Sprint <= t1.Sprint
 JOIN 
   (SELECT SUM(WorkHours) AS wh, Team  FROM tbl GROUP BY Team) g ON t1.Team=g.Team
 GROUP BY t1.Team, t1.Sprint,g.wh

select no from
(SELECT 1 a, 2 b FROM DUAL) dummy
unpivot (no for col in (a as 'A', b as 'B'))

 DECLARE @Table TABLE (
        column_a    INT          ,
        column_b    VARCHAR (128),
        column_c    VARCHAR (128),
        column_d    VARCHAR (128),
        column_date [time]         );

    INSERT  INTO @Table
    VALUES 
    ('1', 'test_1', 'test_1', 'type_1', '11:00'),
    ('2', 'test_2', 'test_2', 'type_2', '11:01'),
    ('3', 'test_3', 'test_6', 'type_2', '11:02'),
    ('4', 'test_4', 'test_4', 'type_3', '11:03'),
    ('5', 'test_2', 'test_6', 'type_2', '11:04'),
    ('6', 'test_1', 'test_2', 'type_1', '11:05');

    WITH     C
    AS       (SELECT *,
                     ROW_NUMBER() OVER (PARTITION BY column_d ORDER BY column_date DESC) AS RN
              FROM   @Table),
             ToCompare
    AS       (SELECT *
              FROM   c
              WHERE  Rn < 3
                     AND EXISTS (SELECT *
                                 FROM   c AS C2
                                 WHERE  C.column_d = C2.column_d
                                        AND Rn = 2))
    SELECT   T.column_a,
             NULLIF (T.column_b, T2.column_b) AS [column_b],
             NULLIF (T.column_c, T2.column_c) AS [column_c],
             T.column_d,
             T.column_date
    FROM     ToCompare AS T
             INNER JOIN
             ToCompare AS T2
             ON T.column_d = T2.column_d
    WHERE    T.Rn = 1
             AND T2.RN = 2
    ORDER BY T.column_a;

SELECT AVG(Salary) as AVERAGE,
       MAX(case when seqnum = cnt / 2 then salary end) as median,
       MAX(SALARY) as MAXIMUM, 
       MIN(SALARY) as MINIMUM,
       SUM(SALARY) as TOTAL,
       TOTAL as NUMBER_OF_EMP
FROM (SELECT e.*, 
             count(*) over () as total,
             row_number() over (order by salary) as seqnum
      FROM TblEmployees e
     ) e

SELECT 'Column1' as Name, Column1 as Value FROM my_table
UNION ALL
SELECT 'Column2' as Name, Column2 as Value FROM my_table
UNION ALL
SELECT 'Column3' as Name, Column3 as Value FROM my_table

   SELECT * FROM SYS.COLUMNS 
    WHERE NAME NOT IN (
      SELECT COLUMN_NAME
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_NAME = 'XXXX'
      AND CHARINDEX(COLUMN_NAME + ';', 'ABC;XYZ;') > 0
    );

SELECT DISTINCT AccountKey
FROM TABLE 
WHERE (ProductGroup = 'A' AND ProductVersion = 13) 
   OR (ProductGroup != 'A' AND ProductVersion = 19)

;WITH  Hierarchy AS
(
    SELECT DISTINCT  JID
            ,CAST(NULL AS DATETIME) EntryDate
            ,CAST(NULL AS DATETIME) RefundDate
            ,CAST(NULL AS VARCHAR(MAX)) Comments
            ,CAST(NULL AS BIT) Refund
            ,CAST(NULL AS VARCHAR(30)) ActionBy
            ,nLevel = 1
            ,CAST(NULL AS INT) AS CID
    FROM refundrequested
    UNION ALL
    SELECT   CAST(NULL AS INT) JID
            ,E.EntryDate
            ,E.RefundDate
            ,E.Comments
            ,E.Refund
            ,E.ActionBy
            ,H.nLevel+1
            ,H.JID  AS CID

    FROM refundrequested   E
    JOIN Hierarchy  H ON E.JID = H.JID

)

SELECT *
FROM Hierarchy
ORDER BY COALESCE(JID, CID) DESC, nLevel

ID    Version
 1        1
 2        2
 3        3
 1        4

SELECT  a.id ,a.[year],valA,valB
from(
SELECT id ,[year],SUM(Total_Volume)/ (count(distinct(month))*7) valA from TableA  
group by id,[year]) a INNER JOIN

(select id,[year],SUM(Total_volume)/(count(distinct(month))*5) valB
from TableA  
WHERE weekday NOT IN ('Friday','Saturday') 
group by station_id,[year]) b
on a.id=b.id and a.[year]=b.[year]

    INSERT INTO t_Duration
    SELECT 
        t.interval
        ,t.call_id
        ,t.agent_id
        ,t.service_id
        ,t.state
        ,t.duration
    FROM (
        SELECT 
            *
        FROM
            inserted AS i
        CROSS APPLY (
        SELECT 
            *
        FROM 
            fInterval2(i.state_time,i.end_time,15) AS iid
        ) AS ext
    ) AS t

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.Deployment.WindowsInstaller;
using System.IO;
using System.Text.RegularExpressions;

namespace SaveSqlStrings
{
    public class CustomActions
    {
        [CustomAction]
        public static ActionResult SaveSqlStrings(Session session)
        {
            StringBuilder sqlStrings = new StringBuilder();
            Database db = session.Database;
            View view = db.OpenView("SELECT * FROM `SqlString`");
            IList<string> SqlStringElements = db.ExecuteStringQuery("SELECT `String` FROM `SqlString`");
            Regex bracketedProperties = new Regex(@"\[(\b[A-Z_]*\b)\]");
            Regex formattedProperties = new Regex(@"{\[(\b[A-Z_]*\b)\]}");
            Regex openeningSquareBrackets = new Regex(@"\[\\\[\]");
            Regex closingSquareBrackets = new Regex(@"\[\\\]\]");
            string sqlDb_ = "";
            string sqlString = "";
            string Database = "";
            foreach (string dbString in SqlStringElements)
            {
                sqlDb_ = (string)db.ExecuteScalar("SELECT `SqlDb_` FROM `SqlString` WHERE `String` ='{0}'",dbString);
                sqlString = (string)db.ExecuteScalar("SELECT `SQL` FROM `SqlString` WHERE `String` ='{0}'",dbString);
                view.Close();
                view = db.OpenView("SELECT * FROM `SqlDatabase`");
                Database = (string)db.ExecuteScalar("SELECT `Database` from `SqlDatabase` WHERE `SqlDb`='{0}'", sqlDb_);
                if(bracketedProperties.IsMatch(Database))
                {
                    Database = bracketedProperties.Match(Database).Groups[1].Value;
                    Database = session[Database];
                }
                if (openeningSquareBrackets.IsMatch(sqlString))
                    sqlString = openeningSquareBrackets.Replace(sqlString, "[");
                if (closingSquareBrackets.IsMatch(sqlString))
                    sqlString = closingSquareBrackets.Replace(sqlString, "]");
                if(formattedProperties.IsMatch(sqlString))
                {
                    string propertyName = formattedProperties.Match(sqlString).Groups[1].Value;
                    string propertyValue = session[propertyName];
                    sqlString = formattedProperties.Replace(sqlString, propertyValue);
                }
                sqlStrings.AppendLine(String.Format("use {0}",Database));
                sqlStrings.AppendLine(sqlString);
            }
            string home = session["PersonalFolder"];
            string sqlPath = string.Concat(home, @"Script.sql");
            try
            {
                File.WriteAllText(sqlPath, sqlStrings.ToString());
            }
            catch (Exception ex)
            {
                session["FailedTowrite"] = sqlPath;
            }
            view.Close();
            db.Close();
            return ActionResult.Success;
        }
    }
}

CASE WHEN (CAST(SVS_DT AS DATE) - CAST(DSCH_TS AS DATE)) < 90 THEN 1 
                                                              ELSE 0 
     END AS FU90

LEFT(A.IVC_Number+'    ',6) INV_Nr , 

select 'max', max(thickness) value from thicknesses where thickness < requirement 
union
select 'min', min(thickness) value from thicknesses where thickness > requirement 

SELECT dbo.AlbumTags.Tag_Name, 
       COUNT(dbo.AlbumTagBridge.Tag_Id) AS Cnt
FROM dbo.AlbumTagBridge 
INNER JOIN dbo.AlbumTags ON dbo.AlbumTagBridge.Tag_Id = dbo.AlbumTags.Tag_ID
GROUP BY dbo.AlbumTags.Tag_Name

SELECT ads.id, ads.title, count(sign_ups.user_id) AS total
FROM sign_ups
RIGHT JOIN ads ON ads.id = sign_ups.ad_id
WHERE advertiser_id=1 AND sign_ups.user_id IS NOT NULL
UNION ALL
SELECT ads.id, ads.title, 0 AS total
FROM sign_ups
RIGHT JOIN ads ON ads.id = sign_ups.ad_id
WHERE advertiser_id=1 AND sign_ups.user_id IS NULL

create table house_law
(   -- the proposed up for vote
law_id varchar(50) NOT NULL PRIMARY KEY,
descr varchar(255)
);

insert house_law (law_id,descr) values ('HR-109B','Forbid driving near turtles');

create table house_rep
(   -- a session is say Monday to Friday, captures a start date
rep_id int not null PRIMARY KEY,
fullname varchar(80) not null,
party varchar(80)
);

insert house_rep (rep_id,fullname,party) values (1001,'Thomas Jefferson','Whig');
insert house_rep (rep_id,fullname,party) values (800,'fred','Abstain Party');
insert house_rep (rep_id,fullname,party) values (700,'stan','Abstain Party');

create table votes_cast
(law_id varchar(50) not null,
rep_id int not null,
the_vote varchar(20) -- for, against, abstain
);

insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',1001,'against');
insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',800,'abstain');
insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',700,'abstain');

-- get the results

select l.law_id,
l.descr,
sum(case when v.the_vote='for' then 1 else 0 end) for_votes,
sum(case when v.the_vote='against' then 1 else 0 end) against_votes,
sum(case when v.the_vote='abstain' then 1 else 0 end) abstain_votes
from house_law l
join votes_cast v
on v.law_id=l.law_id
group by l.law_id -- or a where close for 1 law in particular

CREATE PROCEDURE my_procedure_name AS
    v_file UTL_FILE.file_type;
BEGIN
   ...
END;
/

INSERT INTO tblinbox
/* 
   maybe add column definitions here to make it clearer
   column definitions could look like this:
    (
    someField,
    type,
    subject,
    LRN,
    content,
    `date`,
    newyearLevel,
    someOtherField,
    userType,
    id
    )
*/
SELECT
    '',
    '$sender',
    '$type',
    '$subject',
    '$LRN',
    '$content',
    '$date',
    '$newyearLevel',
    '',
    '$userType',
    id
FROM tblscholar
WHERE schoYear = '$newyearLevel'

create table XXX (
    key number primary key,
    parent number
)
/

alter table XXX add constraint XXX_FK foreign key (parent) references XXX
/

begin
 dbms_stats.gather_table_stats('ALERTS_OWNER','ASYNC_PROCESSING_REQUEST_T');
end;

SELECT CONVERT(CHAR(10), GETDATE(), 105)

result: 10-12-2015

Insert Into TargetDatabase.SchemaName.TableName (TargetColumn)
Select SouorceColumn
From SourceDatabase.SchemaName.TableName

SELECT 
    * 
FROM   
    emp 
WHERE   
    convert(datetime, date, 101)  BETWEEN (Getdate() - 6) AND Getdate() 
ORDER BY 
    date 

SELECT
T1.F01 AS UPC,
T2.F254 AS TheDate,
(SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 1 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS PURCHASED,
(SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 1 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_P,
(SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 2 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS SOLD,
(SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 2 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_S,
(SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 3 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS ADJUSTED,
(SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 3 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_A
FROM [STORESQL].[dbo].[COST_TAB] t1
LEFT OUTER JOIN [STORESQL].[dbo].[RPT_ITM_D] t2 
ON t1.F01=t2.F01 AND (F254='2011-10-1') and (F1034=1 or F1034=2 or F1034=3)
group by T1.F01, T2.F254
ORDER BY T1.F01, T2.F254

SELECT 
    MyTable.team AS team, 
    MyTable.rel AS rel,
    AVG(iif(Testable,1,0)) AS result
FROM MyTable 
WHERE 
    MyTable.team IN (1,2) 
    AND MyTable.rel IN (1,2,3) 
GROUP BY 
    MyTable.rel, 
    MyTable.team 
ORDER BY 
    MyTable.team, 
    MyTable.rel

SELECT Id,
       Year,
       Type,
       Date,
       Amount - IFNULL((SELECT Amount
                        FROM data AS previousQuarter
                        WHERE previousQuarter.Year = data.year
                          AND previousQuarter.Type = data.Type
                          AND previousQuarter.Periods = data.Periods - 1
                       ), 0) AS Amount
FROM data

SELECT  CONVERT(VARCHAR(4),YEAR(LastModifedDate)) + ' ' + 
        CONVERT(VARCHAR(3),DATENAME(MONTH,LastModifedDate)) AS Dates,
        COUNT(*) as Number
FROM aims.Modification
WHERE CompanyID = @companyID 
    AND LastModifedDate >= DATEADD(MONTH,@numberOfMonths * -1,GETDATE())
GROUP BY CONVERT(VARCHAR(4),YEAR(LastModifedDate)) + ' ' + 
         CONVERT(VARCHAR(3),DATENAME(MONTH,LastModifedDate)),
         CONVERT(VARCHAR(6),LastModifedDate,112)
ORDER BY CONVERT(VARCHAR(6),LastModifedDate,112)

WHERE
    MD2.iBatchNumber = @iBatchNumber
ORDER BY
    MD2.sTableName, MD2.iRowIndex

select t.number, t.status,
       row_number() over (partition by status, grp order by number) as seqnum
from (select t.*,
             (row_number() over (order by number) -
              row_number() over (partition by status order by number
             ) as grp
      from table t
     ) t;

SELECT company_name, cnt
FROM (
    SELECT company_name, count(employee_name) AS cnt
    FROM works
    GROUP BY company_name
) w1
ORDER BY cnt DESC
LIMIT 1

DECLARE @result varchar(MAX)
SET @result = '';

SELECT 
  @result = @result + NAME + ','
FROM
  Table
WHERE
  ID = @Id

SET @result = SUBSTRING(@result, 1, LEN(@result) - 1)

SELECT @result

with j as ( select * from jobs )
select j.*, inv.*
from invoices inv
     join j on ( inv.job_no = j.job_no)
union
select j.*, inv.*
from invoices inv
     join j on ( inv.job_no = j.client_no)

CREATE OR REPLACE TRIGGER TBL_ADMINCOMMAND_TRG
BEFORE INSERT OR UPDATE ON tbl_AdminCommands
FOR EACH ROW 
BEGIN 
  IF inserting AND :new.ADMINCOMMANDID IS NULL
  THEN
    SELECT TBL_ADMINCOMMANDS_SEQ.nextval
      INTO :new.ADMINCOMMANDID
      FROM DUAL;
  END IF;
END;
/

ALTER TRIGGER TBL_ADMINCOMMAND_TRG ENABLE;

declare @s varchar(100)

select @s = 'http://info@abc.com'

select right(@s, len(@s) - charindex('@', @s))

UPDATE (PB 
INNER JOIN Noeuds ON PB.NOEUD = Noeuds.NOEUD) 
INNER JOIN ColInfo ON Noeuds.NUM_COL = ColInfo.NUM_COL 
SET PB.FORFAIT = "E"
WHERE (((ColInfo.INTEREXTER)=2));

select  t1.id
        , case
            when t1.value1=t2.value then t2.value
            else null
        end as value1
        , case
            when t1.value2=t2.value then t2.value
            else null
        end as value2
        , case
            when t1.value3=t2.value then t2.value
            else null
        end as value3
from temp1 t1
left join
temp2 t2 on ((t1.value1=t2.value) and (t1.id = t2.id))
            OR ((t1.value2=t2.value) and (t1.id = t2.id))
            OR ((t1.value3=t2.value) and (t1.id = t2.id))

CREATE PROC dbo.Paramtest (@foo int = 42)
AS
SET NOCOUNT ON;
GO

SELECT OBJECT_NAME(object_id), has_default_value, default_value
FROM sys.parameters
WHERE name = '@foo' AND object_id = OBJECT_ID('dbo.Paramtest')

-- gives Paramtest, 0, NULL

create view PAIRWISE_DISTANCE_SQUARES as
select 
  a.id as a_id,
  b.id as b_id,
  (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) as square
from point_table as a, point_table as b
-- where a.id != b.id if you wish

protected void HistoryEngine_AddedEntry(object sender, HistoryAddedEventArgs e)
{
    Item item = e.Database.GetItem(e.Entry.ItemId);
    //TODO: Add logic to make sure e.Entry.ItemId requires a parent/child reindex as well
    //TODO: Make sure that logic also prevents excessive or infinite recursion since we'll be triggering the AddedEntry event again below
    Item parent = item.Parent;
    //RegisterItemSaved doesn't appear to do anything with its second argument
    e.Database.Engines.HistoryEngine.RegisterItemSaved(parent, null);
}

;WITH Top10Distinct AS
(
    SELECT DISTINCT TOP 10 YourColumn
    FROM dbo.YourTable
    ORDER BY YourColumn DESC
)
SELECT *
FROM dbo.YourTable tbl
INNER JOIN Top10Distinct cte ON tbl.YourColumn = cte.YourColumn

SELECT 
    accommodation_id, 
    SUM(amount * persons) as max_persons_available 
FROM 
    availabilities 
WHERE 
    available = 1 and arrival >= '2015-12-19' and arrival < '2015-10-26'
GROUP BY 
    accommodation_id

select usrs.*
from students s 
join system_users usrs on 
    s.father=usrs.user_id OR
    s.mother=usrs.user_id OR
    s.guardian=usrs.user_id
where s.user_id = '201209291';

class procedure TdmodCheckDatabase.UpgradeDatabase(databasePath: string; currentVersion, newVersion: integer);
var
module: TdmodCheckDatabase;
f: integer;
begin
module:= TdmodCheckDatabase.create(nil);
try
  module.OpenDatabase( databasePath );

  for f:= 0 to module.ComponentCount -1  do
  begin
    if module.Components[f] is TDBISAMTable then
    begin
      try
        // if we need to upgrade table to dbisam 4
        if currentVersion <= DB_VERSION_FOR_DBISAM4 then
          TDBISAMTable(module.Components[f]).UpgradeTable;

        module.UpgradeTable(TDBISAMTable(module.Components[f]));
      except
       // logging and error stuff removed
      end;
    end;
  end;

  for f:= currentVersion + 1 to newVersion do
    module.RunUpgradeScripts(f);

  module.sqlMakeIndexes.ExecSQL; // have to create additional indexes manually
 finally
  module.DBISAMDatabase1.Close;
  module.free;
end;
end;


procedure TdmodCheckDatabase.UpgradeTable(table: TDBISAMTable);
var
 fieldIndex: integer;
 needsRestructure: boolean;
 canonical: TField;
begin
 needsRestructure:= false;

 table.FieldDefs.Update;

 // add any new fields to the FieldDefs
 if table.FieldDefs.Count < table.FieldCount then
 begin
   for fieldIndex := table.FieldDefs.Count to table.Fields.Count -1 do
   begin
     table.FieldDefs.Add(fieldIndex + 1, table.Fields[fieldIndex].FieldName, table.Fields[fieldIndex].DataType, table.Fields[fieldIndex].Size, table.Fields[fieldIndex].Required);
   end;
   needsRestructure:= true;
 end;

 // make sure we have correct size for string fields
 for fieldIndex := 0 to table.FieldDefs.Count -1 do
 begin
   if (table.FieldDefs[fieldIndex].DataType = ftString) then
   begin
     canonical:= table.FindField(table.FieldDefs[fieldIndex].Name);
     if assigned(canonical) and (table.FieldDefs[fieldIndex].Size <> canonical.Size) then
   begin
     // field size has changed
     needsRestructure:= true;
     table.FieldDefs[fieldIndex].Size:= canonical.Size;
   end;
   end;
 end;

 if needsRestructure then
   table.AlterTable(); // upgrades table using the new FieldDef values
end;

procedure TdmodCheckDatabase.RunUpgradeScripts(newVersion: integer);
begin
 case newVersion of
   3: sqlVersion3.ExecSQL;
   9: sqlVersion9.ExecSQL;
   11: begin  // change to DBISAM 4
         sqlVersion11a.ExecSQL;
         sqlVersion11b.ExecSQL;
         sqlVersion11c.ExecSQL;
         sqlVersion11d.ExecSQL;
         sqlVersion11e.ExecSQL;
       end;
   19: sqlVersion19.ExecSQL;
   20: sqlVersion20.ExecSQL;
 end;
end;

using (OleDbConnection connection = new OleDbConnection(connectionString))
{
    connection.Open();

    DataTable tableColumns = connection.GetOleDbSchemaTable(OleDbSchemaGuid.Columns, new object[] { null, null, "Streets", null }));
    foreach (DataRow row in tableColumns.Rows)
    {
        var columnNameColumn = row["COLUMN_NAME"];
        var dateTypeColumn = row["DATA_TYPE"];
        var ordinalPositionColumn = row["ORDINAL_POSITION"];
        ...
    }
}

 SELECT u.id, u.orderId, p.productName, u.key2, i.forced_matrix_sponsor_id
 FROM ubercart_reseller_orders u join
      productInfo p
      on p.productId=u.productId join
      ir i
      on u.key2=i.id
 where p.productName like '%OSS HOSTING FEE%' and
       u.createdDate > '2014-02-1' and
 ----------------------^
       forced_matrix_sponsor_id is null
 order by u.key2;

ALTER TABLE tableName ADD NewIdn INT NOT NULL AUTO_INCREMENT KEY

SELECT Position, Count(position) AS 'QTY'
FROM tblemployee
GROUP BY Position
HAVING Count(Position) != 1

mysql> select * from t;
+------+-------+
| id   | data  |
+------+-------+
|    1 | max   |
|    2 | linda |
|    3 | sam   |
|    4 | henry |
+------+-------+
4 rows in set (0.02 sec)

mysql> update t set data=concat(data, 'a');
Query OK, 4 rows affected (0.01 sec)
Rows matched: 4  Changed: 4  Warnings: 0

mysql> select * from t;
+------+--------+
| id   | data   |
+------+--------+
|    1 | maxa   |
|    2 | lindaa |
|    3 | sama   |
|    4 | henrya |
+------+--------+
4 rows in set (0.00 sec)

WITH t AS (
  SELECT row, scan, col, val
  FROM MyTable
  UNPIVOT(val FOR col IN ([1],[2],[3],[4],...<snip>...,[2570],[2571]))p
)
SELECT
  row, scan, col AS range_start, col + 15 AS range_end, min_val
FROM t t1
CROSS APPLY (
  SELECT
    MIN(t2.val) AS min_val
  FROM t
  WHERE
    row = t1.row AND
    scan = t1.scan AND
    col BETWEEN t1.col AND t1.col + 15
) t2

WITH cteRanges
AS
(
    SELECT
            site,
            CASE
              WHEN MONTH(date) IN (1) THEN CAST(YEAR(date) - 1 AS VARCHAR(4)) + '-8' + ' ' + CAST(YEAR(date) AS VARCHAR(4)) + '-1'
              WHEN MONTH(date) IN (8, 9, 10, 11, 12) THEN CAST(YEAR(date) AS VARCHAR(4)) + '-8' + ' ' + CAST(YEAR(date) + 1 AS VARCHAR(4)) + '-1'
              ELSE CAST(YEAR(date) AS VARCHAR(4)) + '-2' + ' ' + CAST(YEAR(date) AS VARCHAR(4)) + '-7'
            END AS range
    FROM
            test
)

SELECT
          site,
          COUNT(*),
          range
FROM
          cteRanges
GROUP BY
          site,
          range
ORDER BY
          range,
          site;

 ResultSet rs = ...
 ResultSetMetaData rsmd = rs.getMetaData();
 int numberOfColumns = rsmd.getColumnCount();
 String columnLabel = rsmd.getColumnLabel(1);
 String columnName = rsmd.getColumnName(1);
 int columnType = rsmd.getColumnType(1);
 String columnTypeName = getColumnTypeName(1);

 etc

DECLARE @var VARCHAR(100) = 'ABC' + CHAR(13) + CHAR(10);

SELECT @var = CASE WHEN @var LIKE '%' + CHAR(13) + CHAR(10) 
                 THEN LEFT(@var, LEN(@var) - 2)
                 ELSE @var
              END;


 SELECT @var, LEN(@var);

SELECT W.LastName + ', ' + W.FirstName AS [Worker], 
       M.LastName + ', ' + M.FirstName AS [Manager], 
       Details.SiteName AS [Site Name], 
       Details.Description AS [Description], 
       Details.Action AS [Action],
FROM Details 
INNER JOIN Staff AS W ON Details.Worker = W.StaffID 
INNER JOIN Staff AS M ON Details.Manager = M.StaffID

create table Drawing (
    DrawingId int not null primary key,
    Name varchar not null
)

create table ShapeKind (
    ShapeKindId int primary key,
    ShapeKindName varchar
)
insert into ShapeKind values (1, 'Line')
insert into ShapeKind values (2, 'Circle')

create table Shape (
    ShapeId int not null,
    ShapeKindId int not null,
    DrawingId int not null,
    CenterX numeric not null,
    CenterY numeric not null,
    SizeX numeric not null,
    SizeY numeric not null,
    Color int not null,
    primary key (ShapeId, ShapeKindId),
    foreign key (ShapeKindId) references ShapeKind (ShapeKindId),
    foreign key (DrawingId) references Drawing (DrawingId)
)

create table Line (
    ShapeId int not null,
    ShapeKindId int not null check (ShapeKindId = 1),
    LineWidth int not null,
    Orientation int not null,
    primary key (ShapeId, ShapeKindId),
    foreign key (ShapeId, ShapeKindId) references Shape (ShapeId, ShapeKindId)
)

create table Circle (
    ShapeId int not null,
    ShapeKindId int not null check (ShapeKindId = 2),
    FillColor int, -- null if not filled
    primary key (ShapeId, ShapeKindId),
    foreign key (ShapeId, ShapeKindId) references Shape (ShapeId, ShapeKindId)
)

SELECT name, GROUP_CONCAT(start_time ORDER BY start_time) AS start_times
FROM your_table GROUP BY name
ORDER BY COUNT(start_time)

ALTER proc [dbo].[sp_mysp]
@starttime datetime,
 @endtime datetime  
 as     
SELECT [Day],
        SUM(CASE WHEN [Type] = 'a' OR [Type] = 'c' THEN price ELSE 0.00 END) SELL,
        SUM(CASE WHEN [Type] = 'b' OR [Type] = 'd' THEN price ELSE 0.00 END) BUY
FROM    [TABLE]
WHERE   [Day] BETWEEN @starttime AND @endtime
GROUP BY    [Day]

select c.customer_id, 
       count(distinct o.order_id) distinct_orders,
       group_concat(distinct i.sku) ordered_item_skus
from customers c
left outer join orders o on c.customer_id = o.customer_id
left outer join order_items oi on o.order_id = oi.order_id
left outer join items  i on oi.item_id = i.item_id
group by c.customer_id

SELECT   m.* 
FROM     main_table m JOIN category_available c ON c.main_table_id = m.id
WHERE    c.category_id IN (206, 207)
GROUP BY m.id
HAVING   COUNT(DISTINCT c.category_id) = 2

SELECT 
    DATE_FORMAT(CHANGE_DATE, '%Y-%m') AS date,
    COUNT(DISTINCT CHANGE_ID) AS change_count,
    NAME
FROM 
    CHANGE_TABLE, (SELECT
       NAME AS name,
         COUNT(DISTINCT CHANGE_ID) AS changes
    FROM CHANGE_TABLE
    WHERE DATE(CHANGE_DATE) > DATE(now() - INTERVAL 1 MONTH)
    GROUP BY name
    ORDER BY changes DESC
) subq
WHERE CHANGE_DATE > curdate() - INTERVAL 10 MONTH AND change_table.name = subq.name
GROUP BY date, name

= "update table set name = '" & B1 & "' where namefk = '" & A1 & "'"

select '[''' || table1.collectdatetime as "['Date-Time",table1.cycletime as "'Time'" from table1 where interfacename='somename' and collectdatetime > (CURRENT_DATE - 1)
order by collectdatetime ASC;

SELECT *
FROM v$tempseg_usage

Select FROM_UNIXTIME(stime), bytes 
from argusTable_2009_10_22 
where stime > (UNIX_TIMESTAMP()-600)
group by floor(stime /10)

SELECT 
  'Quarter '+CAST(DATEPART(Q,DATEADD(MM,-3,GETDATE())) AS VARCHAR) AS QUARTER

select 
    t1.id,
    t1.time2-case when status='HOLD' then t2.time else 0 end-t1.time1
from
    t1 left join t2 on t1.id=t2.id and t2.status='HOLD'

@DatabaseField(dataType = DataType.BYTE_ARRAY)
byte[] imageBytes;

CREATE VIEW [dbo].[School_Year_Amount]
AS SELECT 
ISNULL(ROW_NUMBER() OVER (ORDER BY (SELECT NULL)), -1) AS sID,
Parent_Share_Amount.trans_name AS parent_trans_name,
OJT_Share_Amount.trans_name AS ojt_trans_name,
Parent_Share_Amount.ID_Number AS ID_Number, 
Parent_Share_Amount.adviser_info_id AS adviser_info_id, 
Parent_Share_Amount.student_fname AS student_fname,     
Parent_Share_Amount.student_lname AS student_lname,
Parent_Share_Amount.student_info_id AS student_info_id,
Parent_Share_Amount.amount AS parent_amount,
OJT_Share_Amount.amount AS ojt_amount,
isnull(OJT_Share_Amount.amount,0) + isnull(Parent_Share_Amount.amount,0) AS total_amount,
(120000 - isnull(OJT_Share_Amount.amount,0) - isnull(Parent_Share_Amount.amount,0)) AS total_balance
FROM [Parent_Share_Amount]
LEFT OUTER JOIN OJT_Share_Amount
ON Parent_Share_Amount.student_info_id = OJT_Share_Amount.student_info_id;

Select col1, col2, col3
From dbo.vw_MyView With (NoExpand)

CREATE VIEW test.t1 AS (
    SELECT 
        'pcount' AS type,
        `temp`.`pcount` AS value 
    FROM 
        `temp` 
    WHERE (
        `temp`.`id` = (
                SELECT 
                    MAX(`temp`.`id`) 
                FROM 
                    `temp`
        )
    )
    UNION 
    SELECT 
        'ncount' AS type,
        `temp`.`ncount` AS value 
    FROM 
        `temp` 
    WHERE (
        `temp`.`id` = (
                SELECT 
                    MAX(`temp`.`id`) 
                FROM 
                    `temp`
        )
    )
)

$params = array(
    ...
    'contain' => array(
        'Class' => array(
            'conditions' => array(
                'Class.exp IS NOT NULL', 
                'Class.tb <20',
            ),
            'fields' => array('a', 'b')
        )
    )
);

select
    <city_id>, c.y, count(t.city_id)
from generate_series(1990, 2005) as c(y)
    left outer join Table1 as t on
          c.y between extract(year from t.start_date) and extract(year from t.end_date) and
          t.city_id = <city_id>
group by c.y
order by c.y

SELECT * FROM numbers
WHERE id NOT IN (
    SELECT id FROM numbers
    WHERE val IN (
        SELECT MAX(val) FROM numbers
    ) OR val IN (
        SELECT MIN(val) FROM numbers
    )
);

select substring(reverse(str),
                 patindex('%[^0-9]%', reverse(str)),
                 1)

SELECT d.Department, d.DepartmentID, count(e.EmployeeID)
FROM Departments d
    LEFT JOIN employees e
    ON d.DepartmentID = e.DepartmentID
GROUP BY 
 d.Department, d.DepartmentID

Select p.ProductID , p.ProductDesc, count(p.ProductId)
from Product p
inner join OrderDetails od on p.productid = od.productid
inner join Order1 o on o.orderid = od.orderid
where orderpayment = 'cash'
Group by p.ProductID, p.ProductDesc

select 
  c.name as "Conference Name",
  c.Date, 
  coalesce(n2.name, n2."fallback_name") as "Main Contact",
  group_concat(coalesce(n.name, n."fallback_name"), ', ') as Attendees
from conferences c
inner join attendees a on c."Conference ID" = a."Conference ID"
inner join name n on n.id = a."Name Row"
inner join name n2 on n2.Contact_id = c."main_contact"
group by c.name 
order by c.date

DROP TABLE bar CASCADE CONSTRAINTS;

SELECT * FROM (
SELECT g.*,
@r:= CASE WHEN @g = g.`user` THEN @r +1 ELSE 1 END rownum,
@g:= g.`user` user_group
 FROM sn.sn_graph_reduced g
CROSS JOIN (SELECT @g:=0,@r:=0) t2
ORDER BY `user` , RAND() 
) t
 WHERE rownum <= 100 

DECLARE @OrigDate datetime
DECLARE @NewDate datetime

SET @OrigDate = '1/12/2012'

SET @NewDate = DATEADD(Day, -1, DATEADD(Month, 1, Cast(CAST(Month(@OrigDate) as varchar) + '/1/' + CAST((Year(@OrigDate)+1) as varchar) as datetime)))

SELECT DISTINCT c.Cust, options = ((SELECT c2.opt1 + c2.opt2 
  FROM dbo.myDB AS c2 WHERE c2.Cust = c.Cust 
  FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)'))
FROM dbo.myDB AS c;

SET NOCOUNT ON;

-- (use temp table, since table vars do not participate in transactions)
CREATE TABLE #T1(C int);
CREATE TABLE #T2(C int);
CREATE TABLE #T3(C int);
CREATE TABLE #T4(C int);
CREATE TABLE #T5(C int);

INSERT INTO #T1 SELECT 1;
INSERT INTO #T2 SELECT 1;
INSERT INTO #T3 SELECT 1;
INSERT INTO #T4 SELECT 1;
INSERT INTO #T5 SELECT 1;

BEGIN TRY 

    BEGIN TRAN TR1;

    DELETE FROM #T1;
    DELETE FROM #T2;
    DELETE FROM #T3;    
    DELETE FROM #T4;
    --select 1/0 as 'forced error @ stage1';
END TRY
BEGIN CATCH
    PRINT 'error @stage1';
    PRINT 'rollback @stage1';

    ROLLBACK TRAN TR1;  
    RETURN;
END CATCH

BEGIN TRY
    DELETE FROM #T5;
    select 1/0 as 'forced error @stage2';
    COMMIT TRAN TR1;
END TRY
BEGIN CATCH
    PRINT 'error @stage2';  
    ROLLBACK TRAN TR1;  

    BEGIN TRY
        print 'redo delete T4'
        BEGIN TRAN TR2;
        DELETE FROM #t4;
        --select 1/0 as 'forced error @redo delete';
        COMMIT TRAN TR2;
    END TRY
    BEGIN CATCH
        ROLLBACK TRAN TR2;
        PRINT 'second chance delete from T4 failed';    
    END CATCH

END CATCH

select count(*) as count,'T1' as 'table' from #T1
union all
select count(*) as count,'T2' as 'table' from #T2
union all
select count(*) as count,'T3' as 'table' from #T3
union all
select count(*) as count,'T4' as 'table' from #T4
union all
select count(*) as count,'T5' as 'table' from #T5

DROP TABLE #T1;
DROP TABLE #T2;
DROP TABLE #T3;
DROP TABLE #T4;
DROP TABLE #T5;

SELECT domains.domainID, domainName, COUNT(*), SUM(uniqueUploads)
FROM domains
INNER JOIN files ON files.domainID = domains.domainID
INNER JOIN serverFiles on serverFiles.fileID = files.fileID
GROUP BY domains.domainID, domainName

SELECT 'EMAIL', Email.Email
  FROM Contacts.Email
 WHERE Email.ContactId = :contactId
UNION ALL
SELECT 'PHONE', Phone.Phone
  FROM Contacts.Phone
 WHERE Phone.ContactId = :contactId
 ORDER BY 1 -- put e-mail addresses before phone-numbers
;

=", '" & TEXT(ScriptSQL!L5, "yyyy-MM-dd") & "'"

SELECT activity
    ,DATEADD(wk, DATEDIFF(wk,0,Cast(starttime AS DATE)), 0) AS Week
    ,SUM(datediff(second, starttime, endtime)) / 60.0 AS TimePerDay
FROM cte WITH (NOLOCK)
WHERE starttime >= dateadd(week, @LastXWeeks, last_update)
GROUP BY activity
    ,DATEADD(wk, DATEDIFF(wk,0,Cast(starttime AS DATE)), 0)

SELECT * FROM Articles as a
INNER JOIN comments as c
ON a.articleId = c.ArticleId

select x.ID, x.mindate as FirstActionDate, x.FirstAction as FirstAction, y.maxdate as LastActionDate, y.LastAction as LastAction
from 
(
  --FirstDate and Action 
  select a.ID, a.mindate as mindate, t.action as FirstAction 
  from 
  (

    select ID, Min(date) as mindate
     from data
     group by ID
   ) a inner join data t on a.mindate = t.date
 ) x inner join 
  (
    --Last Date And Action
    select a.ID, a.maxdate, t.action as LastAction 
    from 
    (

      select ID, max(date) as maxdate
       from data
       group by ID
     ) a inner join data t on a.maxdate = t.date
  ) y on x.ID = y.ID

SELECT  a.*,
        b.key,
        COALESCE(c.value, b.default) Value
FROM    Objects a
        CROSS JOIN Attributes b
        LEFT JOIN Object_Attributes c
            ON  a.ID = c.object_id AND
                b.key = c.key
ORDER   BY a.ID, b.key

Select Distinct
  t1.id
From
  Table_1 t1
    Inner Join
  Table_1 t2
    On
      t1.Id = t2.Id And 
      t1.Boolean = True And 
      t2.Boolean = False And
      DateDiff(Second, t1.Timestamp, t2.Timestamp) Between 0 And 1

SELECT
  event.event_name,
  event.event_date,

  MAX(CASE WHEN participant.fighter_id = fighter.id THEN fighter.name   END) AS fighter,
  MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.wins    END) AS wins,
  MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.draws   END) AS draws,
  MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.losses  END) AS losses,

  CASE WHEN fight.winner = participant.fighter_id THEN 'Win'
       WHEN fight.winner IS NULL                  THEN 'Draw'
                                                  ELSE 'Loss' END            AS result,
  fight.method,

  MAX(CASE WHEN participant.fighter_id <> fighter.id THEN fighter.name  END) AS Opp,
  MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.wins   END) AS Opp_wins,
  MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.draws  END) AS Opp_draws,
  MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.losses END) AS Opp_losses      
FROM
  event
INNER JOIN
  fight
     ON event.id = fight.event_id
INNER JOIN
  participant
    ON participant.fight_id = fight.id
INNER JOIN
(
  SELECT
    participant.fighter_id,
    participant.fight_id,
    SUM(CASE WHEN prevFight.winner  = participant.fighter_id THEN 1 ELSE 0 END) AS wins,
    SUM(CASE WHEN prevFight.winner IS NULL)                                     AS draws,
    SUM(CASE WHEN prevFight.winner <> participant.fighter_id THEN 1 ELSE 0 END) AS losses
  FROM
    participant
  INNER JOIN
    fight
      ON  participant.fight_id = fight.id
  INNER JOIN
    participant        AS prevParticipant
      ON  prevParticipant.fighter_id = participant.fighter_id
  INNER JOIN
    fight              AS prevFight
      ON  prevFight.id              = prevParticipant.fight_id
      AND prevFight.fight_date_time < fight.fight_date_time
  GROUP BY
    participant.fighter_id,
    participant.fight_id
)
  AS record
    ON record.fight_id = participant.fight_id
INNER JOIN
  fighter
    ON fighter.id = record.fighter_id
GROUP BY
  event.id,
  fight.id,
  participant.fighter_id

SELECT CASE WHEN LTRIM(RTRIM(Desk_name)) LIKE '% %'  -- finds any space in string
            THEN Desk_name 
            ELSE Desk_name + ' mm'
       END AS Name, 
       head AS sector_head 
FROM   tableName

SELECT
ID,
Score,
ISNULL(convert(int, lead(Score) over(partition by id order by timestamp)), 0) 
- convert(int, Score)
FROM RiskPredLog 
-- where ID = '1002010'

A          R PROM
A            MACT           2A
A            MITEM         20A
A            MP             2A
A            MPITCL         2A
A            MSTDAT         8S 0
A            MEXDAT         8S 0
A            MLIST          8S 2
A            MRETAL         8S 2
A            MCOST          8S 2
A            MQTY          10S 0
A            MPCHNG         6S 0
A            MNPEFT        12A
A            MNSTDT         8S 0
A            MNEXDT         8S 0
A            MNLST          8S 2
A            MPNRTL         8S 2
A            MNCOST         8S 2
A            ZZ14           8A
A            MALPHA         8A
A            ZZ64         170A
A          K MITEM
A          K MP
A          K MPITCL

ALTER INDEX IX_Index ON dbo.Table
DISABLE ;

declare @v varchar(max) = 'bzip2,1,668,sometext'
select substring(@v, CHARINDEX(',', @v, CHARINDEX(',', @v, CHARINDEX(',', @v)+1)+1)+1, len(@v))

db.newColl.insert([a, b])

WHERE 0=1
 OR (owner_name = 'A' AND table_name = 'T1')
 OR (owner_name = 'B' AND table_name = 'T2')
 OR (owner_name = 'A' AND table_name = 'T3')

<security:http auto-config="true" use-expressions="true">
    <security:intercept-url pattern="/login" access="permitAll" />
    <security:intercept-url pattern="/registration" access="permitAll" />
    <security:intercept-url pattern="/**" access="isAuthenticated()" />
     ...
</security:http>

Tournament.objects.order_by(Func('date', function='"time"')).all()

SELECT c.*
FROM dbo_Contact AS c
WHERE
   c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise1, 'BOGUS') & '*' 
OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise2, 'BOGUS') & '*' 
OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise3, 'BOGUS') & '*' 
OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise4, 'BOGUS') & '*'

SELECT p.name, p.birth_date
    FROM Player p
        WHERE p.birth_date > '1986-04-30'
            AND p.birth_date < '1986-06-01';

SELECT Department,
   COUNT(DISTINCT ID) AS total, 
   COUNT(DISTINCT CASE WHEN course LIKE 'AS%' THEN id END) Total_AS 
FROM schedule 
GROUP BY Department 
ORDER BY Department ASC 

WITH cte 
     AS (SELECT ph.IC_PO_HEADER, 
                ph.PO_NUMBER, 
                ph.revision_number, 
                pl.ic_line_key, 
                pl.ic_po_line, 
                Row_number() 
                  OVER ( 

                    ORDER BY ph.IC_PO_HEADER, IC_LINE_KEY) Rn 
         FROM   PO_HEADER ph 
                INNER JOIN PO_LINE pl 
                        ON ph.po_number = pl.po_number 
         ) 
SELECT t1.IC_PO_HEADER, 
       t1.PO_NUMBER, 
       t1.revision_number, 
       t1.ic_line_key,
       t2.ic_line_key + t1.rn - 1, 
       t2.IC_PO_LINE + t1.rn - 1
FROM   cte t1
       INNER JOIN cte t2 
       ON t2.rn = 1

ORDER  BY IC_PO_HEADER

delete from tvsemp e
where rowid>(select min(rowid) from tvsemp m where e.ename=m.ename);

SELECT `mid`, `message`, `created_at`, 
        CASE WHEN (SELECT `uid` 
                   FROM `bulletin_message` AS t2 
                   WHERE t1.`bid` = t2.`bid` 
                   ORDER BY `mid` ASC LIMIT 1) = t1.`uid`  
               THEN 1 
             ELSE 0 
        END AS `is_op`            
FROM`bulletin_message` AS t1
ORDER BY `mid` ASC

BEGIN TRY
    BEGIN TRANSACTION

    INSERT INTO table1(col1, col2)
        SELECT DISTINCT col1, col2 FROM tbl

    INSERT INTO table2(col3, table1fk)
        SELECT
            t.col3,
            t1.Id
        FROM tbl t
        INNER JOIN table1 t1
            ON t1.col1 = t.col1
            AND t1.col2 = t.col2

    COMMIT TRANSACTION
END TRY

BEGIN CATCH
    IF (@@TRANCOUNT > 0) BEGIN
        ROLLBACK TRANSACTION
    END
    DECLARE
            @ErrorNumber    INT,
            @ErrorMessage   NVARCHAR(4000),
            @ErrorState     INT,
            @ErrorSeverity  INT,
            @ErrorLine      INT

    SELECT
        @ErrorNumber    =   ERROR_NUMBER(),
        @ErrorSeverity  =   ERROR_SEVERITY(),
        @ErrorState     =   ERROR_STATE(),
        @ErrorLine      =   ERROR_LINE(),
        @ErrorMessage   =   ERROR_MESSAGE()

    RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState)
    PRINT 'Error detected, transaction rolled back.'
END CATCH

SELECT C.Id AS CategoryId, C.Title AS CategoryTitle, N.Id, N.Title
From NewsCategories C
OUTER APPLY (
   SELECT TOP 10 *
   FROM News 
   WHERE CategoryId = C.Id
) AS N
ORDER BY C.Id Desc

SELECT
 t_cluster.id,
 t_cluster.name,
 t_cluster.desc,
 t_logging_max.xd1
FROM
 t_cluster
 LEFT OUTER JOIN
 (
  SELECT id, MAX(xd1) AS xd1
  FROM t_logging
  GROUP BY id
 ) t_logging_max ON t_cluster.id = t_logging_max.id
WHERE 
 t_cluster.id LIKE '%73%';

select   top 1
         [price]
from(
select  [id],
        [count],
        [price],
        sum([count]) over(order by [id]) as run_sum
from    tbl
) x
where    120 <= run_sum
order by run_sum

:connect server1
use DatabaseName
GO
:r StoredProcedure.sql
GO

:connect server2
use DatabaseName
GO
:r StoredProcedure.sql
GO

:connect server3
use DatabaseName
GO
:r StoredProcedure.sql
GO

 SELECT Customer_details.CUS_name, (SUM(SALES.Bill_Amount) - SUM(SALES.Recived_Amount)) as       Subtract,Customer_details.Cus_id

 from sales INNER JOIN Customer_details ON Customer_details.Cus_id=sales.Cus_id

 where SALES.Cus_id = 1 

 group by Customer_details.CUS_name,Customer_details.Cus_id

 order BY Cus_id

SELECT movie, string_agg(actor, ', ') AS actor_list
FROM   tbl
GROUP  BY 1;

with cte as
(select o.*, 
        case AdjustmentFlag when 1 then -1 else 1 end DrCr,
        row_number() over (partition by OrderId, Amount, case AdjustmentFlag when 1 then 1 end
                           order by AdjustmentFlag, Id) Rn
 from [Order] o)
select OrderId,
       max(case DrCr when 1 then Id end) DrId,
       sum(case DrCr when 1 then Amount else 0 end) DrAmount,
       max(case DrCr when 1 then AdjustmentFlag end) DrAdjustmentFlag,
       max(case DrCr when -1 then Id end) CrId,
       sum(case DrCr when -1 then Amount else 0 end) CrAmount,
       max(case DrCr when -1 then AdjustmentFlag end) CrAdjustmentFlag,
       sum(DrCr * Amount) BalanceAmount
from cte
group by OrderId, Amount, Rn
having sum(DrCr * Amount) >= 0 /* excludes unmatched cancelled orders */

declare @ctr integer

set @ctr = 1

while @ctr < 1000
begin

--Do your logic

select @ctr = @ctr + 1

end

cast(621*1.0/7 as Decimal(5,3))

SELECT a_id FROM mytable GROUP BY a_id HAVING count(a_id) > 1

SELECT p1.product_id,
       substring(
          ( SELECT ',' + engine_id
              FROM ProductEngine p2
              WHERE p2.product_id = p1.product_id
              FOR XML PATH('') ), 2, 4000)
       AS engine_id
      FROM Products p1;

WHERE  ( @param_1 is NULL or field_1 = @param_1)
       AND 
       ( @param_2 is NULL or field_2 = @param_2)
       AND
       ( @param_3 is NULL or field_3 = @param_3)

OPTOIN(RECOMPILE)

SELECT *
  FROM tower
 WHERE sitenumber NOT IN
     (SELECT sitenumber
       FROM sites)

columnname type

SELECT orderNumber FROM `order`
WHERE id IN (
    SELECT orderid FROM orderDetail od1
    INNER JOIN orderDetail od2
    USING (orderid)
    WHERE od1.reference = 'F40' AND od2.description = "Epee"
)

SELECT @StartTm=CASE WHEN @SOSlckTm=8 THEN
DATEADD(day,1,@SODocDueD)
end

CREATE INDEX ON my_table (name) WHERE name IS NOT NULL;

declare @t table ( group_code varchar(15))

insert into @t values ('122.2') ,('122.3' ) ,( '122.4' ) ,( '112.6'),( '112.0') , ( '119.1')

   SELECT  (left(group_code, 3)) as Grop, 
        count(left(group_code, 3)) as occurrence 
    from @t
        group by left(group_code, 3) 

select * from
(

    SELECT  (left(group_code, 3)) as Grop, 
        count(left(group_code, 3)) as occurrence 
    from @t
        group by left(group_code, 3) 
) a
join @t t on a.Grop  = left(t.group_code, 3)

SELECT 
 m.member_id,
 m.login, 
 p.type,
 CASE p.type 
   WHEN 1 THEN '<div id=1>' 
   WHEN 2 THEN '<div id=2>'
 END as MyDiv
FROM 
 permissions p
INNER JOIN members m ON p.member_id = m.member_id
WHERE 
 K_id = '$kid' 
ORDER BY p.type DESC

CREATE TABLE t1(id int primary key);
CREATE TABLE t3(id int primary key);
CREATE TABLE t2(t1_id int references t1(id), t3_id int references t3(id));
CREATE TABLE t4(id int primary key, t1_id int references t1(id));


CREATE FUNCTION Foo(@t4_id int, @t3_id int) 
returns int 
as 
begin  return (select count(*) from t2 where t3_id=@t3_id and t1_id in (select t1_id from t4 where id=@t4_id)); end;
GO;

CREATE TABLE t5(
  t4_id int references t4(id),
  t3_id int references t3(id),
  PRIMARY KEY (t3_id,t4_id),
  CHECK ( Foo(t3_id,t4_id)>0 )
);

select match_id from table_name where "AAA" in (player_1,player_2) and   
"BBB" in (player_1,player_2);  

Private Sub Detail_Format(Cancel As Integer, FormatCount As Integer)

    Me.MyTextBox = "<div><font face=Arial size=4 color=Blue>" & _
                   "<strong>My Blue Bold Text</strong></font></div>"

End Sub

SELECT DATALENGTH (
                    (SELECT *
                    FROM products
                    FOR XML RAW, ROOT('products')
                    ) 
                )

v_url := '<your url to the report>';
host ('cmd /c start '||v_url); 

DECLARE @minDateTime AS DATETIME;
DECLARE @maxDateTime AS DATETIME;

SET @minDateTime = '2014-01-13 02:00:00';
SET @maxDateTime = '2014-12-31 14:00:00';

;
WITH Dates_CTE
     AS (SELECT @minDateTime AS Dates
         UNION ALL
         SELECT Dateadd(hh, 1, Dates)
         FROM   Dates_CTE
         WHERE  Dates < @maxDateTime)
SELECT *
FROM   Dates_CTE
OPTION (MAXRECURSION 0) 

SELECT id
from table1 a FULL JOIN
     table2 b
     using (id) FULL JOIN
     table3 c
     using (id) FULL JOIN
     table4
     using (id);

EXAMPLE
CREATE OR REPLACE PROCEDURE target_deletion
IS
   number_of_the_job   NUMBER;
BEGIN
   DBMS_JOB.submit (number_of_the_job, 'begin stored_procedure_for_deletion; end;', SYSDATE);
END;
/

select exists(
    select 1
    from tbl_stats_assigned
    where username = 'abc'
);

select distinct r.risk_ID, r.title, ah.Approval_ID as Approver_ID  
from dbo.tbl_risk r left join
     dbo.tbl_Approval_History ah
     on ah.risk_ID = r.risk_ID and ah.Status_ID = 5 ;

select dvdID as 'unique number', count(*) as 'times hired' 
from MonthlyRental 
where month(dateHired) = 8 
group by dvdId

SELECT Id,
       Value
  FROM(SELECT Id,
              Value,
              COUNT(*) OVER (PARTITION BY Id) cnt,
              SUM(DECODE(Value, 'X', 1, 0)) OVER (PARTITION BY Id) sumx
         FROM your_table
      )
 WHERE cnt = 1 OR sumx = 0;

select t1.id,
  t1.name,
  t2.cnt
from yourtable t1
inner join
(
  SELECT max(id) id,
    COUNT(id) AS cnt
  FROM   yourtable
  GROUP  BY name
  HAVING cnt > 1
) t2
  on t1.id = t2.id

WITH CTE AS (
SELECT ID, Rating, CreatedDate, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY CreatedDate DESC) RowID
FROM [TABLESWITHJOIN]
)
SELECT *
FROM CTE
WHERE RowID = 1;

SELECT photo.src_big, photo.created, photo.modified, photo.owner, photo.aid, 
photo.caption FROM photo 
inner join album on album.aid = photo.aid 
inner join  friend on album.owner = friend.uid2 
WHERE uid1=me() or uid2 = me()
order by modified desc,created DESC LIMIT 30

SELECT CAST(ABS(CHECKSUM(Indicator)) % 220 AS TINYINT)   AS Indicator,
       CAST(CIndicator AS VARCHAR(100))                  AS CIndicator,
       CAST(ABS(CHECKSUM(SK_IndicatorL2)) % 220 AS TINYINT) AS SK_IndicatorL2,
       CAST(IndicatorL2 AS varchar(100))                   AS IndicatorL2

FROM   ( VALUES ('Alcohol',
       'Alcohol',
       'Audit C recorded',
       'Audit C recorded  (excluding screen in 3y prior to start of quarter)'),
                ('Alcohol',
       'Alcohol',
       'Community Detox and TH CAT',
       'Community Detox and TH CAT'),
                ('Alcohol',
       'Alcohol',
       'Follow Up appointment',
       'Follow Up appointment'),
                ('Healthy Lifestyles',
       'Healthy Lifestyles',
       'HealthyLifestyle-Aged 19-39',
       'HealthyLifestyle-Aged 19-39'),
                ('Healthy Lifestyles',
       'Healthy Lifestyles',
       'Aged 19-39 - BMI recorded',
       'Aged 19-39 - BMI recorded') ) AS Nis (Indicator, 
                                              CIndicator, 
                                              SK_IndicatorL2, 
                                              IndicatorL2)

TimeIn >= '1/8/1950' AND TimeIn < '1/9/1950' 
AND CASE WHEN TimeIn >= '1950-01-08' AND TimeIn < '1950-01-09' 
         THEN DATEADD(week, DATEDIFF(week, '1/8/1950', '9/14/2014'), TimeIn) 
    END >= '2014-09-14'

SELECT dT.partkey, dT.numreturns
FROM
   (SELECT O.o_partkey as partkey,
       SUM(CASE WHEN O.o_returnflag = 'R' THEN 1 ELSE 0 END) as numreturns       
    FROM [ORDER] O
    GROUP BY O.o_partkey) AS dT
ORDER BY dT.numreturns DESC;

timestampfield > current_timestamp - interval '1' hour

WITH RECURSIVE docCTE AS
(
    /* Recursive Seed */
    SELECT
        cast(null as int) as parentdoc
        documentID,
        0 as depth,
        documentid as originalDocument,
        CAST(null as varchar(100) as docpath
    FROM
        dbo.document
    Where originalDocID IS NULL

    UNION ALL

    /* Recursive Term */
    SELECT
        docCTE.DocumentID as parentdoc,
        document.documentID,
        depth + 1 as depth,
        docCTE.originalDocument,
        docCTE.Path + '>' + document.documentID
    FROM
        docCTE
        INNER JOIN dbo.document on doccte.document = document.originalDocID
    WHERE
        depth <= 15 /*Keep it from cycling in case of bad hierarchy*/

)

SELECT * FROM docCTE;

SELECT *
FROM    (
            SELECT *
            FROM TABLE
            WHERE event_time < NOW()
            ORDER BY event_time DESC
            LIMIT 2
        ) First2
UNION ALL
SELECT *
FROM    (
            SELECT *
            FROM TABLE
            WHERE event_time > NOW()
            ORDER BY event_time ASC
            LIMIT 1
        ) Next1
ORDER BY event_time

<?php
    class HompageController extends AppController {


    public function index(){
      ...

      //For us to be able to call a different Model if it doesnt have a relationship with this model. Instantiate Product Model
      $Products = ClassRegistry::init('Product');

      //to get the data in product database. you can do it in two ways
      //1. use the find method to get all data in Product database
      $myproducts = $Products->find('all');

      //2. or call some function in your Product model e.g. get_products() that return the data.
      $myproducts = $Products->get_products();


      //pass myproducts variable to homepage index
      $this->set('myproducts', $myproducts);


    }
?>

SELECT Branch AS 'Branch Code',
    SUM(CASE WHEN CustomerStatus_Value = 'E' THEN 1 ELSE 0 END) AS 'Created',
    SUM(CASE WHEN CustomerStatus_Value = 'A' THEN 1 ELSE 0 END) AS 'Active',
    SUM(CASE WHEN CustomerStatus_Value = 'B' THEN 1 ELSE 0 END) AS 'Blocked',
    SUM(CASE WHEN CustomerStatus_Value = 'C' THEN 1 ELSE 0 END) AS 'Cancelled',
    COUNT(CustomerStatus_Value) AS 'All'
FROM CustomerStatusEntries
GROUP BY Id

Question                 Answer
--------                 ------ 
Question ID              Answer ID
Edit counter             Edit counter
Question text            Answer Text

select t1.TableID as TableID1,
    t1.StateValue as StateValue1,
    t2.TableID as TableID2,
    t2.StateValue as StateValue2,
    t1.StateDefinition  
from MyTable t1
inner join MyTable t2 on t1.TableID = 1 and t2.TableID = 2
where t1.StateValue = t2.StateValue 
    and t1.StateDefinition  = t2.StateDefinition 

CREATE OR REPLACE FUNCTION f_test(string1 varchar)
RETURNS VOID AS
$$
DECLARE
    string2 varchar = 'A1,A2,A3,A4,A5,A6,A7';
    string3 varchar;
    string4 varchar;
    string5 varchar;
    string6 varchar;
    intCount int;
BEGIN
    string3 := REPLACE(string1,',',' = 1 AND ')||' = 1';

    RAISE INFO '%',string3;

    string4 := REPLACE(string2,string1,string3);

    RAISE INFO '%',string4; 
select string_agg(c,' AND ') into  string6 from (
select  * from (
select c ||'= 1' c from (
select regexp_split_to_table(string2,',') c
)t 
where c in (select regexp_split_to_table(string1,','))
union all 
select c ||' IS NULL ' c from (
select regexp_split_to_table(string2,',') c
)t 
where  c  not in (select regexp_split_to_table(string1,','))
) t group by c order by c 
)t;
    RAISE INFO '%',string6; 
END;
$$
LANGUAGE PLPGSQL;

var app = Application;
var interval = TimeSpan.FromSeconds(1);
var windowSize = TimeSpan.FromSeconds(10);
var hopSize = TimeSpan.FromSeconds(1);

/* Replace the Observable.Interval with your logic to poll the database and
   convert the messages to instances of TPayload. It just needs to be a class
   that implements the IObservable<TPayload> interface. */
var observable = app.DefineObservable(()=> Observable.Interval(interval));

// Convert the observable to a point streamable.
var streamable = observable.ToPointStreamable(
            e=> PointEvent.CreateInsert(DateTimeOffset.Now, e),
            AdvanceTimeSettings.IncreasingStartTime);

/* Using the streamable from the step before, write your actual LINQ queries
   to do the analytics you want. */
var query = from win in streamable.HoppingWindow(windowSize, hopSize)
        select new Payload{
            Timestamp = DateTime.UtcNow,
            Value = win.Count()
        };

/* Create a sink to output your events (WCF, etc). It just needs to be a
   class that implements the IObserver<TPayload> interface. The
   implementation is highly dependent on your needs. */
var observer = app.DefineObserver(()=> Observer.Create<Payload>(e => e.Dump()));

query.Bind(observer).Run();

SELECT SUM(transaction_amount)
WHERE YEAR(transaction_date) = '2008'
GROUP BY YEAR(transaction_date)

SELECT VRI.Street_Number_and_Modifier 
    + CASE WHEN VRI.Street_Number_and_Modifier <> '' THEN ', ' ELSE '' END
       + VRI.Street_Direction
    + CASE WHEN VRI.Street_Direction <> '' THEN ', ' ELSE '' END
       + VRI.Street_Name
    + CASE WHEN VRI.Street_Name <> '' THEN ', ' ELSE '' END
       + VRI.Street_Direction
    + CASE WHEN VRI.Street_Direction <> '' THEN ', ' ELSE '' END
       + VRI.Street_Suffix
    + CASE WHEN VRI.Street_Suffix <> '' THEN ', ' ELSE '' END
       + VRI.Street_Post_Direction
    + CASE WHEN VRI.Street_Post_Direction <> '' THEN ', ' ELSE '' END
       + VRI.Unit
    + CASE WHEN VRI.Unit<> '' THEN ', ' ELSE '' END
FROM View_Report_Information_Tables VRI

CREATE PROCEDURE MyFolder_DeleteFolder

    @UserId  int

AS

SET NOCOUNT on

DECLARE @RowsDeleted int
SET @RowsDeleted = 1

WHILE @RowsDeleted > 0
 BEGIN
    --  Loop until a call to DELETE does not delete any rows
    DELETE Folder
     WHERE FolderID IN 
        (SELECT ch.FolderID
          FROM Folder ch 
           LEFT JOIN Folder p
            ON ch.ParentID = p.FolderID 
          WHERE p.FolderID IS NULL
           AND ch.ParentID > 0) 
        AND UserID = @UserID

    SET @RowsDeleted = @@rowcount
 END

RETURN 0

DECLARE @MaxKeyLength INT = (SELECT MAX(LEN([Name])) FROM testTable)


select '(''{' + cast(UniqueId as varchar(MAX)) + '}'',''' + LEFT(LTRIM([Name]) + ''',                                             ', @MaxKeyLength + 4) + ''''  + Address+ '''),'
from testTable;  

SELECT 
  a.id,
  b.id as AlternateID,
  a.value
FROM 
  (SELECT MIN(id) as id , value FROM YourTable GROUP BY value) a
JOIN YourTable b on a.value = b.value and a.id <> b.id

;WITH cte As
(
SELECT array_id, [date], comment,
ROW_NUMBER() OVER (PARTITION BY array_id ORDER BY [date] DESC) AS RN
FROM my_table
WHERE master_frame = 1
)

SELECT array_id, [date], comment
FROM cte 
WHERE RN=1;

UPDATE mytable
SET url = SUBSTRING_INDEX(url, '?', 1)

SELECT *
FROM
(
    **(**
        SELECT profileId
        FROM 
        (
            SELECT profileId
            FROM profile profile2
            WHERE profile2.profilePublishDate <= Now()
            ORDER BY profile2.profilePublishDate DESC
            LIMIT 0,40
        ) AS profile1
        ORDER BY RAND()
        LIMIT 0,20
    **)**
    UNION
    (
        SELECT profileId
        FROM profile profile4
        WHERE profileId NOT IN (
            SELECT profileId
            FROM profile profile4
            WHERE profile4.profilePublishDate <= Now()
            ORDER BY profile4.profilePublishDate DESC
            LIMIT 0,40
            )
        ORDER BY RAND()    
        LIMIT 0,40
    )
) TEMP
ORDER BY RAND();

select p.post_title,m.meta_key,m.meta_value 
from wp_post p 
join wp_postmeta m on p.id=m.post_id 
where p.post_status = 'publish' AND p.post_type = 'product' and
(m.meta_key='_price' or m.meta_key='_regular_price')

UPDATE tablename SET columName = columnName / 42 WHERE rowId !=42;

SELECT @var = ISNULL(MAX(Column1), 0)
FROM   myschema.mytable
WHERE  Id = @suppliedId; 

select c.cust_id, c.name, c.schema_id, s.period, s.amt, s.updated_date
from customer c
inner join
(
  select s1.schema_id, s1.period, s1.amt, s1.updated_date
  from `schemas` s1
  inner join 
  (
    select schema_id, max(updated_date) MaxDate
    from `schemas`
    group by schema_id
  ) s2
    on s1.schema_id = s2.schema_id
    and s1.updated_date = s2.maxdate
) s
  on c.schema_id = s.schema_id

select a_id from table_A_B
where b_id in ('a','c')
group by a_id having count(distinct b_id) = 2

select id as "#",first_name,last_name from student

insert into temp123(description) values('TESTING') returning 23,*;

regexp_replace( CUST_PART_NO, '(.*)(R)(.*)', '\3' )

SELECT 
     u.name 
FROM 
     friends f 
     JOIN users s ON (u.id = f.user_id_2) 
WHERE 
     f.user_id_2 = 1234

$ wdiff a b

# 1,"abc","( @docid =""00123"" or @docid =""00456"") AND [-a_number-] {+@a_number+} is not NULL"

SELECT `src`, `value`
FROM
(
    SELECT 'a' AS `src`, a AS `value` FROM yourtable WHERE id = 42
    UNION ALL
    SELECT 'b' AS `src`, b AS `value` FROM yourtable WHERE id = 42
    UNION ALL
    -- etc...
    UNION ALL
    SELECT 'j' AS `src`, j AS `value` FROM yourtable WHERE id = 42
) T1
ORDER BY `value`
LIMIT 3

  substring(fieldname,50,10)

query {
    for h in dc.Table do
    where h.SectorId.HasValue
    select h
}

For Each row As DataRow In dtDataTable.Rows
    If row.Item("fDateAdded") = *your match criteria* Then
        *Do something - you can utilies* row.Item("fName") *if you need*
    End if
Next row

select * from
(
select row_number()over(partition by id order by time desc) Rn,
       lag(item) over(partition by id order by time) prev_item,*
from yourtable
) A
Where Rn = 1

;WITH
    CTE1 AS
    (
        SELECT      Div, Dept,
                    REPLACE(States,' ','') + ',' AS States
        FROM        Table2
    ),
    CTE2 AS
    (
        SELECT      c1.Div, c1.Dept,
                    LEFT(c1.States,CHARINDEX(',', c1.States)-1)                 AS IndividualState,
                    RIGHT(c1.States,LEN(c1.States)-CHARINDEX(',', c1.States))   AS RemainingStates
        FROM        CTE1    c1
        UNION ALL
        SELECT      c2.Div, c2.Dept,
                    LEFT(c2.RemainingStates,CHARINDEX(',', c2.RemainingStates)-1),
                    RIGHT(c2.RemainingStates,LEN(c2.RemainingStates) - CHARINDEX(',', c2.RemainingStates))
        FROM        CTE2    c2
        WHERE       LEN(c2.RemainingStates) > 0
    ),
    CTE3 AS
    (
        SELECT      Div, Dept,
                    IndividualState,
                    COUNT(*)            AS StateCount
        FROM        CTE2
        GROUP BY    Div, Dept, IndividualState
    ),
    CTE4 AS
    (
        SELECT      t1.Div, t1.Dept,
                    (
                        SELECT  c3.IndividualState + ' - (' + CONVERT(varchar(10),c3.StateCount) + '), ' 
                        FROM    CTE3 c3
                        WHERE   c3.Div = t1.Div AND c3.Dept = t1.Dept
                        FOR XML PATH('')
                    )       AS States
        FROM        Table1  t1
    )

SELECT  Div, Dept,
        LEFT(States, LEN(States) - 1) AS States
FROM    CTE4

       SELECT @Result As ReturnVal

email
phone_number
address

SELECT [coly]/[table].[colx]... 

select c.*, m._id, m.message
from (select c.*,
             (select max(_id) as maxid
              from message m
              where c._id = m.conversationid
             ) as messageid
      from conversation c
     ) c join
     message m
     on c.messageid = m._id;

declare @p table(id int, name varchar(10))
declare @c table(id int, name varchar(10))
declare @pc table(pid int, cid int)

insert into @p (id, name) values (1, 'laptop')
insert into @p (id, name) values (2, 'desktop')
insert into @p (id, name) values (3, 'milk')

insert into @c (id, name) values (1, 'computer')
insert into @c (id, name) values (2, 'device')
insert into @c (id, name) values (3, 'food')

insert into @pc (pid, cid) values (1, 1)
insert into @pc (pid, cid) values (1, 2)
--insert into @pc (pid, cid) values (1, 3)
insert into @pc (pid, cid) values (2, 1)
insert into @pc (pid, cid) values (2, 2)
insert into @pc (pid, cid) values (3, 3)


declare @productId int;
set @productId = 1;

select * 
from @p p 
where  
--count of categories that current product shares with the source product 
--should be equal to the number of categories the source product belongs to
(
select count(*) 
from @pc pc 
where pc.pid = p.id
and pc.cid in (
      select cid from @pc pc
      where pc.pid = @productId
  )
) = (select count(*) from @pc pc where pc.pid = @productId)
and
p.id <> @productId

WITH cte AS (
SELECT  av.userid, av.DateofDays, SUM(rooms.max_guests * av.RoomAvailable) AS maxPeople 
FROM av AS av INNER JOIN rooms 
ON av.room = rooms.ID AND av.DateofDays BETWEEN '09/28/2012' AND '10/03/2012' 
GROUP BY av.userid, av.DateofDays
HAVING SUM(rooms.max_guests * av.RoomAvailable) >= 10 
)
select cte.userid 
from cte 
group by av.userid 
having COUNT(*) = 6

SELECT t1.a,t1.b,t1.c,t1.d,t1.e
FROM tablename AS t1
INNER JOIN (SELECT a, b, c, MAX(d) d
            FROM tablename
            GROUP BY a, b, c
           ) AS t2
ON  t1.a = t2.a
AND t1.b = t2.b
AND t1.c = t2.c
AND t1.d = t2.d

select
  r.employee, d.description
from
  table1 as d
  inner join (select min(rank) as rank, employee
              from
                 table1
              group by employee) r on d.rank = r.rank
                                      and d.employee = r.employee

CREATE VIEW [dbo].[myview] (a,b,c)
AS
SELECT a,b,CAST(NULL AS NVARCHAR(100)) c;

SET ARITHABORT OFF;
SET ANSI_WARNINGS OFF;

WITH Product(Quantity,StatusId) As
(
SELECT -2147483648,1
)
SELECT (CASE WHEN P.StatusId IN (5, 8) THEN 0 ELSE -P.Quantity END) AS Quantity  
FROM Product P

SELECT s.id, s.title, s.description, sq.cc  
 FROM  survey s  
 join ( SELECT ss.id, count(qq.id) as cc 
          FROM  survey ss  
          LEFT OUTER JOIN questionnaire q  
                ON q.survey_id = s.id  
         GROUP BY s.id 
      ) sq 
   on sq.id = s.id 

public override void Input0_ProcessInputRow(Input0Buffer Row)
{
    const string pFirstName = @"^[A-Z]([-']?[a-z]+)*";
    const string pSuffix = @"((Jr|Sr|I|V|X)( ?))*";
    const string pInitial = @"(?<=\s)[A-Z](?=\s)";
    const string pLastName = @"(?!(?:Jr|Sr|I|V|X|^))([A-Z][-'\s]?[a-z]+)";

    string fullName = Row.Name.ToString();
    string firstName = Regex.Match(fullName, pFirstName).Value;
    string suffix = Regex.Match(fullName, pSuffix).Value;
    string initial = Regex.Match(fullName, pInitial).Value;
    string lastName = Regex.Match(fullName, pLastName).Value;

    if (!string.IsNullOrEmpty(initial))
        lastName += " " + initial;

    if (!string.IsNullOrEmpty(suffix))
        lastName += " " + suffix;

    Row.FirstName = firstName;
    Row.LastName = lastName;
}

select wtdate, CONVERT(DATE,
        '20'+RIGHT(wtdate,2)
        +REVERSE(LEFT(SUBSTRING(REVERSE(wtdate),5,2)+'0',2))
        +LEFT(RIGHT(wtdate,4),2)
    ) AS ConvertedDate
from Trans
group by wtdate
order by wtdate

SELECT [FieldA], [FieldB], a.[FieldC], [FieldD], [FieldE]
FROM [TABLE] a
LEFT JOIN(
SELECT DISTINCT [FieldC], pwdencrypt([FieldC]) as [FieldE]
FROM [TABLE]) b
ON a.[FieldC] = b.[FieldC]

SELECT  ParticipantId 
FROM    Contact
WHERE   EXISTS
        (   SELECT  1
            FROM    Contact c2
            WHERE   c2.ParticipantID = c.ParticipantId
            AND     ContactTypeId = 1
            GROUP BY ParticipantID
            HAVING COUNT(*) > 1
            AND COUNT(CASE WHEN IsCurrent = 0 AND IsActive = 1 THEN 1 END) >= 1
        );

select k.*
from
(
  select 1 as pk
  union all
  select 3
  union all
  select 7
) k
left join your_table t on t.id = k.pk
where t.id is null

SELECT * from shops s 
WHERE s.shoptype = 0 
AND NOT EXISTS 
(SELECT 1 
 FROM  receipts r,
       receiptaddinfo ri
 WHERE r.receiptid = ri.receiptid 
 AND   r.shop = ri.shop
 AND   ri.shop = s.shop 
 AND   ri.creationtime >= '2016-05-19 00:00:00') 

SELECT B.PermissionId
    ,A.RoleId
FROM RolesPermissions A
INNER JOIN (
    SELECT PermissionId
    FROM RolesPermissions
    WHERE HasPermission = 0 --Get all permissions for user(Duplicates entries)
        AND RoleId IN (
            SELECT RoleId
            FROM aspnet_UsersInRoles
            WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c'
            )
    GROUP BY PermissionId
    HAVING Count(PermissionId) = (
            SELECT count(RoleId)
            FROM aspnet_UsersInRoles
            WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c'
            )
    ) AS B ON A.PermissionId = B.PermissionId Where HasPermission = 0
          AND A.RoleId IN (
            SELECT RoleId
            FROM aspnet_UsersInRoles
            WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c'
            )
    group by B.PermissionId,A.RoleId

SELECT GetName (empno) name
     , amount
FROM bonus;

insert into a (id, ... ) values 
(coalesce($1, uuid_generate_v4()), ... );

select a.a_name, a.max_b, count(*) as num_a_id from a join a_to_b on a.a_id=a_to_b.a_id group by a_id

declare @Yourtable table
 (SecID int, Date Date, Price int)

 INSERT INTO @Yourtable
SELECT 1,GETDATE()-5,10 union all
SELECT 1,GETDATE()-4,10 union all
SELECT 1,GETDATE()-3,5 union all
SELECT 1,GETDATE()-2,10 union all
SELECT 1,GETDATE()-1, 10

;WITH cte AS
(
SELECT SecID,Date,Price,
       ROW_NUMBER() OVER (PARTITION BY SecID ORDER BY Date) -
       ROW_NUMBER() OVER (PARTITION BY Price, SecID ORDER BY Date) AS Grp
FROM @Yourtable
)
SELECT SecID,Price, MIN(Date) StartDate, MAX(Date) EndDate
FROM cte
GROUP BY SecID, Grp, Price
ORDER BY SecID,  MIN(Date)

SELECT
    cr.TransID,
    MAX(inv.TransID) as InvoiceID,
    MAX(CASE WHEN inv.TransID is NULL THEN 1 ELSE 0 END) as Unsatsified
FROM
    @t cr
       left join
    @t inv
       on
           cr.Product = inv.Product and
           cr.OrderRef = inv.OrderRef and
           cr.Qty = inv.Qty and
           cr.Date = inv.Date and
           inv.TransType = 'Invoice'
WHERE
    cr.TransType = 'Credit'
GROUP BY
    cr.TransID
HAVING
    MAX(CASE WHEN inv.TransID is NULL THEN 1 ELSE 0 END) = 0

UPDATE DisplayArticles
SET    ArticleID = (SELECT MAX(ArticleID) 
                    FROM   Articles AS a                        
                    WHERE  a.CategoryID = CategoryID
                           AND ArticleID NOT IN (
                             SELECT ArticleID 
                             FROM   DisplayArticles da
                             WHERE  da.CategoryID = CategoryID 
                           )
                   )
WHERE  IsAuto = 'true'

SELECT plantname, orderfreq, totalincome 
FROM plantreview 
WHERE score >='5' 
AND recommended='1' 
ORDER BY score DESC
LIMIT 0, 5

SELECT 

    a.Geog1.STIntersection(b.Geog2) AS OverlapGeog
,   a.Geog1.STIntersection(b.Geog2).STArea() AS AreaOverlap
FROM
(
    SELECT 
    GEOGRAPHY::STGeomFromText('POINT(0.0 0.0)',4326).STBuffer(100) AS Geog1
) a
INNER JOIN
(
    SELECT 
    GEOGRAPHY::STGeomFromText('POINT(0.001 0.0)',4326).STBuffer(100) AS Geog2
) b
On
a.Geog1.STIntersects(b.Geog2) = 1

with ABCOrdered as
(
  select *
    , FirstEvent = row_number() over (partition by ID order by CODE_DATE)
    , LastEvent = row_number() over (partition by ID order by CODE_DATE desc)
  from ABC
)
select f.ID
  , [RESULT] = case
    when f.CODE_GROUP = l.CODE_GROUP or l.CODE_GROUP is null then f.CODE_GROUP
    else f.CODE_GROUP + ' THEN ' + l.CODE_GROUP
    end
  , EVER_APPROVED = case
    when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'APPROVED') then 'Y'
    else 'N'
    end
  , EVER_DENIED = case
    when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'DENIED') then 'Y'
    else 'N'
    end
  , EVER_ON_HOLD = case
    when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'ON HOLD') then 'Y'
    else 'N'
    end
from ABCOrdered f
  left join ABCOrdered l on f.ID = l.ID and l.LastEvent = 1
where f.FirstEvent = 1
order by f.ID

SELECT 
  TotalRooms = COUNT(*)
, StartDate = MIN(i.StartDate)
, EndDate =  MAX(i.EndDate)
FROM bookings b 
LEFT JOIN bookingitems bi 
  ON b.BookingID = bi.BookingID
GROUP BY b.BookingID
WHERE MIN(i.StartDate) >= '2010-01-01'
ORDER BY StartDate, EndDate

SELECT 
YEAR(your_column) AS the_year, 
DATE_FORMAT(your_column, '%b') AS the_month_abbreviated, 
GROUP_CONCAT(DATE_FORMAT(your_column, '%D') ORDER BY DAY(your_column) SEPARATOR ', ') AS the_days
FROM your_table
GROUP BY YEAR(your_column), DATE_FORMAT(your_column, '%b')
ORDER BY YEAR(your_column), MONTH(your_column)

SELECT source, user, COUNT(*)
FROM logs
GROUP BY source, user ;

start_date < sysdate - 30 / (24 * 60)

update ... set gameCapacity = gameCapacity -1 where ...

Category
----------
CategoryId
ParentCategoryId --nullable
CategoryName

select t.name as TableWithForeignKey, fk.constraint_column_id as FK_PartNo , c.name as ForeignKeyColumn 
from sys.foreign_key_columns as fk
inner join sys.tables as t on fk.parent_object_id = t.object_id
inner join sys.columns as c on fk.parent_object_id = c.object_id and fk.parent_column_id = c.column_id
where fk.referenced_object_id = (select object_id from sys.tables where name = 'TableOthersForeignKeyInto')
order by TableWithForeignKey, FK_PartNo

revoke all on all tables in schema information_schema from public;

Select p1.fkProductId From AttributeBindings p1
    inner join AttributeBindings p2 on p1.fkProductId = p2.fkProductId
where 
    (p1.fkAttributeId = 17 and p1.fkAttributeValueId = 97)
    and (p2.fkAttributeId = 6 and p2.fkAttributeValueId = 11)

SELECT * FROM test WHERE timestamp < date('now', '-2 days')

CASE 'some_expression'
   WHEN 1 THEN concat('Monday',first)
   WHEN 2 THEN concat('Tuesday',second)
   ELSE 'undefined'
END AS 'days_of_week'

declare @binaryS binary(180)
set @binaryS = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0700000000000000
declare @s varchar(max)
set @s = Convert(varchar(max), @binaryS, 2)
declare @seconds int
set @seconds = 0
declare @i int
set @i = 1
declare @t datetime
set @t = Convert(datetime, '01/01/2014', 101)
WHILE (@i <= 360)
BEGIN
    declare @segment varchar(max)
    set @segment = substring(@s, @i, 2)
    --print '0x' + @segment
    set @seconds = (convert(int, convert(varbinary, '0x' + @segment, 1))) * 15
    set @t = DATEADD(ss,480,@t)
    --print @seconds
    if(@seconds > 0)
      print @t
    set @i = @i + 2
END

USE AdventureWorks2008R2;
GO
WITH OrderedOrders AS
(
    SELECT SalesOrderID, OrderDate,
    ROW_NUMBER() OVER (ORDER BY OrderDate) AS 'RowNumber'
    FROM Sales.SalesOrderHeader 
) 
SELECT * 
FROM OrderedOrders 
WHERE RowNumber BETWEEN 50 AND 60;

select * from TABLE_2 where category_id in (select category_id from TABLE_1 where parent_id = 1) 

UPDATE LookUpWrkflwTemp
    SET SpiralUniverse = (SELECT Count(*)
                          FROM SpiralUniverse su
                          WHERE su.Date = LookUpWrkflwTemp.Date
                         )
    WHERE SprialUniverse IS NULL;

SELECT p.*
FROM categories c
JOIN relationships r ON c.cat_id = r.cat_id
JOIN products p ON r.prod_id = p.prod_id
WHERE c.name = 'Books' -- or specify parameter like @Books

select 
  name
from 
  (select 
    round((min(LATITUDE) + max(LATITUDE)) / 2) as LATITUDE,
    round((min(LONGITUDE) + max(LONGITUDE)) / 2) as LONGITUDE
   from STATION 
   where DISTRICT_ID = '110' 
     AND NAME LIKE 'Vancouver%') AS center
  inner join STATION s
where
  s.DISTRICT_ID = '110' 
  and s.NAME like 'Vancouver%'
  and s.LATITUDE between center.LATITUDE - 5 and center.LATITUDE + 5
  and s.LONGITUDE between center.LONGITUDE - 5 and center.LONGITUDE + 5

SELECT
    MT.some_date,
    COALESCE(ST.search_string, MT.column_1) AS my_group,
    MT.column_2,
    SUM(MT.column_3)
FROM
    My_Table MT
LEFT OUTER JOIN Search_Table ST ON MT.column_1 LIKE '%' + ST.search_string + '%'
GROUP BY
    MT.some_date,
    COALESCE(ST.search_string, MT.column_1) AS my_group,
    MT.column_2

CREATE TABLE Customers(ID INT IDENTITY(1,1),
                       CustomerName VARCHAR(100), Country VARCHAR(100));

INSERT INTO Customers (CustomerName, Country)
VALUES ('John', 'USA'), ('Martin','Germany');

INSERT INTO Customers (CustomerName, Country)
SELECT CustomerName, Country 
FROM Customers
WHERE Country='Germany';

SELECT *
FROM Customers;

CREATE PROCEDURE sort_Students_By_Avg (
    IN in_student_Id INT(11),
    OUT out_student_Name VARCHAR(20)
)
BEGIN
    SELECT s.name INTO out_student_name
    FROM student s
    WHERE s.id = in_student_Id AND s.avg > 70; 
END;

439 left outer join 365 on 439.C = 365.C
left outer join 444 on 365.K = 444.K left outer join T on 444.K = T.K 

SELECT array_agg(id) AS id, "value"
  FROM Two
 GROUP BY "value";

SELECT cname, GROUP_CONCAT(survey_id) as survey_ids
FROM categories 
GROUP BY cname

SELECT STAFF.Name
   ,STAFF.Position
   ,BRANCH.BranchID
FROM STAFF
INNER JOIN BRANCH
    ON STAFF.BranchID = BRANCH.BranchID
ORDER BY STAFF.Name;

;WITH CTE AS (
 SELECT a.BikePathId, c.ZipCodeId,
     Rnum =ROW_NUMBER() OVER (PARTITION BY a.BikePathId ORDER BY c.Boundary.STIntersection(d.Boundary))
 FROM      [dbo].[BikePaths] a
    INNER JOIN [dbo].[BikePathBoundaries] b on a.BikePathId = b.BikePathId
    INNER JOIN [dbo].[ZipCodeBoundaries] c on b.Boundary.STIntersects(c.Boundary) = 1
    INNER JOIN [dbo].[ZipCodes] d on c.ZipCodeId = d.ZipCodeId)
UPDATE a
SET a.ZipCodeId = cte.ZipCodeId
FROM [dbo].[BikePaths] a
    INNER JOIN cte on cte.bikepathid =a.bikepathid and cte.rnum=1;

SELECT e.event_id, COUNT(c.parent_id) as NumComments
FROM events e left JOIN
     comments c
     ON c.parent_id=e.id 
WHERE e.owner_id = X     
group by e.event_id;

WITH X AS ( SELECT id, min(value) as minval from Foo group by id )
SELECT * FROM 
(
    SELECT Foo.*, RANK() OVER ( PARTITION by Foo.id order by Foo.hid, Foo.value ) as Rank
    FROM Foo JOIN X on Foo.id = X.id and Foo.value = X.minval
) tmp
WHERE Rank = 1


id          hid         value       Rank                 
----------- ----------- ----------- -------------------- 
1           1           1           1
2           3           3           1
3           2           2           1

ALTER SYSTEM SET resource_limit = TRUE scope = BOTH 

WITH cte AS (SELECT DISTINCT * FROM Table2)
SELECT t1."pId" 
FROM Table1 t1 JOIN cte t2 ON t1."pId" = t2."pId"
WHERE t1."status" = 1 AND t1."keyVal" = 45
GROUP BY t1."pId"
HAVING SUM(
  CASE WHEN t2."mode"=2 AND t2."modeVal"=5 OR t2."mode"=3 AND t2."modeVal"=6 
       THEN 1 END) = 2 AND COUNT(*)=2

SELECT SUM(CASE WHEN pKey = 1 THEN 1 ELSE 0 END) 
     = SUM(CASE WHEN pKey = 2 THEN 1 ELSE 0 END)
FROM testable
WHERE prodStatus = 0

text VARCHAR2(10) generated always as 
    (cast(to_char(id)||'_'||to_char(num) as VARCHAR2(10))) VIRTUAL

UPDATE animal_attrib_values aav
SET animal_attrib_value_name= 'true'
WHERE aav.animal_attrib_value_id = (
    SELECT a.animal_attrib_value_id 
    FROM animals a 
    WHERE a.animal_id = 458 
        AND a.animal_attrib_type_id  = 38
)
;

UPDATE messages 
    SET message_deleted_from =  
    CASE WHEN message_user = ? 
    AND message_id = ? THEN 1 ELSE message_deleted_from END,

    messages_delete_to = 
    CASE WHEN message_to=? 
    AND message_id = ? THEN 1 ELSE messages_delete_to END

SELECT i.SenderNumber,
       COALESCE(c.Name, d.SpvName, sd.SpvName, v.SpvName) as Name,
       CASE WHEN c.Name IS NOT NULL THEN 'contact'
            WHEN d.SpvName IS NOT NULL THEN 'district'
            WHEN sd.SpvName IS NOT NULL THEN 'sub_district'
            WHEN v.SpvName IS NOT NULL THEN 'village'  
            ELSE ''
       END AS Type,
       i.Message
    FROM inbox i
        LEFT JOIN contact c
            ON i.SenderNumber = c.Number
        LEFT JOIN district d
            ON i.SenderNumber = d.Number
        LEFT JOIN sub_district sd
            ON i.SenderNumber = sd.Number   
        LEFT JOIN village v
            ON i.SenderNumber = v.Number   

select  datename(month,date) [month]
       ,isnull(sum(case when year(DATE) = 2015 then sales end), 0) as '2015'
from tblSales
where tenantcode = 'cmbina13'
group by  datename(month,date)
Order by DATEPART(MM,datename(month,date)+' 01 2011')

select listagg(source,',') within group (order by source) final_source from ( 
select
distinct
b.source source--,
from taba_parent a, taba b
where b.name = a.parent_name
and b.name_type = 'Category'
connect by prior a.parent_name = a.name
start with a.name = 'Name3'        
);

SELECT full_table.attribute, main_table.articleID FROM main_table
INNER JOIN full_table ON full_table.articleID = main_table.articleID 
INNER JOIN other_table ON other_table.attribute = full_table.attribute
GROUP BY full_table.attribute, main_table.articleID

result := REGEXP_REPLACE(subject, '_0+', '_', 1, 0, 'c');

SELECT p.NamePK, p.Name,
 STUFF((
        select '+' + n.Note
        from tblNote n
        where n.NameFK = p.NamePK
        for xml path('')
    ), 1, 1, '')
FROM tblPeople p

SELECT sp_id, company_name
FROM Student_Training
GROUP BY company_name

<?xml version="1.0" encoding="utf-16" standalone="no"?>
<DataMacros xmlns="http://schemas.microsoft.com/office/accessservices/2009/11/application">
  <DataMacro Event="BeforeChange">
    <Statements>
      <ConditionalBlock>
        <If>
          <Condition>Updated(&quot;ThingDateStamped&quot;)</Condition>
          <Statements>
            <ConditionalBlock>
              <If>
                <Condition>Not IsNull([Old].[ThingDateStamped])</Condition>
                <Statements>
                  <Action Name="RaiseError">
                    <Argument Name="Number">1</Argument>
                    <Argument Name="Description">An existing datestamp cannot be altered.</Argument>
                  </Action>
                </Statements>
              </If>
            </ConditionalBlock>
          </Statements>
        </If>
      </ConditionalBlock>
    </Statements>
  </DataMacro>
</DataMacros>

SELECT DISTINCT ON (release) *
FROM   release_country
ORDER  BY release, date_year, date_month, date_day;

mysql -u user -p dbnane

SELECT tag, (SELECT COUNT(1) 
             FROM tag_newPosts t2
             WHERE t2.tag LIKE CONCAT('%',t1.tag,'%')) AS tag_count
FROM tags t1;

SELECT DATEADD(month,6,DATEADD(yy, DATEDIFF(yy,1,GETDATE())-1,0)) AS StartDate
      ,DATEADD(month,6,DATEADD(dd,-1,DATEADD(yy, DATEDIFF(yy,0,GETDATE()),0))) AS EndDate

SELECT MAX(column_name) FROM table_name where column_name => 901000000

select Id,
    name,
    partnumber,
    param1,
    param2,
    param3, 
    stock,
    active 
    from (
        select *, 
            RANK() (parition by id, param1, param2, param3 order by stock desc) as max_stock 
            from product)x
        where max_stock = 1

CREATE TRIGGER trgAfterPersonInsert
ON dbo.Person AFTER INSERT 
AS BEGIN
   INSERT INTO dbo.Car(PersonID)
      SELECT i.PersonID 
      FROM INSERTED i
END

DECLARE @TableName SYSNAME = 'Address'
DECLARE @DataBaseName SYSNAME = 'AdventureWorks2008'

DECLARE @PrimaryKey VARCHAR(max) = '',
        @sql        NVARCHAR(max)

SET @sql ='SELECT @PrimaryKey += '',''+COLUMN_NAME FROM '
          + @DataBaseName + '.INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE TABLE_NAME = '''
          + @TableName
          + ''' AND CONSTRAINT_NAME LIKE ''PK%'''

--print @sql
EXEC Sp_executesql
  @sql,
  N'@PrimaryKey varchar(1000) output',
  @PrimaryKey output

SELECT RIGHT(@PrimaryKey, Len(@PrimaryKey) - 1) 

Select subject_id
    , Sum( Case When Score = 0 Then 1 Else 0 End ) As [0]
    , Sum( Case When Score = 1 Then 1 Else 0 End ) As [1]
    , Sum( Case When Score = 2 Then 1 Else 0 End ) As [2]
    , Sum( Case When Score = 3 Then 1 Else 0 End ) As [3]
    , Sum( Case When Score = 4 Then 1 Else 0 End ) As [4]
From Table
Group By subject_id

IF EXISTS (SELECT ClientId FROM Business WHERE UserId = @userId)
BEGIN
  SELECT DISTINCT Id
  FROM Client
END
ELSE
BEGIN
  SELECT Id
  FROM Client
  WHERE Id NOT IN
  (
    SELECT DISTINCT ClientId
    FROM Business
  )
END

' Note: This code requires the following COM reference:
'
' Microsoft Office 14.0 Access Database Engine Object Library
'
Dim dbe As New Microsoft.Office.Interop.Access.Dao.DBEngine
Dim db As Microsoft.Office.Interop.Access.Dao.Database = dbe.OpenDatabase("C:\__tmp\testData.accdb")
db.TableDefs("Users").Fields("UserName").AllowZeroLength = False

-- ----------------------------
-- Table structure for `gallery_album`
-- ----------------------------
DROP TABLE IF EXISTS `gallery_album`;
CREATE TABLE `gallery_album` (
  `album_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL COMMENT 'name of the album',
  `description` text COMMENT 'description of the album',
  `visible` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'is album visible',
  `position` int(11) unsigned NOT NULL,
  `date_created` datetime NOT NULL,
  `date_updated` datetime NOT NULL,
  PRIMARY KEY (`album_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for `gallery_image`
-- ----------------------------
DROP TABLE IF EXISTS `gallery_image`;
CREATE TABLE `gallery_image` (
  `image_id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(30) DEFAULT NULL COMMENT 'name of the image used as image ALT attribute',
  `description` varchar(100) DEFAULT NULL COMMENT 'description of the image used as image TITLE attribute',
  `visible` enum('0','1') NOT NULL DEFAULT '1',
  `date_created` datetime NOT NULL,
  `date_updated` datetime NOT NULL,
  PRIMARY KEY (`image_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Table structure for `gallery_relation`
-- ----------------------------
DROP TABLE IF EXISTS `gallery_relation`;
CREATE TABLE `gallery_relation` (
  `album_id` int(11) unsigned NOT NULL,
  `image_id` int(11) unsigned NOT NULL,
  `position` int(11) unsigned NOT NULL,
  PRIMARY KEY (`album_id`,`image_id`),
  KEY `image_id` (`image_id`),
  CONSTRAINT `gallery_relation_ibfk_1` FOREIGN KEY (`album_id`) REFERENCES `gallery_album` (`album_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `gallery_relation_ibfk_2` FOREIGN KEY (`image_id`) REFERENCES `gallery_image` (`image_id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

select *
  from all_objects
 where owner = 'OWNER_NAME'
   and object_name = 'ISEMPTY'
   and object_type = 'SYNONYM'

--create list of all possible category values (get first category from every row, then second, then third, etc)
declare @Category table (SingleCategory VARCHAR(50))
insert into @Category
select distinct LEFT(SingleCategory, charindex('~', SingleCategory))
from (
    select categories as SingleCategory from @News
    union
    select SUBSTRING(categories, charindex('~', categories)+1, 100) from @News where Categories like '%~%~'
    union
    select SUBSTRING(categories, charindex('~', categories, charindex('~', categories)+1)+1, 100) from @News where Categories like '%~%~%~'
    --repeat if 4 and 5 occurances possible, etc
) sq

--create a 'glue' table
declare @Glue table(ArticleId INT NOT NULL, DateAdded SMALLDATETIME NOT NULL, Category VARCHAR(50) NOT NULL)
insert into @Glue 
select articleid, dateadded, SingleCategory
from @News n
inner join @Category c on n.categories LIKE '%' + c.SingleCategory + '%'

--use the glue table to identify the articles we do want, and delete all the others
delete from @News where ArticleId not in (
    SELECT articleid
    FROM (
        SELECT articleid, Category, 
        RANK() OVER(PARTITION BY Category ORDER BY dateadded DESC) AS RankThem
        FROM @Glue
    ) sq
    WHERE RankThem <= 5
)

oMainQueryR = "SELECT * FROM DBSelections WHERE 0 = 1"

declare
  x sys.odcinumberlist := sys.odcinumberlist(123);
  y number;
begin
  select column_value into y from table(x);
  dbms_output.put_line(y);
end;

 AND (MATCH( T.truck_number, T.make, T.model, T.engine, T.vin_number,
      T.transmission_number, T.comments) AGAINST( '$vehicle' )
     OR MATCH( P.part_num, P.part_desc, P.part_ref,M.comments, M.work_done) 
     AGAINST( '$keywords' ))

WHERE people.LOGIN LIKE CONCAT(TRIM(IFNULL(expression, '')), '%')

select 
    [contact_list_name] as 'Table'
    , [ov_number_dialed] as 'Number Dialed'
    , convert(date, [time_of_contact], 101) as 'Date'
    , convert(time, dateadd(hour, -7,[time_of_contact]), 108) as 'Time'
    , agent_full_name as 'Agent'
    , max(case when [response_status] = 'DAM' then response_status end) as 'Disp1_DAM'
    , max(case when [response_status] = 'DNA' then response_status end) as 'Disp2_DNA'
    ...
FROM [meldb].[dbo].[cl_contact_event]
GROUP BY
    [contact_list_name] 
    , [ov_number_dialed] 
    , convert(date, [time_of_contact], 101) 
    , convert(time, dateadd(hour, -7,[time_of_contact]), 108) 
    , agent_full_name 

SELECT coalesce( maingroup, 'subgroup_total' ) As maingroup,
       coalesce( subgroup, 'group_total' ) As subgroup,
       count(*) cnt 
FROM very_complex_subquery
GROUP BY GROUPING SETS((maingroup, subgroup), (maingroup), (subgroup))
order by 1,2
;

SELECT PerceptionistID, SSNLastFour, SUM(CommissionPay) CommissionPay,
        SUM(PTOPay) PTOPay, SUM(HolidayPay) HolidayPay, SUM(Overtime) Overtime, SUM(TotalPay) TotalPay
FROM
(
    SELECT  PerceptionistID, SSNLastFour, CommissionPay,
        PTOPay, HolidayPay, Overtime, TotalPay
    FROM [dbo].fnCalculateCommissionForWeekOf(@MondayOfCurrentWeek)

    UNION ALL

    -- Need to get the following week's data and sum the two together
    SELECT  PerceptionistID, SSNLastFour, CommissionPay,
        PTOPay, HolidayPay, Overtime, TotalPay
    FROM [dbo].fnCalculateCommissionForWeekOf(@MondayOfFollowingWeek)
) t
GROUP BY PerceptionistID, SSNLastFour

SELECT Modules.UserID, Module_Info.ModuleTitle, Modules.ModuleMarks,
       Modules.ExamMark, Modules.AssignmentMark, MarkClassification.MarkDescription,
       (SELECT AVG(Modules.ExamMark) 
        FROM Module_Info 
        INNER JOIN Modules ON Module_Info.ModuleID = Modules.ModuleID
        WHERE (Modules.ModuleID = '2')) as Average
FROM Module_Info 
INNER JOIN Modules
 ON Module_Info.ModuleID = Modules.ModuleID 
INNER JOIN MarkClassification
 ON Modules.MarkCodeDescription = MarkClassification.MarkId
WHERE(Modules.UserID = '8')

SELECT DISTINCT ON (id) id, x, y FROM table

SELECT DISTINCT col_name 
FROM table_name
WHERE TRIM(col_name) != ''

SELECT * 
    FROM messages 
        LEFT JOIN users 
            ON messages.message_to = users.user_id OR messages.message_user = users.user_id 
        LEFT JOIN message_replies 
            ON messages.message_id = message_replies.message_reply_main 
        LEFT JOIN user_personal_information 
            ON users.user_id = user_personal_information.user_personal_information_user 
    WHERE message_replies.message_reply_date = (SELECT MAX(message_reply_date) FROM message_replies WHERE message_reply_main = messages.message_id) 
        /* AND more criterias */ 

SELECT M.id, 
       M.accnt, 
       amount = M.amount + Isnull(s.supply, 0), 
       issued = Isnull(I.issued, 0) 
FROM   maintbl M 
       LEFT OUTER JOIN (SELECT id, 
                               Sum(supply) AS supply 
                        FROM   supplytbl 
                        WHERE  Month(dates) = 1  -- Month filter for Jan - feb Month(dates) in (1,2)
                        GROUP  BY id) S 
                    ON s.id = M.id 
       LEFT OUTER JOIN (SELECT id, 
                               Sum(issued) AS issued 
                        FROM   issuedtbl 
                        WHERE  Month(dateissue) = 1 -- Month filter
                        GROUP  BY id) I 
                    ON I.id = M.id 

SELECT
    ct.competition_id FROM
    competitions c
JOIN competition_type ct ON ct.competition_id = c.id AND ct.Type_id = 1 
WHERE
    NOT EXISTS(SELECT * FROM competitions c2 
                     JOIN competition_type ct2 
                     ON ct2.competition_id = c2.id AND ct2.Type_id = 2 
                     WHERE c2.id = c.id)

select min(value) min, max(value) max
from (select value, ROW_NUMBER() over (order by value) - value as [key] 
      from t) v
group by [key]
order by min

SELECT * FROM TABLE_B B
WHERE EXISTS (SELECT field1 from TABLE_A A WHERE A.field1 = B.field1);

SELECT T.[taskId], T.[sectionId], T.[DateAdded],
   CASE 
      WHEN SectionId IS NULL THEN 1
      WHEN o.[type] = 6 THEN 2
      ELSE 3
   END AS [type]
FROM [TASK] AS T 
   -- Applicable join condition goes here ...
   LEFT OUTER JOIN Organisation o ON t.TaskID = o.TaskID
WHERE (T.[deleted] = 0)
ORDER BY T.[DateAdded]

DECLARE @i INT, @sql NVARCHAR(512), @tablename varchar(200) = 'tbl'

SET @sql = N'SELECT @i = COUNT(*) FROM '  + @tablename

EXEC sp_executesql 
    @query = @sql, 
    @params = N'@i INT OUTPUT', 
    @i = @i OUTPUT 

PRINT @i 

SELECT 
    name, 
    entnum,
    CASE 
        WHEN SUBSTRING(entnum,4,1) = '0' THEN SUBSTRING(entnum,5,2)
        ELSE SUBSTRING(entnum,4,3) 
    END agencycode
FROM CUSTFILE 

CREATE TABLE TBL (a int, b varchar(50))
go

INSERT INTO TBL SELECT 1,'hello'
INSERT INTO TBL SELECT 2,'goodbye'
go

GRANT SELECT, UPDATE ON TBL TO guest
go

CREATE TABLE AUDIT (    audittime datetime default(getdate())
    				,	targettable sysname
    				,	loginname sysname
    				,	spid int
    				,	sqltext	nvarchar(max))
go

CREATE TRIGGER TR_TBL ON TBL FOR INSERT, UPDATE, DELETE
AS BEGIN
    CREATE TABLE #DBCC (EventType varchar(50), Parameters varchar(50), EventInfo nvarchar(max))

    INSERT INTO #DBCC
    EXEC ('DBCC INPUTBUFFER(@@SPID)')

    INSERT INTO AUDIT (targettable, loginname, spid, sqltext)
    	SELECT  targettable	=	'TBL'
    	,		suser	    =	suser_name()
    	,		spid	    =	@@SPID
    	,		sqltext     =   EventInfo 
    	FROM #DBCC
END
GO

/* Test the Audit Trigger (can be run as guest) */
UPDATE TBL SET a = 3 WHERE a = 2

SELECT e.* 
FROM db_events.events e 
   JOIN (
      SELECT Max(id) MaxId, device_id
      FROM db_events.events
      GROUP BY device_id ) e2 on e.Id = e2.MaxId AND e.device_id = e2.device_id
WHERE e.device_id IN (
            SELECT device_id 
            FROM db_system.devices 
            WHERE vendor = 1)
ORDER BY e.id DESC

select   t.template_table_name
from     templates    t, 
         documents    d
where    d.template_id = t.template_id
and      d.document_id = @param_document_id

SELECT F_SMART_DATE('{?AS_OF}') SMART_DATE FROM DUAL;

select traveldate, lastservicedate, 
    'Travel services from ' + convert(varchar(20), traveldate) +
    ' to ' + convert(varchar(20), lastservicedate) as TextResult
from tablename

SELECT *
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = N'2000064';

select *
from (select a.*,
             lag(sdt) over (partition by id order by sdt) as prevsdt,
             lead(sdt) over (partition by id order by sdt) as nextsdt
      from table_a a
     ) a
where sdt - prevsdt <= 1/(24*60) or
      nextsdt - sdt <= 1/(24*60);

select session_id, wm_concat(name_status), time from 
(
  select session_id, (name+':'+status) as name_status, time
  from stuff
)
group by session_id
order by time

select
    Lastname, Firstname, Filename,
    case
        when Filename = max(Filename) over(partition by Lastname, Firstname) then Filename
        else null
    end as Max_Filename
from Table1

SELECT t1.* FROM sales t1
JOIN (
  SELECT date, min(price) price FROM sales
  GROUP BY date
) t2 ON t1.date = t2.date AND t1.price = t2.price

  select top(5) *
    from tbl
order by created_date desc

SELECT Total = COUNT(*) OVER()
FROM Table1;

''''+cast(cast(table.field as date) as varchar(255))+''''

SELECT *
FROM address
WHERE name LIKE 'a%' OR name LIKE '% a%' 
ORDER BY CASE WHEN name LIKE 'a%' THEN 0 ELSE 1 END
LIMIT 10

SELECT CAST(`duration` AS DECIMAL(10,4)) * CAST(`fee` AS DECIMAL(10,4))
FROM   `simvoip`

EXEC master.dbo.sp_addlinkedserver @server = N'ALIAS', @srvproduct=N'ACTUALSERVER', @provider=N'SQLOLEDB', @datasrc=N'ACTUALSERVER'

Imports System
Imports System.Data
Imports System.Math
Imports Microsoft.SqlServer.Dts.Pipeline.Wrapper
Imports Microsoft.SqlServer.Dts.Runtime.Wrapper

<microsoft.sqlserver.dts.pipeline.ssisscriptcomponententrypointattribute> _
<clscompliant(false)> _
Public Class ScriptMain
    Inherits UserComponent

    Public Overrides Sub Input0_ProcessInputRow(ByVal Row As Input0Buffer)
        ' Create a Globally Unique Identifier with SSIS
        Row.Guid = System.Guid.NewGuid()
    End Sub
End Class

select *
  from
  (
    select
        sal
          ,dense_rank() over (order by sal desc) ranking
    from   table
  )
  where ranking = 4 -- Replace 4 with any value of N

select t.time, 
isnull(
(select c.studentCode 
from tbClassRsv c 
where c.transdate='2014-02-05 00:00:00' 
and c.class='ROOM 01'
and c.status<>'DEL' 
and DateAdd(MINUTE, 30, Convert(datetime, t.time))>= Convert(datetime, c.time) 
and Convert(datetime, t.time) <= Convert(datetime, c.until)
),'-') from [tbTime] t

select type,
       sum(case when name like '% Smith' then 1 else 0 end) as SmithCount,
       sum(case when name like '% Anderson' then 1 else 0 end) as AndersonCount
    from mates
    group by type

select d.*
from (select d.*,
             (case when month6 is null then 0
                   when month5 is null then 1
                   when month4 is null then 2
                   when month3 is null then 3
                   when month2 is null then 4
                   when month1 is null then 5
              end) as cnt
      from data d
     ) d
where cnt >= 3;

type
  TABSDBHack = class
  private
    FFilename: TFileName;

    // 2 relevant contiguous headers of an Absolute Database file
    FDBHeader: array [0..SIZEOFDBHEADER-1];
    FCryptoHeader: array [0..SIZEOFCRYPTOHEADER-1];

    // Mirror of the ControlBlock record from CryptoHeader
    FControlBlock: array [0..SIZEOFCONTROLBLOCK-1] of Byte; 
    //
    function GetEncrypted: Boolean;
    function GetFileName: TFileName;
    function GetPageSize: Word;
    function GetPageCountInExtent: Word;
    function GetCryptoAlgorithm: Byte;
  protected
    // Retrieving Data from stream into FDBHeader and FCryptoHeader
    procedure ReadStream(F: TStream);

    // Mainly FillChar(..., ...,#0) of the corresponding record
    procedure ClearDBHeader;
    procedure ClearCryptoHeader;
    procedure ClearControlBlock;

    // Probe the existence of 'ABS0LUTEDATABASE' as file signature
    function CheckABSSignature: Boolean;

    // Compute the CRC of FControlBlock record
    function CRC32: Cardinal;

    // Decrypt the persisted Control Block into FControlBlock
    function InternalDecryptBuffer(const APassword: string):Boolean;
  public
    procedure Clear;

    // Wrapping a ReadStream using a local TFileStream
    procedure LoadFromFile(Filename: TFileName);

    // Return True if the decrypted Control Block correspond to original plain one.
    // Otherwise stated: The persisted CRC (in the Crypto Header) is equal to 
    // the value returned by the function CRC32
    function CheckPassword(const APassword: string): Boolean;

    property FileName: TFileName read GetFileName;

    // Sample of plain Data peristed that can be retrieved
    property PageSize: Word read GetPageSize;
    property PageCountInExtent: Word read GetPageCountInExtent;
    property Encrypted: Boolean read GetEncrypted;
    property CryptoAlgorithm: Byte read GetCryptoAlgorithm;
  end;

SELECT  AwardReference.ownerID ,
        COUNT(*) AS count
FROM    AwardReference
WHERE   AwardReference.ownerType = 'song'
GROUP BY AwardReference.ownerID

select
  min(col1) as col1,
  col2
from
  TheTable
group by
  col2
order by
  col2

-- DB2
select * from table fetch first 10 rows only 
-- Informix 
select first 10 * from table 
-- Microsoft SQL Server and Access 
select top 10 * from table 
-- MySQL and PostgreSQL 
select * from table limit 10 
-- Oracle 
select * from (select * from table) where rownum <= 10

UPDATE B
SET B.cpid = 250
FROM A 
WHERE A.id = B.a_id AND A.cgid LIKE '0002' 
     AND B.cpid = 312

Sub SplitData()
    Dim rData As Range
    Dim rCat As Range
    Dim rProd As Range
    Dim Cat As String
    Dim Prod As String
    Dim Price As Currency
    Dim Cat_ID As Long
    Dim Prod_ID As Long

    Set rData = ActiveWorkbook.Worksheets("Data").Cells(1, 1)
    Set rCat = ActiveWorkbook.Worksheets("Catagory").Cells(1, 1)
    Set rProd = ActiveWorkbook.Worksheets("Product").Cells(1, 1)

    rCat = "id"
    rCat.Offset(0, 1) = "title"
    Set rCat = rCat.Offset(1, 0)

    rProd = "id"
    rProd.Offset(0, 1) = "title"
    rProd.Offset(0, 2) = "catagory_id"
    rProd.Offset(0, 3) = "price"
    Set rProd = rProd.Offset(1, 0)

    Cat_ID = 0
    Prod_ID = 0

    Do While rData <> ""
        If rData.Font.Bold Then
            Cat = rData
            Cat_ID = Cat_ID + 1

            rCat = Cat_ID
            rCat.Offset(0, 1) = Cat

            Set rCat = rCat.Offset(1, 0)
        Else
            Prod = rData
            Price = rData.Offset(0, 1)
            Prod_ID = Prod_ID + 1

            rProd = Prod_ID
            rProd.Offset(0, 1) = Prod
            rProd.Offset(0, 2) = Cat_ID
            rProd.Offset(0, 3) = Price

            Set rProd = rProd.Offset(1, 0)
        End If
        Set rData = rData.Offset(1, 0)
    Loop


End Sub

SELECT order,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1COS_BLEACHING_FLAG'
                 THEN value END ) AS tech,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF1'
                 THEN value END ) AS bleach,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF2'
                 THEN value END ) AS af1,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF3'
                 THEN value END ) AS af2,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF4'
                 THEN value END ) AS af3,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_EF'
                 THEN value END ) AS af4,
       MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS_ACCESS_TECHNOLOGY'
                 THEN TO_DATE( value, 'DD/MM/YYYY' ) END ) AS ef
FROM   attributes
WHERE  order IN ( '802605-S844' /*, ...*/ )
GROUP BY order;

SELECT t.formid,
   t.statusname,
   MAX(t.actiondate) 'actiondate',
   t.formtype,
   t.chargeoffaccount,
   t.reasoncode,
   t.approvalcode,
   MAX(t.followupdate) 'followupdate'
FROM (
   SELECT t.formid, 
          fs.name 'StatusName',
          t.actiondate,
          ft.name 'formtype',
          coa.account 'ChargeOffAccount',
          rc.name 'ReasonCode',
          ac.description 'ApprovalCode',
          ffu.followupdate,
          row_number() OVER (PARTITION BY ef.formid ORDER BY t.actiondate DESC) 'DateSortKey'
     FROM EXTENSION.FORMDATE t 
     JOIN EXTENSION.FORM ef ON ef.formid = t.formid
     JOIN EXTENSION.FORMSTATUS fs ON fs.statusid = t.statusid
     JOIN EXTENSION.FORMTYPE ft ON ft.formtypeid = ef.formtypeid
LEFT JOIN EXTENSION.CHARGEOFFACCOUNT coa ON coa.chargeoffid = ef.chargeoffid
LEFT JOIN EXTENSION.REASONCODE rc ON rc.reasoncodeid = ef.reasoncodeid
LEFT JOIN EXTENSION.APPROVALCODE ac ON ac.approvalcodeid = ef.approvalcodeid
LEFT JOIN EXTENSION.FORMFOLLOWUP ffu ON ffu.formid = t.formid) t
    WHERE t.datesortkey = 1
 GROUP BY t.formid, t.statusname, t.formtype, t.chargeoffaccount, t.reasoncode, t.approvalcode
 ORDER BY t.formid

CREATE VIEW dbo.Foo
AS
SELECT 1 AS X

GO

CREATE SCHEMA bar

GO
ALTER SCHEMA bar TRANSFER dbo.Foo;

SELECT *
FROM bar.Foo

select tablename, 
   HAS_TABLE_PRIVILEGE(tablename, 'select') as select,
   HAS_TABLE_PRIVILEGE(tablename, 'insert') as insert,
   HAS_TABLE_PRIVILEGE(tablename, 'update') as update,
   HAS_TABLE_PRIVILEGE(tablename, 'delete') as delete, 
   HAS_TABLE_PRIVILEGE(tablename, 'references') as references 
from pg_tables where schemaname='public' order by tablename;

SELECT *
FROM table1 tab1 
LEFT OUTER JOIN table2 tab2 ON tab1.fg = tab2.fg
LEFT OUTER JOIN table4 tab4 ON tab1.ss = tab4.ss
INNER JOIN table3 tab3 ON tab4.xya = tab3.xya
LEFT OUTER JOIN table5 tab5 ON tab4.kk = tab5.kk

:SYSTEM.MESSAGE_LEVEL := '25';
COMMIT;
:SYSTEM.MESSAGE_LEVEL := '0';

SELECT t.date, t.value_A/t2.value_B AS calc
FROM table t JOIN table t2 ON t.date = DATE_ADD(t2.date, INTERVAL 1 MONTH)

DECLARE @i int
SET @i = 1
DECLARE @sql_alter nvarchar(4000)
      , @sql_update nvarchar(4000)
      , @sql_select nvarchar(4000)

CREATE TABLE #FLAT_TABLE (FID_0 int, FENCODED_0 varchar(10))
SET @sql_select = N'SELECT FID_0, FENCODED_0'

INSERT INTO #FLAT_TABLE (FID_0, FENCODED_0)
SELECT MAPENTRY_ID
     , ENCODED
  FROM XCO_MASTER
 WHERE MAPENTRY_ID = PARENT_ID

while (@@ROWCOUNT > 0) begin

    SET @sql_select = @sql_select + ', FID_' + @i

    SET @sql_alter = N'
        ALTER TABLE #FLAT_TABLE ADD COLUMN FID_' + @i + N' int
        ALTER TABLE #FLAT_TABLE ADD COLUMN FENCODED_' + @i + N' varchar(10)
    '

    SET @sql_update = N'
        UPDATE #FLAT_TABLE
           SET FID_' + @i + N' = MAPENTRY_ID
             , FENCODED_' + @i + N' = ENCODED
          FROM XCO_MASTER
         WHERE MAPENTRY_ID <> PARENT_ID
           and MAPENTRY_ID = FID_' + (Cast (@i - 1) as nvarchar(8))
    '
    SET @i = @i + 1

    sp_executesql @sql_alter
    sp_executesql @sql_update
end

@sql_select = @sql_select + ' FROM #FLAT_TABLE'
SELECT @sql_select

SELECT . . .,
       COUNT(PO_Line.propA) OVER (PARTITION BY PO.ID) as LINES
FROM PO LEFT JOIN
     PO_Lines
     ON PO.ID = PO_Lines.PO_ID;

Select * FROM (
Select *, CASE WHEN weekNo(Tableweeks) < week(TableX) THEN 1 ELSE 0 END 'Valid'
from tableX CROSS APPLY Tableweeks )
WHERE Valid = 1

SELECT C.crsid, MAX(TC.score) as maxscore
FROM Class C
JOIN ClassSection CS
on C.crsid = CS.crsid
JOIN TookClass TC
on TC.secid = CS.secid
GROUP BY C.crsid
order by maxscore desc;

  SELECT a.city AS city
    FROM YOUR_TABLE a
GROUP BY a.city
  HAVING COUNT(a.country) = 1
UNION ALL
 SELECT CONCAT(b.city, ', ', b.country) AS city
   FROM YOUR_TABLE b
  WHERE EXISTS (SELECT NULL
                  FROM YOUR_TABLE c
                 WHERE c.city = b.city
              GROUP BY c.city
                HAVING COUNT(c.country) > 1)
ORDER BY city

SELECT CONNECT_BY_ROOT PART_NO as ROOT_PART_NO,
       LEVEL, PART_NO, COMPONENT_PART, QTY_PER_ASSEMBLY
  FROM MANUF_STRUCTURE 
CONNECT BY
   PRIOR COMPONENT_PART = PART_NO AND 
   PRIOR CONTRACT = CONTRACT AND 
   PRIOR BOM_TYPE_DB = BOM_TYPE_DB 
START WITH PART_NO IN ('&PN1', '&PN2', '&PN3')
ORDER SIBLINGS BY LINE_ITEM_NO;

-- Retrieve maximum value of CustomerId
DECLARE @maxid int = 0
SELECT @maxid = MAX(CustomerId) FROM Company.Customer

-- When inserting data for column CustomerId add maximum id value and row number
-- This should ensure that the key values do not clash
INSERT INTO Company.Customer (CustomerId, FirstName, LastName)
SELECT ROW_NUMBER() OVER (ORDER BY CustomerId ASC) + @maxid, FirstName, LastName 
FROM Company.Customer    
WHERE LastName LIKE '%JONES%';

select *
    from YourTable
    where charindex(' 18,', ' ' + AllowedSystems + ',') <> 0

SUBSTR (text, INSTR(text,'/Library/Caches/')+16)

SHOW CREATE TABLE Courses

SELECT origin, destination 
FROM mytable
GROUP BY origin, destination
HAVING COUNT(*) > 1

create table t1 (col1 number,
                 col2 number,
                 col1_col2_least generated always as (least(col1, col2)),
                 col1_col2_greatest generated always as (greatest(col1, col2)));

--not strictly necessary
alter table t1 add constraint t1_u1 unique (col1, col2);

alter table t1 add constraint t1_u2 unique (col1_col2_least, col1_col2_greatest);

insert into t1 (col1, col2) values (1, 2);

insert into t1 (col1, col2) values (2, 1);

-- ORA-00001: unique constraint (SCHEMA.T1_U2) violated

insert into t1 (col1, col2) values (2, 2);

SELECT FIELD_1, FIELD_2... FIELD_N, SUM(AMOUNT),
       (case when field_1 <> lag(field_1) over (order by FIELD_1, FIELD_2... FIELD_N) or
                  lag(field_1) over (order by FIELD_1, FIELD_2... FIELD_N) is null
             then 'field_1'
             when field_2 <> lag(field_2) over (order by FIELD_1, FIELD_2... FIELD_N)
             then 'field_2'
             . . .
             else 'field_n'
        end) as WhichGrouping
FROM TABLE
GROUP BY FIELD_1, FIELD_2... FIELD_N
ORDER BY FIELD_1, FIELD_2... FIELD_N

DATE_ADD(DATE_FORMAT(now(), "%Y-%m-%d %H:%i:00"), INTERVAL (30 + (IF(SECOND(now() > 29, 1, 0))) MINUTE)

DECLARE @var VARCHAR(MAX) = 'foo'

SELECT *, 
    (LEN(TextColumn) - LEN(REPLACE(TextColumn, @var, ''))) / LEN(@var)
FROM tbl
WHERE 
    CHARINDEX(@var, TextColumn) > 0
ORDER BY 
    (LEN(TextColumn) - LEN(REPLACE(TextColumn, @var, ''))) / LEN(@var) DESC

    select sum(a.costoimp*movstocktotal.stock)
FROM     vsboremix.dbo.CompraLinea AS a 
INNER JOIN
    (SELECT compralinea.IdArticulo, MAX(compralinea.IdDocumento) AS iddocumento, IdListaEmpresa
    FROM     vsboremix.dbo.Compralinea join vsboremix.dbo.documento on CompraLinea.IdDocumento = documento.IdDocumento join VsBoremix.dbo.articulo on compralinea.IdArticulo=articulo.IdArticulo
    where IdDeposito in(30,38,40,44,50,60,70,90,100) and compralinea.CostoImp>0.0 and idseccion=101
    GROUP BY compralinea.IdArticulo, IdListaEmpresa) AS b ON b.IdArticulo = a.IdArticulo AND b.iddocumento = a.IdDocumento 
join vsboremix.dbo.movstocktotal on a.IdArticulo = MovStockTotal.IdArticulo and b.IdListaEmpresa=MovStockTotal.IdEmpresa

select *
from (
    (select *
    from observations
    where category = 'C'
    order by random()
    limit 243369* 0.1)
    union
    (select *
    from observations
    where category <> 'C')
    ) sub
order by random()
limit 1;

SELECT ID, Type, SubType, Percentage, Category
FROM one
UNION
    SELECT DISTINCT 0, t2.Type, t2.SubType, 0.00, t1.Category
    FROM one t1
    INNER JOIN two t2 ON t2.Type = t1.Type AND t2.SubType NOT IN
        (SELECT t3.SubType FROM one t3 WHERE t3.Category = t1.Category and t3.Type = t1.Type)
ORDER BY Category, Type, SubType

CHARACTERSET UTF8

psql -h hostname -p port_number -U username -f your_file.sql databasename 

SELECT
    [item],
    [Prox],
    [z],
    coalesce([item], '') + coalesce([Prox], '') + coalesce([z], '') as result
FROM
    [FIELD$];

select stdcode, group_concat(value separator ';') as values
from table1
group by stdcode;

SQL> create table t( col1 varchar2(3) );

Table created.

SQL> create sequence t_seq;

Sequence created.

SQL> ed
Wrote file afiedt.buf

  1  insert into t
  2    select to_char( t_seq.nextval, 'fm009' )
  3      from dual
  4*  connect by level <= 10
SQL> /

10 rows created.

SQL> select * from t;

COL
---
004
005
006
007
008
009
010
011
012
013

10 rows selected.

select i.*
from Instructor i
where exists (select 1
              from CourseInstructor ci join 
                   Course c
                   on c.CourseId = ci.CourseId 
              where ci.InstructorId = i.InstructorId and
                    c.DepartmentId = @p0
             );

select ROUTINE_NAME
from information_schema.routines
where DATEDIFF(CURDATE(),created) < 14

function combination(n in integer, k in integer)
    return integer
is
    l_result integer;
begin
    for i in 1..k loop
        l_result := l_result * (n-i+1) / k;
    end loop;
    return l_result;
end;
/

SELECT 100 * SUM( CASE WHEN (maint_fault_date + 5) < maint_action_date
                   THEN 1
                   ELSE 0 END
       ) / COUNT(*) AS percentage
FROM mainthistory;

SELECT name 
from   products p
WHERE  backorder IS NULL OR backorder <> 2

from google.appengine.ext import ndb

class User(ndb.Model):
    email = db.StringProperty()


options = ndb.QueryOptions(keys_only=True)
condition_1 = ndb.Query(User, options=options).filter(User.email == "mom@home.com")
condition_1 = ndb.Query(User, options=options).filter(User.email == "dad@home.com")

key_list = list(set(list(condition_1) + list(condition_2)))

mom_and_dad = ndb.get_multi(key_list)

SELECT
    date,
    number,
    ROW_NUMBER() OVER(PARTITION BY date, number ORDER BY number DESC) AS index
FROM
    myTable;

SELECT  d.*
FROM    rule
CROSS APPLY
        (
        SELECT  id, email
        FROM    a
        WHERE   a.id = rule.id
        UNION ALL
        SELECT  id, email
        FROM    b
        WHERE   b.id = rule.id
        UNION ALL
        SELECT  id, email
        FROM    c
        WHERE   c.id = rule.id
        ) d

select family.* 
  from table as member 
  join table as familiy 
    on member.ParentID = family.ParentID 
 where member.ItemID = 'firstGUID'

select idCust, Name, sum(quantity * unitPrice) as TotalPurchase,
       sum(case when sku = 1344 then quantity * unitPrice end) as TotalPurchase_1344
from table t
where date >= '2014-06-01' and date < '2014-07-01'
group by idCust, Name;

select A,B 
from
(
select row_number() over(partition by A order by C desc)rn,A,B,C
from yourtable
)
where RN=1

SELECT Tbl_member.member_id,
       Sum(points_earned) - Sum(points_redeemed) Remaining_points
FROM   Tbl_member
       JOIN Tbl_member_participation
         ON tbl_member_participation.member_id = Tbl_member.member_id
       JOIN Tbl_member_redemption
         ON tbl_member_redemption.member_id = Tbl_member.member_id
GROUP  BY Tbl_member.member_id,
          Datepart(mm, datecol),
          Datepart(yyyy, datecol) 

SELECT t1.name, t2.x, t2.y, t2.z FROM TABLENAME t1
JOIN TABLENAME t2 on t1.id = t2.refer

SELECT DISTINCT ON (book_container_id)
       isbn, book_container_id, shelf_id, update_time 
FROM   bookshelf_configuration
WHERE  isbn = 555
AND    update_time <= '2015-12-01 07:00'  -- ISO 8601 format
ORDER  BY book_container_id, update_time DESC;

with s as (
    select *
    from
        customers
        inner join
        orders using (custid)
        inner join
        itemsordered using (orderid)
        inner join
        items using (itemid)
)
select distinct
    least(s1.name, s2.name),
    greatest(s1.name, s2.name)
from
    s s1
    inner join
    s s2 on
        s1.description = s2.description
        and
        s1.custid < s2.custid
order by 1, 2

pg_restore -O dump_file | fix_latin | psql -d database

SELECT *
FROM comments
ORDER BY IF(ParentId = 0, Id, ParentId), ParentId!=0, Id desc

SELECT [SITE ID], [Parameter],
       Min(Results) As MinOfResults,
       Max(Results) As MaxOfResults,
       Avg(Results) As AvgOfResults,
       StDev(Results) As StDevOfResults,           
       Count(Results) As CountOfResults
FROM Chemistry1
WHERE [SITE ID] = 'LB-100' 
  AND [Parameter] = 'Calcium, Dissolved'
  AND Year([SampleDate]) = 2014
GROUP BY [SITE ID], [Parameter]

public List<TaskClass> getAllTasks() {
    List<TaskClass> tasks = new ArrayList<TaskClass>();
    Cursor cursor = db.query(tb_Name, null, null, null, null, null, "id asc");
    Log.d(TAG, "Getting tasks: " + cursor.getCount());
    while (cursor.moveToNext()) {
        TaskClass task = new TaskClass();
        task.setId(cursor.getLong(0));
        task.setTitle(cursor.getString(1));
        // Populate rest of fields accordingly
        tasks.add(task); 
    }
    Log.d(TAG, "Returning tasks: " + tasks);
    return tasks;
}

SELECT a,b,c, SUM(d) AS d, SUM(e) AS e 
  FROM tableT 
  WHERE (SELECT COUNT(*) FROM tableT) <= 3
  GROUP BY a,b,c 
UNION ALL
SELECT a,b,c,d,e 
  FROM tableT 
  WHERE (SELECT COUNT(*) FROM tableT) > 3
;

SELECT t1.Name, t2.Name
FROM mytable AS t1
INNER JOIN mytable AS t2 ON t1.Name < t2.Name
ORDER BY t1.Name, t2.Name

select
  emp_id,
  work_date
from (
  select
    emp_id,
    work_date,
    min(element) min_element,
    max(element) max_element,
    count(*) rows_counted
  from
    mytable
  where
    work_date = :p_workdate
  group by
    emp_id,
    work_date
  having
    count (*) > 1)
where
  rows_counted > 2 or
  (min_element,max_element) not in (select 'element1' el1, 'element2' el2 from dual union all
                                    select 'element3' el1, 'element4' el2 from dual)

INSERT INTO Temp_table (column1, column2, column3, column4)
SELECT column1, column2, ISNULL(column3,0), ISNULL(column4,0) FROM TABLE1 WHERE someCondition
UNION ALL
SELECT ISNULL(column1,0), ISNULL(column2,0), column3, column4 FROM TABLE1 WHERE someOtherCondition

select *
from tab
qualify
   row_number() over (partition by id order by date) = 1

;WITH Q1
AS (
    SELECT pvt.probcat
        ,pvt.probdesc
        ,ISNULL(pvt.[Dev], 0) AS 'Dev'
        ,ISNULL(pvt.[QA], 0) AS 'QA'
        ,ISNULL(pvt.[Prod], 0) AS 'Prod'
    FROM (
        SELECT pc.probcat
            ,pc.probdesc
            ,ps.noofproblems
            ,ps.stage
        FROM Probcat pc
        LEFT JOIN ProbSummary ps ON pc.probcat = ps.probcat
        ) t
    PIVOT(max(noofproblems) FOR stage IN (
                [Dev]
                ,[QA]
                ,[Prod]
                )) pvt
    ),
q2 as
(SELECT q1.*
    ,sum(q1.Dev + q1.QA + q1.Prod) AS Total
FROM q1

GROUP BY q1.probcat
    ,q1.probdesc
    ,q1.Dev
    ,q1.QA
    ,q1.Prod
)
select q2.probcat
    ,q2.probdesc
    ,q2.Dev
    ,q2.QA
    ,q2.Prod
    ,cast(q2.Total as varchar(10)) + ' (' +
    cast(cast((cast(q2.Total as decimal(5,2))/cast(d.CrossSum as decimal(5,2)))*100 
    as decimal(5,2)) as varchar(10))
    + '% )' as FinalTotal
    from q2
  CROSS APPLY (
    SELECT sum(q1.Dev + q1.QA + q1.Prod) AS CrossSum
    FROM q1
    ) d  
ORDER BY q2.probcat

SELECT ASSETNAME,PROJECT,MIN(T.MIN)START_DAY,MAX(T.MAX) END_DAY,
       DATEDIFF(DD,MIN(t.min) ,MAX(T.MAX)) DURATION
FROM
(
SELECT  ASSETNAME,PROJECT,DATEADD(DD,MIN(WEEK),WEEKBEGINNING) 'MIN',DATEADD(DD,MAX(WEEK),WEEKBEGINNING) 'MAX'
FROM #TEMP  T
CROSS APPLY(SELECT 0 'WEEK' WHERE T.MONDAY=1 UNION ALL SELECT 1 WHERE T.TUESDAY=1 UNION ALL
            SELECT 2 WHERE T.WEDNESDAY=1 UNION ALL SELECT 3 WHERE T.THURSDAY=1 UNION ALL
            SELECT 4 WHERE T.FRIDAY=1 UNION ALL SELECT 5 WHERE T.SATURDAY=1 UNION ALL
            SELECT 6 WHERE T.SUNDAY=1 
            ) D
GROUP BY ASSETNAME,PROJECT,WEEKBEGINNING
)T

ColorPref
ColorPrefQuestion
Rating
RatingQuestion

CREATE TABLE Recipes (
 id int,
 name text,
 PRIMARY KEY (`id`)
);

CREATE TABLE Ingredients(
 id int,
 name text,
 PRIMARY KEY (`id`)
);

CREATE TABLE Recipes2Ingredients (
 rec_id int,
 ing_id int,
 amount int,
 -- and maybe some other needed fields
 FOREIGN KEY (rec_id)
   REFERENCES Recipes(id),
 FOREIGN KEY (ing_id)
   REFERENCES Ingredients(id)
);

SELECT     *
FROM         StaffHours
WHERE     (SiteID = '164') AND (ID IN
                      (SELECT     Min(ID)
                        FROM          StaffHours
                        WHERE      (SiteID = '164')
                        GROUP BY RecordID
                        HAVING      (COUNT(RecordID) > 1)))
ORDER BY RecordID DESC

SELECT SUBSTRING( string , LEN(string) -  CHARINDEX('/',REVERSE(string)) + 2  , LEN(string)  ) FROM SAMPLE;

SELECT

DATE_SUB(
    LAST_DAY(
        DATE_ADD(NOW(), INTERVAL 1 MONTH)
    ), 
    INTERVAL DAY(
        LAST_DAY(
            DATE_ADD(NOW(), INTERVAL 1 MONTH)
        )
    )-1 DAY
) AS firstOfNextMonth,

LAST_DAY(
    DATE_ADD(NOW(), INTERVAL 1 MONTH)
)AS lastOfNextMonth

select *
from (
   SELECT i.BOOK_ID
   , i.in_out
   , i.event_date AS in_time
   , LOCATION in_location
   , lag(event_date) over (partition by book_id order by event_date) out_date
   , lag(location) over (partition by book_id order by event_date) out_location
   FROM TRANSACTIONS i
   ORDER BY i.event_date)
where in_out = 'I'
and   in_location != out_location;

select * from tablename
where (flag & 64) = 64

select 
 case
  when charindex(' ', member_name) > 0 then
  SUBSTRING(member_name, charindex('/', member_name) + 1, charindex(' ', member_name) - charindex('/', member_name))  
  when charindex(' ', member_name) < 1 then
    SUBSTRING(member_name, charindex('/', member_name) + 1, len(member_name) - charindex('/', member_name))  
end as FIRST_NAME, 
  left(member_name, charindex('/', member_name) - 1) + ' ' as last_name
from
  member

select to_char(to_date(TMS,'YYYY-MM-DD')+3,'YYYY-MM-DD') from city;

 SELECT dates.TheDate, count(recordID) 
 FROM 
 ( select 
      convert(date,dateadd(d,number,'2013-08-12')) as theDate 
   from master..spt_values 
   where type='p' and number < 9
 ) dates
 left join yourtable on dates.thedate = convert(date,yourtable.thedate)
 GROUP BY dates.TheDate 

SELECT 
    count(*) AS Cnt
    ,COALESCE(users.country, 'unknown') AS Country
FROM 
    sessions
    LEFT JOIN users ON sessions.username=users.username
GROUP BY users.country;

select player_id, sum(total) total from (
  select winner_id player_id, count(*) total from results group by winner_id
  union all
  select loser_id, count(*) from results group by loser_id
) s
group by player_id
order by total desc

SELECT site_id, MAX(download_date) AS download_date, count(*)
FROM pages_urls
GROUP BY site_id;

SELECT p.id, p.name, p.image, p.stock
FROM Combine as c
inner join
Product as p
on (c.item1=p.id or c.item2=p.id or c.item3=p.id)
Where id = ###

 <dg:DataGrid.ItemContainerStyle>
    <Style
       TargetType="{x:Type dg:DataGridRow}"
       BasedOn="{StaticResource {x:Type dg:DataGridRow}}">
       <Setter
          Property="Background"
          Value="{Binding ItemColour}" />
    </Style>
 </dg:DataGrid.ItemContainerStyle>

set rowcount 1
select * from data order by timestamp desc

select IDs.ID, ifnull(count(globals_lists.global_id),0) as group_count
from (select 3 as ID
             UNION select 4
             UNION select 5
             UNION select 6) as IDs
left join globals_lists on IDs.ID = globals_lists.global_id
group by IDs.ID
order by group_count desc;

SELECT OBJECT_NAME(object_id)
FROM sys.sql_modules
WHERE definition LIKE '%MyTable%'

ContentResolver cr = getContentResolver();
    Cursor cur = cr.query(ContactsContract.Contacts.CONTENT_URI,
            null, null, null, null);
    if (cur.getCount() > 0) {
        while (cur.moveToNext()) {
              String id = cur.getString(cur.getColumnIndex(ContactsContract.Contacts._ID));
              String name = cur.getString(cur.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));
              if (Integer.parseInt(cur.getString(
                    cur.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) {
                 Cursor pCur = cr.query(
                           ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                           null,
                           ContactsContract.CommonDataKinds.Phone.CONTACT_ID +" = ?",
                           new String[]{id}, null);
                 while (pCur.moveToNext()) {
                     String phoneNo = pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER));
              Log.e("TAG","Name :: "+Name);
              Log.e("TAG","Phone no :: "+phoneNo);

                 }
                pCur.close();
            }
        }
    }

select sum(case when category = 'value_a' then 1 else 0 end) as group_a,
       sum(case when category = 'value_b' then 1 else 0 end) as group_b
    from tbl
    where category in ('value_a', 'value_b')

;With T As
(
SELECT 7 AirQuoteID,'M' Name,49.50 SalesValue UNION ALL
SELECT 7 AirQuoteID,'N', 23.10 UNION ALL
SELECT 7 AirQuoteID,'+45',233.20 UNION ALL
SELECT 7 AirQuoteID,'+100',233.20 UNION ALL
SELECT 7 AirQuoteID,'+250',2333.10
)
SELECT AirQuoteID, [M], [N], [+45], [+100], [+250] 
FROM T
PIVOT
(
MAX(SalesValue)
FOR Name IN ([M], [N], [+45], [+100], [+250])
) AS pvt;

C = Check Constraint
D = Default or Default Constraint
F = Foreign Key Constraint
L = Log
Fn = Scalar Function
If = Inlined Table Function
P = Stored Procedure
Pk = Primary Key Constraint
Rf = Replication Filter Stored Procedure 
S = System Table
Tf = Table Function
Tr = Trigger
U = User Table
Uq = Unique Constraint 
V = View

SELECT DISTINCT SysObjects.Name 'Table Name', 
                Procedures.Name 'Stored Procedure'
           FROM SysObjects 
           JOIN (SysObjects Procedures    
           JOIN SysDepends     
             ON Procedures.Id = SysDepends.Id) 
             ON SysDepends.DepId = SysObjects.Id
          WHERE SysObjects.XType = 'U'     
-- Change XType Values here using chart above     
            AND Procedures.XType = 'P'
       GROUP BY SysObjects.Name, 
                SysObjects.Id, 
                Procedures.Name
       ORDER BY SysObjects.Name ASC

select t1.*
from my_table t1
join (select serialno, max(Last_seen) Last_seen
      from my_table
      group by serialno) t2
    on t1.serialno = t2.serialno and t1.Last_seen = t2.Last_seen
order by t1.Last_seen desc

Declare @myDate Datetime    
Set @myDate = dateadd(HOUR, 5, getdate())

SELECT Left(Convert(varchar(10),@myDate,21),10) +
       stuff(right(convert(varchar(26), @myDate, 109 ), 15 ), 7, 7, ' ')

SELECT TOP 1 id FROM table WHERE date = '2010-01-01' ORDER BY value DESC

select   
    case
         when Dr.DrugNDCType = 49 then Dr.DrugNDCNbr
         else
               stuff   (   Dr.DrugNDCNbr,
               case 
                       when Dr.DrugNDCType in (50, 56) then 1 
                       when Dr.DrugNDCType in (51, 57) then 6    
                       when Dr.DrugNDCType = 52 then 10     
               end, 0, '0')
    end

 from drug Dr
where Dr.drugnbrkey = 6284

SELECT 
    TableOne.ID, 
    TableOne_1.Name, 
    TableOne_2.Address
FROM 
    (TableOne 
LEFT JOIN 
    TableOne AS TableOne_1 
        ON TableOne.ID = TableOne_1.ID) 
LEFT JOIN 
    TableOne AS TableOne_2 
        ON TableOne.ID = TableOne_2.ID
GROUP BY 
    TableOne.ID, 
    TableOne_1.Name, 
    TableOne_2.Address
HAVING 
    TableOne_1.Name Is Not Null 
    AND 
    TableOne_2.Address Is Not Null;

SELECT U.NetworkIdentifier, U.FirstName, U.LastName,
       H.HardwareName, H.SerialNumber
  FROM (SELECT UserID, MAX(AssignedOn) LastAssignment
          FROM HardwareAssignments
         GROUP BY UserID) AS T
  JOIN HardwareAssignments AS HA
       ON HA.UserId = T.UserID AND HA.AssignedOn = T.LastAssignment
  JOIN Users AS U ON U.ID = HA.UserID
  JOIN Hardware AS H ON H.ID = HA.HardwareID
 ORDER BY U.NetworkIdentifier;

field LIKE 'Hash.System.Data.DataSet has(%).ds'

SELECT  tblCounty.ID, 
    ISNULL(tblAddress.Code, 'none')
    --Whatever you want to select
FROM tblCounty
LEFT JOIN tblCode ON tblCounty.Name = tblCode.Name
    LEFT JOIN tblAddres ON ISNULL(tblCode.Code, 'none') = ISNULL(tblAddress.Code, 'none')

Select id
, Sum(Case when Type='Link' then 1 else 0 end) as Links
, Sum(Case when Type='Forms' then 1 else 0 end) as Forms
, Sum(Case when Type='Page' then 1 else 0 end) as Pages
From SomeTable
Group by ID

from table1 inner join table2 on table1.x = table2.y and table1.a = table2.b

select FromUser, ToUser, Message, [Date], UserId, UserFullName, UserName, UserPhoto
from (SELECT CM.FromUser, CM.ToUser, CM.Message, CM.Date, U.UserId,
             U.UserFullName, U.UserName, U.UserPhoto,
             row_number() over (partition by CM.FromUser, CM.ToUser order by [Date] desc) as seqnum
      FROM ConversationMessages CM INNER JOIN
           Users U
           ON U.UserName = CM.FromUser
      WHERE  CM.ToUser = @user
     ) s
WHERE seqnum = 1
ORDER BY CM.Date DESC ;

create table test2 (
rowid varchar(10),
id varchar(20),
person_id varchar(20),
item_name varchar(20),
value varchar(20));

insert into test2 
(rowid,id, person_id,item_name,value)
values ('1','1','1','first item','first value');

insert into test2
(rowid,id, person_id,item_name,value)
values ('2','1','1','first item','first value');

commit;

SELECT item_name,Count(*) FROM test2 GROUP BY person_id, item_name;


DELETE FROM Test2
 WHERE rowid NOT IN (SELECT * 
                    FROM (SELECT MAX(n.rowid)
                            FROM test2 n
                        GROUP BY n.person_id, n.item_name) x);

SELECT item_name,Count(*) FROM test2 GROUP BY person_id, item_name;

SELECT x.client_id, 
       x.project_id,
       x.project_name
  FROM (SELECT t.client_id,
               t.project_id,
               t.project_name,
               CASE
                 WHEN @client_id != t.client_id THEN @rownum := 0
                 WHEN @client_id = t.client_id THEN @rownum := @rownum + 1
                 ELSE @rownum 
               END AS rank,
               @client_id := t.client_id
          FROM TABLE t,
               (SELECT @rownum := 0, @client_id
      ORDER BY t.client_id) r) x
ORDER BY x.rank, x.client_id

SELECT D.Username,      
      SUM(CASE WHEN D.type = 'Yes' THEN 1 ELSE 0 END) AS Yes,      
      SUM(CASE WHEN D.type = 'No'  THEN 1 ELSE 0 END) AS No,      
      SUM(CASE WHEN S.mobile IS NULL THEN 0 ELSE 1 END) AS MatchSales 
 FROM dairy AS D     
 LEFT JOIN (SELECT DISTINCT mobile FROM sales) AS S ON D.MobileNo = S.mobile 
 WHERE D.source = 'Company'  
 AND   UNIX_TIMESTAMP(D.CheckDate) >= $From_timestamp 
 AND   UNIX_TIMTIMESTAMP(D.CheckDate) <= $To_timestamp 
 GROUP BY D.Username

FileReader file = new FileReader(fileName);
BufferedReader buffer = new BufferedReader(file);
String line = "";
String tableName ="TABLE_NAME";
String columns = "_id, name, dt1, dt2, dt3";
String str1 = "INSERT INTO " + tableName + " (" + columns + ") values(";
String str2 = ");";

db.beginTransaction();
while ((line = buffer.readLine()) != null) {
    StringBuilder sb = new StringBuilder(str1);
    String[] str = line.split(",");
    sb.append("'" + str[0] + "',");
    sb.append(str[1] + "',");
    sb.append(str[2] + "',");
    sb.append(str[3] + "'");
    sb.append(str[4] + "'");
    sb.append(str2);
    db.execSQL(sb.toString());
}
db.setTransactionSuccessful();
db.endTransaction();

010
009
1

SELECT `Part Name`
FROM Parts p
INNER JOIN OrderDetails o ON p.PartID = o.PartID
WHERE o.OrderDetailsID = ...;

create function [dbo].[getCloaks]
(
@String     varchar(8000)
)
returns @tbl table (s varchar(1000))
as
begin
declare @i int, @j int, @k int
    select  @i = 1
    while charindex('{cloak:id=', @String, @i) > 0
    begin
        select @j = charindex('{cloak:id=', @String, @i)
        select @k = charindex('}', @String, @j)
        insert  @tbl select substring(@String, @j + 10, @k - @j - 10)
        select  @i = @k + 1
    end
    return
end

WITH cte 
     AS (SELECT menuld, 
                menutitle, 
                parentmenuld 
         FROM   Yourtable 
         WHERE  menuld = 1601120013 
         UNION ALL 
         SELECT t.menuld, 
                t.menutitle, 
                t.parentmenuld 
         FROM   cte c 
                INNER JOIN Yourtable t 
                        ON t.menuld = c.parentmenuld) 
SELECT * 
FROM   cte 

select [date], sum( case when type = 'Electronics' then (ordersize) else 0 end) AS ElectronicsSum,
sum( case when type = 'Electronics' then 1 else 0 end) AS ElectronicsCount,
sum( case when type = 'Books' then (ordersize) else 0 end) AS BooksSum,
sum( case when type = 'Books' then 1 else 0 end) AS BooksCoumt
from orders
group by [date]

where Txndate like '%' +   CONVERT(VARCHAR(12), GETDATE(), 107) + '%'

select  AgeGroup
,       count(*)
from    (
        select  case
                when  age between 13 and 17 then 1
                when  age between 18 and 21 then 2
                ...
                end as AgeGroup
        from    (
                SELECT  ROUND(DATEDIFF(Cast(NOW() as Date),
                            Cast(birthday as Date)) / 365, 0) as age
                FROM    YourTable
                ) as SubQueryAlias
        ) as SubQueryAlias2
group by
        AgeGroup

and rownum = 1

SELECT Person, Sum(GiftAmount)
FROM tblGifts 
WHERE Person NOT IN (
    SELECT Person FROM tblGifts
        WHERE GiftDate >  [Forms]![InputForm]![EndDate] 
            OR  GiftDate <  [Forms]![InputForm]![StartDate]
) 
GROUP BY Person

IF EXISTS (SELECT ActiveStatus From TableName where ActiveStatus = 0)
  SELECT 'False'
ELSE
  SELECT 'True'
AS OutputColumn

SELECT OrderID,OrderDate,
DATEADD(DAY,2,OrderDate) as ApproxShipDate,
DATEDIFF(DAY,OrderDate,DATEADD(DAY,2,OrderDate)) as DaysToShip
FROM Orders
WHERE YEAR(OrderDate) = 2012 AND MONTH(OrderDate) = 3

select score,
       max(case when type = 'satisfaction' then count end) as satisfaction_count,
       max(case when type = 'response' then count end) as response_count,
       max(case when type = 'responder' then count end) as responder_count,
       max(case when type = 'service' then count end) as service_count             
from (
  select satisfaction_score as score, 
         count(satisfaction_score) as count, 
         'satisfaction' as type
  from j_survey_response
  where satisfaction_score != 0
  group by satisfaction_score

  union all

  select response_score,
         count(response_score) as count, 'response' as type
  from j_survey_response
  where response_score != 0
  group by response_score

  union all

  select responder_score,
         count(responder_score) as count, 'responder' as type
  from j_survey_response
  where responder_score != 0
  group by responder_score

  union all

  select service_score,
         count(service_score) as count, 'service' as type
  from j_survey_response
  where service_score != 0
  group by service_score) as t
group by score

SELECT
  id2
  , SUM(updated) as updates
  ,MAX(updated_on) as last_update
FROM table1
GROUP BY id2
ORDER BY last_update DESC

DELETE
  FROM table1
 WHERE exists(
           SELECT 1
             FROM table2
            WHERE table2.stn = table1.stn
              and table2.jaar = year(table1.datum)
       )

with userCTE as (
    select
        u.userId ,
            c.columnId
    from tblUsers as u
        cross join tblColumns as c
)

select 
    u.* ,
    Coalesce(cd.ColumnDatacontent, 'N/A') AS columnDataContent
from userCTE as u
    left join tblColumnData as cd
        on u.columnId = cd.columnId and u.userID = cd.userId

  SELECT z.id,
         MAX(z.col)
    FROM (SELECT x.id,
                 x.column1 AS col
            FROM TABLE x
          UNION 
          SELECT y.id,
                 y.column2
            FROM TABLE y) z
GROUP BY z.id

LIKE '%\%%' ESCAPE '\'

SELECT T.user_id, U.username, T.score, T.time 
FROM tests_1 T
JOIN users U on U.user_id = T.user_id
WHERE T.score = (
SELECT MAX(T2.score)
FROM tests_1 T2
WHERE T2.user_id = T.user_id
)
ORDER BY T.score DESC, T.time ASC;

SELECT MAX(Case When B.ValueOrdinal='1' Then B.Displayvalue end) as Account,
       MAX(case when B.ValueOrdinal='2' then B.Displayvalue end) as Department,
       MAX(case when B.ValueOrdinal='3' then B.Displayvalue end) as Misc,
       A.Text,
       Sum(A.reportingcurrencyamount) as PostedAmount,
       A.Recid
From GeneralJournalAccountEntry A Inner Join
     DimensionAttributeLevelValueAllView B
     on A.Ledgerdimension = B.ValueCombinationRecID Inner Join
     DIMENSIONATTRIBUTEVALUECOMBINATION C
     on A.Ledgerdimension = C.RecID
Where C.accountstructure in ('5637145326','5637165585')
Group by A.Recid,  A.Text;

ALTER TRIGGER [dbo].[trigger_insertInStatus] 
   ON  [dbo].[DeviceStatus] 
   AFTER INSERT 
AS 
BEGIN

   --Update Records where DeviceIP does exist in GeneralStatus
   UPDATE GS 
   SET GS.ServiceStatus = I.ServiceStatus
   FROM GeneralStatus GS INNER JOIN Inserted I ON GS.DeviceIP = I.DeviceIP


   -- Insert statements for trigger here:
   -- Insert records where DeviceIP does not exist in GeneralStatus 
   INSERT INTO GeneralStatus
   ( DeviceIP,ServiceStatus )
   SELECT DeviceIP , ServiceStatus FROM INSERTED I
   LEFT JOIN GeneralStatus GS ON GS.DeviceIP = I.DeviceIP 
   WHERE GS.DeviceIP IS NULL;

END

SELECT C.names
FROM C
    INNER JOIN B ON C.B_ID = B.B_ID
    INNER JOIN A ON B.A_ID = A.A_ID
WHERE A.A_ID = 3

SQL> DECLARE
  2    CURSOR c IS SELECT 1 FROM DUAL;
  3  BEGIN
  4     NULL;
  5  END;
  6  /

PL/SQL procedure successfully completed.

SELECT IFNULL(var1, 0) + IFNULL(var2, 0) FROM test

This works in oracle
select a.*
from route  a
start with a.rowid = (select min(rowid) from route )
connect by prior a.t = a.f; 

DECLARE
    @std_y  FLOAT,
    @std_x1 FLOAT,
    @std_x2 FLOAT

SELECT
    @std_y =  SUM(W*Y),
    @std_x1 = SUM(W*X1),
    @std_x2 = SUM(W*X2)
FROM
    dbo.My_Table

UPDATE dbo.My_Table
SET
    Y  = SQRT(W) * (Y  - @std_y),
    X1 = SQRT(W) * (X1 - @std_y),
    X2 = SQRT(W) * (X2 - @std_y)

SELECT
    @std_y  AS std_y,
    @std_x1 AS std_x1,
    @std_x2 AS std_x2

SELECT pl.email
FROM gameday.player_settings pl
WHERE NOT EXISTS (
  SELECT 1
  FROM unnest(?) AS wanted_tags(tag)
  LEFT JOIN admin.tags tags
    ON tags.tag = wanted_tags.tag
  WHERE  tags.player_id = pl.id
    AND wanted_tags.tag IS NULL
);

select t1.id, t1.name, t1.value, t2.id as id2, t2.name as name2, t2.value as value2
from (select t1.*, row_number() over (order by id) as seqnum
      from table_1 t1
     ) t1 full outer join
     (select t2.*, row_number() over (order by id) as seqnum
      from table_2 t2
     ) t2
     on t1.seqnum = t2.seqnum;

SET foreign_key_checks = 'ON'

dte = InputBox("What date was the Data Dump run?", "Please Input a date (MMDDYYYY)")


clientQry = "SELECT DISTINCT t.[CLIENT ID], t.[CLIENT NAME] " & _
            "FROM FN_DataDump_ALL_" & dte & " as t WHERE " & _ 
            " (((t.[CLIENT NAME]) Not Like  ""*Test*"" ));"

SELECT CASE 
        WHEN e.ELECT_BONUS_DFRL_SEQ_ID IS NULL OR MAX(e.ELECT_BONUS_DFRL_SEQ_ID) < 1
        THEN 1
        ELSE MAX(e.ELECT_BONUS_DFRL_SEQ_ID) + 1
    END AS ELECT_BONUS_DFRL_SEQ_ID
FROM ELECT_BONUS_DFRL AS e
GROUP BY e.ELECT_BONUS_DFRL_SEQ_ID;

SET NOCOUNT ON;

DECLARE @user_name    SYSNAME
        , @login_name SYSNAME;

SELECT @user_name = 'user_name',
       @login_name = 'login_name'

SELECT '
    USE ' + QUOTENAME(NAME) + ';

    CREATE USER ' + QUOTENAME(@user_name)
       + ' FOR LOGIN ' + QUOTENAME(@login_name)
       + ' WITH DEFAULT_SCHEMA=[dbo];

    EXEC sys.sp_addrolemember
      ''db_datareader'',
      ''' + QUOTENAME(@user_name) + ''';

    EXEC sys.sp_addrolemember
      ''db_denydatawriter'',
      '''
       + QUOTENAME(@user_name) + '''; 

GO
'
FROM   sys.databases
WHERE  database_id > 4
       AND state_desc = 'ONLINE' 

select t1.ID from Table t1
where EXISTS (
              SELECT *
              FROM Table t2
              WHERE t2.DefID = 1 AND t2.ValStr = 'hi'
              ) and  t1.ValInt = 1

SELECT * FROM task_id AS taskid INNER JOIN task_in AS taskin ON taskid.id = taskin.id INNER JOIN customer AS cust ON taskin.id = cust.id WHERE id = YOUR_VALUE_HERE   

Select T1.TicketNumber,T1.Rules_Count_1,T2.Rules_Count_2
FROM
(
  Select [TicketNumber], COUNT([TicketNumber]) AS Rules_Count_1 
  from [Table1] T1
  group by TicketNumber) T1
INNER JOIN
(
  Select [TicketNumber], COUNT([TicketNumber]) AS Rules_Count_2
  from [Table2] T2
  group by TicketNumber
 ) T2
on T1.TicketNumber = T2.TicketNumber

$count = $query->count()->execute();

SELECT TRIM(SUBSTRING(tag, 1, (CHAR_LENGTH(tag) - LOCATE('(', REVERSE(tag))))) AS new_tag
FROM table_name;

SUM(COALESCE(WOSE,0) +COALESCE(WO,0) + COALESCE(SSSE,0)+COALESCE(SS,0))

select
    AssetID
from (
    select distinct
        AssetID,
        KeywordID
    from AssetKeyword
    where
        KeywordID in (3,4,5)
) t
group by
    AssetID
having 
    COUNT(*) = 3

DECLARE @Range AS INT = 7374

;WITH E1(N) AS( -- 10 ^ 1 = 10 rows
    SELECT 1 FROM(VALUES (1),(1),(1),(1),(1),(1),(1),(1),(1),(1))t(N)
),
E2(N) AS(SELECT 1 FROM E1 a CROSS JOIN E1 b), -- 10 ^ 2 = 100 rows
E4(N) AS(SELECT 1 FROM E2 a CROSS JOIN E2 b), -- 10 ^ 4 = 10,000 rows
E8(N) AS(SELECT 1 FROM E4 a CROSS JOIN E4 b), -- 10 ^ 8 = 10,000,000 rows
CteTally(N) AS(
    SELECT TOP(@Range) ROW_NUMBER() OVER(ORDER BY(SELECT NULL))
    FROM E8
)
SELECT * FROM CteTally

SELECT PersonID FROM FormsSubmitted
WHERE 
    [type]="A" 
    AND 
    [month]="June"
    AND
    PersonID NOT IN (
        SELECT PersonID FROM FormsSubmitted
        WHERE [type]="B" AND [month]="August"
    )

Wishlist
wishlist_id, user_id, ...

WishlistEntry
wishlist_id, book_id, ...

SELECT scores.id, scores.name,items.id,items.weight, scores.score * items.weight/t.sum_weight AS 'last_score'
from scores
INNER JOIN items ON items.id = scores.item_id
INNER JOIN (SELECT scores.name, sum(items.weight) sum_weight
            FROM scores INNER JOIN items ON items.id = scores.item_id
            GROUP BY scores.name) t ON scores.name=t.name

Select ...
From wp_posts As P
Where Exists    (
                Select 1
                From wp_posts As P1
                    Join wp_term_relationship As WTR1
                        On WTR1.object_id = P1.ID
                            And WTR1.term_taxonomy_id In(3)
                Where P1.post_parent = P.Id
                    And P1.post_type = 'attachment'
                )
    And P.post_type = 'post'
Order By p.post_date DESC
Limit 15    

SELECT
    UserSessionSequenceID, 
    SessionGuid, 
    UserSessionID,
    SiteID, 
    Timestamp, 
    UrlTitle, 
    Url
FROM (
    SELECT
        Seq.UserSessionSequenceID, 
        Usr.SessionGuid, 
        Usr.UserSessionID,
        Usr.SiteID, 
        Usr.Timestamp AS UsrTimestamp, 
        Seq.Timestamp, 
        Seq.UrlTitle, 
        Seq.Url,
        ROW_NUMBER() OVER (PARTITION BY Usr.UserSessionID
                           ORDER BY Seq.UserSessionSequenceID DESC) AS rn
    FROM
        tblUserSession Usr
    INNER JOIN  
        tblUserSessionSequence Seq ON Usr.UserSessionID = Seq.UserSessionID
    WHERE     
        (Usr.Timestamp > DATEADD(mi, -45, GETDATE())) AND (Usr.SiteID = 15)
) T1
WHERE rn = 1
ORDER BY UsrTimestamp DESC

SELECT COUNT(*) AS count_value 
FROM submissions s
JOIN (
    SELECT username, number, tstmp 
    FROM submissions WHERE id = 1
) o ON s.number = o.number AND s.username = o.username AND s.tstmp < o.tstmp 

select pt.Schedid, pt.schedname,
       max(case when ct.citerianame = 'color' then ct.criteriavalue end) as Color, 
       max(case when ct.citerianame = 'width' then ct.criteriavalue end) as Width, 
       max(case when ct.citerianame = 'depth' then ct.criteriavalue end) as Depth
from parenttbl pt inner join
     criteriatbl ct
     on pt.schedid = ct.schedid
group by pt.schedid, pt.schedname;

insert into FINAL_TABLE   (EVENT_ID,  OID,  LINE_NUMBER)
  (
    select EVENT_ID,OID,
       ROW_NUMBER() OVER(PARTITION BY EVENT_ID ORDER BY OID) as LINE_NUMBER
    from source_table
  );

SELECT id, code 
FROM table 
GROUP BY id, code 
HAVING COUNT(code) > 1;

with vw1(val,flg,sumval) as
(select 1 val,0 flg,TOT_COUNT sumval
from TEMP where RESOURCE_VALUE = '1'
union all
select vw1.val + 1 val,
case when vw1.sumval + t1.TOT_COUNT > 300 then vw1.flg + 1 else vw1.flg end flg,
case when vw1.sumval + t1.TOT_COUNT > 300 then t1.TOT_COUNT else vw1.sumval + t1.TOT_COUNT end sumval
From TEMP t1,vw1 WHERE t1.RESOURCE_VALUE = TO_CHAR(vw1.val + 1))
select min(val) START_RESOURCE_VALUE,max(val) END_RESOURCE_VALUE,
max(sumval) "SUM" from vw1 group by flg order by min(val);

select case cast(month as number)
    when 1 then 'Jan'
    when 2 then 'Feb'
    when 3 then 'Mar'
    when 4 then 'Apr'
    when 5 then 'May'
    when 6 then 'Jun'
    when 7 then 'Jul'
    when 8 then 'Aug'
    when 9 then 'Sep'
    when 10 then 'Oct'
    when 11 then 'Nov'
    when 12 then 'Dec'
  end as mon
from ods_calendar_weeks cal
where cal.year not in (0, 9999);

DECLARE @dtstart DATETIME= '20150101'
DECLARE @dtend DATETIME= '20151231'

;WITH CTE AS 
(
SELECT 1 as WeekNo, @dtstart weekstart,DATEADD(d,6-DATEPART(WEEKDAY,@dtstart),@dtstart) weekend
UNION ALL
SELECT CTE.WeekNo + 1 as WeekNo, DATEADD(d,1,CTE.weekend),CASE WHEN  DATEADD(d,7,CTE.weekend) < @dtend THEN DATEADD(d,7,CTE.weekend) ELSE @dtend END
FROM CTE WHERE DATEADD(d,1,CTE.weekend) < @dtend
)
SELECT * FROM CTE;

create table i (i_dt date, i_val number);

insert into i values (to_date('18/5/2010 1pm','dd/mm/yyyy hham'),        40);
insert into i values (to_date('18/5/2010 2pm','dd/mm/yyyy hham'),        20);
insert into i values (to_date('18/5/2010 3pm','dd/mm/yyyy hham'),        60);
insert into i values (to_date('18/5/2010 4pm','dd/mm/yyyy hham'),        30);
insert into i values (to_date('18/5/2010 5pm','dd/mm/yyyy hham'),        60);
insert into i values (to_date('18/5/2010 6pm','dd/mm/yyyy hham'),        25 );
insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'),        300 );
insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'),        450 );
insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'),        375 );
insert into i values (to_date('20/5/2010 6pm','dd/mm/yyyy hham'),        250 );
insert into i values (to_date('20/5/2010 6pm','dd/mm/yyyy hham'),        310 );

select i_dt, i_val from 
   (select i.*, rank() over (partition by trunc(i_dt) order by i_val desc, i_dt asc) rn 
   from i) 
where rn = 1;

DELETE FROM `table_name` WHERE `P2` < `P1`;

DELETE FROM Element
WHERE Id IN (
    SELECT
        Ele
    FROM Cluster AS T
    CROSS APPLY (VALUES
        (T.Ele1)
        , (T.Ele2)
        , (T.Ele3)
    ) AS X (Ele)
    WHERE T.Group= 1
)

SELECT PROD_ID, GEOG_ID, SUM(VALUE1) AS TOTAL
FROM database 
WHERE GEOG_ID = 'MT' 
AND TIME_ID IN ('JAN', 'FEB')
GROUP BY PROD_ID, GEOG_ID

SELECT mt.emp_id
FROM my_table mt
LEFT JOIN my_table mtx ON (mtx.emp_id = mt.emp_id AND (mtx.isapproved = 0 OR mtx.isvalid = 0))
WHERE mt.isapproved = 1 AND mt.isvalid = 1 AND mtx.id IS NULL
GROUP BY mt.emp_id

SELECT
  Heading, 
  A Package_A,
  B Package_B,
  C Package_C,
  D Package_D
FROM (
      SELECT * FROM YourTable
) up 
PIVOT (sum(Limit) FOR Package IN (A, B, C, D)) AS pvt

SELECT FIND_IN_SET('b','a,b,c,d');

WITH t AS (SELECT 'first path**second path' text FROM DUAL
           UNION
           SELECT 'third pathfourth path' text FROM DUAL)
SELECT SUBSTR(REGEXP_SUBSTR(t.text,'(\*{2})(.+)'),3)
FROM t

SELECT name
CASE 
   WHEN ' ' || name || ' ' LIKE '% N %' THEN 'Red'
   WHEN ' ' || name || ' ' LIKE '% B %' THEN 'White'
   WHEN ' ' || name || ' ' LIKE '% RS %' THEN 'Green'
   ELSE 'Other'
END 
FROM mytable

ORDER BY CASE 
WHEN RQID <> '' 
THEN 1 
ELSE 0 
END, RQID, NEWID()

select year, 
       month,
       fixes,
       fixes - lag(fixes) over (order by year, month) as increase,
from the_table;

SELECT 
   A.sifKorisnikPK,
   IsNull(BrojDobrih,0) BrojDobrih,
   IsNull(BrojLosih,0) BrojLosih
FROM (select distinct sifKorisnikPK from Rezervacija) A
LEFT JOIN #LosaRez B
   ON A.sifKorisnikPK = B.sifKorisnikPK 
LEFT JOIN #DobraRez C
   ON A.sifKorisnikPK  = C.sifKorisnikPK 
ORDER BY (IsNull(BrojDobrih,0) - IsNull(BrojLosih,0))

SELECT userID, testID, MAX(someDate)
FROM @tmp
GROUP BY testId,userID;

SELECT IF(a > b, a, b) AS max_value
  FROM (SELECT MAX(up) AS a,
               MAX(down) AS b
          FROM table) x

select * from (
  select 'Test 1' thename union
  select 'Test 2' union 
  select 'Test 3'
)
where thename not in (select name from foo)

SELECT u.id AS userId, u.name AS userName, 
       g.id AS gradeId, g.name As grade
FROM users AS u
INNER JOIN grades AS g ON g.id = u.grade_id

SELECT C.*
  FROM Customer C 
       INNER JOIN CustDetail CD ON C.CustomerId = CD.CustomerId
       INNER JOIN Address A ON CD.DetailID = A.DetailID
       LEFT OUTER JOIN Group G ON C.CustomerId = G.CustomerId
       LEFT OUTER JOIN GroupDetail D ON G.GroupId = D.DetailId
WHERE ((G.Active = 1 AND C.code = 1) OR G.Active IS NULL) AND
      ((D.code = '1' AND C.code = 1) OR D.code IS NULL) AND
      C.Id = @customerId

declare @xml xml

set @xml = N'<CodeFiveReport><Owner UnitNumber="Mixed"/></CodeFiveReport>'
select T1.C1.value('upper-case((/CodeFiveReport/Owner/@UnitNumber)[1])', 'varchar(10)') from @xml.nodes('/') T1(C1)

SET @xml.modify('
                replace value of (/CodeFiveReport/Owner/@UnitNumber)[1]
                with xs:string(upper-case((/CodeFiveReport/Owner/@UnitNumber)[1]))
                ')

select @xml

Select @originalTxt = @SqlTxt, @orgtxt=@SqlTxt

Set @len=LEN(@orgtxt)

While @len > 0
    Begin       
        Set @len=LEN(@orgtxt)   
        Select @start=CHARINDEX('from',@orgtxt)
        Select @end=CHARINDEX('where',@orgtxt)


        If(@start != 0 and @end!=0)
            Begin
                set @split = Substring(@orgtxt, @start, @end-@start)

                Set @orgtxt = SUBSTRING(@orgtxt,@end + 5 ,@len-@end)

                Set @txt=@split

                Select @split=Replace(Replace(Replace(Convert(Varchar(Max),@split),'from ','from AB.'),'join ','join AB.') ,',',', AB.')

                Select @originalTxt=REPLACE(@originalTxt,@txt,@split)

                Set @txt=@originalTxt
            End
        Else
            Begin
                break
            End
    End

    If @txt is null
        Begin
            Select @txt=Replace(Replace(Convert(Varchar(Max),@originalTxt),'from ','from AB.'),'join ','join AB.')
        End

return @txt

CREATE TABLE #TEMP(id int, name varchar(100))
INSERT INTO #TEMP VALUES(1, 'John')
INSERT INTO #TEMP VALUES(1, 'Adam')
INSERT INTO #TEMP VALUES(1, 'Robert')
INSERT INTO #TEMP VALUES(1, 'Copper')
INSERT INTO #TEMP VALUES(1, 'Jumbo')
INSERT INTO #TEMP VALUES(2, 'Jill')
INSERT INTO #TEMP VALUES(2, 'Rocky')
INSERT INTO #TEMP VALUES(2, 'Jack')
INSERT INTO #TEMP VALUES(2, 'Lisa')
INSERT INTO #TEMP VALUES(3, 'Amy')

SELECT *
FROM #TEMP;

WITH CTE(N) AS
(
 SELECT ROW_NUMBER() OVER(PARTITION BY id ORDER BY id)
 FROM #Temp
)
DELETE CTE WHERE N>3;

SELECT *
FROM #TEMP;

DROP TABLE #TEMP

INSERT INTO studies
(
    id
    ,name_string
    ,description
    ,field
    ,is_active
    ,register_start
    ,register_end
    )

SELECT nextval('studiesSequence')
    ,NAME
    ,''
    ,3
    ,0
    ,register_start
    ,register_end
FROM dblink('dbname=mydb', 'select name,begins,ends from study') 
     AS t1(NAME VARCHAR(50), register_start DATE, register_end DATE);

DECLARE @input VARCHAR(10) = ' Person '; 

DECLARE @sql NVARCHAR(MAX) = '
SELECT count(*) AS  [@Input Open Data]    
FROM #Accounts a JOIN
     dbo.FileFeed t
     On t.ID = a.AccountID     
GROUP BY a.accountid';

SET @sql = REPLACE(@sql, '@Input', @Input);

exec sp_executesql @sql;

Dim query As String = "SELECT * FROM [Hiragana List] WHERE Pronunciation='" & character & "';"

SELECT a from Frais a where a.libelle = 'FRET' or a.libelle = 'Douane' or a.libelle = 'Transitaire'
order by case a.libelle when 'FRET' then 0 when 'Douane' then 1 when 'Transitaire' then 2 end

FMResultSet *results = [db executeQueryWithFormat:@"SELECT * FROM allitems WHERE choice1='%@' AND choice2='%@' AND choice3='%@' AND choice4='%@'"
                        ,capsChoiceOne,capsChoiceTwo,capsChoiceThree,capsChoiceFour];

SQL> select to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS.FF TZD') as d from dual;

D
----------------------------------
2008-10-21 17:00:43.501591

Select id, type from 
(SELECT id, GROUP_CONCAT(type SEPARATOR ',') AS type FROM rock_types 
        GROUP BY id) a
WHERE INSTR(type,"DWS")>0 OR INSTR(type,"Top rope")>0

SELECT "DATE", BUS, VALUE
FROM {your_table}
WHERE "DATE" >= trunc(sysdate) and "DATE" < trunc(sysdate+1)

SELECT name, 
       surname, 
       max(greatest(tbl_name.ora_rowscn, tbl_surname.ora_rowscn)) over () as max_rowscn
FROM tbl_name, tbl_surname 
WHERE tbl_name.id = tbl_surname.id

SELECT table_schema, table_name
FROM   information_schema.columns
WHERE  COLUMN_NAME = 'Id'        AND DATA_TYPE = 'uniqueidentifier'
OR     COLUMN_NAME = 'Message'   AND DATA_TYPE = 'nvarchar'
OR     COLUMN_NAME = 'EnteredOn' AND DATA_TYPE = 'datetime'
GROUP BY table_schema, table_name
HAVING COUNT(COLUMN_NAME) = 3

SELECT saledateid, sum(sl.quantity * sl.unitamount),
       sum(case when seqnum = 1 then s.saleamount end)
FROM sales s JOIN
     (SELECT sl.*, row_number() over (partition by saleid order by saleid) as seqnum
      FROM salelines sl
     ) sl
     USING (saleid)
GROUP BY saledateid;

SELECT  T.ID,
        T.Date,
        Lookback = COUNT(CASE WHEN t2.Date < T.Date THEN t2.ID END),
        Lookahead = COUNT(CASE WHEN t2.Date > T.Date THEN t2.ID END)
FROM    T
        INNER JOIN T t2
            ON t2.ID = t.ID
            AND t2.Date >= DATEADD(MONTH, -6, T.Date)
            AND T2.Date < DATEADD(MONTH, 6, T.Date)
GROUP BY T.ID, T.Date, T.KeyID;

content_type = models.ForeignKey(ContentType)
object_id = models.PositiveIntegerField()
content_object = generic.GenericForeignKey('content_type', 'object_id')

 UPDATE second_table ST
 SET ST.id = FT.id
 FROM first_table FT
 WHERE ST.date BETWEEN FT.run_date + interval '4 hour'
                   AND FT.run_date + interval '4 hour' + interval '1 day'

SELECT [Value] = T.c.value('.', 'varchar(30)')
FROM   (SELECT Cast(( '<s>' + Replace ((SELECT tag_id+',' FROM tbl_container_track FOR xml path('')), ',', '</s> <s>')
                      + '</s>' ) AS XML)) AS Data
       CROSS APPLY Data.nodes('/s') T(c) 

SELECT SUM(t1.total_time) FROM table1 as t1 
INNER JOIN table2 as t2 ON t1.vehicle_id = t2.vehicle_id AND t2.feature_id = 2

USE master;
GO
DENY VIEW ANY DATABASE TO [newlogin]; 
GO
USE yourDB;
GO
DROP USER newlogin;
GO
USE master;
GO
ALTER AUTHORIZATION ON DATABASE::yourDB TO [newlogin];
GO

explain select * from from cars;

LOAD DATA LOCAL INFILE 'c:/mytestfile.csv' INTO TABLE report.test
FIELDS TERMINATED BY ','
OPTIONALLY ENCLOSED BY '"' 
LINES TERMINATED BY '\n'
IGNORE 1 LINES
(ONE, TWO)

 ;WITH TEMPTABLE AS(
    SELECT  DATE_STAMP,
            ID,
            ROW_NUMBER() OVER( PARTITION BY ID ORDER BY DATE_STAMP ) AS ROWNUMBER,
            Count(ID) OVER(PARTITION BY Date_Stamp, ID) as countID
    FROM #temp)
    SELECT DATE_STAMP,
            ID,
            MAX(CASE WHEN ROWNUMBER = 1 THEN 1 ELSE 0 END )AS FIRST_ATTEMPT,
            MAX(CASE WHEN ROWNUMBER = 2 THEN 1 ELSE 0 END) AS SECOND_ATTEMPT,
            MAX(CASE WHEN ROWNUMBER = 3 THEN 1 ELSE 0 END) AS THIRD_ATTEMPT,
            MAX(countID) Total_Attempts
     FROM TEMPTABLE 
     GROUP BY DATE_STAMP,ID

SQL> SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual;
Enter value for 10:
old   1: SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual
new   1: SELECT 'HYPERLINK(".\"&"-00.PDF")' FROM dual

'HYPERLINK(".\"&"-00.PDF"
-------------------------
HYPERLINK(".\"&"-00.PDF")

SQL> SET DEFINE OFF
SQL> SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual;

'HYPERLINK(".\"&10&"-00.PDF"
----------------------------
HYPERLINK(".\"&10&"-00.PDF")

SQL>

 SELECT level, components.component_id, components.component_label, component_color.component_color
   FROM compenents JOIN component_color ON components.component = component_color.component
  START WITH components.component_label = 'Sample'
CONNECT BY PRIOR components.component_id = components.component_parent_id

SELECT 
    Item.Titel, Item.Uitgever, Game.PEGI, Game.EAN, 
    convert(varchar, Item.DvU, 101) AS DatumVUitgave, 
    Platform.Soort as Platform, Media.soort as Media, 
    GameGenre.Genre AS Genre,
    -- here's your new column:
    case when Item.Status=1 then 'Uitgeleend' else 'Binnen' end as Status
FROM Game 
LEFT JOIN ITEM ON Item.ID = Game.itemID 
LEFT JOIN Media ON Game.MediaID = Media.Id 
LEFT JOIN Platform ON Game.PlatformID = Platform.Id 
LEFT JOIN GameGenre ON Game.GameGenreID = GameGenre.Id

WITH Cte AS(
    SELECT
        dtt.*,
        dt.Data,
        Total = SUM(dt.Data) OVER(PARTITION BY dtt.Data_Type_ID),
        rn = ROW_NUMBER() OVER(PARTITION by dtt.Data_Type_ID ORDER BY dt.Date_Entered DESC)
    FROM Data_Type_Table dtt
    LEFT JOIN Data_Table dt
        ON dt.Data_Type_ID = dtt.Data_Type_ID
)
SELECT
    Data_Type,
    Total = ISNULL(Total, 0),
    Most_Recent = ISNULL(Data, 0)
FROM CTE 
WHERE rn = 1

SELECT m0.rowid AS r0,
       m1.rowid AS rn,
       m0.timestamp AS a,
       m1.timestamp AS b,
       m1.timestamp - m0.timestamp AS rd,
       m1.timetick - m0.timetick AS d
FROM (SELECT rowid,     -- This is the core query attaching to each row
             timestamp, -- the rowid of its next
             timetick,
             (SELECT rowid
              FROM measurements
              WHERE timestamp > m.timestamp
              ORDER BY timestamp
              LIMIT 1
             ) AS r1
      FROM Measurements AS m
     ) AS m0
JOIN measurements AS m1 ON m0.r1 = m1.rowid
WHERE m1.timetick - m0.timetick < 0;

SELECT G.value('@GroupId', 'varchar(max)') FROM
(
SELECT
    CAST(Document.data as XML) AS Goods
FROM 
    Documents as Document
WHERE type = 1
) T
CROSS APPLY T.Goods.nodes('Document/Good') D(G)
LEFT JOIN @Groups GS
ON G.value('@GroupId', 'varchar(max)') = GS.groupId
WHERE GS.groupId IS NULL

SELECT  
  transactions.idCampaignsList
  SUM(amountOriginal) AS euro,
  SUM(amountFinal) AS deducted,
  EXTRACT(YEAR_MONTH FROM(dateTransaction)) AS period
FROM transactions 
INNER JOIN campaignsList
        ON campaignsList.idCampaignsList = transactions.idCampaignsList 
INNER JOIN customers 
        ON customers.idCustomer = campaignsList.idCustomer 
WHERE customers.idCustomer = 14
GROUP BY period, transactions.idCampaignsList
ORDER BY period

select rownum, id,
       substr(']'||check_number||']'
              ,instr(']'||check_number||']',']',1,level)+1
              ,instr(']'||check_number||']',']',1,level+1) 
               - instr(']'||check_number||']',']',1,level) - 1) C1VALUE,
       substr(']'||amount||']'
              ,instr(']'||amount||']',']',1,level)+1
              ,instr(']'||amount||']',']',1,level+1) 
               - instr(']'||amount||']',']',1,level) - 1) C2VALUE
    from table
connect by id = prior id and prior dbms_random.value is not null  
      and level <= length(check_number) - length(replace(check_number,']')) + 1


ROWNUM ID  C1VALUE C2VALUE

1      1   1001    200
2      1   1002    300
3      1   1003    100
4      2   2001    500
5      2   2002    1000
6      3   3002    100
7      3   3004    300
8      3   3005    600
9      3   3007    200

SELECT id, description, 
CASE
   WHEN _dateUpdate IS NULL THEN _dateEntry
   WHEN _dateUpdate > _dateEntry THEN dateUpdate
   ELSE _dateEntry
END as date 
FROM mytable 
ORDER BY 
CASE
   WHEN _dateUpdate IS NULL THEN _dateEntry
   WHEN _dateUpdate > _dateEntry THEN dateUpdate
   ELSE _dateEntry
END desc

  SELECT DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)  AS WEEK_ENDING_DATE
        ,Year(DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)) AS [YEAR]
        ,(SUM(Value1) + SUM(Value2)) AS [Total1]
        ,(SUM(Value3) + SUM(Value4)) AS [Total2]
        ,((SUM(Value1) + SUM(Value2)) / (SUM(Value3) + SUM(Value4))) AS [Quote]
    FROM tbl
    WHERE DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE) BETWEEN DATEADD(dd, 7-(DATEPART(dw, FromDatePickerField)), FromDatePickerField)
            AND DATEADD(dd, 7-(DATEPART(dw, ToDatePickerField)), ToDatePickerField)
and date >= FromDatePickerField
and date <= ToDatePickerField
    GROUP BY DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)    
    ORDER BY DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)

SELECT Rnk,
       min(CASE WHEN Categ = 'A' THEN Nm END) as A,
       min(CASE WHEN Categ = 'B' THEN Nm END) as B,
       min(CASE WHEN Categ = 'C' THEN Nm END) as C
FROM (select t.*, row_number() over (partition by categ, rnk order by newid()) as sub_rnk
      from Tbl t
     ) t
GROUP BY rnk, sub_rnk
ORDER BY rnk;

select * from Vehicle v
where not exists (
    select 1 from Booking 
    where regNo = v.regNo
      and date_from <= '2015-04-05'
      and date_to   >= '2015-03-25' 
    )

SELECT Tanks.*, main.*, DT.MaxInspectionID, DT.MaxInspectionOrComplianceDate 

FROM
    (TankInspections main
    INNER JOIN Tanks ON Tanks.TankID = main.TankID)
    INNER JOIN    
    (
        SELECT [TankID],    
               Max(InspectionID) As MaxInspectionID,
               Min([Planned Inspection Date]) As MinInspection,
               Max([Planned Inspection Date]) As MaxInspection,    

               Min([Inspection Out of Compliance Date]) As MinCompliance,
               Max([Inspection Out of Compliance Date]) As MaxCompliance,

               Max(IIF(([Planned Inspection Date]) Is Null, 
                       IIF(ISNULL([Inspection Out of Compliance Date]), 
                           NULL, 
                           [Inspection Out of Compliance Date]),
                       [Planned Inspection Date])) As MaxInspectionOrComplianceDate        
        FROM TankInspections
        GROUP BY [TankID]    
    ) As DT

    ON main.TankID = DT.TankID
    AND main.InspectionID = DT.MaxInspectionID;

    <cfset form.filename = CFFILE.serverfile>

SELECT id, type, description FROM cars
UNION
SELECT id, type, description FROM planes
UNION
SELECT id, type, description FROM trains
ORDER BY id, type

with todelete as (
      select t.*, row_number() over (partition by Patientid, state, grp order by id) as seqnum
      from (select t.*,
                   (row_number() over (partition by PatientId order by id) -
                    row_number() over (partition by PatientId, state order by id)
                   ) as grp
            from table t
           ) t
    )
delete from todelete
    where seqnum > 1;

Sub Whatever()
    connection.ConnectionString = "server=***01\SQLEXPRESS; database=Billing; integrated security=yes"
    connection.Open()
    Using da As New SqlDataAdapter("Select * FROM [Billing] ORDER BY Customer", connection)
        da.Fill(datatableMain)
    End Using
    connection.Close()

    ' get distinct customers
    Dim dv As New DataView(datatableMain)
    Dim distinctCustomers As DataTable = dv.ToTable(True, "Customer")

    For Each customer As DataRow In distinctCustomers.Rows
        ' this messagebox is only to give you an idea which customer you are printing
        ' not required in actual code.
        MessageBox.Show("Exporting Customer... " & customer("Customer").ToString)

        Dim customerRows() As DataRow = datatableMain.Select("Customer=" & customer("Customer").ToString)  '<-- put single quotes around value if "Customer" field is of string type. e.g. "Customer='value'"
        For Each customerRow As DataRow In customerRows
            ' all the rows related to this customer are here
            ' do whatever you do to export

        Next
    Next
End Sub

CREATE OR REPLACE FUNCTION get_join_date( in_emp_no) RETURN DATE
IS
  v_join_DATE DATE;
BEGIN
  SELECT MIN(JOINED_DATE)
    INTO v_join_DATE 
    FROM employee
   WHERE employee_number = in_emp_no
     AND TYPE=in_type;
  return v_join_DATE;
end

SELECT 
    * 
FROM x_world as xr
INNER JOIN (
        SELECT 
                x,
                MAX(population)
        FROM x_world as xr
        GROUP BY x 
) as xt ON xt.x = xr.x
GROUP BY village

SELECT t2.CustomerID, t1.`Quarter`
FROM (
  SELECT 1 AS `Quarter` UNION ALL SELECT 2 UNION ALL 
  SELECT 3 UNION ALL SELECT 4
) AS t1
CROSS JOIN (
  SELECT DISTINCT CustomerID
  FROM salesorderheader
) AS t2 
LEFT JOIN (
  SELECT CustomerID, QUARTER(OrderDate) AS `Quarter`
  FROM salesorderheader
) AS t3 ON t2.CustomerID = t3.CustomerID 
           AND t1.`Quarter` = t3.`Quarter`  
WHERE t3.`Quarter` IS NULL
ORDER BY t2.CustomerID

SELECT c.name, COUNT(n.category) AS count_in_name_table
FROM categories c
LEFT JOIN name n ON n.category = c.name
GROUP BY c.name

with t as
(
select 'cab1' as c1, 'ae1' as e1 from dual
union all
select 'cab1' , 'ae2'  from dual
union all
select 'cab1' , 'ae3'  from dual
union all
select 'cab1' , 'ae4'  from dual
union all
select 'cab3' , 'ae1'  from dual
union all
select 'cab3' , 'ae1'  from dual
union all
select 'cab2' , 'ae'  from dual
)
SELECT
 c1,
 e1,
 COUNT(*) OVER (partition by c1) as p1
FROM t
GROUP BY c1, e1

select a, b, c, value
from tab
where tab.state = 'A' and not exists (
  select 1                          -- let the optimizer do its thing
  from tab ti
  where tab.state = 'B' and ti.a=tab.a and ti.b=tab.b and ti.c=tab.c)

ALTER PROCEDURE [dbo].[Provider]
(
    @strPro varchar(200)
)

AS
BEGIN
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT ON;

    DECLARE @SQL varchar(2000)

    -- Insert statements for procedure here
    SET @SQL = 'SELECT * FROM [db1].[dbo].[table1] '

    if @strPro <> 'All People'
    BEGIN
        SET @SQL = @SQL + ' WHERE [Name] = ''' + @strPro + '''
    END

    EXEC (@SQL)

END

select product_id, sum(quantity) As ProductQtySum
from OrdersProducts 
group by product_id 
order by ProductQtySum Desc

UPDATE table_name 
SET column1 = value, column2 = value2 
WHERE some_column = some_value

SELECT * FROM Items
WHERE (@ItemsWithPriceTenDollarsOrMore = 1 AND Price >=10)
OR (@ItemsWithPriceTenDollarsOrMore = 0 AND Price <10)
OR (@ItemsWithPriceTenDollarsOrMore IS NULL)

UPDATE  regm
SET     regm_pk = REGM_SEQ.nextval

CREATE TABLE PHONE_NUMBERS(PH_ID NUMBER(12), PHONE_NUMBER VARCHAR2(20));


   CREATE OR replace TRIGGER trg_test_numbers 
  BEFORE INSERT OR UPDATE ON phone_numbers 
  FOR EACH ROW 
BEGIN 
    IF Substr(:new.phone_number, 1, 2) = '1-' THEN 
      :new.phone_number := Substr(:new.phone_number, 1, 9) 
                           || '-' 
                           || Substr(:new.phone_number, 10); 
    END IF; 
END trg_test_numbers; 

insert into phone_numbers(ph_id, phone_number) VALUES(1,'1-210-5551212');
SELECT * from phone_numbers;

select a 
from tt
where B in (
            select B
            from tt
            group by b
            having count(*) >= 2);

SELECT c.city_name, pc.subcategory_id,
IFNULL((select `count` from products_counter where city_id = c.city_id 
                and subcategory_id = pc.subcategory_id),0) as 'Count'
FROM cities c CROSS JOIN products_counter pc

DECLARE @due_date DATE, @difference varchar(50), @id INT, @Now datetime = (Select GetDate());

DECLARE myCursor CURSOR FORWARD_ONLY FOR 
    SELECT [Engr Due], [Progress] 
    FROM dbo.Employee_Table OPEN myCursor

FETCH NEXT FROM myCursor INTO @due_date, @Progress
WHILE @@FETCH_STATUS = 0 
BEGIN 
    if (@Progress != 'Completed')
    BEGIN
        SELECT @difference = DATEDIFF(day, @Now, @due_date) 
        UPDATE Employee_Table
        SET [Remaining Days]=@difference 
        WHERE CURRENT OF myCursor 
    END
    FETCH NEXT FROM myCursor INTO @due_date, @Progress

END

CLOSE myCursor DEALLOCATE myCursor

mysql> SELECT GREATEST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00');
+-------------------------------------------------------------------+
| GREATEST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00') |
+-------------------------------------------------------------------+
| 2041-11-13                                                        |
+-------------------------------------------------------------------+
1 row in set (0.00 sec)

mysql> SELECT LEAST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00');
+----------------------------------------------------------------+
| LEAST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00') |
+----------------------------------------------------------------+
| 0000-00-00                                                     |
+----------------------------------------------------------------+
1 row in set (0.00 sec)

SELECT
    Contact
,   Customers
,   (SELECT SUM(Customers) FROM myTable t2 WHERE t2.Contact >= t1.Contact) as CummCustomers
FROM myTable t1

ORDER by MODULE_ID
   , case when COALESCE(fun.parent_function, fun2.function_id) is null then 1 else 0 end
   , FUNCTION_ID

proc sql;
create table want as
select ed, sum(smoke=1) as smoke1, sum(smoke=0) as smoke0
from sashelp.bweight
group by ed
order by ed;
quit;

INSERT INTO table_1 (user_id, room_id, enter_date)
VALUES  (1,1, NOW())
ON DUPLICATE KEY UPDATE
enter_date = NOW()

// or
INSERT IGNORE INTO table_1 (user_id, room_id)
VALUES (1,1)

insert Brands (AccountID, BrandName, Description, etc...)
  select 99, BrandName, Description, etc...
  from Brands
  where AccountID = 88;

select u.*
from (select u.unit_name, sum(hp + shield) as totalhealth,
             rank() over (order by sum(hp + shield) desc) as seqnum
      from units u
      group by unit_name
     ) u
where seqnum = 1;

SELECT * --You really should use only the columns you need instead of *
FROM Careers  
where (Location = @country OR @country is null)
and ([state] = @state OR @state is null)
and (position = @position or @position is null)

SELECT ID, Name, Designation,
    ROW_NUMBER() OVER (PARTITION BY Designation ORDER BY ID) AS Appearance
FROM theTable

UPDATE customers 
SET balance = balance - @amount
WHERE id = @id;

SELECT a.idea_id, a.property_id, a.the_idea, a.user_id, a.added_date, a.status, 
       SUM(b.thumbs = 1) AS up, SUM(b.thumbs = 0) AS down
FROM idea_box a 
LEFT JOIN idea_box_voting b ON a.idea_id = b.idea_id 
GROUP BY a.idea_id;

select max(case when id = 1 then x1 end) as x1_1,
       max(case when id = 1 then x2 end) as x2_1,
       max(case when id = 2 then x1 end) as x1_2,
       max(case when id = 2 then x2 end) as x2_2,
       max(case when id = 3 then x1 end) as x1_3,
       max(case when id = 3 then x2 end) as x2_3       
from (select t.*,
             row_number() over (partition by id order by (select null)) a seqnum
      from #test t
     ) t
group by seqnum;

select 
  u.userid
from
  usergroup u
where
  u.groupid in (27, 714)
group by
  u.userid
having 
  count(u.userid) > 1

SELECT
    COALESCE(p.id, c.id),
    COALESCE(p.name, c.name),
    p.num AS pending,
    c.num AS completed,
    COALESCE (p.num, 0) + COALESCE (c.num, 0) AS total
FROM
    pending p
    FULL OUTER JOIN
    completed c ON p.id = c.id

SELECT t1.date, t1.symbol, t1.MPR
FROM table1 t1
WHERE t1.MPR IN
(
  SELECT TOP 2 t2.MPR FROM table1 t2
  WHERE
  t2.date = t1.date
  ORDER BY t2.MPR DESC
)

ALTER PROC SP_SampleOuter
AS
DECLARE @count int
EXEC @count = SP_SampleInner

IF @count > 0
BEGIN
SELECT @count as Ctr,1
END
ELSE
BEGIN
SELECT @count as Ctr,0
END

SELECT COUNT(it.mac_id) AS total_installations, 
       COUNT(DISTINCT it.mac_id) AS unique_installations,
       COUNT(CASE WHEN it.uninstalled_date <> '0000-00-00 00:00:00' 
             THEN it.mac_id 
             ELSE NULL
             END) as total_uninstallations,
       COUNT(DISTINCT CASE WHEN it.uninstalled_date <> '0000-00-00 00:00:00' 
                      THEN it.mac_id 
                      ELSE NULL
                      END) as unique_uninstallations
FROM installation_tracking it 
GROUP BY it.rs_id

select count(*) as numCustomersFromSydney from table where Suburb = "Sydney";

SELECT  *
FROM    (
        SELECT  id
        FROM    (
                SELECT  id
                FROM    VWTenantPropertiesResults
                WHERE   ContentStreet = 'Holderness Road'
                UNION ALL
                SELECT  id
                FROM    VWTenantPropertiesResults
                WHERE   ContentTown = 'Hull'
                UNION ALL
                SELECT  id
                FROM    VWTenantPropertiesResults
                WHERE   ContentPostCode = 'HU'
                ) qi
        GROUP BY
                id
        HAVING  COUNT(*) >= 2
        ) q
JOIN    VWTenantPropertiesResults r
ON      r.id = q.id
WHERE   ContentBedrooms BETWEEN 1 AND 4
        AND ContentPrice BETWEEN 50 AND 500
ORDER BY
        ContentPrice

SELECT estimates.id,
estimates.estimate_number, 
estimates.description,
estimates.meeting_date,
estimates.job_date,
estimates.status,
estimates.price,
count(estimate_versions.estimate_id)
FROM
(estimates)
LEFT OUTER JOIN estimate_versions estimate_versions ON estimates.id = estimate_versions.estimate_id
LEFT OUTER JOIN customers customers ON estimates.customer_id = customers.id
WHERE customers.key = 'JsB4ND90bn'
group by
estimates.id,
estimates.estimate_number, 
estimates.description,
estimates.meeting_date,
estimates.job_date,
estimates.status,
estimates.price

WHERE users_friends.bID='$USER' AND users_friends.type = '$typeUsers' AND (
 (users.firstname = '$firstname' AND users.lastname='$lastname') OR
 (users.firstname LIKE '$firstname%' AND users.lastname LIKE '$lastname%') OR
 users.firstname LIKE '$firstname%' OR
 users.lastname LIKE '$firstname%'
)

insert into tbl_Name (Name)
values (EncryptByKey( Key_GUID('SymmetricKey1'), N'Catégories'))

update contacts set title =@title, firstName=@firstName, middleName=@middleName, lastName=@lastName where contactID=@ContactID

-- note table1 is your table

UPDATE t1 set t1.filed3 = t2.filed3 
from table1 t1, table1 t2
where t1.filed3 is null
and t2.filed3 is not null 
and t1.filed2 = t2.filed2 and 
t1.filed1 = t2.filed1

UPDATE `contacts` 
       SET `calls_to` = `calls_to`+1, 
             `cost_to` = `cost_to`+0.25 
  WHERE `contact_no`='0412345678' AND
          calls_to is not null AND
          cost_to is not null;

SELECT st_astext(st_line_substring(  st_linemerge(geom)  ,
                                  $bas/st_length(geom),
                                 $son/st_length(geom) ))
FROM geom_line
WHERE i_project = $id;

SELECT tsgroup
FROM   master
GROUP  BY tsgroup
ORDER  BY RIGHT(RTRIM(tsgroup), 3),
          LEFT(RTRIM(tsgroup), 3) 

DECLARE @sql AS NVARCHAR(MAX)
       ,@table AS NVARCHAR(MAX) = 'DATA_table';

SET @sql = 'stuff(( SELECT distinct [Site]
                    FROM [ProcterGamble_analytics].[dbo].' + @table + '
                    FOR XML PATH(''''), TYPE
                     ).value(''.'', ''NVARCHAR(MAX)'') 
                        , 1,  0, '''')';

EXEC(@sql);

CAST(value AS int)

SELECT T.*
FROM MyTable T
LEFT JOIN TblCountries C ON(T.Country = C.Country AND T.CountryCode = C.CountryCode)
WHERE C.CountryId IS NULL -- Assuming you have a column by that name that's not nullable.

select month, count(*)
from status s outer apply
     (select top 1 s2.*
      from status s2
      where s.person_id = s2.person_id and s2.month < s.month
      order by s2.month desc
     ) as sprev
where s.status = 3 and (sprev.status is null or sprev.status = 2)
group by month;

SELECT team, SUM(Win) As Won, SUM(Loss) as Lost, SUM(score) as Score
FROM
( SELECT team_one as team, 
     CASE WHEN one_score > two_score THEN 1 ELSE 0 END as Win, 
     CASE WHEN one_score < two_score THEN 1 ELSE 0 END as Loss, one_score as score
  FROM matches
  UNION ALL
  SELECT team_two as team
     CASE WHEN two_score > one_score THEN 1 ELSE 0 END as Win, 
     CASE WHEN two_score < one_score THEN 1 ELSE 0 END as Loss, two_score as score
  FROM matches
) t
GROUP BY team
ORDER By Won, Lost DESC, Score

values (NULL, "heart", "heart_shape.jpg", now());

SELECT
  n.id,
  IF(pmu.name IS NULL, pmm.name, pmu.name) recipient, 
  pmus.name sender, pm.msg, m.modification_id
FROM
  notification n
  LEFT JOIN user_modification m ON (n.modification_id = m.modification_id)
  LEFT JOIN pm ON (n.pm_id = pm.pm_id)
  LEFT JOIN users pmu ON (pm.recipent_id = pmu.user_id)
  LEFT JOIN users pmus ON (pm.sender_id = pmus.user_id)
  LEFT JOIN users pmm ON (m.user_id = pmm.user_id)
WHERE
  (pmu.name = 'Peter' OR 
     pmm.name = 'Peter') AND
  n.is_read = 0;

create schema authorization [schema name]
create table department 
(   code      varchar2(3) primary key,
    name      varchar2(40)  not null,
    chair     varchar2(11),
    constraint departmentChairFk foreign key(chair) references facultyStaff(staffId) on delete set null
)
create table facultyStaff 
(   staffID     varchar2(5) primary key,
    dob     date,
    firstName   varchar2(20),
    lastName    varchar2(20),
    rank        varchar2(10),
    deptCode    varchar2(3),
    constraint rankValue check (rank in ('Assistant', 'Associate', 'Full', 'Emeritus')),
    constraint facultyDeptFk foreign key (deptCode) references department (code)
)
create table student 
(   studentId   varchar2(5) primary key,
    dob     date ,
    firstName   varchar2(20),
    lastName    varchar2(20),
    status      varchar(10),
    major       varchar(3),
constraint statusValue check (status in ('Freshman', 'Sophomore', 'Junior', 'Senior',  'Graduate')),
    constraint studentMajorFk foreign key (major) references department (code)
);

WHERE CUS_joinDate BETWEEN DATEADD(mm,-1,GETDATE()) AND DATEADD(mm,1,GETDATE())

SELECT Centre.Centre_Name, Count(Shop_No) AS shopcount 
FROM Centre 
    LEFT JOIN Space ON Centre.Centre_Name = Space.Centre_Name 
GROUP BY Centre.Centre_Name

declare @stepsize float = 20.0

declare @val float = 17.6

select CEILING(@val / @stepsize) * @stepsize    -- Result 20.0

set @val = 31.2

select CEILING(@val / @stepsize) * @stepsize    -- Result 40.0

select `table1`.`NAME` AS `NAME`,`table2`.`PROMOTERID` AS `Promoter`
,(IFNULL(sum(`table2`.`GUESTS`),0) + `table1`.`GUESTS`) AS `TOTAL` from
(`table1` LEFT join `table2` on((`table1`.`ID` = `table2`.`PROMOTERID`))),
group by `table1`.`ID`

select * from users where  REGEXP_LIKE (first_name, '^[^0-9a-z]+$', 'i');

SELECT test_column 
FROM test_table 
ORDER BY cast(test_column as int)

DELETE  d
FROM device d
JOIN (
    SELECT DevNum, MAX(DevReadDate) maxDevReadDate
    FROM device
    WHERE devReadType = 'xx'
    GROUP BY DevNum
) b
ON d.DevNum = b.DevNum AND (d.DevReadDate < b.maxDevReadDate OR d.devReadType = 'xx')

select 
    @myWhereString =stuff((select 'or isnull('+COLUMN_NAME+','''') = '''' ' as [text()] 
                       from Primebet.INFORMATION_SCHEMA.COLUMNS 
                       where TABLE_NAME = 'YourTable'
                           and (column_name like 'col_as%'
                                or
                                column_name like 'col_m%')
                       for xml path('')),1,3,'')
set @myWhereString ='rest of your query'+ @myWhereString

exec executesql with your query

DROP TABLE IF EXISTS my_table;

CREATE TABLE my_table
(measurement_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
,TreeID  INT NOT NULL
,Diameter INT NOT NULL
);

INSERT INTO my_table (treeid,diameter) VALUES
(1      , 3),
(1      , 2),
(1      , 3),
(2      , 2),
(2      , 2),
(2      , 1),
(1      , 3);

SELECT x.*
     , COUNT(*) rank
  FROM my_table x
  JOIN my_table y
    ON y.treeid = x.treeid
   AND 
     ( y.diameter > x.diameter
       OR (y.diameter = x.diameter AND y.measurement_id <= x.measurement_id )
     )
  GROUP 
     BY x.treeid, x.diameter, x.measurement_id
-- HAVING rank < something
  ORDER BY treeid,rank;

  +----------------+--------+----------+------+
  | measurement_id | TreeID | Diameter | rank |
  +----------------+--------+----------+------+
  |              1 |      1 |        3 |    1 |
  |              3 |      1 |        3 |    2 |
  |              7 |      1 |        3 |    3 |
  |              2 |      1 |        2 |    4 |
  |              4 |      2 |        2 |    1 |
  |              5 |      2 |        2 |    2 |
  |              6 |      2 |        1 |    3 |
  +----------------+--------+----------+------+

Select
  Order.AccountID,
  Order.UserID,
  Order.OrderID,
  Order.OrderDate,
  User.UserName,
  Note.NoteID,
  Note.UserID,
  Note.NoteDate,
  Note.Text,
  NoteWriter.UserName as 'NoteWriter_Username'

FROM
  INNER JOIN User ON (Order.UserID=User.UserID)
  LEFT OUTER JOIN Note ON (Order.AccountID=Note.AccountID)
  LEFT OUTER JOIN user NoteWriter on NoteWriter.userid = Note.userID

WHERE
  Order.OrderDate >="2016-01-01"
  AND Order.OrderDate <= (current date -1 day)
  AND Note.NoteID IN (21,41,89)
  AND Note.NoteDate >="2016-01-01"
  AND Note.NoteDate<= (current date -1 day)

 SELECT e.Text AS StatusText,
        a.Created AS [DATE],
        CASE a.status
            WHEN 2 THEN NULL
            WHEN 3 THEN NULL
            ELSE a.Username
        END,  
        b.Name  AS CustomerName,
        c.Name  AS ServiceName,
        d.Message AS DeviationMessage
   FROM dbo.StatusUpdate AS a
        LEFT OUTER JOIN dbo.Customer AS b ON a.CustomerId = b.CustomerID
        LEFT OUTER JOIN dbo.Service AS c ON a.ServiceId = c.ServiceID
        LEFT OUTER JOIN dbo.Deviation AS d ON a.DeviationId = d.DeviationID
        LEFT OUTER JOIN dbo.StatusText AS e ON a.Status = e.ID

SELECT 'allEqual' AS COL1, COUNT(*) AS imgCount FROM (
    SELECT imgId AS primaryId FROM primary_images pi
    WHERE pi.ImgId = '$imgId' 
      AND pi.imgWidth = '$maxImageWidth' 
      AND pi.imgHeight = '$maxImageHeight'
    UNION ALL 
    SELECT primaryId FROM secondary_images si
    WHERE si.primaryId = '$imgId' 
      AND si.imgWidth = '$maxImageWidth'    
      AND si.imgHeight = '$maxImageHeight'  
) AS union_table                      

SELECT COUNT(CASE WHEN id = 2  THEN 1 END) 
       / COUNT(CASE WHEN id = 2 || id = 3 THEN 1 END) 
FROM candidate 

UPDATE
   DestinationTable 
SET 
   DestinationTable.money_owed = SourceTable.Credit
FROM
   DestinationTable 
INNER JOIN SourceTable
ON DestinationTable.Field2 = SourceTable.Field2

client_win_api_environment.get_windows_username();

Declare @total varchar (max)
set @total = 1

Declare @total2 varchar (max)
set @total2 = '1,4'

exec ('if '+@total+' in ('+@total2+') print ''Success'' ' )

DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX)

select @cols = STUFF((SELECT distinct ',' + QUOTENAME(task) 
                    from t1
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT entity, ' + @cols + ' from 
             (
                select entity, task, timespan
                from t1
            ) x
            pivot 
            (
                min(timespan)
                for task in (' + @cols + ')
            ) p '

execute(@query)

$result = db_query('SELECT nid FROM {node} WHERE ((status = :status) AND (type IN  (:type)) ORDER BY created DESC', array(':status'=>'1', ':type'=>'_my_content_type'))->fetchAll(PDO::FETCH_ASSOC);

foreach ($result as $row) {
  $node = node_load($row['nid']);
  // Access the field as $node->field_data_my_field_node_entity_type.
}

Select
    p.*,
    m.*
From (
    Select
        p.*,
        ph.*,
        count(pv.vote) vote_count,
        sum(pv.vote) vote_sum,
        sum(case when pv.vote > 0 Then 1 else 0 end) plus_votes,
        sum(case when pv.vote < 0 then 1 else 0 end) minus_votes
    From
        pictures p
            left join
        picture_votes pv
            On pv.picture_id = p.picture_id
            left join
        photographers ph
            On p.photographer_id = ph.photographer_id
    Where
        p.authenticated = 1 And
        p.picture_id = ?
    ) p
        left join
    picture_models m
        On p.model_id = m.model_id

update group_table 
join
  (
        select tab1.letter, tab1.id_group_table from 
        (
          select  letter,
          id_group_table, 
          count(letter) as occurrences
          from letter
          group by id_group_table, letter 
          order by occurrences desc
        ) tab1
        group by tab1.id_group_table having max(tab1.occurrences)    

  ) tab2 on group_table.id_group_table = tab2.id_group_table

set champion = tab2.letter
where group_table.id_whatever in (1,2,3,4);

=SUBSTITUTE(A1, "'", "''")

select id_one from yourtable
union 
select id_two from yourtable

2|4|8|16 -- rather than 30
1|32     -- rather than 33

String whereClause = "package_mane = ?"; // package_name perhaps?
String[] whereArgs = new String[]{"com.mynamespase.db"};

select s.id, s.classDate, s.instructor ,
count(distinct e.id) as enrolled,
count(distinct w.id) as waiting
from schedule as s
left outer join enrolled as e
on s.id = e.scheduleID
left outer join waitlist as w
on s.id = w.scheduleID
group by s.id

SQL> select rpad('*', level, '*') as c from dual connect by level <= 20 order by 
     length(c) desc;

C
------------------------------------
********************
*******************
******************
*****************
****************
***************
**************
*************
************
***********
**********
*********
********
*******
******
*****
****
***
**
*

20 rows selected.

SQL> select rpad('*', 2*level-1, ' *') as c from dual connect by level <= 20 order by 
     length(c) desc;

C
--------------------------------------------------
* * * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * * *
* * * * * * * * * * * * * * *
* * * * * * * * * * * * * *
* * * * * * * * * * * * *
* * * * * * * * * * * *
* * * * * * * * * * *
* * * * * * * * * *
* * * * * * * * *
* * * * * * * *
* * * * * * *
* * * * * *
* * * * *
* * * *
* * *
* *
*

20 rows selected.

select t.PATIENT_NUMBER, t.DATE_OF_VISIT, t.BMI
from t inner join
     (select PATIENT_NUMBER, max(DATE_OF_VISIT) as maxdate
      from t
      group by PATIENT_NUMBER
     ) tmax
     on t.PATIENT_NUMBER = tmax.PATIENT_NUMBER and t.DATE_OF_VISIT = tmax.maxdate;

select project
       sum(case when score = 'labour' then hours else 0 end) as labourHrs,
       sum(case when score = 'travel' then hours else 0 end) as travelhours
from t
group by project;

CREATE OR REPLACE TRIGGER check_order_employee_no
  ON INSERT INTO orders
  BEFORE EACH ROW
  AS
    match_count  INTEGER;
  BEGIN
    SELECT COUNT(*)
      INTO match_count
      FROM employee
      WHERE employee_no = :new.employee_no
        AND position IN (3,4,5,6);
    IF match_count = 0 THEN
      raise_application_error( -20000, 'Employee # for order must be for a Sales employee' );
    END IF;
  END check_order_employee_no;

SELECT MAX(RIGHT('0000000' + REVERSE(LEFT(REVERSE(YourTextColumn), PATINDEX('%[a-z]%', REVERSE(YourTextColumn)) - 1)), 7))
FROM YourTable

Declare @test as datetime
set @test = '2014-09-09 9:00:00'
SELECT DATEADD(second, DATEDIFF(second, GETDATE(), GETUTCDATE()), @test)

DECLARE
  max_length INTEGER; --Declare a variable to store max length in.
  v_owner VARCHAR2(255) :='exampleSchema';     -- Type the owner of the tables you are looking at

BEGIN
  -- loop through column names in all_tab_columns for a given table
  FOR t IN (SELECT table_name, column_name FROM all_tab_cols where owner=v_owner and table_name = 'exampleTableName') LOOP

    EXECUTE IMMEDIATE 
    -- store maximum length of each looped column in max_length variable
    'select nvl(max(length('||t.column_name||')),0) FROM '||t.table_name
    INTO max_length;

    IF max_length >= 0 THEN -- this isn't really necessary but just to ignore empty columns. nvl might work as well
      dbms_output.put_line( t.table_name ||' '||t.column_name||' '||max_length ); --print the tableName, columnName and max length
    END IF;

  END LOOP;
END;

WITH
MaxSalarySum AS (
  SELECT
    deptNo
    , twelveMonthsPlusYear
    , SUM(salValue) salValueSum
  FROM (
    select deptno, 12*month+year twelveMonthsPlusYear, salvalue 
    from career join salary on career.empno = salary.empno 
    and startdate<=to_date('01-'||to_CHAR(month)||'-'||to_CHAR(year),'dd-mm-yyyy') 
    and (
          enddate>=to_date('01-'||to_CHAR(month)||'-'||to_CHAR(year),'dd-mm-yyyy') 
          or enddate is null
        )
  )
  GROUP BY deptNo, twelveMonthsPlusYear
)
SELECT
  deptNo
FROM MaxSalarySum
WHERE salValueSum = (SELECT MAX(salValueSum) FROM MaxSalarySum)
;

SELECT MAX(Date), SUM(Value)
FROM MyTable
WHERE Date BETWEEN '2014-01-01' AND '2014-08-15';

SELECT MAX(a) + CASE WHEN (5 IN (SELECT a FROM t)) THEN 1 ELSE 2 END AS max_plus_something FROM t

declare @sqlstring varchar(1000)

set @sqlstring = 'SELECT * FROM Order WHERE 1=1 '

if @StartTime <> null OR @StartTime <> '' 
BEGIN 
set @sqlstring = @sqlstring + 'AND CreatedOn > CAST(@StartTime as datetime) ' 
END 

if @EndTime <> null OR @EndTime <> '' 
BEGIN 
set @sqlstring = @sqlstring + 'AND CreatedOn < CAST(@EndTime as datetime) ' 
END 

if @OrderStatusID <> null OR @OrderStatusID <> '' 
BEGIN 
set @sqlstring = @sqlstring + 'AND OrderStatusID = @OrderStatusID ' 
END 

if @CustomerEmail <> null OR @CustomerEmail <> '' 
BEGIN 
set @sqlstring = @sqlstring + 'AND CustomerEmail > @CustomerEmail ' 
END 

print @sqlstring
Exec(@sqlstring)

SQL> SELECT root || ',' || stragg(DISTINCT column2)
  2    FROM (SELECT CONNECT_BY_ROOT(column1) root, t.*
  3             FROM t
  4           CONNECT BY PRIOR column2 = column1
  5            START WITH column1 IN (SELECT column1
  6                                     FROM t
  7                                    WHERE column1 NOT IN (SELECT column2
  8                                                            FROM t))) v
  9   GROUP BY root;

ROOT||','||STRAGG(DISTINCTCOLU
-----------------------------------------
value1,value2,value3,value4,value7
value8,value9

SELECT         memno.1 EDTCDE(L), name.2, 'SYS1' NAME(SYS), "&&startdate" NAME(StartDate), CURRENT DATE NAME(CurDate)
FROM           library1/table1, library1/table2
JOIN               SSAN.1=SSAN.2
WHERE          DATE(TIMESTAMP)>StartDate AND RSCODE='STP'
UNION 
SELECT         memno.1 EDTCDE(L), name.2, 'SYS2' NAME(SYS), "&&startdate" NAME(StartDate), CURRENT DATE NAME(CurDate)
FROM           library2/table1, library2/table1
JOIN               SSAN.1=SSAN.2
WHERE          DATE(TIMESTAMP)>StartDate AND RSCODE='STP'
ORDER BY   sys ASC, memno ASC

SELECT
TO_CHAR(TO_DATE(TABLE.timestamp,'YYYYMMDDHH24MISS'), 'mm/dd/yyyy hh24:mi')
From XXXX.TABLE
WHERE ROWNUM < 10;

db2 VALUES CURRENT TIMEZONE

db2 "select CURRENT TIMEZONE from sysibm.sysdummy1"

SQL> ed
Wrote file afiedt.buf

  1  with x as (
  2    select 'Steve Jobs' str from dual union all
  3    select 'Stack Overflow Question' from dual
  4  )
  5  select substr( str, instr( str, ' ', -1 ) + 1 ) last_word
  6*   from x
SQL> /

LAST_WORD
----------------------------------------------------------------------  
Jobs
Question

SELECT  PRVDR_NUM,SUM(ITM_VAL) as SumReimb FROM hha2011num
INNER JOIN hha2011rpt ON hha2011num.RPT_REC_NUM = hha2011rpt.RPT_REC_NUM 
WHERE WKSHT_CD='D000000' AND LINE_NUM = '01201' AND CLMN_NUM in('0100','0200')
GROUP BY PRVDR_NUM ORDER BY PRVDR_NUM

ALTER TABLE tableA ADD version AS CHECKSUM(CityName)  PERSISTED

UPDATE     Car
SET        brand = 'Renault'
FROM       Car c
INNER JOIN Driver d ON c.driver = d.id
WHERE      d.Name = 'Marc'

SELECT *
  FROM T_USER u
 WHERE NOT EXISTS (SELECT NULL
                     FROM T_MESSAGE
                    WHERE user_id = u.user_id
                      AND msgType = 1
                      AND answered = 0)

SELECT DISTINCT 
     Renter.RenterID, 
     Property.PropertyId, 
     Property.PropertyName, 
     Type.TYPEName  
FROM Rental
    inner join Property on Rental.PropertyID = Property.PropertyID
    inner join Type on Property.TypeID = Type.TypeID
    inner join Renter on Rental.RenterID = Renter.RenterID
where Type.TypeName = 'villa'
and Renter.RenterFirstName = 'al'
and Renter.RenterLastName = 'smith'

SELECT state_name,district_name from TableName WHERE id='jk-01' //you can have your specific id here

SELECT table_1.id FROM table_1 LEFT JOIN table_2 ON table_2.id = table_1.id WHERE table_2.id IS NULL

Insert into taggings (id,tag_id,taggable_id,taggable_type,created_at) values (...your values...)

SELECT `UserName`, 
        `Message`,
        SUM(CASE WHEN `status` = 'SendingOK' THEN 1 ELSE 0 END) OkStat,
        SUM(CASE WHEN `status` = 'SendingFailed' THEN 1 ELSE 0 END) FailedStat
FROM    db1.SmsBroadcast as A
        JOIN db2.sentitems as B 
            ON A.MessageSMS1 = B.TextDecoded
WHERE   A.Username = 'jamesbond'
GROUP BY A.Username, A.Message

declare @start_date datetime, @end_Date datetime
select @start_date='2012-05-29 08:30:00.000', @end_date='2012-05-29 15:00:00.000'
select datediff(minute,@start_date ,@end_Date)/60.0

select p.id, p.name, 
  t.id as toyid, t.name as toyname
from person p
  inner join toys t on p.id = t.person_id
  inner join (
    select person_id
    from toys 
    group by person_id
    having sum(name = 'hat') > 0 and
      sum(name = 'doll') > 0
    ) t2 on p.id = t2.person_id

select
    user_id,
    days,
    date
from
    (
    select
        user_id,
        days,
        date,
        @sum_days := @sum_days + days as sum_days
    from
        myTable
    order by
        date desc
    ) t
    cross join (select @sum_days := 0) const -- resetting your @sum_days var.
where
    sum_days < X -- fill a number in for X here.

SELECT *
FROM `category`   AS c
INNER JOIN images AS i ON i.category = c.id
INNER JOIN
(
    SELECT  category, MAX(ID) AS MAXId
    FROM `images` 
    GROUP BY `category`
)AS a  ON i.category = a.category
      AND i.ID       = a.MaxID
WHERE c.`parent` = '1';

select xp.productid,
    xp.product,
    xc.classid,
    xco.optionid,
    xco.option_name,
    count(xi.optionid) as cnt
from xcart_products xp
inner join xcart_classes xc on xp.productid = xc.productid
    and xc.class = 'Color'
inner join xcart_class_options xco on xc.classid = xco.classid
left outer join xcart_images_D xi on xi.optionid = xco.optionid
group by xp.product
order by xp.product desc

SELECT * FROM Messages main LEFT JOIN Messages earlier
    ON earlier.time < main.time AND 
        (
            earlier.To_User = main.To_User AND earlier.From_User = main.From_User OR  
            earlier.To_User = main.From_User AND earlier.From_User = main.To_User
        )
WHERE (main.To_User = x OR main.From_User = x) AND earlier.id IS NULL
ORDER BY main.Time DESC

function h($s) { return htmlspecialchars($s); }
$conn = mysqli_connect(…);
$result = mysqli_query($conn, 'select * from fixtures order by date');

$lastdate = NULL;
while(($row = mysqli_fetch_assoc($result)) !== FALSE) {
  if($lastdate != $row['date']) {
    // output date divider/header
    echo '<h1>',h($row['date']),'</h1>';
    $lastdate = $row['date'];
  }

  echo h($row['hometeam']), ', ', h($row['awayteam']), ', ', h($row['time']);
}

SELECT   *
FROM     wp_booking_transaction
WHERE    /* Conditions that appeared in both original queries */
         DATE(launched) >= "2013-10-10" 
AND      DATE(launched) <= "2013-11-10"
AND      type = 2 
AND      student_id = 81569
AND      /* Conditions that are different between the two queries */
         ((action = 1 AND status = 1) OR (action IN(20, 21) AND status = 0))
ORDER BY launched DESC

CREATE PROCEDURE p_GetFromLog(@LogId int)
AS
BEGIN
    DECLARE 
    	@exe nvarchar(1000)
    	,@RefID int
    	,@RefTbl varchar(200)

    SET @RefTbl = SELECT [ReferenceLocation] FROM dbo.[Log] WHERE [LogID] = @LogId
    SET @RefID = SELECT [ReferenceID] FROM dbo.[Log] WHERE [LogID] = @LogId

    SET @exe= N'select * from database.schema.table_here WHERE [ID] = refrence_id_here'
    SET @exe = replace(@exe, 'database.schema.table_here', @RefTbl)
    SET @exe = replace(@exe, 'refrence_id_here', cast(@RefID AS varchar(12)))
    EXEC sp_executesql @exe
END

 DEFAULT 0

SELECT CONVERT(VARCHAR(15),CAST(sa.StartDateTime AS TIME),100

SELECT
  Year,
  CASE
    WHEN Item IN ('A', 'B', 'C') THEN 'Group1'
    WHEN Item IN ('D', 'E', 'F') THEN 'Group2'
    ELSE 'Others' END AS Item,
  SUM(Cost1),
  SUM(Cost2)
FROM myTable
GROUP BY
  Year,
  CASE
    WHEN Item IN ('A', 'B', 'C') THEN 'Group1'
    WHEN Item IN ('D', 'E', 'F') THEN 'Group2'
    ELSE 'Others' END;

SELECT REGEXP_SUBSTR('Outstanding Trade Ticket Report_08 Apr 14.xlsx', '\_(.*)\.', 
1, 1, NULL, 1) from dual

select
  Col_2,
  count(*)
from 
  your_table
group by
  Col_2
having
  count(*) > 1

SELECT 
  p.id_user,
  ap.post AS last_post,
  COUNT(*) as count
FROM 
  posts p
  JOIN posts ap on (
    p.id_user = ap.id_user
    AND ap.post_id = (
      SELECT MAX(post_id) FROM posts ip WHERE p.id_user = ip.id_user
    )
GROUP BY 
  p.id_user,
  ap.post
ORDER BY 
  COUNT(*) DESC

 SYS.DBMS_LOGMNR_D.BUILD(options => SYS.DBMS_LOGMNR_D.STORE_IN_REDO_LOGS);
                                                      ^^^^^^^^^^^^^^^^^^

SELECT     addon, status, SUM(amt1), SUM(amt2), company
FROM         test
WHERE     (addon = 'theft cover' OR
                  addon = 'key loss') AND (status = 'yes')
GROUP BY company, addon

SELECT `idMedication`,`idPatient`, CONCAT('(', `Drug` ,')') AS Drug from medication 

select *
from qsys2.systables
where table_schema IN ('LAWMOD9T', 'LIBDDS')

SQL> show parameter spfile;

NAME    TYPE    VALUE
----    ----   ----------------------------------------------------------
spfile  string /root/apps/oracle/10g/dbs/spfile<DB_NAME>.ora

select a.x,
select(mean(b.y) where b.x<a.x from data2 b) as m_y
from data1 a

CREATE TRIGGER ...
BEFORE UPDATE
...
DECLARE
  l_exists number(10);
  ...
BEGIN
  ...
  WHEN UPDATING ('SFBETRM_ESTS_CODE') THEN
    SELECT COUNT(*)
      INTO l_exists
      FROM DUAL
     WHERE EXISTS (SELECT null FROM SFBETRM_ESTS_CODE WHERE code = :new.SFBETRM_ESTS_CODE)
    ;
    IF l_exists = 1
    THEN
      ... -- perform the update operation
    ELSE
      ... -- ignore update operation
    END IF;
    ...
END;

where '#'+LangCodes+'#' like '%#en-us#%'

SELECT DISTINCT pbox.id as pbid,
cbox.id as cbid,
box.upload_type,
box.id,
box.box_type,
box.page_name,
box.title,
box.connect,
box.type,
box.uid,
box.description,
box.image,
box.url,
box.status,
box.date,
box.time
FROM boxes as box
LEFT JOIN page_boxes as pbox on pbox.bid=box.id
JOIN page_subcribers as pages on pages.page_id=pbox.page_id 
LEFT JOIN category_boxes as cbox on cbox.bid=box.id 
LEFT JOIN subcribers as catsb on cbox.category_id=catsb.cid 
WHERE (pages.uid='".$session_id."' 
or catsb.uid='".$session_id."')
and box.status='".$approval."' 
and cbox.id<'".$cbid."' 
and pbox.id<'".$pbid."'
ORDER BY pbox.id desc,cbox.id DESC 
LIMIT 10

var criteria = unitOfWork.CurrentSession.CreateCriteria(typeof(PageDetails))
               .CreateAlias("PageDetails", "pageDetails")
               .Add(Restrictions.Eq("pageDetails.PageRoom_Id", pageRoom.PageRoom_Id))
               .AddOrder(Order.Desc("SentDate"))
               .AddOrder(Order.Desc("Id"));

<?php

include("path/to/cake/config/database.php");
$db = new DATABASE_CONFIG;

echo $db->default['login'];
echo $db->default['password'];
echo $db->default['database'];

?>

select
  cast(left(r, charindex('%', r) - 1) AS float) as minVal,
  cast(replace(right(r, charindex('-', r) - 1), '%', '') as float) AS maxVal
from ( select '22.45% - 42.32%' as r ) as tableStub

where Info like '%foo%foo%'

SELECT *
FROM YourTable T
WHERE CustId IN (SELECT CustId
                 FROM YourTable
                 GROUP BY CustId
                 HAVING MIN(Location) <> MAX(Location))

SELECT
    Animal,
    SUM(CASE WHEN flg = 'A' THEN V1 ELSE 0 END) AS A_V1,
    SUM(CASE WHEN flg = 'A' THEN V2 ELSE 0 END) AS A_V2,
    SUM(CASE WHEN flg = 'B' THEN V1 ELSE 0 END) AS B_V1,
    SUM(CASE WHEN flg = 'B' THEN V2 ELSE 0 END) AS B_V2
FROM
    MyTab
GROUP BY
    Animal

select [Order qty] from [Client sales]

SELECT
    vf.Value AS Updated,
    item.ID AS ItemId,
    item.Name AS ItemName
FROM
    VersionedFields vf 
    JOIN Items item ON item.ID = vf.ItemId
WHERE
    vf.FieldId = 'D9CF14B1-FA16-4BA6-9288-E8A174D4D522' -- id of the __updated field
    -- vf.FieldId = '25BED78C-4957-4165-998A-CA1B52F67497' -- id of the __created field
    AND vf.Value > '20151027'

SELECT distinct
 c1.companyName,
 STUFF((SELECT ', '+ cn.name  
        from WMCCMCategories cn  
        INNER JOIN CategorySets uc 
        ON uc.categoryId = cn.categoryID 
        INNER JOIN KeyProcesses u 
        ON u.categorySetId = uc.setId  
        INNER JOIN Companies c 
        ON c.companyId = u.companyId        
        WHERE c.companyName = c1.companyName 
        ORDER BY cn.name FOR XML PATH('')), 1, 1, '') AS listStr 
FROM Companies c1
Group by c1.companyName

SELECT *
FROM myTable
WHERE ( YEAR(myfield) = '2009')
  AND ( MONTH(myfield) = '1')

CREATE OR REPLACE TYPE NUMBER_TABLE_TYPE AS TABLE OF NUMBER;

DECLARE

    updatedEmp NUMBER_TABLE_TYPE;
    sqlstr VARCHAR2(1000);
    tableName VARCHAR2(30) := 'EMPLOYEE';
    deptId NUMBER := 12;

BEGIN

    sqlstr := 'UPDATE '||tableName||' SET SALARY = SALARY * 2 WHERE DEPT_ID = :deptId '||
              'RETURNING EMP_ID  INTO :res'; 

EXECUTE IMMEDIATE sqlstr 
      USING deptId RETURNING BULK COLLECT INTO updatedEmp ;

END;

SET ROWCOUNT 1
SELECT %s FROM %s

SELECT ID, things = STUFF(
(
  SELECT ',' + t2.thing 
     FROM Table2 AS t2
    INNER JOIN Table1 AS ti
    ON ',' + ti.ids + ',' LIKE '%,' + CONVERT(VARCHAR(12), t2.id) + ',%'
    WHERE ti.ID = tout.ID
    FOR XML PATH, TYPE
).value('.[1]', 'nvarchar(max)'), 1, 1, '')
FROM Table1 AS tout
ORDER BY ID

UPDATE  board a
        LEFT JOIN pins b
            ON a.id = b.board_ID
SET     a.hide = 1
WHERE   b.board_ID IS NULL

DELETE t1
FROM mytable t1
JOIN (SELECT Title, MAX(Created_at) AS max_date
      FROM mytable
      GROUP BY Title) t2
ON t1.Title = t2.Title AND t1.Created_at < t2.max_date   

update table1 set "date" = to_date(date_txt, 'MM/DD/YYYY HH:MI:ss AM')

SELECT DISTINCT
   r.id,
   r.name
FROM
   resource r
WHERE
   NOT EXISTS(
      SELECT
         *
      FROM
         resource_role_join rrj
         LEFT OUTER JOIN
            user_role_join urj
         ON
            urj.role_id = rrj.role_id AND
            urj.user_id = :USER_ID
      WHERE
         r.id = rrj.resource_id AND
         urj.role_id IS NULL
   )
;

WITH archive AS
(
    SELECT CASE WHEN EXISTS(SELECT 1 FROM dbo.tbl_Department d
                            WHERE d.DepartmentID = e.DepartmentID)
           THEN 'Department Found' 
           ELSE 'Department Not Found' END AS DepartmentStatus
    FROM   dbo.tbl_Employee WITH (NOLOCK) e
)
SELECT DepartmentStatus, Count(*) As Cnt 
FROM archive
GROUP BY DepartmentStatus

cd /opt/db
DATESTRING=$(date "+%Y-%m-%d 00:00:00" -d "now -90 day")
for DBFILE in *.db
do
  echo "delete from tbl_outbox where time<='$DATESTRING'; vacuum;" | sqlite3 $DBFILE
done

select id from table2 where feature = 'Car'
intersect 
select id from table2 where feature = 'Moto'

UPDATE DOT_WORKS 
SET START_DATE = case when END_DATE IS NULL then :StartDate else START_DATE end,
    WORKS_TYPE = case when WORKS_GROUP = :WorksGroup then :WorksType else WORKS_TYPE end,
    WORKS_CONNECTION = case when WORKS_PLACE = :WorksPlace then :WorksConn else WORKS_CONNECTION end
WHERE ID = :WorksId 
and 
(
  END_DATE IS NULL OR
  WORKS_GROUP = :WorksGroup OR
  WORKS_PLACE = :WorksPlace
)

SELECT t1.v
FROM (VALUES (1), (2), (3), (4), (5)) t1(v)
LEFT JOIN mytable t2 ON t1.v = t2.id
WHERE t2.id IS NULL

LOAD DATA LOCAL INFILE 'file.csv' INTO TABLE my_table
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
(name, address, @var1)
set dateOfBirth = STR_TO_DATE(@var1, '%d-%b-%y')

--Cursor for iterating
DECLARE @tableCursor       CURSOR
DECLARE @TABLE_NAME        NVARCHAR(255)
DECLARE @COLUM_NAME        NVARCHAR(255)
DECLARE @ID_COLUM          NVARCHAR(255)
DECLARE @CODELANGUE_COLUMN  NVARCHAR(255)

SET @tableCursor = CURSOR FOR SELECT TABLE_NAME, COLUM_NAME, ID_COLUMN, CODELANGUE_COLUMN FROM [tableData] -- Substitute with the name of your table as given in your question (which you didn't specify)

OPEN @tableCursor
FETCH NEXT FROM @tableCursor INTO @TABLE_NAME, @COLUM_NAME, @ID_COLUMN, @CODELANGUE_COLUMN
WHILE (@@fetch_status = 0)
BEGIN
   --dynamic sql
   DECLARE @sql NVARCHAR(max)

   --Your logic here...
   SET @sql = 'SELECT ' + @COLUM_NAME + ', ' + @ID_COLUM + ' FROM ' + @TABLE_NAME + ' WHERE ' + @CODELANGUE_COLUMN + ' = 1'
   EXEC dbo.sp_executesql @sql

FETCH NEXT FROM @tableCursor INTO @TABLE_NAME, @COLUM_NAME, @ID_COLUMN, @CODELANGUE_COLUMN
END

CLOSE @tableCursor
DEALLOCATE @tableCursor

select * from MyDatabase.dbo.MyTable

select id from foo
inner join bar b1 on b1.fooId=foo.id and b1.baz=94
left outer join bar b2 on b2.fooId=foo.id and b2.baz=100
where b2.fooId is null

var query = from a in context.TB_UTILIDADE_PUBLIC_UTP
            join b in context.TB_UTILIDADE_PUBLIC_SECTOR_UPS 
              on a.UPS_ID equals b.UPS_ID
            join c in context.TB_UTILIDADE_PUBLIC_SUBSECTOR_USS 
              on new { a.USS_ID, a.UPS_ID } equals new { c.USS_ID, c.UPS_ID }
            select new
            {
              a.UTP_NAME, 
              b.UPS_NAME, 
              c.USS_NAME
            };

SELECT DATE(c.date_created) AS `date`
       ,COUNT(DISTINCT c.customer_id) AS registered_customers_who_bought
FROM customer AS c
JOIN purchase AS p
  ON c.customer_id = p.customer_id
    AND DATE(c.date_created) = DATE(p.date_modified)
WHERE (c.`date_created` >= '2011/09/01' and c.`date_created` < '2014/05/14')
GROUP BY DATE(c.date_created)

BEGIN
   FOR rs in (SELECT TABLESPACE_NAME 
                FROM DBA_DATA_FILES WHERE FILE_NAME LIKE '/vol1/u06%')  LOOP
      BEGIN
         EXECUTE IMMEDIATE 'DROP TABLESPACE ' || rs.TABLESPACE_NAME || ' INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS';
      END;
   END LOOP;
END;

CREATE TABLE table1 (
  column1 VARCHAR(255) DEFAULT NULL
);

CREATE TABLE messages (
  id INT(11) NOT NULL AUTO_INCREMENT,
  message VARCHAR(255) DEFAULT NULL,
  time TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (id)
);

DELIMITER $$

CREATE TRIGGER trigger1
    AFTER INSERT
    ON table1
    FOR EACH ROW
BEGIN
  INSERT INTO messages(message) VALUES ('new action');
END
$$

DELIMITER ;

select
    P.ID
from dbo.Partners as P
    left outer join dbo.vw_Partners_Codes2 as PC with (noexpand) on PC.Partner_ID = P.ID;

SELECT field, ca2.c2, ca3.c3
FROM table t
cross apply(SELECT COUNT(*) c2
            FROM table2 t2
            WHERE t2.field = t.field)ca2
cross apply(SELECT COUNT(*) c3
            FROM table3 t3
            WHERE t3.field = t.field)ca3
where ca2.c2 <> ca1.c1

 SELECT ti.FIRST_NAME "Technician",wo.WORKORDERID "Request ID",aau.FIRST_NAME "Requester",ti.FIRST_NAME "Technician",
    wotodesc.FULLDESCRIPTION "Description",DATEDIFF(day, DATEADD(s, wo.CREATEDTIME/1000, '01-01-1970 00:00:00'), getDate()) "Created Time",
    std.STATUSNAME "Request Status" 
    FROM WorkOrder wo 
    LEFT JOIN SDUser sdu 
    ON wo.REQUESTERID=sdu.USERID 
    LEFT JOIN AaaUser aau 
    ON sdu.USERID=aau.USER_ID 
    LEFT JOIN WorkOrderToDescription wotodesc 
    ON wo.WORKORDERID=wotodesc.WORKORDERID 
    LEFT JOIN WorkOrderStates wos 
    ON wo.WORKORDERID=wos.WORKORDERID
    LEFT JOIN SDUser td 
    ON wos.OWNERID=td.USERID 
    LEFT JOIN AaaUser ti 
    ON td.USERID=ti.USER_ID 
    LEFT JOIN StatusDefinition std 
    ON wos.STATUSID=std.STATUSID
    WHERE  ((std.STATUSNAME != N'Closed' COLLATE SQL_Latin1_General_CP1_CI_AS) OR (std.STATUSNAME IS NULL)) AND (DATEDIFF(day, DATEADD(s, wo.CREATEDTIME/1000, '01-01-1970 00:00:00'), getDate()) >= 7)
    order by ti.FIRST_NAME

INSERT INTO receiving_tbl(id, name, color) 
SELECT id, name
     , CASE color_id WHEN 1 THEN 'Green'
                     WHEN 2 THEN 'Red'
                     ...
                     ELSE NULL
       END 
FROM parent_tbl

If CurrentRecord = Recordset.RecordCount And CurrentRecord <> 1 Then
    DoCmd.GoToRecord , "", acFirst
Else
    DoCmd.GoToRecord , "", acNext
End If    

select Steuersatz% 
from USt
where Steuersatz = 1
and Datum = (select max(Datum)
             from USt
             where Steuersatz = 1
               and Datum <= your_date)  

SELECT
    *
FROM
    node_weather
JOIN
(
    SELECT
        tblInner.P_id,
        MAX(tblInner.time) AS maxTime
    FROM
        node_weather as tblInner
    GROUP BY
        tblInner.P_id
) AS tblMax 
    ON tblMax.maxTime = node_weather.time 
    AND tblMax.P_id = node_weather.P_id

Private Sub SearchButton_Click(sender As Object, e As EventArgs) Handles SearchButton.Click
    Dim connection = New SqlConnection("Your Connection string here")
    Dim command = New SqlCommand("SELECT StringColumn, BooleanColumn FROM YourTable WHERE KeyColumn=@KeyColumn", connection)
    command.Parameters.Add(New SqlParameter("@KeyColumn", Int32.Parse(KeyColumnTextBox.Text)))
    connection.Open()
    Dim reader = command.ExecuteReader()
    While reader.Read()
        StringColumnTextBox.Text = reader.GetString(0)
        BooleanColumnCheckBox.Checked = reader.GetBoolean(1)
    End While
End Sub

declare @idToDelete varchar(max) = '10'

declare @sql nvarchar(max) = ''

set @sql =
(
select 'delete ' + object_name(c.object_id) + ' where id = ' + @idToDelete +  char(10)
from sys.columns c 
    join sys.objects o on o.object_id = c.object_id
    join sys.schemas s on s.schema_id = o.schema_id
        and s.name = 'dbo'
where c.name = 'id'     
for xml path('')
)

print @sql

exec sp_executesql @sql

select k.*
from (select k.*,
             row_number() over (partition by cla_id order by final_score desc) as seqnum
      from klas
     ) k
where seqnum <= 10;

having amount <> 0

select emp_id,name,
(select name from employee_details a where a.emp_id = b.manager_id) as manager_name  
from employee_details b

where a.c1 in
 (
   SELECT CAST(token AS INT)
   FROM TABLE (STRTOK_SPLIT_TO_TABLE(1, '1,2,3,4,5,6,7,8,9,5000', ',')
        RETURNS (outkey INTEGER,
                 tokennum INTEGER,
                 token VARCHAR(10) CHARACTER SET UNICODE)
              ) AS dt 
 )

SELECT
    CASE WHEN
        (SELECT TOP 1 x FROM y) IS NULL
    THEN 'No'
    ELSE 'Yes'
    END AS BooleanValue

SELECT Value1,
       CASE WHEN Value2 = 50 THEN 0 ELSE Value2 END Value2,
       .....

... AND EXTRACT(YEAR FROM "ExpiryDate") = 2012 ...

SELECT service_name,
       GROUP_CONCAT(sensor_name ORDER BY sensor_name) AS sensors
FROM sensor_common_service
GROUP BY service_name
HAVING sensors='humidity,temperature'

select t.* from TeamRankings t
inner join (select team_id, year, min(source_id) as minSource
            from TeamRankings group by team_id, year) f
on t.team_id = f.team_id AND t.year = f.year AND t.source_id = f.minSource

select
    f1.data, f2.data, f3. data

from (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f1

left join (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f2 on f2.row_num = f1.row_num + (select CEILING(COUNT(1) / 3) + 1 from your_table)
left join (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f3 on f3.row_num = f1.row_num + (select CEILING(COUNT(1) / 3) + 1 from your_table) * 2

where f1.row_num between 1 and FLOOR((select COUNT(1) from your_table) / 3) + 1

SELECT row_number() over (ORDER BY something) as num_by_something, *
FROM table
ORDER BY something;

-- find t1 where it has 2 and 7 in t2

    select t1.*
    from table1 t1
    join table2 ov2 on t1.id=ov2.masterid and ov2.optionValue=2
    join table2 ov7 on t1.id=ov7.masterid and ov7.optionValue=7

-- find t1 where it has 2 and 7 in t2, and no others in t2

select t1.*, ovx.id
    from table1 t1
      join table2 ov2 on t1.id=ov2.masterid and ov2.optionValue=2
      join table2 ov7 on t1.id=ov7.masterid and ov7.optionValue=7
      LEFT OUTER JOIN table2 ovx on t1.id=ovx.masterid and ovx.optionValue not in (2,7)
    WHERE ovx.id is null

// Join table B on table A through a foreign key
$sql = 'select a.id, a.x, b.y
    from a
    left join b on b.a_id=a.id
    order by a.id';

// Execute query
$result = $this->db->query($sql)->result_array();

// Initialise desired result
$shaped_result = array();

// Loop through the SQL result creating the data in your desired shape
foreach ($result as $row)
{
    // The primary key of A
    $id = $row['id'];

    // Add a new result row for A if we have not come across this key before
    if (!array_key_exists($id, $shaped_result))
    {
        $shaped_result[$id] = array('id' => $id, 'x' => $row['x'], 'b_items' => array());
    }

    if ($row['y'] != null)
    {
        // Push B item onto sub array
        $shaped_result[$id]['b_items'][] = $row['y'];
    }
}

**Customer table**
CustomerId
LastName
FirstName
...

**CustomerAttributes table**
CustomerId
AttributeName
AttributeValue

if coalesce(@var, 0) <> 1
    PRINT 'not 1'
ELSE 
    PRINT 'equals 1'

SELECT Path FROM PathTable WHERE Path NOT LIKE '%/%'

IF ((SELECT COUNT(*) FROM table1 WHERE project = 1) > 0) 
    SELECT product, price FROM table1 WHERE project = 1
ELSE IF ((SELECT COUNT(*) FROM table1 WHERE project = 2) > 0) 
    SELECT product, price FROM table1 WHERE project = 2
ELSE IF ((SELECT COUNT(*) FROM table1 WHERE project = 3) > 0)
    SELECT product, price FROM table1 WHERE project = 3

SELECT
   e.Name,
   (SELECT
      SUM(TravelDurationDays)
   FROM
      TravelType1
   WHERE
      EmployeeID = e.EmployeeID
   ) TravelType1Days,
   (SELECT
      COUNT(*)
   FROM
      TravelType2
   WHERE
      EmployeeID = e.EmployeeID AND
      Travel = 'yes'
   ) TravelType2Days
FROM
   Employees e

ORDER BY RIGHT(CONVERT(CHAR(4), InvoiceDate, 100) + CONVERT(CHAR(4), InvoiceDate, 120),4)
         MONTH(InvoiceDate)

DECLARE @InputString VARCHAR(100);
SET @InputString = 'hello i am here in this bright room';

SELECT *
    FROM YourTable
    WHERE CHARINDEX(YourColumn, @InputString) <> 0;

DECLARE @sqlstmt VARCHAR(MAX)
SET @sqlstmt = 'SELECT vin FROM cars WHERE 1=1'
IF @interior<>'No Preference'
   SET @sqlstmt = @sqlstmt + ' AND interior = '''+@interior+'''
IF @color<>'No Preference'
   SET @sqlstmt = @sqlstmt + ' AND color = '''+@color+'''
...
exec(@sqlstmt)

alter table category modify column catid int(11) NOT NULL;

SELECT g.id group_id, g.name group_name,
       a.last_written, a.total_articles, a.total_done,
       c.last_comment
  FROM groups g LEFT JOIN 
(
    SELECT `group`, 
            MAX(CASE WHEN done = 1 THEN written END) last_written,
            COUNT(*) total_articles,
            SUM(done) total_done
      FROM articles
     WHERE active = 1
       AND user_id = 1
     GROUP BY `group`
) a 
    ON g.id = a.`group` LEFT JOIN 
(
    SELECT a.`group`,
           MAX(date_added) last_comment
      FROM commants c JOIN articles a
        ON c.article_id = a.id
     WHERE a.active = 1
       AND a.user_id = 1
     GROUP BY a.`group`
) c
    ON g.id = c.`group`
 WHERE  user_id =  1

SELECT  ss1.userid, ss2.userid, SUM(sales)
FROM    session ss1
JOIN    session ss2
ON      ss2.sessionid = ss1.sessionid
        AND ss2.userid < ss1.userid
JOIN    sales s
ON      s.sessionid = ss1.sessionid
GROUP BY
        ss1.userid, ss2.userid

SELECT * FROM 
 (  
 SELECT deptno
      , ename
      , sal
      , RANK() OVER (PARTITION BY deptno ORDER BY sal desc) rnk 
      , ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal desc) rno 
      , MAX(hiredate) OVER (PARTITION BY deptno ORDER BY deptno) max_hire_date
   FROM emp_test
  WHERE deptno = 20
 ORDER BY deptno
 )
 WHERE rnk = 1
   --AND rno = 1 -- or 2 or any other number...
/

SQL>

DEPTNO  ENAME   SAL    RNK  RNO HIREDATE    MAX_HIRE_DATE
-----------------------------------------------------------
 20     SCOTT   3000    1   1   1/28/2013   1/28/2013
 20     FORD    3000    1   2   12/3/1981   1/28/2013

SELECT user_id, username, SUM(revenue) FROM table
GROUP BY user_id /* add ', username' ONLY if two different usernames with the same user_id is a possible case */
ORDER BY SUM(revenue) DESC
LIMIT 0,1

SELECT *
FROM 
(
    SELECT 
        *
    FROM 
        TableA
    WHERE ColA = '001'
)
PIVOT
(
    MAX(ColC)
    FOR ColB IN ('AA1','AB1','AC1')
 )

update table1 t1
join table2 t2 on t1.B = t2.B
set t1.A = 'some value'

DELETE target 
FROM MnA target INNER JOIN MnA temp 
     ON (target.symbol = temp.symbol 
         AND target.direction = temp.symbol
         AND target.start_doy = temp.start_doy
         AND target.diff = temp.diff
         AND target.id != temp.id 
         AND temp.avg_percent > target.avg_percent);

SELECT * from customers
WHERE customer_id not in (select customer_id from order)

select empcode, DateValue(PunchTime),
    sum(IIF(IsInPunch='F',PunchTime,0)) -
    sum(IIF(IsInPunch='T',PunchTime,0))
from TimeSheet
group by empcode, DateValue(PunchTime)

CREATE TABLE Emp(EPID INT PRIMARY KEY,
    t CHAR(2) NOT NULL, UNIQUE (EPID,t));

CREATE TABLE EmpFT(EPID INT PRIMARY KEY, ... other columns
    t CHAR(2) NOT NULL CHECK (t = 'FT'),
    FOREIGN KEY (EPID,t) REFERENCES Emp (EPID,t));

CREATE TABLE EmpPT(EPID INT PRIMARY KEY, ... other columns
    t CHAR(2) NOT NULL CHECK (t = 'PT'),
    FOREIGN KEY (EPID,t) REFERENCES Emp (EPID,t));

    public partial class LegacyDate
    {
      public static implicit operator DateTime?(LegacyDate value)
      {
          return LegacyDateConverter.ToDate(value.DbData);
      }

      public static implicit operator LegacyDate(DateTime? value)
      {
          return new LegacyDate { DbData = LegacyDateConverter.ToLegacyDate(value) };
      }
   }

    internal static class LegacyDateConverter
    {
        public static DateTime? ToDate(int data)
        {
            if (data == 0) return null;
            int year = data/10000;
            int month = (data%10000)/100;
            int day = data/1000000;
            DateTime date;

            try
            {
                date = new DateTime(year, month, day);
            }
            catch (Exception e)
            {
                throw new ArgumentException(String.Format(
                    "Value {0} kan not be converted to DateTime", data), e);
            }
            return date;
        }

        public static int ToLegacyDate(DateTime? value)
        {
            int dateInt = 0;
            if (value.HasValue)
            {
                dateInt =
                value.Value.Year*10000 + value.Value.Month*100 + value.Value.Day;
            }
            return dateInt;            
        }
    }

UPDATE `Products`
SET `Price` = REPLACE(`Price`, '$', '')
WHERE `Price` LIKE '%$%';

SELECT *
FROM User u1 
INNER JOIN User u2 on u2.id_company = u1.id_company
INNER JOIN Ticket t on t.id_author = u2.id_user
WHERE u1.Name = @SessionUser

SELECT * FROM table1 t1
WHERE EXISTS (
  SELECT null FROM Table1 t2
  WHERE t1."TEACHER" = t2."TEACHER"
    AND t1."SUBJECT" = t2."SUBJECT"
    AND t1."ID" <> t2."ID"
)
ORDER BY "ID"

TINYBLOB, TINYTEXT       L + 1 bytes, where L < 2^8    (255 Bytes)
BLOB, TEXT               L + 2 bytes, where L < 2^16   (64 Kilobytes)
MEDIUMBLOB, MEDIUMTEXT   L + 3 bytes, where L < 2^24   (16 Megabytes)
LONGBLOB, LONGTEXT       L + 4 bytes, where L < 2^32   (4 Gigabytes)

SELECT
  serialnumber,
  state,
  at,
  operatorid,
  LAG(state) OVER (PARTITION BY serialnumber ORDER BY at) AS previous
FROM
  voucher
WHERE
  serialnumber in (SELECT DISTINCT serialnumber FROM voucher WHERE at LIKE '&1')

SELECT stats.gds_id,
  TRUNC(stats.stat_date) stat_date,
  SUM(stats.A_BOOKINGS_NBR) as "Bookings",
  SUM(stats.RESPONSES_LESS_1_NBR) as "<1",
  SUM(stats.RESPONSES_LESS_2_NBR) AS "<2",
  SUM(STATS.RESPONSES_LESS_3_NBR) AS "<3",
  SUM(stats.RESPONSES_LESS_4_NBR) AS "<4",
  SUM(stats.RESPONSES_LESS_5_NBR) AS "<5",
  SUM(stats.RESPONSES_LESS_6_NBR + stats.RESPONSES_LESS_7_NBR + stats.RESPONSES_GREATER_7_NBR) AS ">5",
  SUM(stats.RESPONSES_LESS_6_NBR) AS "<6",
  SUM(stats.RESPONSES_LESS_7_NBR) AS "<7",
  SUM(stats.RESPONSES_GREATER_7_NBR) AS ">7",
  SUM(stats.RESPONSES_LESS_1_NBR + stats.RESPONSES_LESS_2_NBR + stats.RESPONSES_LESS_3_NBR + stats.RESPONSES_LESS_4_NBR + stats.RESPONSES_LESS_5_NBR + stats.RESPONSES_LESS_6_NBR + stats.RESPONSES_LESS_7_NBR + stats.RESPONSES_GREATER_7_NBR) as "Total"
FROM gwydb.statistics stats
WHERE stats.stat_date >= '01-JUN-2011'
GROUP BY stats.gds_id, TRUNC(stats.stat_date)

SELECT a.cost, a.quantity, COUNT(b.id) AS count
FROM accounts AS a LEFT JOIN accounts AS b ON b.cost = a.cost

ON DUPLICATE KEY UPDATE total = VALUES(total)

SELECT A.ID,
       A.NAME,
       A.STORE,
       B.STOREADDRESS as yourAlias /* AS is ok for column aliases ... */
FROM TableALong A                  /* ... but not for table aliases */
     LEFT OUTER JOIN TableBLong  B /* JOIN syntax */
       ON (A.NAME = B.NAME and A.STORE = B.STORE)
WHERE ...

SELECT delivery_name 
FROM orders 
WHERE CONCAT('a',orders_id) = CONCAT('a','985225a')

select my, interesting, columns
from (
    select distinct GUID, ...
    from ...
)

SELECT
  A.[Date],
  A.[Hour],
  SUM(CASE WHEN (B.[SessionID] IS NULL) THEN 0 ELSE 1 END) AS [Number_of_Sessions_Per_Hour]
FROM
(
    SELECT DISTINCT
        CONVERT(DATETIME,
            LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date]))))
            + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2)
            + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2)
            , 120) AS [Date],
        hours_table.[Hour]
    FROM
        userlog,
        (
            SELECT 1 AS [Hour] UNION ALL SELECT 3 AS [Hour] UNION ALL SELECT 4 AS [Hour] UNION ALL SELECT 5 AS [Hour] UNION ALL SELECT 6 AS [Hour]
             UNION ALL SELECT 7 AS [Hour] UNION ALL SELECT 7 AS [Hour] UNION ALL SELECT 8 AS [Hour] UNION ALL SELECT 9 AS [Hour] UNION ALL SELECT 10 AS [Hour]
             UNION ALL SELECT 11 AS [Hour] UNION ALL SELECT 12 AS [Hour] UNION ALL SELECT 13 AS [Hour] UNION ALL SELECT 14 AS [Hour] UNION ALL SELECT 15 AS [Hour]
             UNION ALL SELECT 16 AS [Hour] UNION ALL SELECT 17 AS [Hour] UNION ALL SELECT 18 AS [Hour] UNION ALL SELECT 19 AS [Hour] UNION ALL SELECT 20 AS [Hour]
             UNION ALL SELECT 21 AS [Hour] UNION ALL SELECT 22 AS [Hour] UNION ALL SELECT 23 AS [Hour] UNION ALL SELECT 24 AS [Hour] 
        ) as hours_table
) AS A
LEFT OUTER JOIN
(
    SELECT 
        userlog.SessionID,
        MAX(CASE WHEN userlog.LogType = 'LOGON' 
                 THEN CONVERT(DATETIME,
                        LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date]))))
                        + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2)
                        + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2)
                        , 120)
                 ELSE CONVERT(DATETIME, '1900-01-01', 120)
            END) AS [Date_Session_START],
        MAX(CASE WHEN userlog.LogType = 'LOGOFF' 
                 THEN CONVERT(DATETIME,
                        LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date]))))
                        + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2)
                        + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2)
                        , 120)
                 ELSE CONVERT(DATETIME, '1900-01-01', 120)
            END) AS [Date_Session_END],
        MAX(CASE WHEN userlog.LogType = 'LOGON' THEN DATEPART(HOUR, userlog.[Date]) ELSE 0 END) AS [Hour_Session_START],
        MAX(CASE WHEN userlog.LogType = 'LOGOFF' THEN DATEPART(HOUR, userlog.[Date]) ELSE 0 END) AS [Hour_Session_END],
    FROM
        userlog
    GROUP BY
        userlog.SessionID
) AS B
    ON (A.[Date] >= B.[Date_Session_START] AND A.[Date] <= B.[Date_Session_END])
        AND (A.[Hour] >= B.[Hour_Session_START] AND A.[Hour] <= B.[Hour_Session_END])
WHERE
    A.[Date] Between @X and @Y
GROUP BY
  A.[Date],
  A.[Hour]

SELECT (SELECT ...) AS `005`
FROM table1
GROUP BY ...
HAVING `005` > 0

SELECT MAX(cov_julian(t.tatime)) 
FROM   table1   t
WHERE  t.tatime <= TO_NUMBER(TO_CHAR(SYSDATE,'J'))
AND   (EXISTS (SELECT NULL
               FROM   table2        a
               WHERE  a.empid = t.personid)
    OR EXISTS (SELECT NULL
               FROM   table3        c
               WHERE  c.col5  = t.personid2))
;

postgresqlExecStatement(con, "DELETE FROM foos WHERE id = $1 AND baz = $2", list(1, "bar"))

WHERE FREETEXT(k.Keyword, @SearchQ) 
  AND d.IsSearch=1 
  AND d.IsApproved=1 
  AND ((@CategoryId NOT IN (1,2,3)) OR (d.CategoryId = @CategoryId))
) AS Search_Data

public class AppContext : DbContext
{
    public DbSet<Instrument> Instruments { get; set; }
    public DbSet<Order> Orders { get; set; }
}
public class Instrument
{
    public int Id { get; set; }
    public string Book { get; set; }
    public string Page { get; set; }
    public virtual ICollection<MatchedInstrument> MatchedInstruments { get; set; }
}
public class Order
{
    public int Id { get; set; }
    public string OrderName { get; set; }
    public virtual ICollection<MatchedInstrument> MatchedInstruments { get; set; }
}
public class MatchedInstrument
{
    public int Id { get; set; }
    public int InstrumentId { get; set; }
    public Instrument Instrument { get; set; }
    public int OrderId { get; set; }
    public Order Order { get; set; }
    public bool IsFavorite { get; set; }
    public string Notes { get; set; }
}

SELECT  ID,
        Value1,
        CASE WHEN Value1 = 1 THEN 0 ELSE Value2 END Value2
FROM (  SELECT  ID,
                MAX(CASE WHEN Value1 = 1 THEN 1 ELSE 0 END) Value1,
                MAX(Value2) Value2
        FROM YourTable
        GROUP BY ID) A

    SELECT fieldId, COUNT(Id) AS count FROM tag GROUP BY fieldId

mysql> SELECT 'abc' LIKE 'ABC';
    -> 1
mysql> SELECT 'abc' LIKE BINARY 'ABC';
    -> 0

delete viewed_product where id in
( select id from
  ( select id, row_number() over (order by created_at desc) rn
    from viewed_product
    where my_id = :bindvar
  )
  where rn > 20
)

CREATE TABLE #Test (ID int, LOC int, RNK char(1), NBR1 int, NBR2 char(1) )

INSERT INTO #Test VALUES
    (1, 2, 'A', 10, 'b'),
    (3, 4, 'A', 10, 'b'),
    (5, 6, 'A', 11, 'C'),
    (8, 2, 'A', 12, 'D'),
    (6, 3, 'A', 10, 'b')

SELECT *
FROM #Test t1
WHERE EXISTS
    (SELECT 1
     FROM #Test t2
     WHERE t1.NBR1 = t2.NBR1
       AND t1.NBR2 = t2.NBR2
     GROUP BY NBR1, NBR2
     HAVING COUNT(1) > 1)

SELECT owner, name, type
  FROM dba_dependencies
 WHERE referenced_name = 'SEND_MAIL'
   AND referenced_owner = <<owner of procedure>>

declare @tmpGuid uniqueidentifier
select @tmpGuid = CLIENT_GUID from #mapping where NEW_CLIENT_GUID is null 
while @@ROWCOUNT > 0
begin   
  --Set the first unset guid to itself
  update #mapping
  set NEW_CLIENT_GUID = @tmpGuid
  where CLIENT_GUID = @tmpGuid

  --set all other duplicates to the guid we just used.
  update #mapping
  set NEW_CLIENT_GUID = @tmpGuid
  where CLIENT_GUID in (select CLIENT_GUID from FindDuplicateClientsByClient(@tmpGuid))
       and NEW_CLIENT_GUID is null

  --get next guid
  select @tmpGuid = CLIENT_GUID from #mapping where NEW_CLIENT_GUID is null 
end
set nocount off
go

SELECT B.Var1, A.Var2
FROM A LEFT OUTER JOIN B ON A.Var1 = B.Var1

SELECT t1.Name, t1.BirthDate, t1.OrderNumber
    FROM Table1 t1
    WHERE NOT EXISTS(SELECT NULL
                         FROM Table2 t2
                         WHERE t2.Name = t1.Name
                             AND t2.BirthDate = t1.BirthDate
                             AND t2.OrderNumber = t1.OrderNumber)

SELECT TRUNC(SYSDATE) - TRUNC(SYSDATE,'MONTH') + 1 FROM DUAL

UPDATE
      (SELECT
            T3.SOME_VALUE1 TARGET1,
            T3.OTHER_VALUE1 TARGET2,
            T3.SOME_VALUE2 TARGET3,
            T3.OTHER_VALUE2 TARGET4,
            T1.SOME_VALUE1 SOURCE1,
            T1.OTHER_VALUE1 SOURCE2,
            T2.SOME_VALUE2 SOURCE3,
            T2.OTHER_VALUE2 SOURCE4
       FROM
            TABLE1 T1
            JOIN TABLE2 T2
                ON T1.ID = T2.ID
            JOIN T3
                ON T3.FK = T1.ID)
SET
      TARGET1   = SOURCE1,
      TARGET2   = SOURCE2,
      TARGET3   = SOURCE3,
      TARGET4   = SOURCE4;

CREATE TABLE employees (
 employee_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
 family_name VARCHAR(100) NOT NULL,
 first_name VARCHAR(100) NOT NULL,
 birth_date DATETIME NULL DEFAULT NULL,
 PRIMARY KEY(employee_id)
) ENGINE=INNODB;

CREATE TABLE employee_bonus (
 bonus_id INT UNSIGNED NOT NULL AUTO_INCREMENT, 
 employee_id INT UNSIGNED NOT NULL,
 bonus_value DECIMAL(10,2) DEFAULT 0.00,
 PRIMARY KEY(bonus_id),
 KEY fk_employee_id (employee_id),
 CONSTRAINT fk_employee_constraint FOREIGN KEY fk_employee_id(employee_id) 
    REFERENCES employees(employee_id) ON DELETE CASCADE ON UPDATE CASCADE 
) ENGINE=INNODB;

SELECT DISTINCT(BINARY name) AS Name FROM X;

DELETE * FROM contacts WHERE value='x'

where DATEDIFF(MM, OrderDate, GETDATE()) < 4

push-location
import-module sqlps -disablenamechecking
pop-location

@Offset = ((DATEDIFF(day, @BaseDate, GETDATE()) % @DayCount)

        -- CTE to the rescue!!!
WITH cal AS (
        SELECT generate_series('2012-02-02 00:00:00'::timestamp , '2012-03-02 05:00:00'::timestamp , '1 hour'::interval) AS stamp
        )
, qqq AS (
        SELECT date_trunc('hour', executiontime) AS stamp
        , count(*) AS zcount
        FROM mytable
        GROUP BY date_trunc('hour', executiontime)
        )
SELECT cal.stamp
        , COALESCE (qqq.zcount, 0) AS zcount
FROM cal
LEFT JOIN qqq ON cal.stamp = qqq.stamp
ORDER BY stamp ASC
        ;

select * from table1 t1
cross apply ( select * from (select top 1 * from table2 t2 where t1.rn = t2.rn order by t2.id desc) t where t.name <> t1.name) c

select * 
from table
where trunc(es_date) = TO_DATE('27-APR-12','dd-MON-yy')

SELECT  USERNAME, 
        COUNT(USERNAME) AS TotalCount, 
        MAX(logindate) AS LastLoginDate
FROM    LOGINTABLE 
GROUP   BY USERNAME

WITH CTE AS (
    SELECT
      PeriodStart,
      PeriodEnd,
      SUM(TotalActive) As TotalActive,
      SUM(TotalAdded) As TotalAdded,
      SUM(TotalRemoved) As TotalRemoved
    FROM (
      SELECT
        PeriodStart = CASE @Frequency
          WHEN 'day'     THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, [Date]))
          WHEN 'week'    THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(DAY, 1 - DATEPART(WEEKDAY, [Date]), [Date])))
          WHEN 'month'   THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(MONTH,   DATEDIFF(MONTH,   0, [Date]), 0)))
          WHEN 'quarter' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]), 0)))
          WHEN 'year'    THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(YEAR,    DATEDIFF(YEAR,    0, [Date]), 0)))
        END,
        PeriodEnd   = CASE @Frequency
          WHEN 'day'     THEN DATEADD(s, -1, DATEADD(day, 1, DATEDIFF(DAY, 0, [Date])))
          WHEN 'week'    THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, 7 - DATEPART(WEEKDAY, [Date]), [Date]))))
          WHEN 'month'   THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(MONTH,   DATEDIFF(MONTH,   0, [Date]) + 1, 0)))))
          WHEN 'quarter' THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]) + 1, 0)))))
          WHEN 'year'    THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(YEAR,    DATEDIFF(YEAR,    0, [Date]) + 1, 0)))))
        END,
        TotalActive,
        TotalAdded,
        TotalRemoved
      FROM TrendReport P
      WHERE [Date] BETWEEN @DateStart AND @DateEnd
    ) s
    GROUP BY
      PeriodStart,
      PeriodEnd
    ORDER BY PeriodStart

), U AS (
    SELECT qty_type, PeriodStart, qty
    FROM CTE
    UNPIVOT(qty FOR qty_type IN([TotalActive], [TotalAdded], [TotalRemoved]))Q
)     
SELECT * FROM U 
PIVOT (SUM(Qty) FOR PeriodStart IN([03/01/2011], [03/08/2011], [03/15/2011])) AS P

SELECT 
    [RowKey],
    x.y.value('(.)[1]', 'INT') AS ItemKey
FROM
    dbo.[tbl_MyDataTable] AS t
CROSS APPLY
    t.[Format].nodes('/MultiSelect/ItemKey') x(y)

SELECT MAX(score), MAX(whenadded) FROM scores

CAST (FLAGS  AS NUMBER(19))

SELECT
    M1.city AS iCity
,   M2.city AS jCity
,   M1.month
,   M1.temperature - M2.temperature AS final_temperature
FROM
    MASTER M1
    CROSS APPLY
    MASTER M2
    ON M2.month = M1.month

SELECT CAT_NO, PROD_CODE, DESCRIPTION, COLOR 
FROM (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY PROD_CODE ORDER BY CAT_NO) AS row_num
  FROM TABLE
) t
WHERE t.row_num = 1

   SELECT b.id,
          COUNT(i.id) AS num_inspections,
          COUNT(v.id) AS num_violations
     FROM BUSINESS b
LEFT JOIN INSPECTION i ON i.business_id = b.id
LEFT JOIN VIOLATION v ON v.inspection_id = i.id
 GROUP BY b.id

select top 1 with ties
    MessageID, 
    MessageSent, 
    MessageSenderUserID, 
    MessageRecipientUserID
from [Messaging_Message]
order by row_number() over (partition by MessageSenderUserID 
                            order by MessageSent desc)

SELECT sum(case when Stat='1' then 1 else 0 end) as Counted, 
       sum(case when Stat='2' then 1 else 0 end) as Counted2 
from dbo.Batch

Where Status = 0 or (Department = 100 And Status = 1)

SELECT  l.BuildingID, l.ApartmentID, l.LeaseID, l.ApplicantID,
            ROW_NUMBER() OVER (PARTITION BY l.ApartmentID ORDER BY s.Importance DESC, MovedOut, MovedIN DESC, LLSigned DESC, Approved DESC, Applied DESC) AS 'RowNumber'
FROM    dbo.NPleaseapplicant AS l INNER JOIN
        dbo.NPappstatus AS s ON l.BuildingID = s.BuildingID AND l.AppStatus = s.Code
WHERE  (l.BuildingID = @BuildingID)

SELECT b.id
FROM big_table b
WHERE EXISTS (SELECT 1
              FROM small_table s
              WHERE s.name LIKE 'something%' AND s.id = b.small_id
             )
ORDER BY b.name;

select a.*, b.*
from tablea a outer apply
     (select top 1 b.*
      from tableb b
      where b.id = a.id and
            b.date <= a.date
      order by b.date desc
     ) b;

RETURN(LPAD(_RESTRICTEDROUTE, 4, "0"))

select DATEADD(s, dateTimeInMilliseconds, '19700101')

SELECT * FROM mytable WHERE name LIKE 'a%' OR name like 'A%'

SELECT client, email, alt_email
FROM (
 select 'user.CustomAttribute.Client' client 
         ,'user.Email' email
         ,'user.customAttribute.alternateEmail' alt_email
          -- here we add an aid to ordering, 1 comes first
         , 1 displayorder
  from dual 
  UNION ALL 
  Select c.client 
         ,c.email
         ,c.alt_email
          -- here we add an aid to ordering, 2 comes after our header
         , 2 displayorder
  from contact    )
order by displayorder, client;

ALTER TABLE `TableAB` DROP FOREIGN KEY FK_KEY_Test;
ALTER TABLE `TableAB` ADD CONSTRAINT FK_KEY_Test FOREIGN KEY ('some_column') 
REFERENCES `TableA` ('Test_column1') ON UPDATE CASCADE ON DELETE CASCADE;

  IF OBJECT_ID('TempDB.dbo.#DuplicateAssignments') IS NOT NULL 
  BEGIN 
  DROP TABLE #DuplicateAssignments 
  END  

SELECT DISTINCT
        contact.id,
        contact.`Contact group`,
        contact.Media,
        contact.E-mail,
        contact.Nationality,
        contact.Country,
        contact.City,
        contact.Area,
        contact.Gender,
        contact.Married,
        contact.Children,
        contact.`Drivers license`
FROM contact
INNER JOIN contactlanguage ON contact.id = contactlanguage.contactid
INNER JOIN language ON contactlanguage.languageid = language.id
WHERE isdeleted = 0 AND language.language in ('English', 'Hindi', '');

select * from
(select 
   *,
   ROW_NUMBER() OVER (PARTITION BY tkid order by DateTimeStamp desc) as rn
from Prog_Timer
)
T
where 
T.rn = 1 -- the latest status for each tkid 
and T.Status = 'Start' -- returns only started and not stopped timers
-- if timer is stopped, t.Status will be 'Stop' in the latest row

SELECT
    ST_AsText (centroid),
    ST_SRID   (centroid)
FROM (SELECT ST_Centroid(ST_GeomFromText(geom, srid)) as centroid) as t;

  SELECT e.event_name,
         SUM(invited.contact_id) 'total_invited',
         SUM(confirmed.contact_id) 'total_invitations_confirmed'
    FROM EVENT e
    JOIN INVITATIONS invited ON invited.event_id = e.event_id
    JOIN INVITATIONS confirmed ON confirmed.event_id = e.event_id
                            AND confirmed.responded = 'Y'
GROUP BY e.event_id, e.event_name

CREATE TABLE emp(ename varchar(100),DOB date,  Age varchar(100))
INSERT INTO emp
VALUES('d','06/02/2011',NULL)--,('b','07/10/1947',NULL),('c','12/21/1982',NULL)



;WITH CTE(ename,DOB,years,months,days) 
AS 
(
SELECT 
    ename,DOB,DATEDIFF(yy,DOB,getdate()),DATEDIFF(mm,DOB,getdate()),DATEDIFF(dd,DOB,getdate()) 
FROM 
    emp
)
SELECT 
    ename,DOB,CAST(months/12 as varchar(5))+' Years'+
    CAST((months % 12) as varchar(5))+' month/s '+
    CAST(CASE WHEN DATEADD(MM,(months % 12),DATEADD(YY,(months/12),DOB)) <= GETDATE() then 
            DATEDIFF(dd,DATEADD(MM,(months % 12),DATEADD(YY,(months/12),DOB)),GETDATE()) 
        ELSE DAY(getdate())   
        END 
        as varchar(5))+' days' as Age
FROM CTE

SELECT t.*,
       CASE WHEN s.quantity is null then null 
           ELSE CASE WHEN s.quantity > 0 and t.quantity - s.quantity > 0 then s.quantity
               ELSE CASE WHEN s.quantity > 0 and t.quantity - s.quantity < 0 then t.quantity end end end as 'UPGRADE'
from YourTable t
LEFT OUTER JOIN YourTable s ON(t.group = s.group and t.year = s.year-1 
                               AND t.type = 't2' and s.type = 't1')

declare @ds  nvarchar(22);
declare @qry  nvarchar(max);
set @ds = 'KaamKaaj';

set @qry = N' SELECT '''+ @ds + ''' as DBName , T.name AS [TABLE NAME], 
       I.rows AS [ROWCOUNT] 
FROM   @ds.sys.tables AS T 
       INNER JOIN @ds.sys.sysindexes AS I 
               ON T.object_id = I.id 
                  AND I.indid < 2 
ORDER  BY I.rows DESC';

SET @qry    =   REPLACE(@qry, '@ds', @ds)
print @qry;

declare @TableList TABLE(Id int IDENTITY(1,1),DataBaseName VARCHAR(100),TableName VARCHAR(100),RecordCount INT,NameOfIndex VARCHAR(100),TypeOfIndex VARCHAR(100))

INSERT INTO @TableList(DataBaseName,TableName,RecordCount)
exec(@qry
);

declare @qry2  nvarchar(max);

set @qry2 =  N'SELECT 
     '''+ @ds + ''' as DBName,
     t.name,
     ind.name,
     ind.type_desc
FROM 
     @ds.sys.indexes ind 
INNER JOIN 
     @ds.sys.index_columns ic ON  ind.object_id = ic.object_id and ind.index_id = ic.index_id 
INNER JOIN 
     @ds.sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id 
INNER JOIN 
     @ds.sys.tables t ON ind.object_id = t.object_id 
WHERE 
     ind.is_primary_key = 0 
     AND ind.is_unique = 0 
     AND ind.is_unique_constraint = 0 
     AND t.is_ms_shipped = 0 
ORDER BY 
     t.name, ind.name, ind.index_id, ic.index_column_id 

     ';
SET @qry2   =   REPLACE(@qry2, '@ds', @ds)

declare @TableListWithIndex TABLE(Id int IDENTITY(1,1),DataBaseName VARCHAR(100),TableName VARCHAR(100),NameOfIndex VARCHAR(100),TypeOfIndex VARCHAR(100))
INSERT INTO @TableListWithIndex(DataBaseName,TableName,NameOfIndex,TypeOfIndex)
exec(@qry2
);


select * from @TableList
select * from @TableListWithIndex

int sumAlias = 0;

_dataAccessor.QueryOver<Player>()
    .Inner.JoinQueryOver<PlayerPerformance>(player => player.Performances)
    .Inner.JoinQueryOver<Achievement>(perf => perf.Achievements, () => achievementAlias)
    .Where(a => a.Descriptor == "Goals Scored")
    .SelectList(list => list.SelectGroup(player => player.Id).SelectSum(() => achievementAlias.Value).WithAlias(() => sumAlias)
    .OrderByAlias(() => sumAlias).Desc
    .List<object[]>()
    ;

select {fn timestampdiff(SQL_TSI_MINUTE, startdate, enddate)}/60 as diff 

Select CP.ProductName,sum(Cp.ProductQuantity) 
FROM VendorTrading VT inner join CustomerProducts CP 
ON VT.Id = CP.VendorTradingId
WHERE  CP.ProductName = ISNULL('XYZ', CP.ProductName)
AND VT.Tradedate = isnull('2015-01-20',VT.Tradedate)
AND CP.ProductName in ('xyz','abc')
GROUP BY CP.ProductName

SELECT redCount, COUNT(*)
FROM (SELECT user_id, COUNT(color) as redCount
      FROM cars
      WHERE color = 'red'
      GROUP BY user_id
     ) uc
GROUP BY redCount;

select 
  stuff((
        select ' ' + cast(product as char(10))
        from datainformation
        for XML path('')),1,1,'') as products,
 stuff((
        select ' ' + cast(quantity as char(10))
        from datainformation
        for XML path('')),1,1,'') as quantity

SELECT date_trunc(...)::date;

DECLARE @mindate DATETIME
DECLARE @maxdate DATETIME
DECLARE @diff INT
SET @maxdate = '2014-02-15'
SET @mindate = '2014-01-15'

SET @diff = DATEDIFF(DAY,  @mindate,@maxdate)
;WITH cte(dt,level)
AS
(
    SELECT  @mindate AS dt, 0 AS level 
    UNION ALL
    SELECT DATEADD(day,1,cte.dt),level + 1 from cte WHERE level < @diff
)
SELECT dt FROM cte
option (maxrecursion 32767)

SELECT t2.a,t2.b,t2.c 
FROM (SELECT a, b, max(d) as max_d
FROM TABLE_NAME
GROUP BY a,b) t1 
inner join TABLE_NAME t2 on(t1.a=t2.a AND t1.b=t2.b AND t1.max_d=t2.d)

AddHandler myConnection.InfoMessage, New SqlInfoMessageEventHandler(AddressOf OnInfoMessage)

Private Sub OnInfoMessage(ByVal sender As Object, ByVal e As System.Data.SqlClient.SqlInfoMessageEventArgs)
        mySB.AppendLine(e.Message)
End Sub

create table search_thread (
   thread_id int,
   date_entered datetime,
   PRIMARY KEY (thread_id)
   FOREIGN KEY (thread_id) REFERENCES thread(thread_id));

create table search_results (
   thread_id int,
   result_id int,
   PRIMARY KEY (thread_id, result_id),
   FOREIGN KEY (thread_id) REFERENCES search_thread(thread_id),
   FOREIGN KEY (thread_id) REFERENCES thread(thread_id).
   FOREIGN KEY (result_id) REFERENCES thread(thread_id));

select EMPID, EMPNAME, COMPANY1
  from EMPLOYEE
 where COMPANY1 is not null
union
select EMPID, EMPNAME, COMPANY2
  from EMPLOYEE
 where COMPANY2 is not null
union
select EMPID, EMPNAME, COMPANY3
  from EMPLOYEE
 where COMPANY3 is not null
union
select EMPID, EMPNAME, COMPANY4
  from EMPLOYEE
 where COMPANY4 is not null

SELECT c.id, t.line_id, t.date, u.name, a.name,
       sum(case when t.adjustment_no IS NOT NULL then t.sale_amount else 0 end) as adjustment,
       sum(case when t.adjustment_no IS NULL then t.sale_amount else 0 end) as sales
FROM invoice i JOIN
     contract c
     on c.contract_no = i.contract_no JOIN
     transaction t
     on t.invoice_no = i.invoice_no JOIN
     unit u
     on u.unit_no = t.unit_no JOIN
     agency a
     on a.agency_no = i.agency_no
WHERE t.unit_no in (44) AND
      i.hard_invoice = 'Y' AND
      t.code in ('New', 'Edit')
GROUP BY c.id, t.date, u.name, a.name, t.line_id;

   SELECT name , create_date, modify_date ,sm.definition FROM sys.procedures sp
   Inner join sys.sql_modules sm  ON sp.object_id = sm.object_id 
   WHERE CONVERT(DATE,sp.modify_date)    = CONVERT(DATE, '02/19/2013')

SELECT b.BOOKINGID,
       b.GUESTID,
       d.DEPENDANTID,
       d.FORENAME AS firstname,
       d.SURNAME AS lastname,
       br.FLOORNO,
       br.ROOMNO
FROM  BOOKING b
      LEFT JOIN BOOKINGDEPENDANT bd
      ON b.BOOKINGID = bd.BOOKINGID
      LEFT JOIN DEPENDANT d
      ON d.DEPENDANTID = bd.DEPENDANTID
      LEFT JOIN BOOKINGROOM br 
      ON br.ID = bd.ROOMID and ON br.BOOKINGID = b.BOOKINGID
WHERE b.BOOKINGID = &BOOKINGID; 

insert into table1
(
    col1,
    col2,
    col3,
    col4
)
select
    col1,
    col2,
    col3,
    'foo'

from table2

where something = 'foo'

declare @t table ([Date] date, Clockin time, CLockout time, Trip1 int, Trip2 int)
insert into @t  

    select '01/01/2013', '13:00', '17:00', 3, 3 union all
    select '01/01/2013', '13:00', '17:00', 0, 3 union all
    select '01/01/2013', '13:00', '17:00', 0, 0 union all
    select '01/01/2013', '13:00', '17:00', 3, null;

select  [minutes]=datediff(mi, Clockin, Clockout), 
        [trips] = ((isnull(Trip1, 0)+isnull(Trip2,0))),
        [calc] = datediff(mi, Clockin, Clockout)/ (nullif((isnull(Trip1, 0)+isnull(Trip2,0)), 0)),
        [calc2] = datediff(mi, Clockin, Clockout)/ isnull((nullif((isnull(Trip1, 0)+isnull(Trip2,0)), 0)), 1)
from @t

declare
  v_pk   my_pk_arr;
  v_cur  t_cursor;
begin

  v_pk := MY_PK_ARR(MY_PK(1, 'a'), MY_PK(2, 'b')); -- or build in a loop etc.
  get_data(v_pk, v_cur);

end;
/

SELECT SubjectID, DepartmentID, SubjectName, SubjectDescription, SubjectShortCode
FROM BS_Subject 
WHERE NOT EXISTS 
(SELECT SubjectToClassID FROM BS_SubjectToClass WHERE 
BS_Subject.SubjectID = BS_SubjectToClass.SubjectID
AND BS_SubjectToClass.ClassID =2)

select ps.*
from @ProductSub ps
inner join (
    select     
      CASE 
        WHEN c.ClientID is null THEN m.ClientID
        WHEN m.ClientID is null THEN c.ClientID
        WHEN m.ExpiryDate is not null and c.ExpiryDate is not null THEN
          CASE 
            WHEN c.ExpiryDate > m.ExpiryDate THEN c.ClientID
            ELSE m.ClientID
          END
        WHEN m.ExpiryDate is null THEN m.ClientID
        WHEN c.ExpiryDate is null THEN c.ClientID
        ELSE m.ClientID
      END as ClientId,
      COALESCE(m.ProductId, c.ProductId) as ProductId
    from       @ProductSub m
    full outer join  @ProductSub c
    on         m.ProductID = c.ProductID
    and        m.ClientID <> c.ClientID
    where      IsNull(m.clientid,@MasterClient) = @MasterClient
    and        IsNull(c.clientid,@ConsolClient) = @ConsolClient
) filter
on filter.clientid = ps.clientid
and filter.productid = ps.productid
order by ps.ProductId

SELECT       m.*
FROM         messages m
  INNER JOIN users u
  ON         m.userId = u.userId
WHERE        u.username = 'UsernameHere';

Sub Reformat()

    Dim arr, d1, d2, arrOut(), r As Long, ub As Long
    Dim r2 As Long, c As Long

    arr = Selection.Value 'select the source data first
    ub = UBound(arr, 1)
    Set d1 = distinct(arr, 1)
    Set d2 = distinct(arr, 2)
    ReDim arrOut(1 To d1.Count, 1 To 1 + (d2.Count * 2))

    For r = 1 To ub
        r2 = d1(arr(r, 1))
        c = 2 + (d2(arr(r, 2)) - 1) * 2
        arrOut(r2, 1) = arr(r, 1)
        arrOut(r2, c) = arr(r, 2)
        arrOut(r2, c + 1) = arr(r, 3)
    Next r

    With ThisWorkbook.Sheets("out")
        .Range("A2").Resize(UBound(arrOut, 1), UBound(arrOut, 2)).Value = arrOut
    End With

End Sub

'get all distinct values in a "column" of a 2-d array
Function distinct(arr As Variant, colNum) As Object
    Dim r As Long, ub As Long, i As Long, d
    Set d = CreateObject("scripting.dictionary")
    ub = UBound(arr, 1)
    i = 1
    For r = 1 To ub
        If Not d.exists(arr(r, colNum)) Then
            d.Add arr(r, colNum), i
            i = i + 1
        End If
    Next r
    Set distinct = d
End Function

select name
  from tbl
 where movid in (select movid from tbl where name = 'me')
   and name <> 'me'
 group by name
having count(*) = (select count(*) from tbl where name = 'me')

DECLARE @SQL varchar(500)

SELECT @SQL = 'osql -S' +@@servername +' -E -q "exec dbName..sprocName "'

EXEC master..xp_cmdshell @SQL

DECLARE @xmlTest xml;
SET @xmlTest = '<Mapping>
    <Element name="FirstTable">
        <Column>
            <Source>SourceColumn1</Source>
            <Destination>DestinationColumn1</Destination>
        </Column>
        <Column>
            <Source>SourceColumn2</Source>
            <Destination>DestinationColumn2</Destination>
        </Column>
        <Column>
            <Source>SourceColumn3</Source>
            <Destination>DestinationColumn3</Destination>
        </Column>           
    </Element>
    <Element name="SecondTable">
        <Column>
            <Source>SourceColumn4</Source>
            <Destination>DestinationColumn4</Destination>
        </Column>
        <Column>
            <Source>SourceColumn5</Source>
            <Destination>DestinationColumn5</Destination>
        </Column>
    </Element>
</Mapping>'

;With Map
As
(
    SELECT
         x.value('../@name', 'nvarchar(50)') TableName
        ,x.value('Source[1]', 'nvarchar(50)') SourceColumn
        ,x.value('Destination[1]', 'nvarchar(50)') DestinationColumn
    from
        @xmlTest.nodes('/Mapping/Element/Column') T(x)
)
select distinct 'INSERT INTO [' + M.TableName + '] (' + Left(DC.DestinationColumns, Len(DC.DestinationColumns) - 1) + ') SELECT (' + Left(SC.SourceColumns, Len(SC.SourceColumns) - 1) + ') FROM [RawDataTable]' as SQLs
from Map M
cross apply (
    select
        CONVERT(VARCHAR(255), SourceColumn) + ',' AS [text()]
    from
        Map M2
    where
        M.TableName = M2.TableName
    FOR XML PATH('')
) SC(SourceColumns)
cross apply (
    select
        CONVERT(VARCHAR(255), DestinationColumn) + ',' AS [text()]
    from
        Map M2
    where
        M.TableName = M2.TableName
    FOR XML PATH('')
) DC(DestinationColumns)

SELECT SUM(tfspm.PaymentOn) AS Amount,
       tfsp.campaignID,
       cc.Name
FROM   tbl_FormSubmissions_PaymentsMade tfspm
       INNER JOIN tbl_FormSubmissions_Payment tfsp
         ON tfspm.SubmissionID = tfsp.SubmissionID
       INNER JOIN tbl_CurrentCampaigns cc
         ON tfsp.CampaignID = cc.ID
WHERE  tfspm.isApproved = 'True'
       AND ( tfspm.PaymentOn BETWEEN '2013-05-01 12:00:00.000' 
                                 AND '2013-05-07 12:00:00.000'
              OR tfspm.PaymentOn BETWEEN '2013-05-08 12:00:00.000' 
                                     AND '2013-05-14 12:00:00.000' )
GROUP  BY tfsp.campaignID,
          cc.Name 

SELECT 
      id,
      name,
      [begin],
      [end]
FROM 
      orders o
WHERE EXISTS(
            SELECT  *   
            FROM access         
            WHERE orderId = o.id AND [user] = @user AND role >= 1
           )

SELECT
  Contact.Email,
  Contact.FirstName,
  Contact.Surname,
  recent.HotlineID,
  Hotline.Action
FROM
  (SELECT HotlineID, MAX([Date]) as maxDate
    FROM Hotline
    GROUP BY HotlineID) recent
  INNER JOIN Hotline
    ON recent.HotlineId = Hotline.HotlineId
  LEFT JOIN Contact
    ON Hotline.HotlineId = Contact.HotlineId
WHERE
  datediff(hour, recent.maxDate, GetDate()) < 48
  AND Hotline.Flag = 1

WITH example AS (
  SELECT ad.applicantdetailid,
         ad.applicantmasterid, 
         ad.dateeffective,
         ROW_NUMBER() OVER(PARTITION BY ad.applicantmasterid
                               ORDER BY ad.dateeffective DESC) AS rank
    FROM #APPLICANTDETAIL ad)
  SELECT e.applicantdetailid
    FROM example e
   WHERE e.rank = 1
ORDER BY e.applicantmasterid, e.dateeffective

SELECT 
    sub.name AS ARName,
    sub.desc AS ARDescription,
    m.name AS MessageName,
    m.subj AS MessageDescription,
    clk.type AS EventType,
    COUNT(DISTINCT clk.eid) AS CountAdmins,
    COUNT(DISTINCT CASE WHEN my.my_id = 3347 THEN clk.eid END) AS CountUpgradeAdmins,
    COUNT(DISTINCT CASE WHEN my.my_id = 2765 THEN my.data END) AS CountAccounts,
    COUNT(DISTINCT  my2.data ) AS CountUpgradedAccounts 
FROM
    bata.sseq seq 
INNER JOIN bata.messages m 
    ON m.id = seq.mid 
INNER JOIN bm_arc.clicks208 clk 
    ON clk.camp = seq.camp 
INNER JOIN bemails.cid cid 
    ON cid.id = clk.eid 
INNER JOIN bonfig.sub
    ON sub.id = seq.sid
LEFT JOIN bemails.my208 my 
    ON cid.id = my.eid AND (my.my_id = 3347 OR my.my_id = 2765) # only return people who upgraded and     

LEFT JOIN bemails.my208 my2 
    ON  my2.my_id = 2765 and my2.userID = my.userID and my.my_id=3347 #get the accounts that the user belongs to
WHERE 
    seq.cid = 208
    AND
    sub.desc REGEXP '^Home pg free trail (A|B)' 
GROUP BY
    ARName,
    ARDescription,
    MessageName,
    MessageDescription,
    EventType

SELECT  *
FROM    mytable
WHERE   %%LOCKRES%% = '{0000ABCDEFAB}'

insert into table1 (_id)
select _id from table2;

select object_name as view_name,
       to_number(extractvalue(xmltype(dbms_xmlgen.getxml('select count(*) c from "'||owner||'"."'||object_name||'"')),'/ROWSET/ROW/C')) as row_count
from dba_objects
where object_type = 'VIEW'
  and owner = 'ADMIN'
order by 1;

INSERT INTO #Temp (id, id2, a, b)
SELECT TABLE_A.ID, TABLE_B.ID2, TABLE_A.A, TABLE_B.B
FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.[primary_key] = TABLE_B.[foreign_key]

BEGIN TRAN 'tran1'
       INSERT INTO Whatever table...
      IF(... check for null)
      BEGIN 
        ROLLBACK TRAN 'tran1'
        RETURN 0
      END
COMMIT TRAN 'tran1'

CREATE TABLE DATA_TABLE(VALUE NUMBER,
                        REJECT_COUNT NUMBER DEFAULT 1,
                        A NUMBER,
                        B NUMBER,
                        C NUMBER,
                        CONSTRAINT DAT_PK PRIMARY KEY (VALUE));

CREATE OR REPLACE TRIGGER DATA_TABLE_TRIGGER BEFORE UPDATE ON DATA_TABLE
  FOR EACH ROW

DECLARE

BEGIN

  :NEW.REJECT_COUNT := :OLD.REJECT_COUNT + 1;

END;

SET @the_list = myStoredProc();
SET @the_query = CONCAT('SELECT * FROM myTable WHERE columnName IN (' , @the_list , ')');
PREPARE the_statement FROM @the_query;
EXECUTE the_statement;

SELECT COUNT(*)
FROM (
  SELECT p.prod_id,  p.prod_list_price, avg(c.unit_cost) avg_cost
  FROM products p inner join costs c
   ON c.prod_id = p.prod_id
  GROUP BY p.prod_id, p.prod_list_price
) 
WHERE prod_list_price < 1.15 * avg_cost

SELECT
rep.RPT_ID
,tech.TECH_ID
,proc.PROC_ID
FROM REPORT rep
LEFT JOIN TECHNICIAN tech ON tech.RPT_ID = rep.RPT_ID
LEFT JOIN PROCEDURE proc ON proc.RPT_ID = rep.RPT_ID AND proc.PROC_ID = tech.PROC_ID
WHERE rep.LAB_ID in ('test_lab');

SELECT [1 Cut Wire & Cable Only].Element
  FROM [1 Cut Wire & Cable Only]
 WHERE  (
           [1 Cut Wire & Cable Only].Product_ID = [Forms]![New Report]![cbProduct_ID]
        );

SELECT events.event_id, COALESCE(attendance.status, 0) status
FROM events LEFT JOIN attendance
     ON events.event_id = attendance.event_id AND
        attendance.user_id='someoutsideinput'
ORDER BY events.event_date ASC

;WITH x AS
(
    SELECT col1, col2, ROW_NUMBER() OVER(ORDER BY id DESC) rn
    FROM Table1
)
SELECT col1, col2
FROM x x1
WHERE NOT EXISTS
(
    SELECT 1
    FROM x x2
    WHERE x2.rn <= x1.rn
    AND x2.col2 = 'b'
)

  SELECT t.userid
         MAX(CASE WHEN t.fieldname = 'Username' THEN t.fieldvalue ELSE NULL END) AS Username,
         MAX(CASE WHEN t.fieldname = 'Password' THEN t.fieldvalue ELSE NULL END) AS Password,
         MAX(CASE WHEN t.fieldname = 'Email Address' THEN t.fieldvalue ELSE NULL END) AS Email
    FROM TABLE t
GROUP BY t.userid

<cfscript>
q = queryNew("LTM,LTM_1,LTM_2,LTM_3,LTM_4");

queryAddRow(q);
QuerySetCell(q, "LTM", "OSTAPOWER");
QuerySetCell(q, "LTM_1", "VENKAT");
QuerySetCell(q, "LTM_2", "LYNN");
QuerySetCell(q, "LTM_3", "SMITH");
QuerySetCell(q, "LTM_4", "HARTLEY");

queryAddRow(q);
QuerySetCell(q, "LTM", "OSTAPOWER");
QuerySetCell(q, "LTM_1", "VENKAT");
QuerySetCell(q, "LTM_2", "LYNN");
QuerySetCell(q, "LTM_3", "SMITH");
QuerySetCell(q, "LTM_4", "SHREVE");

function collect(q) {
    var data = {};
    for (var row in q)
    {
        var varName = "data";
        for (var i = 0; i <= 4; i++)
        {
            var col = i == 0 ? "LTM" : "LTM_#i#";
            var name = row[col];
            if (len(name))
                varName = listAppend(varName, name, ".");
            else
                break;
        }
        setVariable(varName, {});
    }

    return data;
}

function transform(tree, nodeName, level=0, parent="") 
{
    if (structIsEmpty(tree))
        return "";

    var node = {
        'name': nodeName,
        'parent': len(parent) ? parent : javacast("null",""),
        'level': javacast("int", level),
        'groups': []
    };

    var branch = tree[nodeName];

    for (var child in branch)
        arrayAppend(node.groups, transform(branch, child, level+1, nodeName));

    return node;
}

c=collect(q);

writeDump(transform(c,'OSTAPOWER'));
</cfscript>

with minRow(ID) as 
    (select min(ID)
    from    Table_1
    group by data1, data2, data3)
select  t1.*
from    Table_1 t1 join minRow m1 on t1.ID = m1.ID

SELECT product, condition1 FROM table_name
UNION SELECT product, condition2 FROM table_name
UNION SELECT product, condition3 FROM table_name
UNION ORDER BY product

JOIN [cubing].[dbo].[WCA_export_RanksAverage] AS RanksAverage
ON RanksAverage.personId = RanksSingle.personId
AND RanksAverage.eventId = RanksSingle.eventId

SELECT * FROM sys.views

select column1,column2,1 as column3 from mytable

SELECT a.pk_FamilyID, a.Salutation, e.Title, e.Forename, e.Surname, c.Title, c.Forename, c.Surname
FROM Family a
INNER JOIN PersonFamily b ON a.pk_FamilyID = b.fk_FamilyID
INNER JOIN Person c ON b.fk_PersonID = c.pk_PersonID
INNER JOIN Relation d ON c.pk_PersonID = d.fk_RelatedPersonID
INNER JOIN Person e ON d.fk_PersonID = e.pk_PersonID
WHERE (d.Relationship LIKE '%Father' OR d.Relationship LIKE '%Mother')
AND e.pk_PersonID IN('" & Substitute ( ListOfPersonUUID ; ¶ ; "','" ) & "')
ORDER BY e.SurnameForename ASC

UPDATE ltm_op_risk_event ltm
SET ltm.sent_into_wf_by_id =
  (SELECT ltmRev.adm_user_id
   FROM ltm_op_risk_event_rev ltmRev
   WHERE ltmRev.ltm_op_risk_event_id = ltm.ltm_op_risk_event_id
     AND ltmRev.status !=
       (SELECT ltmRev2.status
        FROM LTM_OP_RISK_EVENT_REV ltmRev2
        WHERE valid_from IS NOT NULL
          AND ltmRev.ltm_op_risk_event_id = ltmRev2.ltm_op_risk_event_id
        ORDER BY valid_from ASC LIMIT 1)
   ORDER BY ltmRev.valid_to ASC LIMIT 1)
WHERE ltm.sent_into_wf_by_id IS NULL;

where completeddate <= dateadd(hour, 4, createddate)

SELECT o.official_name Official, p.official_name Supervisor
FROM official o
LEFT JOIN officialsupervisor s ON o.official_id = s.official_id
LEFT JOIN official p ON p.official_id = s.supervisor_official_id

select id, sum, sum_amount, pair,
       (case when max(sum_amount) over (partition by pair) = sum_amount
             then sum_amount / min(sum_amount) over (partition by pair)
             else sum_amount / max(sum_amount) over (partition by pair)
        end) as div
from t;

select 
 StepID, 
 cast(sum(case when Rating > 9 then 100.0 else 0 end)
 /count(*) as decimal(5,2)) pct
from yourtable
group by StepID

  SELECT
    E.Visitor Toilet_Type,
    SUM(case when SE.SemiEnragedPotty_ID is not null and
        M.Toilet_ID is not null then 1 else 0 end) MANUAL_PORTA_POTTY,
    SUM(case when R.Toilet_ID is not null then 1 else 0 end) REGULAR_PORTA_POTTY
  FROM 
    BORE.EnragedPotty E,
    BORE.SemiEnragedPotty SE,
    BORE.ManualPotty M,
    BORE.RegularPotty R
  WHERE
    E.SemiEnragedPotty_ID = SE.SemiEnragedPotty_ID (+) AND
    E.Toilet_ID = M.Toilet_ID (+)
    E.Toilet_ID = R.Toilet_ID (+)
  GROUP BY Visitor
  ORDER BY Visitor ASC

select * from `owners`
join `records` ON (`records`.`pa_no` = `owners`.`contact_no`)
WHERE email <> ""
and not exists (select reg_no from `buyers` 
                where `buyers`.reg_no = `records`.reg_no)

SELECT status
FROM all_objects
WHERE object_name = 'MYFUNCTIONNAME'
AND object_type = 'FUNCTION';

SELECT
    modify_date
        ,type_desc
        ,name
    FROM sys.objects
    WHERE is_ms_shipped=0
        --AND modify_date>='yyyy/mm/dd'  <--optionally put in your date here
    ORDER BY 1 DESC

    $id = 5;$parent_id = 5; /* set default to values you want*/

    while($parent_id != 0)
    {

       $sql = 'SELECT id,parent_id from sub_table where id = $parent_id ';
       $rs= $mysqli->query($sql);  /* fetch details */
       $old_id = $id; /* this will save the last id in current iteration */
       $parent_id = $rs['parent_id'];
       $id = $rs['id'];

    }

SELECT (CASE WHEN postedDate IS NULL THEN '0' ELSE CAST(postedDate AS VARCHAR(MAX))) postedDate ...

$file = "D:\PostDeployment.sql"

  $SQLCommandText = @(Get-Content -Path $file) # loads content
    foreach($SQLString in  $SQLCommandText) 
    { 

        if($SQLString -ne "go") # if string is not equal to go then add it to existing string
        { 
            #Preparation of SQL packet 
            $SQLPacket += $SQLString + "`n" 
        } 
        else 
        { 
            Write-Host "---------------------------------------------" 
            Write-Host "Executed SQL packet:" 
            Write-Host $SQLPacket 

            $SQLPacket = ""  # clear up sql string
        } 
    } 

--get rid of the sparsely used commas
--get rid of the duplicate spaces
update MyTable set
    CityStZip= 
        replace(
            replace(
                replace(CityStZip,'   ',' '),
                '  ',' '),
            ',','')

select
    --check if state and zip are there and then grab the city
    case when isNumeric(right(CityStZip,1))=1
            then left(CityStZip,len(CityStZip)-charindex(' ',reverse(CityStZip),
                                        charindex(' ',reverse(CityStZip))+1)+1)
        --no zip. check for state
        when left(right(CityStZip,3),1) = ' '
            then left(CityStZip,len(CityStZip)-charIndex(' ',reverse(CityStZip)))
        else CityStZip
        end as City,
    --check if zip is there and then grab the city
    case when isNumeric(right(CityStZip,1))=1
            then substring(CityStZip,
                    len(CityStZip)-charindex(' ',reverse(CityStZip),
                                                charindex(' ',reverse(CityStZip))+1)+2,
                    2)
        --no zip. check if 3rd to last char is a space and grab the last two chars
        when left(right(CityStZip,3),1) = ' '
            then right(CityStZip,2)
        end as [State],
    --grab everything after the last space if the last character is numeric
    case when isNumeric(right(CityStZip,1))=1
            then substring(CityStZip,
                    len(CityStZip)-charindex(' ',reverse(CityStZip))+1,
                    charindex(' ',reverse(CityStZip)))
        end as Zip
from MyTable

SELECT generate_series, COUNT("timeStarted") 
FROM generate_series('2015-04-07 00:00:00+01', '2015-04-07 23:59:00+01', '1 hour'::interval)
LEFT JOIN session s ON date_trunc('hour', "timeStarted"::timestamp) = generate_series
    AND "timeStarted" BETWEEN timestamp with time zone '2015-04-07 00:00:00+01' AND timestamp with time zone '2015-04-07 23:59:00+01'
    GROUP BY generate_series
ORDER BY generate_series;

select firstname, lastname, scheduled, posted, eventadded
from (select rs.*,
             row_number() over (partition by firstname, lastname
                                order by (case when eventadded is not null then 1 else 2 end)
                               ) as seqnum
      from ResultSet rs
     ) rs
where seqnum = 1;

select t1.id, 
       t1.name,
       case when t2.id is null 
            then 'False' 
            else 'True' 
        end DoesExist
  from Table1 t1
  left join Table2 t2
    on t1.ID = t2.ID

INSERT INTO `test_data` 
(`product_id`, `meta_key`, `meta_value`)  
SELECT 
    td.`product_id`, 
    wp2.`meta_key`, 
    wp2.`meta_value` 
FROM `test_data` td
INNER JOIN `wp_postmeta` wp1 ON 
    wp1.`meta_value` = td.`meta_value` AND wp1.`meta_key`= '_wpsc_sku' 
INNER JOIN `wp_postmeta` wp2 ON 
    wp2.`post_id` = wp1.`post_id` AND wp2.`meta_key`= '_wpsc_smaak' 

array_length(array[[1, 2], [3, 4], [5, 6]], 1) ---> 3
array_length(array[[1, 2], [3, 4], [5, 6]], 2) ---> 2

SELECT table1.user_id, schools.value AS school, languages.value AS language
FROM table1  
LEFT JOIN table2 AS schools ON schools.user_id = table1.user_id
    AND schools.key = 'school'
LEFT JOIN table2 AS languages ON languages.user_id = table1.user_id
    AND languages.key = 'language'

Select FFE.form_entry_id
    , Min( Case When FF.name = 'Foo' Then FFE.value End ) As `Foo`
    , Min( Case When FF.name = 'Bar' Then FFE.value End ) As `Bar`
    , ...
From FormFieldEntry As FFE
    Join FormField As FF
        On FF.id = FFE.form_field_id
Group By FFE.form_entry_id

SELECT * FROM table t1
JOIN table t2
ON t1.Title = t2.Title
WHERE t1.Codes = '020'
AND t2.Codes = '021'

select count(distinct l1.leadId) as accepted from leads l1
left join leads l2
on l1.leadId = l2.leadId and l1.date < l2.date
where l2.date is null and l1.`change` like '%OK%'

select sum(case when col1 in ('a','b') then col2 end) as ab_sum,
       sum(case when col1 in ('c','d') then col2 end) as cd_sum
from your_table

CREATE transaction_vw AS
SELECT t.*
      ,CASE WHEN date_returned is null
             and (sysdate - date_returned_out)
               > DECODE(rental_code
                       ,'R101', 1
                       ,'R103', 3
                       ,'R105', 5)
       THEN trunc(sysdate - date_returned_out) * 2
       END AS fine_due
FROM transaction t;

DELETE FROM table WHERE primary_key NOT IN (SELECT MIN(primary_key) FROM table GROUP BY secondID)

SELECT user_id,GROUP_CONCAT(id separator ",") as sets 
FROM my_table 
GROUP BY user_id;

Select Count(*) as CountRecord from Account

 SELECT t.*, m.*
 FROM topic t
 LEFT JOIN
   (SELECT id_topic, MAX(created) AS created
    FROM message
    GROUP BY id_topic
   ) T2 ON t.id = T2.id_topic
 LEFT JOIN message m ON m.id_topic = T2.id_topic AND m.created = T2.created

 SELECT Initialdate, OriginalTime, Gate1, 
      Destindate, DestinationTime, Gate2, 
      COUNT(1) as Freq
 FROM TABLE1
 GROUP BY Initialdate, OriginalTime, Gate1, 
      Destindate, DestinationTime, Gate2

Select EmailAddress,Birthday From table1 Where Birthday Between to_date('01-01-1946','MM-DD-YYYY') AND to_date('01-01-1988','MM-DD-YYYY');

SQL> select
  2      translate(
  3            initcap('newyork is a BEAUTIFUL city')
  4               , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz'
  5               , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  6              )
  7  from dual
  8  /

TRANS
-----
NIABC

SQL>

if($sql = $db->prepare('select zip from _zipcode where zip like ?'))
{
    $sql->bind_param("s", $consulta);
    $sql->execute();
    $sql->bind_result($zip);

    while ($sql->fetch()) {
        echo "Zip: $zip\n";
    }

    $sql->close();
}

DECLARE @liststr VARCHAR(MAX);
SET @liststr = '';

DELETE a.*
FROM Aliases_Table a
WHERE a.Aliase_ID IN ( 
                       SELECT
                       c.Aliase_ID 
                       FROM CI_Aliases c
                       WHERE c.CI_Ref = 3
                      )

SELECT n.id
FROM news INNER JOIN
     news_tag_cross ntc 
     ON ntc.newsid = n.id INNER JOIN
     tags t 
     ON t.id = ntc.tagid
GROUP BY n.id
HAVING SUM(t.name = 'Dealer') > 0 AND
       SUM(t.name = 'Client') > 0;

$query = "INSERT INTO `user`
    (`fname`,
    `lname`,
    `email`,
    `password`,
    `permission`,
    `idcustomer`)
     select
    '" . $firstname . "',
    '" . $lastname . "',
    '" . $email . "',            
    '" . $password . "',
    'admin',
    " . $idcustomer . "
    from customer
    where idcustomer = 2
          and (number_of_users - (select count(*) from user where idcustomer=2)) > 0
    );";

Update Table_A
Set A.ColX = B.Colx
From Table_A A
 Join Table_B B on B.col1 = A.col1
    and (B.col2 = A.col2 OR or B.col2 is null)

UPDATE test_t t
   SET t.complete_flag =
       (SELECT tt.complete_flag
          FROM test_t tt
         WHERE tt.component_id = 30101
           AND tt.form_id = t.form_id)
 WHERE t.component_id = 30162;

id             int   auto_increment & primary key
title          varchar(*)
content        text or big varchar according to your needs
posted_on      datetime or timestamp
posted_by      int key representing the authors id

UPDATE my_table
SET    column_1 = COALESCE(column_1,'')
     , column_2 = COALESCE(column_2,'')
     ...
WHERE  column_1 IS NULL OR
       column_2 IS NULL OR
       ...                  -- avoid empty updates
;

Create Table admin.dupes( col1, col2, col3 )
AS
select col1, col2,right(rtrim(col3),1) as col3 
FROM table
GROUP BY col1, col2,right(rtrim(col3),1)
having COUNT(NULLIF(ltrim(col4), '')) =1 and COUNT(*)=2

delete from table
where 
table.col4 is not  null and LTRIM(table.col4)<>''
and exists (select 1 from dupes d where table.col1 = d.col1 and table.col2= d.col2 and right(rtrim(table.col3),1) = d.col3
)

Drop Table admin.dupes

     SELECT  wp_posts.post_title as name, 
address.meta_value as address,
 latitude.meta_value as lat,
 longitude.meta_value as lng,
 telephone.meta_value as telephone,

   ( 3959 * acos(
    cos( radians( '%s' ) ) *
    cos( radians( CONVERT( latitude.meta_value, DECIMAL( 10, 6 ) ) ) ) *
    cos( radians( CONVERT( longitude.meta_value, DECIMAL( 10, 6 ) ) ) - radians( '%s' ) ) +
    sin( radians( '%s' ) ) * sin( radians( CONVERT( latitude.meta_value, DECIMAL( 10, 6 ) ) ) )
     ) ) AS distance

FROM wp_posts
LEFT JOIN wp_postmeta AS address ON(
wp_posts.ID = address.post_id
AND address.meta_key = '_dealer_address'
)
LEFT JOIN wp_postmeta AS latitude ON(
wp_posts.ID = latitude.post_id
AND latitude.meta_key = '_dealer_latitude'
)
LEFT JOIN wp_postmeta AS longitude ON(
wp_posts.ID = longitude.post_id
AND longitude.meta_key = '_dealer_longitude'
)
LEFT JOIN wp_postmeta AS telephone ON(
wp_posts.ID = telephone.post_id
AND telephone.meta_key = '_dealer_telephone'
)
WHERE wp_posts.post_type = 'dealers' HAVING distance < '%s' ORDER BY distance LIMIT 0 ,         20

SELECT p.*
FROM person p
JOIN person_availability pa ON p.id = pa.person_id
JOIN availability a ON a.id = pa.availability_id
WHERE p.id = 1 AND a.day IN (1,2,3)
GROUP BY p.id
HAVING COUNT(a.day) = 3;

SET @sql = NULL;

SELECT GROUP_CONCAT(DISTINCT
  CONCAT('MAX(CASE WHEN job_id = ''',
         job_id, 
         ''' THEN start_time END) `',
         job_id,
         '_start`',
         ',',
         'MAX(CASE WHEN job_id = ''',
         job_id,
         ''' THEN end_time END) `',
         job_id,
         '_end`' 
         )
          ORDER BY start_time ASC        
 )
  INTO @sql
  FROM t;

SET @sql = CONCAT('SELECT exec_id, ', @sql, ' 
                     FROM t 
                    GROUP BY exec_id');

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

CREATE TABLE t1 (a integer PRIMARY KEY);

CREATE FUNCTION test_exception() RETURNS boolean LANGUAGE plpgsql AS
$$BEGIN
   INSERT INTO t1 (a) VALUES (1);
   INSERT INTO t1 (a) VALUES (2);
   INSERT INTO t1 (a) VALUES (1);
   INSERT INTO t1 (a) VALUES (3);
   RETURN TRUE;
EXCEPTION
   WHEN integrity_constraint_violation THEN
      RAISE NOTICE 'Rollback to savepoint';
      RETURN FALSE;
END;$$;

BEGIN;

SELECT test_exception();
NOTICE:  Rollback to savepoint
 test_exception 
----------------
 f
(1 row)

COMMIT;

SELECT count(*) FROM t1;
 count 
-------
     0
(1 row)

SELECT user.name, photo_a.url AS profile_photo_url, photo_b.url as background_photo_url FROM user LEFT JOIN photo as photo_a ON user.profile_photo_uuid = photo_a.uuid LEFT JOIN photo as photo_b ON user.background_photo_uuid = photo_b.uuid WHERE user.uuid = SOME_ID

select min(category_id) as min_cat, 
       group_concat(distinct category_id order by category_id) as category_list, 
       bookmark_id
from your_table
group by bookmark_id

SELECT COUNT(C1), COUNT(C2), COUNT(C3) FROM table WHERE uid=2

Update statement
Update `table_name`
Set `field_name` = '{"notifyEmailSystem":1,"privacyProfileView":0,"privacyPhotoView":0,"privacyFriendsView":0,"privacyGroupsView":"","privacyVideoView":0,"notifyEmailMessage":1,"notifyEmailApps":1,"notifyWallComment":0}'

SELECT ...
       (SELECT ... ) AS 'Current - 1',
       (SELECT ... ) AS 'Current - 2',
       ...
  FROM ...

declare @searchvalue varchar(100)

set nocount off

set @searchvalue = 'Hello world'


create table #tt (table_name varchar(64), column_name varchar(64), count int)
select * into #t from 
(
select 'select ''' + a.table_name + ''' ''table_name'',''' + a.column_name + ''' ''column_name'', count(*) count from [' + a.table_name +'] where [' +a.column_name+']='''+@searchvalue +'''' + ' group by ['+ a.column_name+']' sqlstring
from INFORMATION_SCHEMA.COLUMNS a
join 
INFORMATION_SCHEMA.TABLES b
on a.table_name = b.table_name
and b.table_type = 'base table'
 where data_type = 'varchar'
) a

--loop cursor
Declare @sqlstring as nvarchar(500)
Declare SqlCursor CURSOR FAST_FORWARD FOR
SELECT sqlstring FROM #t
OPEN SqlCursor
FETCH NEXT FROM SqlCursor
INTO @sqlstring
WHILE @@FETCH_STATUS = 0
BEGIN
insert #tt
exec(@sqlstring)
     FETCH NEXT FROM SqlCursor
     INTO @sqlstring
END
CLOSE SqlCursor
DEALLOCATE SqlCursor
select * from #tt
drop table #tt
drop table #t

update orders
set shipname = replace(replace(shipname, '[',''),']','')

select userId from myTable group by userId having count(*) = 91

Public Sub SaveAnswer(ByVal answer As String)
    Dim sql As String = "INSERT INTO [table1] (ans) VALUES (@Answer)"

    Using cn As New SqlConnection(getConnectionString()), _
          cmd As New SqlCommand(sql)

        cmd.Parameters.Add("@Answer", SqlDbType.VarChar, 50).Value = answer

        cn.Open()
        cmd.ExecuteNonQuery()
    End Using
End Sub

Private Function getConnectionString() As String
    ''//normally read from a config file for this

    Return "Server=(local)\SQLEXPRESS;Database=testdb;Trusted_Connection=True;"
End Function

select *
from (
  select addresses.phone, addresses.name, orders.order_number, 
         count(orders.order_number) over (partition by addresses.phone) as cnt
  from orders 
     inner join carts on orders.order_number = carts.id 
     inner join address on carts.address_id = addresses.id 
) t 
where cnt = 1;

SELECT 
  u.id AS user_id,
  SUM(CASE WHEN p.`case` = 1 THEN p.amount ELSE 0 END) AS total_amount_case_1,
  SUM(CASE WHEN p.`case` = 2 THEN p.amount ELSE 0 END) AS total_amount_case_2 
FROM
  users u
  LEFT JOIN payments p ON u.id = p.user_id 
GROUP BY u.user_id 
ORDER BY u.user_id ;

select userid,
       state,
       ctime as start_time, 
       lead(ctime) over (partition by userid order by ctime) as end_time
from userstate;

if not exists (select ID from where name = @...)
   insert into ...
   select SCOPE_IDENTITY()
else 
   (select ID from where name = @...)

Update app_chatmessage set seen='FALSE' where
activity_id in 
(
SELECT
    app_activity.id
 FROM
     app_chatmessage
 JOIN
      app_activity ON app_chatmessage.activity_id = app_activity.id
 GROUP BY
     app_activity.name
 HAVING
     COUNT(app_chatmessage.owner_id) = 1
);

mysql> create table city (
  id int not null auto_increment, 
  name varchar(45), 
  active tinyint, 
  primary key (id),
  unique key (id, active));

mysql> create table person (
  id int not null auto_increment, 
  city_id int,
  active tinyint, 
  primary key (id), 
  foreign key (city_id, active) references city (id, active) on update cascade);

mysql> insert into city (name, active) values ('New York', 1);

mysql> insert into person (city_id, active) values (1, 1);

mysql> select * from person;
+----+---------+--------+
| id | city_id | active |
+----+---------+--------+
|  1 |       1 |      1 |
+----+---------+--------+

mysql> update city set active = 0 where id = 1;

mysql> select * from person;
+----+---------+--------+
| id | city_id | active |
+----+---------+--------+
|  1 |       1 |      0 |
+----+---------+--------+

SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT
  FROM INFORMATION_SCHEMA.COLUMNS
 WHERE table_name = 'tbl_name'
  [AND table_schema = 'db_name']
  [AND column_name LIKE 'wild']
ORDER BY COLUMN_NAME

select * 
from (SELECT a, b, a+b as TOTAL FROM ( 
           select 7 as a, 8 as b FROM DUAL 
           UNION ALL 
           select 8 as a, 8 as b FROM DUAL 
           UNION ALL 
           select 0 as a, 0 as b FROM DUAL) 
    )
WHERE TOTAL <> 0 
; 

SELECT t.Name, t.Street, t.City, t.State
FROM table t 
INNER JOIN (
     SELECT m.Name, MIN(m.Street + ';' + m.City  + ';' + m.State) AS comb
     FROM table m
     GROUP BY m.Name
) x
   ON  x.Name = t.Name
   AND x.comb = t.Street + ';' + t.City  + ';' + t.State

INSERT INTO SASH1.VALIDOSES
    (col1, col2, ... ,coln)
SELECT SWOSNAME, 'IBM', SWOSNAME, 'Y', SWPLATFORM 
FROM SASH1.LISTOSNAMES


// Generate random value for use as the 'state'.  Mitigates
// risk of CSRF attacks when this value is verified against the
// value returned from the OAuth provider with the authorization
// code.
$_SESSION['state'] = rand(0,999999999);

$authorizationUrlBase = 'https://accounts.google.com/o/oauth2/auth';
$redirectUriPath = '/oauth2callback.php';

// For example only.  A valid value for client_id needs to be obtained 
// for your environment from the Google APIs Console at 
// http://code.google.com/apis/console.
$queryParams = array(
  'client_id' => '240195362.apps.googleusercontent.com',
  'redirect_uri' => (isset($_SERVER['HTTPS'])?'https://':'http://') .
                   $_SERVER['HTTP_HOST'] . $redirectUriPath,
  'scope' => 'https://www.googleapis.com/auth/tasks',
  'response_type' => 'code',
  'state' => $_SESSION['state'],
  'approval_prompt' => 'force', // always request user consent
  'access_type' => 'offline' // obtain a refresh token
);

$goToUrl = $authorizationUrlBase . '?' . http_build_query($queryParams);

// Output a webpage directing users to the $goToUrl after 
// they click a "Let's Go" button
include 'access_request_template.php';

DECLARE @Source table
(
    SourceUrl varchar(200)
)
INSERT INTO @Source
(SourceUrl)
VALUES
('<a href="/publications/gss2007/gss2007_6879.ppt">Presentation (PowerPoint File)</a><br>  <a href="http://xxx.xx.xxx.xx:xxxx/ramgen/Ipam/2007/smil/7-09-am1.smil">Presentation (Webcast)</a>');

-- INSPECT THIS, IF APPROPRIATE THEN
SELECT
    S.SourceUrl AS Before
,   CHARINDEX('<a href="http://', S.SourceUrl) AS WhereFound
,   LEFT(S.SourceUrl, CHARINDEX('<a href="http://', S.SourceUrl) -1) AS After
FROM
    @Source AS S
WHERE
    S.SourceUrl LIKE '%smil%';

-- Only run this if you like the results of the above
UPDATE
    S
SET
    SourceUrl = LEFT(S.SourceUrl, CHARINDEX('<a href="http://', S.SourceUrl) -1)
FROM
    @Source AS S
WHERE
    S.SourceUrl LIKE '%smil%';

create trigger LimitTable
on YourTableToLimit
after insert
as
    declare @tableCount int
    select @tableCount = Count(*)
    from YourTableToLimit

    if @tableCount > 50
    begin
        rollback
    end
go

 CREATE VIEW MRClockByEmployee (ece_employee_ID, ece_most_recent_datetime) AS
    AS SELECT ece_employee_ID, MAX(ece_datetime) 
    FROM employee_clock_events
    GROUP BY ece_employee_id;

 CREATE VIEW MRClockInfoByEmployee 
     (ece_id, ece_employee_ID, ece_type, ece_datetime, ece_active) AS
 SELECT CE.* FROM employee_clock_events CE JOIN MRClockByEmployee MR
    ON CE.ece_employee_ID = MR.ece_employee_id AND
       CE.ece_datetime = MR.ece_most_recent_datetime

 SELECT ece_employee_id FROM MRClockInfoByEmployee
    WHERE type IN ('shift_start', 'shift_resume')

update X 
set data.modify('delete /date/entry[@insertedTime < sql:column("M.I")]')
from xmltemp as X
  cross apply (
              select dateadd(day, -2, max(E.X.value('@insertedTime', 'datetime')))
              from X.data.nodes('/date/entry') as E(X)
              ) as M(I)

SELECT
   u.firstname, u.lastname, t.*
FROM
   #users AS u
   CROSS APPLY
   (SELECT TOP 1 * 
    FROM OtherTable AS ot 
    WHERE u.userid = ot.userid
   ORDER BY something) t

MATCH (u)-[:VIEW]->(v)
RETURN u.username,v.title

Update SomeTable
set MyField = case when LEFT(MyField, 1) = '|' then '' else '|' end + MyField + case when Right(MyField, 1) = '|' then '' else '|' end

where (($P{parameter1} is null) or (user.id = $P{parameter1}))

update table t
    set pin = lpad(pin, 3, '0')
    where length(pin) < 3;

; with transponded as 
(
  select ID, Type, Value
    from 
    (
      select ID, 
             Name, 
             cast (Cost as varchar(100)) Cost, 
             cast (case when Included = 1 then 'Yes' else 'No' end as varchar(100)) Included
        from ProductInfo
    ) p
      unpivot (Value for Type in (Name, Cost, Included) ) a
)
select t1.Type, 
       t1.Value Product1, 
       t2.Value Product2, 
       t3.Value Product3
  from transponded t1
  left join transponded t2
         on t1.Type = t2.Type
        and t2.id = 2
   left join transponded t3
     on t1.Type = t3.Type
    and t3.id = 3
  where t1.id = 1

SELECT MIN([PrimaryCompensationBasis-Amount(USD))
FROM (SELECT TOP 50 PERCENT [PrimaryCompensationBasis-Amount(USD)] FROM qryEEGroup ORDER BY [PrimaryCompensationBasis-Amount(USD)]) tab;

SELECT NOBLOC, SUP_HA,
       AVG(TigehaBOP) AS NOM_BOP,
       AVG(TigehaPET) AS NOM_PET,
       AVG(TigehaSEP) AS NOM_SEP,
       AVG(VolhaBOP) AS VOL_BOP,
       AVG(VolhaPET) AS VOL_PET,
       AVG(VolhaSEP) AS VOL_SEP
FROM Table
GROUP BY NOBLOC, SUP_HA

SELECT SERVERPROPERTY ('InstanceName')

SELECT state, max(orderamount) AS amount FROM table GROUP BY state HAVING amount > 15;

SELECT *
FROM
    Reps
    CROSS APPLY
    (
        SELECT *
        FROM Invoices
        WHERE
            Invoices.RepID = Reps.ID
            AND Invoices.InvoiceID < Reps.MaxInvoiceID
    ) AS CA
;

CommandText = "Insert into FileMaster(Subject,FileID) Values('" & obj.Subject & "','" & obj.FileID & "')

select sum(case when ws.ID_WorkflowType = 1 then 1 else 0 end) as cntCM_PRWK
     , sum(case when ws.ID_WorkflowType = 3 then 1 else 0 end) as cntCM_CMQ
from dbo.CaseWorkflow cw 
join vew_CasePersonnelSystemIDs vcps on cw.ID_Case = vcps.ID_Case
join dbo.WorkflowStates ws on ws.ID_WorkflowState = cw.ID_WorkflowState
where CMSUID = @nSUID

DoCmd.SetWarnings = False
DoCmd.RunSQL ...
DoCmd.SetWarnings = True

select * from table1 where key not in (select tab1 from table2)

select
    tid
from
    teacher t
where
    not exists (
        select
            'x'
        from
            course_score cs
                inner join
            course c
                on cs.cid = c.cid
        where
            c.tid = t.tid
        group by
            c.cid
        having
            avg(score) <= 80
    );

CREATE PROCEDURE GetData(@key int = null)
BEGIN
  SELECT * FROM Table WHERE (@Key Is NULL or id = @Key)
END

select lPE.Person, Sum(lpe.ethnicity) as SumOfIDs,
       Ethnicity = stuff((select ', ' + E.Name as [text()]
                          from _linkPersonEthnicity lPE2 join
                               _Ethnicities e
                               on lpe2.Ethnicity = e.id
                          where lpe2.Person = lPE.Person
                          for xml path('')
                         ), 1, 2, '')
from _linkPersonEthnicity lPE 
group by lPE.Person;

CREATE OR REPLACE TRIGGER trigger_name  
BEFORE UPDATE of unique_id_to_match
ON table
FOR EACH ROW
AS
BEGIN
  select 
    NVL(
      (SELECT b.unique_to_update_from
      FROM table b
      WHERE B.other_unique_id = :new.unique_id_to_match
      ), 0)
   into :new.unique_to_update 
   FROM dual;
END;

WITH    q AS
        (
        SELECT  CAST('<root><node>1</node></root>' AS XML) AS doc
        )
SELECT  doc.value('(/root/node)[1]', 'INT'),
        doc.value(N'(/root/node)[1]', 'INT')
FROM    q

select 
    c1, c2, c3  
    from form_name
    where data_created >'1273446000' and data_creazione<'1274569200'
    group by c1,c2, c3 
    having count(c3)>1
INTERSECT
select 
    c1, c2, c3
    from form_name 
    where data_created>'1272236400' and data_creazione<'1274569200'
    group by c1,c2, c3 
    having count(c3)>2

ObjectQuery<Article> articles = (db as IObjectContextAdapter).ObjectContext.CreateObjectSet<Article>();
articles = articles.OrderBy("it." + orderBy + ((bool)desc ? " desc" : ""));

IQueryable<Article> iArticles = articles;

if(!String.IsNullOrEmpty(search))
    iArticles = iArticles.Where(a => a.Title.Contains(search) ||
                                                  a.FullArticle.Contains(search));

Response.AppendHeader("X-Total-Row-Count", iArticles.Count().ToString());

return PartialView(iArticles.Skip(start).Take((int)itemsPerPage));

WITH cte2 AS (SELECT        TOP (100) PERCENT ContractServices_1.ContractServiceID, ContractServices_1.ContractID, ContractServices_1.ServiceType, ContractServices_1.QuoteID, ContractParts_1.PartDescription, 
                                                         ServiceCallCharges_1.ChargeDescription, ServiceCalls_1.ServiceCallID, ServiceCallCharges_1.ShowOnFieldTicket, ContractServices_1.Renewed
                                FROM            dbo.ContractServices AS ContractServices_1 INNER JOIN
                                                         dbo.ContractParts AS ContractParts_1 ON ContractServices_1.ContractServiceID = ContractParts_1.ContractServiceID INNER JOIN
                                                         dbo.ServiceCallCharges AS ServiceCallCharges_1 ON ServiceCallCharges_1.ChargeDescription LIKE '%' + ContractParts_1.PartDescription + '%' INNER JOIN
                                                         dbo.ServiceCalls AS ServiceCalls_1 ON ServiceCallCharges_1.ServiceCallID = ServiceCalls_1.ServiceCallID AND ContractServices_1.ContractID = ServiceCalls_1.ContractID AND 
                                                         ContractParts_1.ContractID = ServiceCalls_1.ContractID
                                WHERE        (ServiceCallCharges_1.ChargeDescription LIKE '   -%' OR
                                                         ServiceCallCharges_1.ChargeDescription LIKE '%') AND (ServiceCallCharges_1.ShowOnFieldTicket = 'True') AND (ContractServices_1.Renewed = 'True')
                                GROUP BY ContractServices_1.ContractServiceID, ContractServices_1.ContractID, ContractServices_1.ServiceType, ContractServices_1.QuoteID, ContractParts_1.PartDescription, 
                                                         ServiceCallCharges_1.ChargeDescription, ServiceCalls_1.ServiceCallID, ContractServices_1.Renewed, ServiceCallCharges_1.ShowOnFieldTicket
                                ORDER BY ContractServices_1.ContractID), cte1 AS
    (SELECT        TOP (100) PERCENT dbo.ContractServices.ContractServiceID, dbo.ContractServices.ContractID, dbo.ContractServices.ServiceType, dbo.ContractServices.QuoteID, dbo.ContractParts.PartDescription, 
                                dbo.ServiceCallCharges.ChargeDescription, dbo.ServiceCalls.ServiceCallID, dbo.ServiceCallCharges.ShowOnFieldTicket, dbo.ContractServices.Renewed
      FROM            dbo.ContractServices INNER JOIN
                                dbo.ContractParts ON dbo.ContractServices.ContractServiceID = dbo.ContractParts.ContractServiceID INNER JOIN
                                dbo.ServiceCallCharges ON dbo.ServiceCallCharges.ChargeDescription LIKE '%' + dbo.ContractParts.PartDescription + '%' INNER JOIN
                                dbo.ServiceCalls ON dbo.ServiceCallCharges.ServiceCallID = dbo.ServiceCalls.ServiceCallID AND dbo.ContractServices.ContractID = dbo.ServiceCalls.ContractID AND 
                                dbo.ContractParts.ContractID = dbo.ServiceCalls.ContractID
      WHERE        (dbo.ServiceCallCharges.ChargeDescription LIKE '   -%' OR
                                dbo.ServiceCallCharges.ChargeDescription LIKE '%') AND (dbo.ServiceCallCharges.ShowOnFieldTicket = 'False') AND (dbo.ContractServices.Renewed = 'True')
      GROUP BY dbo.ContractServices.ContractServiceID, dbo.ContractServices.ContractID, dbo.ContractServices.ServiceType, dbo.ContractServices.QuoteID, dbo.ContractParts.PartDescription, 
                                dbo.ServiceCallCharges.ChargeDescription, dbo.ServiceCalls.ServiceCallID, dbo.ContractServices.Renewed, dbo.ServiceCallCharges.ShowOnFieldTicket
      ORDER BY dbo.ContractServices.ContractID)
    SELECT        TOP (100) PERCENT cte1_1.ContractServiceID, cte1_1.ContractID, cte1_1.ServiceType, cte1_1.QuoteID, cte1_1.PartDescription, cte1_1.ChargeDescription, cte1_1.ServiceCallID, cte1_1.ShowOnFieldTicket, 
                              cte1_1.Renewed
     FROM            cte1 AS cte1_1 LEFT OUTER JOIN
                              cte2 AS cte2_1 ON cte1_1.PartDescription = cte2_1.PartDescription AND cte1_1.ContractID = cte2_1.ContractID
     WHERE        (cte2_1.ShowOnFieldTicket IS NULL)
     GROUP BY cte1_1.ContractServiceID, cte1_1.ContractID, cte1_1.ServiceType, cte1_1.QuoteID, cte1_1.PartDescription, cte1_1.ChargeDescription, cte1_1.ServiceCallID, cte1_1.ShowOnFieldTicket, cte1_1.Renewed, 
                              cte2_1.ShowOnFieldTicket
     ORDER BY cte1_1.ContractID

select t.*
from (select t.*,
             row_number() over (partition by ordernum order by createdon desc) as seqnum
      from table t
     ) t
where seqnum = 1;

SELECT user.id, campaign_id, user_id
FROM user
LEFT JOIN email_solus
ON email_solus.user_id=user.id
WHERE user.id NOT IN
(
    SELECT user_id
    FROM email_solus
    WHERE campaign_id = 3
)

update
table1 inner join table2 on (//join condition)

set table1.column1=table2.column2

where // the clause

SELECT A.*
FROM YourTable A
INNER JOIN SPLIT(@Status,',') B
ON A.Status = B.Value

SELECT c.[id_Cust]
      ,[Name]
      ,[Omset]
      ,[Colour]
      ,[seq]
      ,(SELECT a.[Address],a.[no1],a.[no2] FROM address_BSM a
      WHERE a.id_cust = c.id_cust
  FOR XML PATH ('address_bsm'), TYPE)
  FROM [dbo].[Customer_BSM] c
  FOR XML PATH ('customer_bsm')

If coalesce( expr1, expr2, ... expr_n ) is not null then do something end if;

select user_id, req_time, item, v[1] as value1, v[2] as value2
from (
    select t.*,
        (
            select array[
                coalesce(sum(is_active::integer), 0),
                count(*)
                ] as v
            from t s
            where
                user_id = t.user_id
                and item = t.item
                and req_time <= t.req_time - interval '1 hour'
        ) as v
    from t
) s
order by req_time, user_id, item

;WITH emps AS (
    SELECT 
        [EmpName] AS 'EmployeeName',
        [EndYear] - [Begin Year] AS 'TotalYears'
    FROM    
        [dbo].[Employee]
)

SELECT * FROM emps WHERE TotalYears = (SELECT MAX(TotalYears) FROM emps)

$like_city = preg_replace('//', '%', $search_city); // Hyderbad => %H%y%d%e%r%b%a%d%
$sql = "SELECT * FROM jobs_tbl WHERE job_city LIKE '$like_city' "

$ java -jar path/to/gerrit.war reindex -d path/to/gerrit-site-dir

SELECT T1.Animal_ID, 
       T1.TestDate,
       (SELECT min(TestDate)
        FROM Exams
        WHERE Animal_ID = T1.Animal_ID
          AND TestDate > T1.TestDate
        GROUP BY Animal_ID
        ) AS Next_TestDate, 
        datediff((SELECT min(TestDate)
                  FROM Exams
                  WHERE Animal_ID = T1.Animal_ID
                    AND TestDate > T1.TestDate
                  GROUP BY Animal_ID
                  ), T1.TestDate) AS Elapsed_Days
FROM Exams T1
ORDER BY Animal_ID, TestDate;

   SELECT WMSYS.WM_CONCAT('PARTITION TABLE_NAME_'
  || TO_CHAR(sysdate + (level-1)/24, 'yyyymmddHH24')
  || ' VALUES LESS THAN (TIMESTAMP'''
  || TO_CHAR(sysdate + (level)/24, 'yyyy-mm-dd HH24')
  || ':00:00'') ') OUTPUT
FROM DUAL
  CONNECT BY level <= 24

    -----------------------------OUTPUT----------------------------------------
 OUTPUT
PARTITION TABLE_NAME_2016041907 VALUES LESS THAN (TIMESTAMP'2016-04-19 08:00:00') ,PARTITION TABLE_NAME_2016041908 VALUES LESS THAN (TIMESTAMP'2016-04-19 09:00:00') ,PARTITION TABLE_NAME_2016041909 VALUES LESS THAN (TIMESTAMP'2016-04-19 10:00:00') ,PARTITION TABLE_NAME_2016041910 VALUES LESS THAN (TIMESTAMP'2016-04-19 11:00:00') ,PARTITION TABLE_NAME_2016041911 VALUES LESS THAN (TIMESTAMP'2016-04-19 12:00:00') ,PARTITION TABLE_NAME_2016041912 VALUES LESS THAN (TIMESTAMP'2016-04-19 13:00:00') ,PARTITION TABLE_NAME_2016041913 VALUES LESS THAN (TIMESTAMP'2016-04-19 14:00:00') ,PARTITION TABLE_NAME_2016041914 VALUES LESS THAN (TIMESTAMP'2016-04-19 15:00:00') ,PARTITION TABLE_NAME_2016041915 VALUES LESS THAN (TIMESTAMP'2016-04-19 16:00:00') ,PARTITION TABLE_NAME_2016041916 VALUES LESS THAN (TIMESTAMP'2016-04-19 17:00:00') ,PARTITION TABLE_NAME_2016041917 VALUES LESS THAN (TIMESTAMP'2016-04-19 18:00:00') ,PARTITION TABLE_NAME_2016041918 VALUES LESS THAN (TIMESTAMP'2016-04-19 19:00:00') ,PARTITION TABLE_NAME_2016041919 VALUES LESS THAN (TIMESTAMP'2016-04-19 20:00:00') ,PARTITION TABLE_NAME_2016041920 VALUES LESS THAN (TIMESTAMP'2016-04-19 21:00:00') ,PARTITION TABLE_NAME_2016041921 VALUES LESS THAN (TIMESTAMP'2016-04-19 22:00:00') ,PARTITION TABLE_NAME_2016041922 VALUES LESS THAN (TIMESTAMP'2016-04-19 23:00:00') ,PARTITION TABLE_NAME_2016041923 VALUES LESS THAN (TIMESTAMP'2016-04-20 00:00:00') ,PARTITION TABLE_NAME_2016042000 VALUES LESS THAN (TIMESTAMP'2016-04-20 01:00:00') ,PARTITION TABLE_NAME_2016042001 VALUES LESS THAN (TIMESTAMP'2016-04-20 02:00:00') ,PARTITION TABLE_NAME_2016042002 VALUES LESS THAN (TIMESTAMP'2016-04-20 03:00:00') ,PARTITION TABLE_NAME_2016042003 VALUES LESS THAN (TIMESTAMP'2016-04-20 04:00:00') ,PARTITION TABLE_NAME_2016042004 VALUES LESS THAN (TIMESTAMP'2016-04-20 05:00:00') ,PARTITION TABLE_NAME_2016042005 VALUES LESS THAN (TIMESTAMP'2016-04-20 06:00:00') ,PARTITION TABLE_NAME_2016042006 VALUES LESS THAN (TIMESTAMP'2016-04-20 07:00:00') -----------------------------------------------------------------------------

select field1
      , f2
      , f3
      , 'FLOW'||trim(to_char(rnk))
from 
     (select field1
      , f2
      , f3
      , sum(case when f3 = 1 then 1 else 0 end)
     over (order by field1, f3 range between unbounded preceding and current row) rnk
    from your_table )

bcp "SELECT * FROM CustomerTable" queryout "c:\temp\CustomerTable.bcp" -N -S SOURCESERVERNAME -T 

bcp TargetDatabaseTable in "c:\temp\CustomerTable.bcp" -N -S TARGETSERVERNAME -T -E

SELECT display_order AS CurrentDisplayOrder, 
    ROW_NUMBER() OVER (ORDER BY display_order) AS NewDisplayOrder
FROM YourTable
ORDER BY display_order

DECLARE @PersonID INT

INSERT INTO dbo.Person (Name, Address)
VALUES (@Name, @Address)

SET @PersonID = SCOPE_IDENTITY()

INSERT INTO dbo.Product_Data (PersonID, Product, Quantity, DueDate)
VALUES (@PersonID, @Product, @Quantity, @DueDate)

update mytable
   set a = first_part(gen.id),
       b = second_part(gen.id),
       c = third_path(gen.id)
  from (
          select genid() as genid, id
          from mytable 
          where package_id = 10
       ) gen
 where mytable.id = gen.id;
 --and package_id = 10 -- This predicate is no longer necessary as the subquery
                       -- already filters on package_id, as Erwin mentioned

delete 
from posts 
where timestampdiff(hour, current_timestamp, time_published)>=4

SELECT * FROM COM
WHERE DateofPurchase between trunc((trunc(sysdate,'MM')-1),'MM')  and trunc(sysdate,'MM')-1

trunc((trunc(sysdate,'MM')-1),'MM') -->  last_month_fist_day
trunc(sysdate,'MM')-1               -->  last_month_last_day

SELECT M.ConversationID, 
MAX(CASE WHEN M.DateTime = X.FirstRow THEN M.Subject END) AS Subject,
CAST(COALESCE(MAX(CASE WHEN M.DateTime = X.LastRowSentByOtherUser 
                       THEN M.DateTime END),X.LastRow) AS DateTime)AS LastTime,
MAX(CASE WHEN M.DateTime = X.LastRow THEN M.Message END) AS Message,
MAX(CASE WHEN FromID = 1 THEN ToID ELSE FromID END) AS OtherParticipantId
FROM messages M
JOIN (
    SELECT ConversationID, MIN(DateTime) AS FirstRow, MAX(DateTime) AS LastRow,
    MAX(CASE WHEN FromID<>1 THEN DateTime END) AS LastRowSentByOtherUser
    FROM messages
    WHERE FromID=1 OR ToID=1
    GROUP BY ConversationID
) X ON X.ConversationID = M.ConversationID
AND (M.DateTime IN (X.FirstRow, X.LastRow, X.LastRowSentByOtherUser))
GROUP BY M.ConversationID
HAVING MAX(CASE WHEN M.DateTime = X.LastRowSentByOtherUser 
                   THEN M.DateTime END) IS NOT NULL

SELECT DISTINCT LOWER(SUBSTR(firstName,1,1)) firstChars
FROM your_table
WHERE LOWER(SUBSTR(firstName,1,1)) IN
 ('a','b','c','d','e','f','g','h','i','j',
  'k','l','m','n','o','p','q','r','s','t',
  'u','v','w','x','y','z')
ORDER BY firstChars

SELECT strftime('%s','now','localtime')-strftime('%s','2011-08-18 22:49:00') as date;

UPDATE T_Example  
    SET MT_Lang_DE = upper(substring(MT_Lang_DE, 1, 1)) + substring(lower(MT_Lang_DE), 2, length(MT_Lang_DE)-1)

DROP TABLE dbo.Report
CREATE TABLE dbo.Report (
PatientID varchar(10) NOT NULL,
ReviewId int NOT NULL
)

DECLARE c_patients CURSOR
READ_ONLY
FOR SELECT DISTINCT PatientID, ReviewId FROM dbo.BloodSampleData ORDER BY PatientID ASC

DECLARE @patient_id varchar(10), @review_id int
OPEN c_patients
FETCH NEXT FROM c_patients INTO @patient_id, @review_id
WHILE (@@fetch_status <> -1)
BEGIN
    IF (@@fetch_status <> -2)
    BEGIN
        INSERT INTO dbo.Report (PatientID, ReviewId) VALUES (@patient_id, @review_id)

        DECLARE c_reviews CURSOR
        READ_ONLY
        FOR SELECT [Date], [BloodSampleID] FROM dbo.BloodSampleData WHERE PatientID = @patient_id AND ReviewId = @review_id ORDER BY [Date] ASC

        DECLARE @date DATE, @blood_sample_id INT, @review_num int
        OPEN c_reviews
        SET @review_num = 0
        FETCH NEXT FROM c_reviews INTO @date, @blood_sample_id
        WHILE (@@fetch_status <> -1)
        BEGIN
            IF (@@fetch_status <> -2)
            BEGIN

                IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'Report' AND COLUMN_NAME LIKE '%' + CAST(@review_num AS VARCHAR))
                    EXEC ('ALTER TABLE dbo.Report ADD [Date' + @review_num + '] date, [BloodSampleID' + @review_num + '] int')
                DECLARE @update_sql VARCHAR(MAX) 
                SET @update_sql  ='UPDATE dbo.Report SET [Date' + CAST(@review_num AS VARCHAR) + '] =  CONVERT(date, ''' + CONVERT(varchar, @date, 120) + ''', 120), [BloodSampleID' + CAST(@review_num AS VARCHAR) + '] = ' + CAST(@blood_sample_id AS VARCHAR) + ' WHERE PatientID = ''' + @patient_id + ''' AND ReviewId = ' + CAST(@review_id AS varchar)
                PRINT @update_sql
                EXEC (@update_sql) 

                SET @review_num = @review_num + 1    
            END
            FETCH NEXT FROM c_reviews INTO @date, @blood_sample_id
        END

        CLOSE c_reviews
        DEALLOCATE c_reviews

    END
    FETCH NEXT FROM c_patients INTO  @patient_id, @review_id
END

CLOSE c_patients
DEALLOCATE c_patients
GO

SELECT * FROM dbo.Report

1, 1, 1
1, 6, 2

select s.*, f.firma_adi,
       (select SUM(sd.fiyat)
        from fuar_sozlesme1_detay fd
        where sd.sozlesme_id = s.id
       ) as konak,
       (select SUM(ss.fiyat)
        from fuar_sozlesme1_sponsor ss
        where (ss.sozlesme_id = s.id)
       ) as sponsor
from fuar_sozlesme1 s inner join
     fuar_firma_2012 f
     on (s.cari = f.cari)
order by s.id DESC

create table numbers (
    number int not null
        check(number >= 1234 and number <= 4523),
    ...
)

create table numbers (
    number int not null,
    check(number >= 1234 and number <= 4523),
    ...
)

create table numbers (
    number int not null,
    constraint number_range_check
        check(number >= 1234 and number <= 4523),
    ...
)

SELECT Widget, to_char(timestamp_,'YYYY-MM-DD'), Count(Widget)
FROM Widget
WHERE timestamp_ BETWEEN to_date('YYYY-MM-DD HH24:MI:SS','%date1%') AND to_date('YYYY-MM-DD HH24:MI:SS','%date2%')
AND action LIKE 'reject'
GROUP BY Widget, to_char(timestamp_,'YYYY-MM-DD')
HAVING Count(Widget) > 1;

INSERT INTO basic_data (customer,total_value)
SELECT customer, total_value
FROM
(
    SELECT customer, SUM(sales) total_value
    FROM   sales a
    GROUP  BY customer
) c
ON DUPLICATE KEY UPDATE total_value = c.total_value

SELECT DATE_FORMAT(dateadded, '%y-%m-%d') 
FROM my_table

select datediff(second, date1, date2) / 60.0 as diff_in_minutes

BEGIN
    if (@ANSI_Attachment = 1) 
    begin
        --Copy temp attachments to sysmail_attachments      
        INSERT INTO sysmail_attachments(mailitem_id, filename, filesize, attachment)
        SELECT @mailitem_id, filename, filesize, 
                convert(varbinary(max), 
                    substring( -- remove BOM mark from unicode
                        convert(varchar(max), CONVERT (nvarchar(max), attachment)), 
                        2, DATALENGTH(attachment)/2
                    )
                )
        FROM sysmail_attachments_transfer
        WHERE uid = @temp_table_uid
    end else begin
        --Copy temp attachments to sysmail_attachments      
        INSERT INTO sysmail_attachments(mailitem_id, filename, filesize, attachment)
        SELECT @mailitem_id, filename, filesize, attachment
        FROM sysmail_attachments_transfer
        WHERE uid = @temp_table_uid
    end
END `

SELECT a.Id,a.Value,a.Year,MAX(b.Value)
FROM tableA A
JOIN tableB B ON A.Year = b.Year AND b.Value < A.Value
GROUP BY a.Id,a.Value,a.Year

SELECT 
m.match_id
FROM match m
WHERE 
m.match_id NOT IN
(
    SELECT
    ml.match_id 
    FROM message_log ml
)

SELECT MAX(ID)
FROM YourTable
WHERE Result = 'PASS'
GROUP BY `GROUP`;

  SELECT t.inv,
         MAX(CASE WHEN t.description = 'CHARGES' THEN t.amount ELSE NULL END) AS charges,
         MAX(CASE WHEN t.description = 'FREIGHT' THEN t.amount ELSE NULL END) AS freight,
         MAX(CASE WHEN t.description = 'INSURANCE' THEN t.amount ELSE NULL END) AS insurance
    FROM YOUR_TABLE t
GROUP BY t.inv
ORDER BY t.inv

-- declare a helper table variable
DECLARE @TableOfID TABLE (OldID INT, NewID INT)  

-- insert rows into the "newtable" - OUTPUT the inserted ID (assuming it's INT IDENTITY)
-- and the "old ID" into the table variable
INSERT INTO dbo.newTable(OldID, Col1, Col2, ..., ColN)
OUTPUT Inserted.ID, Inserted.OldID INTO @TableOfID(NewID, OldID)
   SELECT 
       ID, Col1, Col2, .., ColN
   FROM 
       dbo.oldtable
   WHERE 
      ..... (some WHERE conditions here)

-- update the "oldtable"
UPDATE 
    dbo.oldtable
SET 
    NewID = t.NewID
FROM 
    @TableOfID t
WHERE
    dbo.oldtable.ID = t.OldID

CREATE OR REPLACE FUNCTION dwh.dim_table_notification()
  RETURNS void LANGUAGE plpgsql AS
$func$
DECLARE
   myschema text;
BEGIN

-- truncate simply goes here:
TRUNCATE dwh.prod_table_notify;

FOR myschema IN
   SELECT quote_ident(table_schema)
   FROM   information_schema.tables
   WHERE  table_name IN ('dim_loan_type', 'dim_acct_type')
   AND    table_schema NOT LIKE 'pg_%'
   AND    table_schema NOT IN
          ('information_schema', 'ad_delivery', 'dwh', 'users', 'wand', 'ttd')
   ORDER  BY table_schema
LOOP
   EXECUTE '
   INSERT INTO dwh.prod_table_notify
              (userid, acct_type_id, acct_type, acct_type_desc, loan_type)
   SELECT '''|| myschema ||''', loan_type_id, loan_type::varchar(10)
        , loan_type_desc::varchar(50), term_code, 1 AS loan_type
   FROM   '|| myschema || '.dim_loan_type
   WHERE  term_code IS NULL
   UNION ALL
   SELECT '''|| myschema ||''' AS userid, acct_type_id, acct_type::varchar(10)
       , acct_type_desc::varchar(50), term_code, 0 AS loan_type
   FROM   '|| myschema || '.dim_acct_type
   WHERE term_code IS NULL';
END LOOP;
END
$func$

Date mmsDate = new Date(dateVal * 1000);

;with FundCounts As
(
    Select FundID, Count(*) * 0.2 As TopTwentyCount
    From Finance
    Group By FundID
)
select F.FundID, Sum(Value) as TopTwentyValueSum
from Finance F
inner join FundCounts FC on F.FundID = FC.FundID
where F.[Rank] <= FC.TopTwentyCount 
group by F.FundID

SELECT rec.id, title.name
FROM Records rec
LEFT JOIN Titles title ON title.record_id = rec.id and title.language='de';

SELECT rec.id, title.name
FROM Records rec
LEFT JOIN Titles title ON title.record_id = rec.id and title.language='en';


ID  NAME
1   ACHTUNG
2   (null)

ID  NAME
1   Warning
2   Ambulance

Sub LoadSheet()
Dim accappl As Access.Application
Dim strpathdb As String
Dim strpathxls As String
Dim myrange As String, myrow1 As String, myrow2 As String

myrow1 = Range("a1").End(xlDown).End(xlDown).Row
myrow2 = Range("a1").End(xlDown).End(xlDown).End(xlDown).Row

myrange = ActiveSheet.Name & "!A" & myrow1 & ":H" & myrow2

'path to the database
strpathdb = "X:\cre\dep\STRAT_PLAN\StratPlan.mdb"
'path to the upload file
strpathxls = ActiveWorkbook.FullName
Set accappl = New Access.Application

accappl.OpenCurrentDatabase strpathdb

accappl.DoCmd.TransferSpreadsheet transfertype:=acImport, _
            tablename:="Tbl_Growth_Metric", _
            Filename:=strpathxls, Hasfieldnames:=True, _
            Range:=myrange, SpreadsheetType:=5
            'The Spreadsheet type = 5 specifies an Excel 5.0/7.0 file
            'format

MsgBox "All records are loaded"

accappl.Quit

End Sub

select 
    utl_raw.cast_to_number(low_value), 
    utl_raw.cast_to_number(high_value)
from cols
where column_name = '<column_name>' and table_name = '<table_name>'

--Create table of dummy data
create table #person (
personID integer IDENTITY(1,1) NOT NULL,
name      varchar(255) not null,
dob       date,
father    integer
);

INSERT INTO #person(name,dob,father)Values('Pops','1900/1/1',NULL);  
INSERT INTO #person(name,dob,father)Values('Grandma','1903/2/4',null);
INSERT INTO #person(name,dob,father)Values('Dad','1925/4/2',1);
INSERT INTO #person(name,dob,father)Values('Uncle Kev','1927/3/3',1);
INSERT INTO #person(name,dob,father)Values('Cuz Dave','1953/7/8',4);
INSERT INTO #person(name,dob,father)Values('Billy','1954/8/1',3);

DECLARE @OldestPerson INT; 
SET @OldestPerson = 1; -- Set this value to the ID of the oldest person in the family

WITH PersonHierarchy (personID,Name,dob,father, HierarchyLevel) AS
(
   SELECT
      personID
      ,Name
      ,dob
      ,father,
      1 as HierarchyLevel
   FROM #person
   WHERE personID = @OldestPerson

   UNION ALL

   SELECT
    e.personID,
      e.Name,
      e.dob,
      e.father,
      eh.HierarchyLevel + 1 AS HierarchyLevel
   FROM #person e
      INNER JOIN PersonHierarchy eh ON
         e.father = eh.personID
)

SELECT *
FROM PersonHierarchy
ORDER BY HierarchyLevel, father;

DROP TABLE #person;

select column_name
from information_schema.columns
where table_name = 'yourTableName'
and data_type like '%date%'

;WITH Payments AS
(   SELECT  CARHARTAR,
            CARHARREFNO,
            CARHARCARKOD,
            CARHARCARUNVAN,
            CARHARACIKLAMA,
            CARHARTUTAR,
            ROW_NUMBER() OVER(PARTITION BY CARHARCARKOD ORDER BY CARHARTAR DESC) [RowNumber]
    FROM    CARHAR
    WHERE   CARHARTIPI IN (2, 4)
    AND     CARHARISTIPNO IN (2, 6)
    AND     CARHARCARKOD NOT LIKE 'W%'
    AND     CARHARCARKOD NOT LIKE 'Z%'
    AND     CARHARGCFLAG = 2
    AND     CARHARIADEFLAG = 0
)
SELECT  CARHARTAR,
        CARHARREFNO,
        CARHARCARKOD,
        CARHARCARUNVAN,
        CARHARACIKLAMA,
        CARHARTUTAR
FROM    Payments
WHERE   RowNumber = 1
ORDER BY CARHARTAR 

select movie.name
from movie
join moviehascast mc on mc.movieid = movie.id
join cast on cast.id = mc.castid
where cast.name in (@actor1, @actor2)
group by movie.name
having count(1) = @numberOfActorsSearched

UPDATE [rs_DEVICES]
SET [device] = dbo.pad_zero(12,[device])
WHERE LEN([device]) < 12 AND NOT EXISTS (
    SELECT 1 FROM rs_DEVICES r1 WHERE r1.device = dbo.pad_zero(12,[device])
)

SELECT
  Place.*,
  IF(IFNULL(MIN(place_discount.idDiscount),0)>0,1,0) AS hasDiscount
FROM place
LEFT JOIN place_discount ON Place.id=place_discount.idPlace
GROUP BY Place.id

SELECT fruits FROM tblEatables WHERE EatID 
 NOT IN
 (SELECT Eatbles_Id WHERE  Edible_Status = 1)

select t1.ID1
     , t2.grade
     , t1.ID2
     , t3.grade
from Friends t1 
join Highschooler t2 on t1.ID1 = t2.ID 
join Highschooler t3 on t1.ID2 = t3.ID

IF @DefaultID IS NULL

CREATE FUNCTION getDescription1 (@code varchar(32))
RETURNS  nvarchar(1000)
AS
  DECLARE @p_str NVARCHAR(1000)
    SET @p_str = ''      
 SELECT @p_str = @p_str +  (specName+': '+specStr+', ')
     FROM productSpecs 
where specStr<>'' and visibility=1 and productCode=@code
 RETURN LEFT(@p_str, len(@p_str) -1)

Map(x => x.BirthDate)
    .Column("dtBirthDate")
    .Not.Nullable()
    .CustomSqlType("smalldatetime")
    .CustomType("datetime")

select 
    *
from 
    releases,
    (select 
        min(id) as x, 
        max(id) as y
     from
        releases
     where released > "2011-12-01"
     ) as D   
where
    id between D.x and D.y
limit 0,30

SELECT
  * 
FROM 
  test_table
WHERE 
  test_column != ASCIISTR(test_column)

select p.*
from person p
where p.datetime = (select max(p2.datetime) from person p2 where p2.name = p.name);

select 
time_decimal
,cast(cast(cast(time_decimal as int) as varchar)+
':'+cast(cast((time_decimal - cast(time_decimal as int)) * 60 as int) as varchar)+
':'+cast(cast(((time_decimal - cast(time_decimal as int)) * 60-
    cast((time_decimal - cast(time_decimal as int)) * 60 as int)) * 60 as int) as varchar) as time) as real_time
from time1

select * from UserLog l1
where Operation = 'Enter' and 
      not exists(select * from UserLog l2 
                 where l1.user = l2.user and 
                       l2.Operation = 'Exit' and 
                       l2.Time > l1.Time)

SELECT * 
FROM data 
RIGHT JOIN 
( 
   select 2 as o, 2 as p
   union all
   select 4, 6
) as t ON p = set1_value AND o = set2_value 
where id is null;

SELECT
     [item_id],
     STUFF(
         (SELECT ',' + [item]
          FROM TableName
          WHERE [item_id] = a.[item_id] AND item_id = 82
          FOR XML PATH (''))
          , 1, 1, '')  AS NamesList
FROM TableName AS a
WHERE item_id = 82
GROUP BY [item_id]

<cfset sortable_column_list = "age,height,weight,first_name">
<cfquery ...>
  SELECT first_name, age, height, weight
  FROM people
  ORDER BY <cfif ListFindNoCase(sortable_column_list, url.sort_column)>#url.sort_column#<cfelse>first_name</cfif>
</cfquery>

CREATE TRIGGER dbo.uniqueUserQuestion 
ON dbo.submit_Answer
INSTEAD OF INSERT
AS
BEGIN
    SET NOCOUNT ON
    IF EXISTS 
    (
        SELECT 1 
        FROM dbo.submit_Answer T 
        INNER JOIN INSERTED I 
        ON T.user_name = I.user_name 
            AND T.question_id = I.question_id
    )
    BEGIN
        -- Do dupe handling here
        PRINT 'duplicate'
        raiserror('cant submit answer to same question twice')
        return
    END

    -- actually add it in
    INSERT INTO
        dbo.submit_Answer
    SELECT
        *
    FROM
        INSERTED I
END
GO

INSERT INTO [dbo].[Users]
(
  [Name]
  ,[Surname]
  ,[Email]
  ,[Password]
  ,[Status]
  ,[DepartmentId]
  ,[Guid]
)
VALUES
(
  'david'
  ,'van staden'
  ,'ds@ik.io'
  ,123123  
  ,0
  ,8
  ,newid()
)

select
  m.name,
  count (distinct m2.name)
from
  Membership m join 
  Membership m2 on m.clubName = m2.clubName 
group
  by m.name 
order by
  count (distinct m2.name) desc

DECLARE

TYPE table1 IS TABLE OF NUMBER 
  INDEX BY PLS_INTEGER;

TYPE table2 IS TABLE OF table1
  INDEX BY PLS_INTEGER;
var_i table2

BEGIN

var_i (1) (1) := 1;
var_i (1) (2) := 12;

END;

    select t1.* from table1 t1
    left join table2 t2 on 
        substring_index(t2.path, '/', -1) =  substring_index(t1.path, '/', -1) 
        and t2.frn = t1.frn 
        and t2.byte = t1.byte
    where t2.path is null or t2.frn is null or t2.byte is null

select t.*,
       (case when expiry_date > @somdate and
                  row_number() over (partition by cod_suc, cod_ramo,
                                                  (case when expiry_date > @somdate then 1 else 0 end)
                                     order by id_pv desc) as col1
              then 1 else 0
         end)
from table t;

EXEC xp_cmdshell 'bcp "EXEC DatabaseName.dbo.pn_FlatProductXML ''KA-0009'' " queryout "C:\test.txt" -T -c '

SELECT `age` FROM `users` WHERE `userid`=
  (SELECT `id` FROM `second`  
   WHERE `second`.`name` = 'Berna')

DECLARE i INT DEFAULT 1;
DECLARE count DEFAULT ExtractValue(xml, 'count(//child)');

WHILE i <= count DO
SELECT ExtractValue(xml, '//child[$i]');
SET i = i+1;
END WHILE

CREATE FUNCTION [dbo].[ufn_test]
(
  @deptid INT
)        
RETURNS TABLE
AS
RETURN
      (SELECT * 
      FROM workorder
      WHERE deptid = @deptid);

$sql = "INSERT INTO table(column1, column2) VALUES(:value1, :value2)";
$result = DB::query(Database::INSERT, $sql)->bind(':value1', $val1)->bind(':value2', $val2)->execute();
echo $result[0]; // last_insert_id
echo $result[1]; // total rows inserted

SELECT MIN(value_0-value) as MinDiff
FROM TableName
WHERE value_0>=value

DECLARE @test TABLE (
  SampleCol varchar(50)
)

INSERT INTO @Test
  VALUES ('Test')
INSERT INTO @Test
  VALUES ('Test 1')
INSERT INTO @Test
  VALUES ('Test 2')
INSERT INTO @Test
  VALUES ('Test 3')
INSERT INTO @Test
  VALUES ('Test 4')

DECLARE @aa varchar(200)
SET @aa = ''

SELECT
  @aa =
  COALESCE(CASE
    WHEN @aa = '' THEN SampleCol
    ELSE @aa + ',' + SampleCol
  END
  , '')
FROM @test

SELECT
  @aa

CREATE OR REPLACE FUNCTION trigA()
  RETURNS trigger AS
$BODY$
begin
    new.modify=LOCALTIMESTAMP;
    return new;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE

$this->Student->find('all', array('conditions' => array('Human.first_name' => 'AnyFirstNameYouWant')));

select 
    name, 
    sum(col1*weighting) as weightedCol1, 
    sum(col2*weighting) as weightedCol2,
    n.date, 
    [hour]
from
    nodes n
    inner join weights w
        on w.nodeid = n.nodeid
        and w.date = n.date
group by 
    name, n.date, [hour]

SELECT USERID, OTHER,
       (SELECT TOP 1 c.CLASS
        FROM DBCLASSTABLE c
        WHERE c.USERID = u.USERID AND c.EFFECTIVEDATE < '2015-01-01'
        ORDER BY A.EFFECTIVEDATE DESC
       ) as Class
FROM @USERS u;

create table #tmp (c1 int, c2 int, dt datetime default(getdate()) )

insert into #tmp
(c1, c2)
exec mysproc

foreach (var deleteMe in deleteThese)
{ 
   // Delete validation
   if(CanDeleteItem(deleteMe.ItemId))
   {
      ///
      deleteMe.Prices.ToList().ForEach(p => db.ItemPrices.Remove(p));
      ///

      db.Entry(deleteMe).State = EntityState.Deleted;
   }
}
db.SaveChanges();

 select case substring(mystring,1,1)
        when 'G' then 'Green'
        when 'R' then 'Red'
        else '?'
    end as mycolumn from test;

-- Setup a test table

DECLARE @tbl AS TABLE(R1 NVARCHAR(10), R2 NVARCHAR(10), R3 NVARCHAR(10), R4 NVARCHAR(10), PC NVARCHAR(10));

INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','x','i',NULL,'1');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','y','i',NULL,'2');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','y','j',NULL,'2');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','z','k',NULL,'3');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('b','u','m',NULL,'4');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('b',NULL,'n',NULL,'4');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('c',NULL,NULL,NULL,'5');
INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('c','q',NULL,NULL,'6');

-- Calculate the result:

SELECT 
    PC,
    CASE WHEN LVL1 = 1 THEN R1 ELSE NULL END AS R1,
    CASE WHEN LVL2 = 1 THEN R2 ELSE NULL END AS R2,
    CASE WHEN LVL3 = 1 THEN R3 ELSE NULL END AS R3,
    CASE WHEN LVL4 = 1 THEN R4 ELSE NULL END AS R4
FROM
(
    SELECT
      PC,
      MAX(R1) AS R1, 
      MAX(R2) AS R2,
      MAX(R3) AS R3, 
      MAX(R4) AS R4,
      COUNT(DISTINCT ISNULL(R1,'.')) AS LVL1, 
      COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.')) AS LVL2, 
      COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.') + ISNULL(R3,'.')) AS LVL3,
      COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.') + ISNULL(R3,'.') + ISNULL(R4,'.')) AS LVL4
    FROM @tbl
    GROUP BY PC
) A

CREATE TRIGGER SetReason BEFORE UPDATE ON <table1>
FOR EACH ROW BEGIN
    SET NEW.event_id = 
        (CASE WHEN OLD.name != NEW.name THEN 1 ELSE 0 END) + 
        (CASE WHEN OLD.oid != NEW.oid THEN 2 ELSE 0 END) + 
        (CASE WHEN OLD.state != NEW.state THEN 4 ELSE 0 END) +  
        (CASE WHEN OLD.ctrl != NEW.ctrl THEN 8 ELSE 0 END)    
END;

ALTER TABLE points ADD xy POINT;

UPDATE  points
SET     xy = Point(x, y);

ALTER TABLE points MODIFY xy POINT NOT NULL;


CREATE SPATIAL INDEX sx_points_xy ON points (xy);

SELECT  *
FROM    points
WHERE   MBRContains(LineString(Point(100, 100), Point(200, 200), xy)
        AND z BETWEEN 100 and 200
        AND otherParameter > 10;

select tt.trainingCode
from TotalTraining tt left join
     SelectedTraining st
     on tt.trainingCode = st.trainingCode and
        st.EmpCode = 7190 and
        st.appraisalId = 12
where st.trainingCode is null ;

SELECT Package, SUM(Licences) as TotalLicences
  FROM (
        SELECT Package, Licences FROM Table1
         UNION ALL
        SELECT Package, Licences FROM Table2
         UNION ALL
        SELECT Package, Licences FROM Table3
       ) AS AllLicences
 GROUP BY Package

        connection.open();
        foreach (DictionaryEntry myInfo in myOrderInfo){//contain 183 times

        foreach (DictionaryEntry myBi in myInfo.value){//loop 13 times
        ...//some code
        cmd2.Parameters.AddWithValue("@" + myBi.Key, myBi.Value + "");
        ....
        cmd2.ExecuteNonQuery();

        }
        .....//some conditions

        cmd.Parameters.AddWithValue("@" + myInfo.Key, myInfo.Value + "");
        .....//some conditions

        cmd.ExecuteNonQuery();
        }
        connection.close();

create table posts (
id int not null auto_increment primary key,
user_id int,
post_date date
) engine = myisam;


insert into posts (user_id,post_date)
values 
(1,'2011-03-02'),
(1,'2011-04-10'),
(1,'2011-11-13'),
(2,'2011-03-02'),
(2,'2011-03-02'),
(3,'2011-01-01'),
(3,'2011-01-02'),
(3,'2011-01-03');


select * from (
select posts.*,
   @num := if(@user_id = user_id, @num + 1, 1) as rownum,
   @user_id:=user_id as uid
from posts,(select @user_id := 0, @num := 1) as t
order by user_id asc, post_date asc) 
as tab 
where rownum = 3
order by post_date limit 1

UPDATE [tablename] SET lab_no = REPLACE(lab_no, 'EPI8', 'EPI80');

GROUP BY categories.name, color_variant.pcode, color_variant.price 

where concat(a.name, a.surname) like . . .

CREATE TYPE num_tbl AS TABLE OF NUMBER;

CREATE FUNCTION has_kw( p_k IN VARCHAR2 )
  RETURN num_tbl
  PIPELINED
IS
BEGIN
  FOR i IN (SELECT DISTINCT id FROM kw WHERE k = p_k)
  LOOP
    PIPE ROW( i.id );
  END LOOP;
  RETURN;
END;

-- {0} is your table name
-- {1} is your identity value of the reset

IF EXISTS (SELECT null FROM sys.identity_columns WHERE OBJECT_NAME(OBJECT_ID) = '{0}' AND           last_value IS NOT NULL) 
    DBCC CHECKIDENT ({0}, RESEED, {1});

select 
    pair_1, pair_2
from 
    (select distinct name as pair_1 from TABLE_NAME),
    (select distinct name as pair_2 from TABLE_NAME)
where
    pair_1 <> pair_2

Select 
    *,
    (Select Count(*) From YourTable As T 
    Where T.well_name = W.well_name And T.rpt_date <= W.rpt_date) As [Normalized Time]
From
    YourTable As W
Order By
    well_name,
    rpt_date

select date_part('second',date1) - date_part('second',date2)

ALTER TABLE foo ADD COLUMN tempbar text;
UPDATE foo SET tempbar = cast(cast(bar as varchar) as text);
ALTER TABLE foo DROP COLUMN bar;
ALTER TABLE foo ADD COLUMN bar text;
UPDATE foo SET bar = tempbar;
ALTER TABLE foo DROP COLUMN tempbar;

declare @T table
(
  [key] char(4),
  code int,
  primary key([key], code)
)

insert into @T values
('key1',    220),
('key1',    221),
('key2',    220),
('key2',    221),
('key2',    222),
('key3',    220),
('key3',    333),
('key4',    255),
('key5',    220),
('key5',    221)

declare @Match table (code int)
insert into @Match values (220),(221)

select T.[key]
from @T as T
  left outer join @Match as M
    on T.code = M.code
group by T.[key]
having count(*) = (select count(*) from @Match) and
       count(M.code) = (select count(*) from @Match)

select (id/1000)+((id%1000)/100)+((id%100)/10)+(id%10)

SELECT orig_loc, COUNT(*) order_ct, COUNT(DISTINCT dest_loc) dest_ct
FROM order_table
GROUP BY orig_loc

CREATE TRIGGER trigger_Insert_TableB
ON TableB
FOR INSERT
AS
Begin
    Select * FROM Inserted //This will give you the inserted data
End

SELECT COUNT(*) FROM
(SELECT values 
 FROM table 
 GROUP BY values 
 HAVING COUNT(*) > 1) t

select count(distinct username) as TotalUserCountOnTheDay
from dbo.LoginHistory
where datediff(day,LoginDate, '2014-11-19') = 0;

declare @str1 varchar(1024) = 'and hello w w w search how are you',
        @str2 varchar(1024) = 'and hello w w search how are you',
        @likeStr varchar(512),
        @pos int,
        @maxMatch int;

set @maxMatch = 2;
set @pos = 0;

set @likeStr = '%hello';

while (@pos < @maxMatch)
begin
    set @likeStr += ' [^ ]';

    set @pos += 1;
end

set @likeStr += ' search%';

select @likeStr, (case when @str1 like @likeStr then 1 else 0 end), (case when @str2 like @likeStr then 1 else 0 end)

SELECT  c.ROW_ID
,       p.NAME
,       p.DATE
FROM    Cust c
JOIN    (
        SELECT  row_number() over (partition by pc.CUST_ID order by p.DATE) rn
        ,       pc.CUST_ID
        ,       p.NAME
        ,       p.DATE
        FROM    Prod p
        JOIN    ProdCust pc 
        ON      pc.PROD_ID = p.ROW_ID
        ) p
ON      c.ROW_ID = p.CUST_ID
        AND p.rn = 1 -- First row only 

dev> create table dctest (x number);

Table created.

dev> insert into dctest VALUES (0.98692326671601283);

1 row created.

dev> select * from dctest;

         X
----------
.986923267

dev> column x format 0.000000000000000000000000000
dev> /

                             X
------------------------------
 0.986923266716012830000000000

if v_type IN ('ABC','DEF','ASD') then
  do things;
end if;

SELECT *
FROM produit
WHERE date_format(date_commande, '%Y-%m-%d) BETWEEN $filtre_Date1 AND $filtre_Date2;

   select column1, column2 
    from table1 
    where 
    (@filtertype=1 AND (column3 in (select columnb from table2)))
    OR
    (@filtertype=2 AND (column2 in (select columnb from table2)))

DECLARE   @temp      YOURTYPE 
DECLARE   c          CURSOR
FOR       SELECT     CodeDesc 
          FROM       authors
OPEN      c
FETCH     NEXT FROM c 
INTO      @temp
WHILE     @@FETCH_STATUS = 0
BEGIN
         -do something with temp
         FETCH NEXT INTO @temp
END
CLOSE      c
DEALLOCATE c

UPDATE  a
SET     a.fieldA = b.fieldA,
        a.fieldB = b.fieldB
FROM    TableA a
        INNER JOIN TableB b
            ON  a.keyA = b.keyA AND
                a.keyB = b.keyB

select name, DOB, 
truncate(datediff(sysdate(),DOB)/365.25,0) as 'age'
from animal
where colour = 'Brown' and truncate(datediff(sysdate(),DOB)/365.25,0) <=2;

  SELECT TO_CHAR(DATE_OF_BIRTH,'fm MONTH')"Month", COUNT(TO_CHAR(DATE_OF_BIRTH,'fm MONTH'))"NoS"
    FROM EMP
   WHERE DATE_OF_BIRTH <= TO_DATE('31-12-1990','DD-MM-YYYY') AND DATE_OF_BIRTH >= TO_DATE('01-01-1990','DD-MM-YYYY')
GROUP BY TO_CHAR(DATE_OF_BIRTH,'fm MONTH') 
  HAVING COUNT(TO_CHAR(DATE_OF_BIRTH,'fm MONTH')) >= 2

ALTER TABLE emp ADD listOfSalaries salaryList NESTED TABLE listOfSalaries STORE AS salaryList_tab;

SELECT ss.softwareId AS 'Software ID',
    s.softwareDescription AS 'Software Description',
    sv.vendorName AS 'Vendor Name',
    c.cityName AS 'City Name'
FROM software AS s
left outer JOIN systemSoftware AS ss
ON s.softwareId = ss.softwareId
left outer JOIN softwareVendor AS sv
ON s.vendorId = sv.vendorId
left outer JOIN city AS c
ON sv.zipCode = c.zipCode
WHERE ss.softwareId is NULL
ORDER BY s.softwareId

SELECT        R1.id, 
              R1.way_id, 
              R1.node_id, 
              R1.sort
FROM          Relations R1
WHERE        R1.way_id = 107187465
AND R1.id = (SELECT MAX(R2.id) FROM Relations R2
             WHERE R1.node_id = R2.node_id)

Proc SurveySelect data=Have out=Want noprint
    Method = urs
    N = 1
    outhits
    rep = 1;
    Strata Id ;
run;

drop table if exists users;
create table users (  
   _id bigint unsigned auto_increment primary key,   
   name varchar(50) not null, 
   number_of_posts integer not null default 0
);

drop table if exists posts;
create table posts (  
   _id bigint unsigned auto_increment primary key,   
   user_id bigint unsigned not null, 
   post_text text
);

-- Populate with dummy data
insert into users (name) values ('Bob'), ('Sally');
insert into posts (user_id, post_text) 
    values (1, 'First!!'), (1, 'Second...'), 
           (2, 'Post 1'), (2, 'another post'), (2, 'more posts');

-- One-time update of users table
update users u
set u.number_of_posts = (      
  select count(0) from posts p
  where u._id = p.user_id      
);

-- trigger to keep post count up to date when future posts are made
drop trigger if exists trg_post_count;
delimiter $$

create trigger trg_post_count
after insert on posts
for each row 
begin
    select count(0) into @post_count 
    from posts
    where user_id = NEW.user_id;

    update users
    set number_of_posts = @post_count
    where _id = NEW.user_id;
end;
$$

delimiter ;

-- test trigger
insert into posts (user_id) values (2);
select * from users;

...

UPDATE dbo.system_numbers
SET @return_value = current_number = current_number + auto_increment,
    last_updated_on = GETDATE()
WHERE [type] = @parmtype
  AND auto_increment = 1
;
IF @@ROWCOUNT = 0
  SELECT @return_value = current_number
  FROM dbo.system_numbers
  WHERE [type] = @parmtype
;

select  *
from    tbl t
where   name =  (  select   name
                   from     tbl
                   where    billnumber = 100756 -- can be any of his
                )
    and date =  (  select   max(date)
                   from     tbl x
                   where    x.name = t.name
                )

-- First you have to enable SB for your database
USE master
ALTER DATABASE Playground
SET ENABLE_BROKER
GO

USE Playground
GO

-- Then create a message type; usually it will be XML
-- because it's very easy to serialize/deserialize it
CREATE MESSAGE TYPE [//Playground/YourMessageType]
VALIDATION = WELL_FORMED_XML
GO

-- Then create a contract to have a rule for communication
-- Specifies who sends which message type
CREATE CONTRACT [//Playground/YourContract] (
    [//Playground/YourMessageType] SENT BY ANY)
GO

--Creates queues, one for initiator (1) and one for target (2)
CREATE QUEUE MyQueue1
GO
CREATE QUEUE MyQueue2
GO

-- Finally, configure services that 'consume' queues
CREATE SERVICE [//Playground/YourService1]
ON QUEUE MyQueue1 ([//Playground/YourContract])
GO

CREATE SERVICE [//Playground/YourService2] 
ON QUEUE MyQueue2 ([//Playground/YourContract])
GO

-- Now you can send a message from service to service using contract
DECLARE 
    @dHandle uniqueidentifier,
    @Msg nvarchar(max) 

BEGIN DIALOG @dHandle
    FROM SERVICE [//Playground/YourService1]
    TO SERVICE '//Playground/YourService2'
    ON CONTRACT [//Playground/YourContract]
WITH ENCRYPTION = OFF

SELECT @Msg = (
    SELECT TOP 3 *
    FROM Table1
    FOR XML PATH('row'), ROOT('Table1'))

;SEND ON CONVERSATION @dHandle 
MESSAGE TYPE [//Playground/YourMessageType] (@Msg)

PRINT @Msg
GO

-- To get the message on the other end, use RECEIVE
-- Execute this in another query window
DECLARE @dHandle uniqueidentifier
DECLARE @MsgType nvarchar(128)
DECLARE @Msg nvarchar(max)

;RECEIVE TOP(1)
    @dHandle = conversation_handle,
    @Msg = message_body,
    @MsgType = message_type_name
FROM MyQueue2

SELECT @MsgType 
SELECT @Msg

END CONVERSATION @dHandle 
GO

WITH sumQuart AS
 (
   SELECT *,
      CASE
        WHEN ROW_NUMBER() -- for the 1st month in a quarter
             OVER (PARTITION BY CCP, Years, Quart
                   ORDER BY months) = 1
                  -- return the sum of all GTS of this quarter
        THEN SUM(GTS) OVER (PARTITION BY CCP, Years, Quart)
        ELSE NULL -- other months
      END AS sumGTS
   FROM gts
 )
,cte AS
 (
   SELECT 
      sq.*,
      COALESCE(b.Baseline, -- 1st quarter
               -- product of all previous quarters
               CASE
                 WHEN MIN(ABS(sumGTS)) -- any zeros?
                      OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months 
                            ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING) = 0 
                   THEN 0  
                 ELSE -- product
                      EXP(SUM(LOG(NULLIF(ABS(COALESCE(b.Baseline,1) * sumGTS),0)))
                          OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months 
                                ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING)) -- product
                      -- odd number of negative values -> negative result
                    * CASE WHEN COUNT(CASE WHEN sumGTS < 0 THEN 1 END) 
                                OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months 
                                      ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING) % 2 = 0 THEN 1 ELSE -1 END
               END) AS newBaseline
   FROM sumQuart AS sq
   LEFT JOIN BASELINE AS b
          ON B.CCP = sq.CCP
          AND b.Quart = sq.Quart
          AND b.Years = sq.Years
 )
SELECT 
   CCP, months, Quart, Years, GTS,
   round(newBaseline * GTS,2),
   round(newBaseline,2)
FROM cte

SELECT CONCAT('http://site.com/uni-', number, '-uni') as url FROM table

1,"a string",100.20
2,"a string containing a , comma",102.20
3,"a string containing a \" quote",102.20
4,"a string containing a \", quote and comma",102.20

DATE_FORMAT(my_date, '%Y-%m-%d') 

with cte_dates as (
    select distinct [Date] from MyTable
), cte_vals as (
    select distinct ColA from MyTable
)
select
    d.[Date],
    v.ColA,
    T1.ColB as ColB_Today,
    T2.ColB as ColB_Prev_Day
from cte_dates as d
    cross join cte_vals as v
    left outer join MyTable as T1 on T1.ColA = v.ColA and T1.[Date] = d.[Date]
    outer apply (
        select top 1 TT.ColB
        from MyTable as TT
        where TT.ColA = v.ColA and TT.[Date] < d.[Date]
        order by TT.[Date] desc
    ) as T2

SELECT @sSQL = 'SELECT @xCount = COUNT(ID) FROM Authors' 
EXEC sp_ExecuteSQL @sSQL, N'@xCount int output', @count = @xCount output

SELECT MONTH(user_lastlogin) AS Month,
       YEAR(user_lastlogin) AS Year,
       COUNT(*) AS 'Total Reg',
       SUM(CASE WHEN user_regtype = 'LR' THEN 1 ELSE 0 END) AS 'LR Reg',
       SUM(CASE WHEN IS NULL OR user_regtype = 'BBR' THEN 1 ELSE 0 END) AS 'BBR Reg'
  FROM bb_user 
GROUP BY MONTH(user_lastlogin), YEAR(user_lastlogin)
ORDER BY Year DESC, Month DESC

WITH Pivoted AS
(
  SELECT person_ID, eye, hair, teeth
  FROM SourceBodyPartColors
    PIVOT
    (
    MAX (color) FOR body_part_name IN ( [eye], [hair], [teeth] )
    ) AS pvt
  )  
MERGE TargetBodyPartColors AS target
USING  Pivoted AS source
ON (target.person_ID = source.person_ID)
WHEN MATCHED THEN 
UPDATE SET eye_color = source.eye,  
           hair_color = source.hair,  
           teeth_color = source.teeth ;

CREATE TEMPORARY TABLE IF NOT EXISTS people_hours (
    people_id INTEGER NOT NULL,
    society_id INTEGER NOT NULL,
    year INTEGER NOT NULL,
    month INTEGER NOT NULL,
    hours DOUBLE NOT NULL,
    PRIMARY KEY(people_id, society_id, year, month)
);

CREATE TEMPORARY TABLE IF NOT EXISTS people_cost (
    people_id INTEGER NOT NULL,
    year INTEGER NOT NULL,
    month INTEGER NOT NULL,
    cost DOUBLE NOT NULL,
    PRIMARY KEY(people_id, year, month)
);

TRUNCATE people_hours;
TRUNCATE people_cost;

INSERT INTO people_hours (people_id, society_id, year, month, hours)
SELECT
    p.id as people_id,
    s.id as society_id,
    YEAR(t.assigndate) as year,
    MONTH(t.assigndate) as month,
    SUM(t.timeunits)/60 as hours
FROM people p, society s, timesheet t
WHERE
    t.society_id = s.id AND
    t.people_id = p.id
GROUP BY year, month, people_id, society_id;

INSERT INTO people_cost (people_id, year, month, cost)
SELECT
    p.id as people_id,
    YEAR(o.date) as cost_year,
    MONTH(o.date) as cost_month,
    SUM(o.hourtarif + s.hourtarif) as cost
FROM people p, salarystate s, overhead o
WHERE
    s.people_id = p.id AND
    CONVERT(SUBSTRING(s.month FROM 1 FOR 4), UNSIGNED) = YEAR(o.date) AND
    CONVERT(SUBSTRING(s.month, -2), UNSIGNED) = MONTH(o.date)
GROUP BY cost_year, cost_month, people_id;

SELECT 
    h.year,
    h.month,
    h.society_id,
    h.hours,
    c.cost,
    (h.hours * c.cost) AS total_cost,
    CONCAT(p.name, ' ', p.firstname) AS employee,
    CONCAT(ps.name, ' ', ps.firstname) AS society
FROM people_hours h, people_cost c, people p, people ps, society s
WHERE
    h.society_id = s.id AND
    h.people_id = p.id AND
    h.people_id = c.people_id AND
    s.people_id = ps.id AND
    h.year = c.year AND
    h.month = c.month
ORDER BY h.year, h.month, h.people_id, h.society_id;

select min(A),B
  from table
 group by B

SELECT DATEADD(hour, -DATEPART(hour, TimeToLive), GETDATE());

WITH CTE as (
  SELECT
    RN = ROW_NUMBER() OVER (ORDER BY id),
    *
  FROM tablename
)
SELECT
  [Current Row].*
FROM CTE [Current Row]
LEFT JOIN CTE [Previous Row] ON
  [Previous Row].RN = [Current Row].RN - 1
LEFT JOIN CTE [Next Row] ON
  [Next Row].RN = [Current Row].RN + 1
WHERE
  not([Current Row].value = 0 AND [Next Row].value = 0) AND  
     // this deletes the row where value is zero and the next rows value is zero
  not([Previous Row].value = 0 AND [Current Row].value = 0) 
     // this deletes the row where value is zero and the previous rows value is zero

select t.Id
from Tent as t
left join (
    select p.tentId, count(*) as occupiedSpots
    from person as p
    group by p.tentId) as i ON i.tentId = z.id
where t.numberOfSpots > IFNULL(i.occupiedSpots,0)

    SELECT *, match(project_title) against('sample project 55') as similarity
    FROM projects
    WHERE status IN(1, 2, 3, 4, 5, 6) AND id != ? AND match('sample project 55') against(?)
    ORDER BY similarity DESC

DECLARE
  rec_count integer default 0;
  str varchar(100);
BEGIN
    str := 'select count(*) from emp_table';
    EXECUTE IMMEDIATE str into rec_count;
    dbms_output.put_line(rec_count);
END;

create or replace function split_xmcuser_groups_to_tuples() RETURNS SETOF RECORD AS $$
DECLARE
    r a%rowtype;
    strLen integer;
    curIdx integer;
    commaCnt integer;
    curCSV varchar;
BEGIN
    curIdx := 1;
    commaCnt := 1;
    FOR r IN SELECT * FROM a
    LOOP
        strLen := char_length(r.csv);
        while curIdx <= strLen LOOP
            curIdx := curIdx + 1;
            if substr(r.csv, curIdx, 1) = ',' THEN
                commaCnt := commaCnt + 1;
            END IF;
        END LOOP;
        curIdx := 1;
        while curIdx <= commaCnt LOOP
            curCSV := split_part(r.csv, ',', curIdx);
            if curCSV != '' THEN
                RETURN QUERY select r.a,curCSV;
            END IF;
            curIdx := curIdx + 1;
        END LOOP;
    END LOOP;
    RETURN;
END
$$ LANGUAGE 'plpgsql';

SELECT GROUP_CONCAT(product,',' ,quantity) FROM ORDERS;

min(timestamp) as first_interaction format = datetime.

SELECT id, header, text, ... 
  FROM CONTENT
 WHERE online_at < current_timestamp
 MINUS
SELECT id, header, text, ... 
  FROM CONTENT
 WHERE offline_at < current_timestamp

How to reset the root password for mysql:
Stop mysql:
1. service mysql stop

Run mysql with skip grants to be able to login without any password
2. mysqld_safe --skip-grant-tables &

Login as root
3. mysql -u root

4. mysql commands:
mysql> use mysql;
mysql> update user set password=PASSWORD("YourPWHere") where User='root';
mysql> flush privileges;
mysql> quit

Stop mysql
5. service mysql stop

Start mysql normally:
6. service mysql start

Try to login using your new password:
7. mysql -u root -p

Select * From (
Select 
Transacion_ID,
Case When C.lvl = 1 Then 'GROSS'
     When C.lvl = 2 Then 'DISC'
End TYPE,
Case When C.lvl = 1 Then GROSS_AMOUNT
     When C.lvl = 2 Then DISCOUNT_AMOUNT
End AMOUNT
From T
cross join (select level lvl from dual connect by level<=2) c     
) where amount is not null
order by 1

Create PROCEDURE  [dbo].[SCN_SP_SCE_Weekly_Report]
@startdate as datetime

AS
BEGIN
SET NOCOUNT ON;


declare @date datetime
declare @LastWeekStart datetime
declare @LastWeekEnd datetime
declare @ThisWeekStart datetime
declare @ThisWeekEnd datetime

set @date=(select dateadd(w, -7, @startdate))

set @LastWeekStart=(SELECT  DATEADD(DAY, 1 - DATEPART(WEEKDAY, @date), CAST(@date AS DateTime)))
set @LastWeekEnd=(DATEADD(DAY, 7 - DATEPART(WEEKDAY, @date), CAST(@date AS DateTime)))

set @ThisWeekStart=(SELECT  DATEADD(DAY, 1 - DATEPART(WEEKDAY, @startdate), CAST(@startdate AS DateTime)))
set @ThisWeekEnd=(DATEADD(DAY, 7 - DATEPART(WEEKDAY, @startdate), CAST(@startdate AS DateTime)))

select * into #a from(
select BU.bu_desc as [BU], prod.Product_Desc as [Product Name], NULL as [SC-ID], 
'OVERALL PROJECT STATUS' as [Project Name],'' as [Requestor], NULL as [Request Date],
case
when BU.bu_desc in ('DSM','Synexis','ALD') then 'GW'
when BU.bu_desc in ('Etch','SRP','FEP') then 'MS'
when BU.bu_desc in ('CMP','MDP') then 'RS'
else 'PT'
end as [PM],
'' as [SCE],
(count(parts.part_id_num)-count(parts.cancelled_date)) as [Total Parts Requested],
null as [No. Of Parts Completed Last Week],
null as [No. Of Parts Completed This Week],
count(parts.analysis_Complete_date) as [Total No.Of Parts Completed], 
case 
when (((count(parts.part_id_num)-count(parts.cancelled_date))-(count(parts.analysis_Complete_date)))=0) then 100
when ((count(parts.analysis_Complete_date))=0) then 0
else
((count(parts.analysis_Complete_date)*100)/(count(parts.part_id_num)-count(parts.cancelled_date)))
end as [SC Analysis Completed (%)],NULL as [Requested Completion Date],
NULL as [Committed Date],NULL as Notes,'' as sc_id
from scn_project_details as proj 
left join scn_part_details as parts on proj.project_id=parts.project_id 
left join SCN_BU bu on bu.bu_id=proj.bu_id 
left join dbo.SCN_Product_Name prod on prod.Product_Id=proj.Product_Id 
where proj.status_id<>12 and (proj.analysis_complete_date between @startdate and getdate()
or (proj.status_id >= 4 and proj.status_id < 8)) and parts.sc_id is not null
group by BU.bu_desc,prod.Product_Desc

union

select BU.bu_desc as [BU], prod.Product_Desc as [Product Name], proj.project_id as [SC-ID], 
proj.project_name as [Project Name],usr1.fname+' '+usr1.lname as [Requestor], 
proj.created_date as [Request Date],left(proj.pm_id,2) as [PM],usr2.fname+' '+usr2.lname as     [SCE],
(count(parts.part_id_num)-count(parts.cancelled_date)) as [Total Parts Requested],
null as [No. Of Parts Completed Last Week],
null as [No. Of Parts Completed This Week],
count(parts.analysis_Complete_date) as [Total No.Of Parts Completed], 
case 
when (((count(parts.part_id_num)-count(parts.cancelled_date))-(count(parts.analysis_Complete_date)))=0) then 100
when ((count(parts.analysis_Complete_date))=0) then 0
else
((count(parts.analysis_Complete_date)*100)/(count(parts.part_id_num)-count(parts.cancelled_date)))
end as [SC Analysis Completed (%)],
proj.project_completition_date as [Requested Completion Date],
proj.original_commit_date as [Committed Date],
NULL as Notes,parts.sc_id as sc_id
from scn_project_details as proj 
join scn_part_details as parts on proj.project_id=parts.project_id  and parts.sc_id is not null
left join SCN_users usr1 on proj.created_by=usr1.[user_id] 
left join SCN_users usr2 on parts.sc_id=usr2.[user_id] 
left join SCN_BU bu on bu.bu_id=proj.bu_id 
left join dbo.SCN_Product_Name prod on prod.Product_Id=proj.Product_Id 
where proj.status_id<>12 and (proj.analysis_complete_date between @startdate and getdate()
or (proj.status_id >= 4 and proj.status_id < 8)) and parts.sc_id is not null
group by BU.bu_desc,prod.Product_Desc,proj.project_id,proj.project_name,usr1.fname+'     '+usr1.lname,
proj.created_date,proj.project_completition_date,proj.original_commit_date,
proj.pm_id,usr2.fname+' '+usr2.lname,proj.analysis_complete_date,parts.sc_id ) as t


update a
set a.[No. Of Parts Completed Last Week]=c.cnt
from #a a, (
select count(b.sc_id) as cnt,b.project_id,b.sc_id
from scn_part_details as b
where b.analysis_complete_date between @LastWeekStart and @LastWeekEnd
group by b.project_id,b.sc_id) as c
where a.[SC-ID]=c.project_id
and a.sc_id=c.sc_id

update a
set a.[No. Of Parts Completed This Week]=c.cnt
from #a a, (
select count(b.sc_id) as cnt,b.project_id,b.sc_id
from scn_part_details as b
where b.analysis_complete_date between @ThisWeekStart and @ThisWeekEnd
group by b.project_id,b.sc_id) as c
where a.[SC-ID]=c.project_id
and a.sc_id=c.sc_id

select BU,[Product Name],[SC-ID],[Project Name],Requestor,[Request Date],PM,SCE,
[Total Parts Requested],[No. Of Parts Completed Last Week],[No. Of Parts Completed This Week],
[Total No.Of Parts Completed], [SC Analysis Completed (%)],[Requested Completion Date],
[Committed Date],Notes
from #a

End 

GO

SELECT r.name AS radio_name,Pod.*,Sh.* 
FROM podcasts Pod INNER JOIN
     radios r
     ON r.id = Pod.radio_id INNER JOIN
     shows Sh
     ON Sh.podcast_id = Pod.id 
WHERE NOT EXISTS (select 1
                  from shows sh2
                  where sh2.podcast_id = sh.podcast_id.id and
                        sh2.publication_date > sh.publication_date
                 )
ORDER BY sh.publication_date DESC
LIMIT 5;

BEGIN AUTONOMOUS TRANSACTION
   INSERT INTO LogTable () VALUES ();
   COMMIT;
   RESIGNAL;
END;

UPDATE targetTable t, sourceTable s 
SET t.y1 = s.y1, t.y2 = s.y2 -- (and so on...)
WHERE t.member = s.member AND t.year = m.year;

  SELECT `company_name`, 
         `employee_name`, 
         COUNT(`cid`) 
    FROM `tbl_reports` 
GROUP BY `company_name`,
         `employee_name`;

SELECT
  MD.*,
  P.City,
  P.State,
  P.Areacode
FROM MemberDetails AS MD
   LEFT JOIN PostcodeData  P ON MD.Postcode = P.Postcode

declare
  o anydata;
begin
  o := anydata.convertobject(myclass('hi ancestor'));
end;
/

SELECT name 
FROM groups 
WHERE id = (
    SELECT DISTINCT immediateparentid 
    FROM cachedgroupmembers 
    WHERE groupid = (
        SELECT g.id 
        FROM Tickets t, groups g
        WHERE t.Id = 124 AND t.id = g.instance AND g.type = 'AdminCc'
    ) AND immediateparentid != groupid
)

 SELECT 
    count(local_doc.providerno) NumberofReferals, 
    LOCAL_DOC.FULLNAME FULLNAME, 
    LOCAL_DOC.TELNUMBER TELNUMBER, 
    LOCAL_DOC.STREET STREET, 
    LOCAL_DOC.SUBURB SUBURB, 
    LOCAL_DOC.STATE STATE, 
    LOCAL_DOC.POSTCODE POSTCODE,
    LOCAL_DOC.PROVIDERNO
FROM 
    LOCAL_DOC, 
    PATIENT 
WHERE 
    PATIENT.PROVIDERNO = LOCAL_DOC.PROVIDERNO AND PATIENT.REFERALDATE <= sysdate AND PATIENT.REFERALDATE >= ADD_MONTHS(sysdate, -6)
GROUP BY
    LOCAL_DOC.FULLNAME , 
    LOCAL_DOC.TELNUMBER , 
    LOCAL_DOC.STREET , 
    LOCAL_DOC.SUBURB , 
    LOCAL_DOC.STATE , 
    LOCAL_DOC.POSTCODE ,
    LOCAL_DOC.PROVIDERNO

select *
from ls_comments c
where c.itemID = 9 or
      c.parentID in (select c2.commentId from ls_comments c2 where c2.itemId = 9)

SELECT t.tag_name, i.image_name FROM image_tags it
    INNER JOIN images i on it.image_id = i.id
    INNER JOIN tags t on it.tag_id = t.id
WHERE t.tag_name in ('beach', 'palms')

SELECT v.id as venue, COUNT(a.id) as visits
FROM users AS u
CROSS JOIN venues as v --<-- CROSS JOIN for Cartesian product between users and venues
LEFT JOIN activities AS a ON u.id = a.user_id AND a.venue_id = v.id
WHERE u.id = 1234
GROUP BY v.id
ORDER BY v.id

SELECT DATE(JULIANDAY('NOW', 'START OF MONTH')+d1*9+d2*3+d3) AS Days FROM (
    SELECT 0 AS d1 UNION SELECT 1 UNION SELECT 2 UNION SELECT 3
) JOIN (
    SELECT 0 AS d2 UNION SELECT 1 UNION SELECT 2
) JOIN (
    SELECT 0 AS d3 UNION SELECT 1 UNION SELECT 2
) WHERE STRFTIME('%m', Days)=STRFTIME('%m', 'NOW') ORDER BY Days;

select distinct fk_col from table1
minus
(select distinct fk_col from table1 where col_entry='ab3'
intersect
select distinct fk_col from table1 where col_entry='ab4')

CREATE TABLE name ( id int , UNIQUE (col_name1 type , col_name2 type) ON CONFLICT IGNORE )

SELECT `performers`.`hash`, `performers`.`alias`, 
  `performers`.`date_updated`, `performers`.`status`,
  IF(`performers`.`status` = 'active', 'deleted','active') AS `statususe`,
  `images`.`image_hash_file`
FROM `performers`
LEFT JOIN `images` ON `images`.`asset_id` = `performers`.`id` AND `images`.`asset_type` = 'performer'
ORDER BY `alias` ASC
LIMIT 12

create dbo.MyProc (
    @Param int = 30;
)
. . . 

WITH cte
     AS
     (
         SELECT CatId    AS ParentCatId,
                CatName,
                CatName  AS ParentName,
                HigherCatId,
                CatId,
                CAST(CatName AS VARCHAR(255)) AS PATH
         FROM   Categories
         UNION ALL 
         SELECT c.CatId    AS ParentCatId,
                cte.CatName,
                c.CatName  AS ParentName,
                c.HigherCatId,
                cte.CatId,
                CAST(cte.path + ', ' + c.CatName AS VARCHAR(255)) AS PATH
         FROM   cte
                INNER JOIN Categories c
                     ON  c.CatId = cte.HigherCatId
     )

SELECT c.parentName,
       COUNT(p.ProductId) AS ProductsCount
FROM   cte c
       LEFT OUTER JOIN products p
            ON  c.CatId = p.CatId
GROUP BY
       c.ParentCatId,
       c.ParentName
ORDER BY
       c.ParentCatId

create table abc_new as select *,sysdate as someDate from abc

bool overlap = db.Records.Any(x=>(x.TerminationDate >= givenRecord.StartDate 
                  && x.StartDate <= givenRecord.TerminationDate) ||
                  (x.TerminationDate <= givenRecord.TerminationDate 
                  && x.StartDate >= givenRecord.StartDate));

  select A, max(B) 
  from tbl
  group by A
  having count(A) > 1

select k.id, k.title
from knowledge k
inner join
(
  select kID
  from sorting
  group by kID
  having count(kID) < 2
) s
  on k.id = s.kid
LIMIT 0,8;

SELECT links.*, users.user_name
FROM links 
INNER JOIN terms 
  ON links.link_id = terms.terms_link_id AND terms.terms_tag_id = $tag_id
INNER JOIN users 
  ON links.link_user = users.user_id;

SET @total = 0, @lasttime = 0, @laststatus = 0;
SELECT IF(`status`=0,
          @total := IF(@lasttime=0,
                       0,
                       @total+TIMEDIFF(`datetime`,@lasttime)
          ),
          @lasttime := `datetime`
       ), (@laststatus := `status`) FROM `table`;
SET @total = @total + IF(@laststatus=1,TIMEDIFF(NOW(),@lasttime),0);
SELECT @total AS `result`

SELECT images.image_id, COUNT(votes.vote_id) AS cote_count
FROM votes 
JOIN images ON images.image_id=votes.image_id
GROUP BY images.image_id

SELECT *
FROM weapons
LEFT OUTER JOIN weapon_powers ON weapons.ID = weapon_powers.WEAPONTYPE
WHERE weapons.ID = @somevariable

SELECT convert(date, column1) as date
from table1
where convert(date, column1) < '01/25/2011'
and date is not null and date <> ''

SELECT *
FROM cars
LEFT JOIN carLog
  ON cars.id=carLog.car
     AND carLog.username='Juddling'

SELECT 
p.*, 
u.firstname, 
u.lastname, 
l.post_id AS liked 
FROM `posts` p 
LEFT JOIN `users` u ON u.id = p.author_id 
LEFT JOIN `likes` l ON l.user_id = p.author_id 
  AND l.post_id = p.id 
WHERE p.author_id=1 
AND p.published = 1 
ORDER BY p.post_date DESC LIMIT 0, 10 

select bill.bill_no,bill.total,bill.discount,bill.to_be_paid,
       isnull(Service_bill.total_amt,0) as ServiceCharge,
       isnull(Damage_cost.total_amt,0) as DamageCost,
       isnull(Extraperson_cost.total_amt,0) as ExtraCost,
       isnull(Advance_cost.total_amount,0) as Advance 
from   bill 
left join Advance_cost           on bill.bill_no=Advance_cost.room_bill_no 
left outer join Service_bill     on bill.bill_no=Service_bill.room_bill_no 
left outer join Damage_cost      on bill.bill_no=Damage_cost.room_bill_no 
left outer join Extraperson_cost on bill.bill_no=Extraperson_cost.room_bill_no
where  bill.bill_no='57'

CREATE TABLE TEAM (
    TEAM_ID INT PRIMARY KEY
    -- Other fields...
);

CREATE TABLE SCORE (
    TEAM1_ID INT,
    TEAM2_ID INT,
    -- Other field(s) that descibe the score...
    PRIMARY KEY (TEAM1_ID, TEAM2_ID),
    FOREIGN KEY (TEAM1_ID) REFERENCES TEAM (TEAM_ID),
    FOREIGN KEY (TEAM2_ID) REFERENCES TEAM (TEAM_ID)
);

 Select * from table1 where my_id in (
   Select Max(My_Id) from table1 where phase='Close' group by your_id)

SELECT event_id, event_name,
   LAG (event_end_date ) OVER (ORDER BY event_end_date ASC )+1
                                                         event_start_date,
   event_end_date
 FROM event

select STD_ID from SCHOOL order by STD_ID+0

 SELECT * FROM ps_product WHERE id_product=44 OR id_product=29

SELECT a_case.Id,      
    ISNULL(R1.Type, 'ND') AS Referred_by_1,     
    ISNULL(R2.Type, 'ND') AS Referred_by_2,     
    ISNULL(R3.Type, 'ND') AS Referred_by_3 
FROM ...

select distinct substring(convert(varchar(20),RunDateTime, 9), 13, 5) +' '
+ substring(convert(varchar(30),RunDateTime, 9), 25, 2) from
TestDates;

ALTER TABLE table1 ADD INDEX (fk_id);

management.call_command('flush')

position('\xefbbbf'::bytea IN convert_to(your_text_column,'UTF-8'))=1

SELECT COUNT(*) FROM table_name
WHERE DATEPART(HOUR, date_created) BETWEEN 9 AND 21

with cte as (
  select *, 
    row_number() over (partition by report_id order by timestamp desc) as RowNum
  from report_status_log
)

select * 
from report r
inner join cte c
on r.report_id = c.report_id
where c.code = 'finished' and RowNum = 1

SELECT DISTINCT item FROM myTable WHERE something = 3

SQL> with tbl(str) as (
      select 'SERO02~~~NA_@ERO5' from dual
    )
    select regexp_substr(str, '(.*?)(~~~|$)', 1, level, null, 1) element
    from tbl
    connect by  level <= regexp_count(str, '~~~') + 1;

ELEMENT
-----------------
SERO02
NA_@ERO5

SQL>

UPDATE some_table
    SET some_column = some_column || '_more_data';

WITH "Period" (PeriodM, PeriodName) AS (
    -- // I would store it as another table basically, but having it as part of the view would do
                SELECT  01, '1 mo'
    UNION ALL   SELECT  02, '2 mo' -- // data not stored
    UNION ALL   SELECT  03, '3 mo'
    UNION ALL   SELECT  06, '6 mo'
    UNION ALL   SELECT  12, '1 yr'
    UNION ALL   SELECT  24, '2 yr'
    UNION ALL   SELECT  36, '3 yr'
    UNION ALL   SELECT  48, '4 yr' -- // data not stored
    UNION ALL   SELECT  60, '5 yr'
    UNION ALL   SELECT  72, '6 yr' -- // data not stored
    UNION ALL   SELECT  84, '7 yr'
    UNION ALL   SELECT  96, '8 yr' -- // data not stored
    UNION ALL   SELECT 108, '9 yr' -- // data not stored
    UNION ALL   SELECT 120, '10 yr'
    -- ... // add more
    UNION ALL   SELECT 240, '20 yr'
    -- ... // add more
    UNION ALL   SELECT 360, '30 yr'
)
, "Yield" (ID, PeriodM, Date, Value) AS (
    -- // ** This is the TABLE your data is stored in **
    -- // 
    -- // value of ID column is not important, but it must be unique (you may have your PK)
    -- // ... it is used for a Tie-Breaker type of JOIN in the view
    -- //
    -- // This is just a test data:
                SELECT 101, 01 /* '1 mo'*/, '2009-05-01', 0.06
    UNION ALL   SELECT 102, 03 /* '3 mo'*/, '2009-05-01', 0.16
    UNION ALL   SELECT 103, 06 /* '6 mo'*/, '2009-05-01', 0.31
    UNION ALL   SELECT 104, 12 /* '1 yr'*/, '2009-05-01', 0.49
    UNION ALL   SELECT 105, 24 /* '2 yr'*/, '2009-05-01', 0.92
    UNION ALL   SELECT 346, 36 /* '3 yr'*/, '2009-05-01', 1.39
    UNION ALL   SELECT 237, 60 /* '5 yr'*/, '2009-05-01', 2.03
    UNION ALL   SELECT 238, 84 /* '7 yr'*/, '2009-05-01', 2.72
    UNION ALL   SELECT 239,120 /*'10 yr'*/, '2009-05-01', 3.21
    UNION ALL   SELECT 240,240 /*'20 yr'*/, '2009-05-01', 4.14
    UNION ALL   SELECT 250,360 /*'30 yr'*/, '2009-05-01', 4.09
)
, "ReportingDate" ("Date") AS (
    -- // this should be a part of the view (or a separate table)
    SELECT DISTINCT Date FROM "Yield"
)

-- // This is the Final VIEW that you want given the data structure as above
SELECT      d.Date, p.PeriodName, --//p.PeriodM,
            CAST(
                COALESCE(y_curr.Value,
                    (   (p.PeriodM - y_prev.PeriodM) * y_prev.Value
                    +   (y_next.PeriodM - p.PeriodM) * y_next.Value
                    ) / (y_next.PeriodM - y_prev.PeriodM)
                ) AS DECIMAL(9,4) -- // TODO: cast to your type if not FLOAT
            )  AS Value
FROM        "Period" p
CROSS JOIN  "ReportingDate" d
LEFT JOIN   "Yield" y_curr
        ON  y_curr.Date = d.Date
        AND y_curr.PeriodM = p.PeriodM
LEFT JOIN   "Yield" y_prev
        ON  y_prev.ID = (SELECT TOP 1 y.ID FROM Yield y WHERE y.Date = d.Date AND y.PeriodM <= p.PeriodM ORDER BY y.PeriodM DESC)
LEFT JOIN   "Yield" y_next
        ON  y_next.ID = (SELECT TOP 1 y.ID FROM Yield y WHERE y.Date = d.Date AND y.PeriodM >= p.PeriodM ORDER BY y.PeriodM ASC)

--//WHERE       d.Date = '2009-05-01'

;with T(f) as (
    select '' union 
    select 'xxx' union 
    select 'xxx (yyy)' union 
    select 'xxx (yyy) (zzz)'
)
select 
    right(f, patindex('%(%', reverse(f) + '('))
from T

>>

(No column name)

xxx
(yyy)
(zzz)

UPDATE `table` SET `current` = `max` WHERE `id` = 1

UPDATE t1 
SET t1.codeA = t2_1.codeB
FROM table1 t1
JOIN table2 t2_1      
  ON CHARINDEX(t2_1.colB, t1.colA) > 0
LEFT JOIN table2 t2_2 
  ON CHARINDEX(t2_2.colB, t1.colA) > 0
 AND t2_1.codeB <> t2_2.codeB 
 AND LEN(t2_2.colB) > LEN(t2_1.colB)
WHERE t2_2.colB IS NULL;

SELECT 
    'ALTER TABLE ' + OBJECT_NAME(so.parent_obj) + ' DROP CONSTRAINT ' + so.name
FROM sysobjects so
WHERE so.xtype = 'UQ'

CreateDocumentAsync(coll_link, 
    new {foo: "bar"}, 
    new RequestOptions {IncludePreTrigger = "TriggerName"}); 

select client_name, count(*) as transactions
from TableA
group by client_name
order by count(*) DESC

SELECT t.name, c.name, COUNT(item.id)
FROM typelookup t
CROSS JOIN codelookup c
LEFT JOIN itemCodePivot icp ON icp.codeId = c.codeId
LEFT JOIN item i ON i.itemId = icp.itemId AND i.TypeId = t.TypeId
GROUP BY t.name, c.name

SELECT pd.saleid,
       pd.firstpaymentdate                               AS FirstPaymentDate,
       (SELECT amountdue
        FROM   repaymentschedule
        WHERE  saleid = pd.saleid
               AND paymentduedate = pd.firstpaymentdate) AS FirstPaymentValue,
       (SELECT TOP 1 amountdue
        FROM   repaymentschedule
        WHERE  saleid = pd.saleid
               AND paymentduedate <> pd.firstpaymentdate
               AND paymentduedate <> pd.lastpaymentdate) AS RegularPaymentValue,
       (SELECT amountdue
        FROM   repaymentschedule
        WHERE  saleid = pd.saleid
               AND paymentduedate = pd.lastpaymentdate)  AS FinalPaymentValue
FROM   (SELECT saleid,
               Min(paymentduedate) AS FirstPaymentDate,
               Max(paymentduedate) AS LastPaymentDate
        FROM   repaymentschedule
        GROUP  BY saleid) pd 

SELECT  u.* 
FROM    Users u
        INNER JOIN 
        (   SELECT  ur.UserID
            FROM    Users_Roles ur
                    INNER JOIN Roles r
                        ON r.RoleID = ur.RoleID
            WHERE   r.PermissionLevel > 100 
            GROUP BY ur.UserID
        ) ur
            ON u.UserId = ur.UserId
WHERE   u.Active = 1  
ORDER BY u.LastName

SELECT d.ID, GROUP_CONCAT(m.Field) AS ConcatFields
FROM d JOIN m ON d.ID = m.dID
GROUP BY d.ID

SELECT   SUM(`quant`), MONTH(`date`) AS month, `id` 
FROM     ((SELECT `date`, `id`, count(`hit`) AS `quant` 
           FROM   `stat_2014_07` 
           WHERE  `k_id` = '123') t1
          UNION ALL 
          (SELECT `date`, `id`, count(`hit`) AS `quant` 
           FROM   `stat_2014_08` 
           WHERE  `k_id ` = '123') t2
         ) t_union
GROUP BY id, month

select count(case tipo_sangre when 'apositivo' then 1 end) as apositivo,
       count(case tipo_sangre when 'anegativo' then 1 end) as anegativo, 
       .....
       count(case tipo_sangre when 'onegativo' then 1 end) as onegativo
from donate

Select  
    NULLIF(Column1, '') as [Column1],
    NULLIF(Column2, '') as [Column2]
From TableA

UNION

Select 
    NULLIF(Column1, '') as [Column1],
    NULLIF(Column2, '') as [Column2]
From TableB

STUDENT_CHOICES=(
    ('None', 'None'),
)

CREATE TEMP TABLE items AS SELECT rowid FROM tblEvent_basic WHERE sguid=11

DELETE FROM tblEvent_type WHERE eguid in  (select rowid from items)
DELETE FROM tblEvent_group WHERE eguid in (select rowid from items)

DROP TABLE items

SELECT Name , MemberNumber
FROM (
    SELECT members.Name, friends.MemberNumber1 as MemberNumber
    FROM friends
    INNER JOIN members ON friends.MemberNumber1= members.MemNo
    WHERE friends.MemberNumber2 LIKE 1

    UNION ALL

    SELECT members.Name, friends.MemberNumber2 as MemberNumber
    FROM friends
    INNER JOIN members ON friends.MemberNumber2= members.MemNo
    WHERE friends.MemberNumber1 LIKE 1) AS derived1
ORDER BY derived1.Name

select id,version, team, date, time, oppo 
from fixtures A where id in
(
    select max(id)from fixtures 
    where date = "2012-06-01" 
    group by team
)

  select * from faculty F
     JOIN course C
          on CHARINDEX((','+CAST(c.id as varchar(10))+','), (','+f.courseid+',')) > 0
     JOIN subject s
          on CHARINDEX((','+CAST(s.id as varchar(10))+','), (','+f.subjectid+',')) > 0

SELECT CONCAT(city , ', ', country) AS x_axis, COUNT(*) as y_axis
FROM beer
GROUP BY city, country
HAVING COUNT(*) > 100
ORDER BY country, city;

SELECT * FROM TABLE WHERE COLUMN BETWEEN '1' AND '9' and LEN(COLUMN) = 1;

add_library(sql_cpp_target EXCLUDE_FROM_ALL myfile.sql.in.c)

UPDATE my_table
SET my_field =
    CASE
          WHEN position('a' in my_field) = 0 THEN my_field
          WHEN position('a' in my_field) = 1 THEN substring(my_field from 1 for 5)
          WHEN position('a' in my_field) > 1 THEN substring(my_field from 2 for 5)
    END

SELECT  a.STATE , 
        COALESCE(b.count, 0) AS Count
FROM 
    (
        SELECT 'done' AS STATE
        UNION
        SELECT 'open' AS STATE
        UNION
        SELECT 'pending' AS STATE
        UNION
        SELECT 'draft' AS STATE
        UNION
        SELECT 'cancel' AS STATE
    ) a LEFT JOIN 
    (
        SELECT  STATE , 
                count(*) AS count
        FROM    crm_lead
        GROUP BY STATE
    ) b ON a.STATE = b.STATE

select a1.acnumber, a1.opening_balance + coalesce(sum(a2.transaction_amount), 0)
from account a1 left join
     trandetails a2
     on a1.acnumber = a2.acnumber and
        a2.transaction_type like 'Deposit'
group by a1.acnumber, a1.opening_balance;

SELECT ID
FROM TableA
WHERE ID NOT IN(SELECT ID
            FROM TableA
            WHERE CODE='AAA')

;WITH CTE
AS
( 
   SELECT EmployeeID, EmployeeName, Department,
     ROW_NUMBER() OVER(PARTITION BY Department ORDER BY(SELECT 1)) rownum
  FROM table1
)
SELECT
  EmployeeId,
  EmployeeName,
  CASE rownum
    WHEN 1 THEN Department
    ELSE ''
  END AS Department
FROM CTE
ORDER BY EmployeeID;

Cursor cursor = db.rawQuery("Select * from tbl_name",SelectionArgs[]);

SELECT DATEADD(day, DATEDIFF(day, 0, GETDATE()), '03:30:00')

CREATE TABLE Swap (
  a CHAR(1),
  b CHAR(1)
);

INSERT INTO Swap (a, b) VALUES ('a', 'b');

UPDATE Swap SET a = b, b = a;

SELECT * FROM Swap;

select s.StudentName, a.AssignmentName, a.PointsPossible, g.PointsReceived
from students s cross join
     assignments a left outer join
     grades g
     on g.StudentId = a.StudentId and g.AssignmentId = a.AssignmentId;
order by s.StudentName;

  SELECT x.col1, x.col2,
         MAX(CASE WHEN x.rk = 1 THEN x.col3 END) AS Res1,
         MAX(CASE WHEN x.rk = 2 THEN x.col3 END) AS Res2,
         MAX(CASE WHEN x.rk = 3 THEN x.col3 END) AS Res3
    FROM (SELECT yt.col1,
                 yt.col2,
                 yt.col3,
                 ROW_NUMBER() OVER(PARTITION BY yt.col1, yt.col2
                                       ORDER BY yt.col3) AS rk
            FROM YOUR_TABLE yt) x
GROUP BY x.col1, x.col2

SELECT SUM(rl.paxon)
    ,r.id AS port_id
    ,rl.[date]
FROM runlogs rl
    INNER JOIN runs r
        ON r.code = rl.runsegment
    INNER JOIN runsegments rs
        ON rs.code = rl.runsegment
WHERE rl.[date] BETWEEN '20120709' AND '20120716'  
    AND rl.account in ('311','312','313')
    AND rs.org_id = 13
GROUP BY rl.[date], r.id

SELECT   Employee.Name      
, Employee.ID       
, Sum(Sales.Money)
, Year(Sales.Date)           
, Month(Sales.Date)
FROM Database.Sales.Sales       
INNER JOIN Database.Employee.Employee        
ON Sales.ID=Employee.ID        
WHERE Sales.Date BETWEEN '2000-01-01' AND '2001-01-01'            
group by 
    Employee.Name      
    , Employee.ID
    , Year(Sales.Date)           
    , Month(Sales.Date)
ORDER BY Employee.Name,  Year(Sales.Date), Month(Sales.Date)

SELECT TOP 1 a.logtime, a.BL1_data_SS_ST, a.BL2_data_SS_ST, a.BL3_data_SS_ST, 
a.BL4_data_SS_ST, a.BL5_data_SS_ST, a.BL6_data_SS_ST, a.BL7_data_SS_ST, 
a.BL8_data_SS_ST, a.BL9_data_SS_ST, a.BL10_data_SS_ST, a.BL11_data_SS_ST,
a.BL12_data_SS_ST, a.BL13_data_SS_ST, a.BL14_data_SS_ST, a.BL15_data_SS_ST,
a.BL16_data_SS_ST, a.BL17_data_SS_ST, a.BL18_data_SS_ST, a.BL19_data_SS_ST,
a.BL20_data_SS_ST, a.BL21_data_SS_ST, a.BL22_data_SS_ST, a.BL23_data_SS_ST, 
a.BL24_data_SS_ST, a.BL25_data_SS_ST, a.BL26_data_SS_ST, a.BL27_data_SS_ST,
b.st1_prmt_status_p45,c.beam_current, c.beam_energy
FROM INDUS2_BLFE.dbo.main_BLFE_status a 
INNER JOIN INDUS2_MSIS.dbo.main_MSIS_status b on a.logtime = b.logtime 
INNER JOIN INDUS2_BDS.dbo.DCCT c on b.logtime = c.logtime ''
ORDER BY a.logtime DESC

;WITH MaxPricePerCategory
AS
    (
    SELECT MAX(Price) AS [Price]
        -- You can remove category if you just need the maximum price
        , Category
    FROM Table1
    WHERE VendorID = 69041
    AND Table1.Category IN (49,50,45)
    GROUP BY Category
    )
SELECT DISTINCT Table2.name
    , Table2.city
    , Table2.state
FROM Table1 
JOIN Table2 
    ON Table1.VendorID = Table2.VendorID
JOIN MaxPricePerCategory MPPC
    ON Table1.Category = MPPC.Category
        AND Table1.price > MPPC.Price

select coalesce(t.SalesOrderID, 0) SalesOrderID
,      coalesce(t.OrderDate, d.OrderDate) OrderDate
,      coalesce(t.ItemID, 0) ItemID
,      coalesce(t.Quantity, 0) Quantity
,      coalesce(t.PromotionCode, 0) PromotionCode
from   (select @dateParameter OrderDate) d
left
outer
join   ( SELECT SalesOrderID, OrderDate, ItemID, Quantity, PromotionCode
         FROM tblSalesOrder
       ) t
on     t.OrderDate = d.OrderDate

$sql = "DELETE adjectives.*, declensions.* 
FROM adjectives adj
JOIN declensions decl ON 
   (adj.decl_m_id = decl.id OR
   adj.decl_f_id = decl.id OR
   adj.decl_n_id = decl.id OR
   adj.decl_pl_id = decl.id)
WHERE adj.word_id IN ?";

        Plan Hash           Total Elapsed                 1st Capture   Last Capture
     Value                    Time(ms)    Executions       Snap ID        Snap ID
    --- ---------------- ---------------- ------------- ------------- --------------
     54069910                   81,459           256         19864          19864

CREATE OR REPLACE PROCEDURE SP_EMPLOYEE_LOOKUP_BY_EMP_ID
(
      IN_USER_ID IN NUMBER, 
      IN_EMPLOYEE_ID NUMBER,
      IN_HC_AS_ON_DATE VARCHAR2,
      emp_cursor OUT SYS_REFCURSOR
) 
IS 

 is_found_rec boolean := false;    

 CURSOR employees IS 
    SELECT  * FROM EMPLOYEE e; 

BEGIN    

 FOR employee IN employees
  LOOP  

    is_found_rec := true;

        // do something  

  END LOOP; 

 if not is_found_rec then 
     // do something else 
 end if;

END;

SELECT 
    ban_id,
    ban_url,
    IFNULL(SUM(bansta_event = 'C'), 0) as num_impressions,
    IFNULL(SUM(bansta_event = 'I'), 0) as num_clicks
FROM banner
LEFT JOIN banner_statistics
    ON bansta_ban_id = ban_id
        AND bansta_event IN ('I', 'C') 
WHERE ban_id = 1

SELECT count(DISTINCT wp_postmeta.`post_id`) 
  FROM wp_posts
       LEFT JOIN wp_postmeta ON (wp_posts.ID = wp_postmeta.post_id)
       LEFT JOIN wp_term_relationships ON (wp_posts.ID = wp_term_relationships.object_id)
       LEFT JOIN wp_term_taxonomy ON (wp_term_relationships.term_taxonomy_id = wp_term_taxonomy.term_taxonomy_id) 
 WHERE wp_postmeta.meta_key       = 'betting_status'
    AND wp_postmeta.meta_value    = 'yes'
    AND wp_posts.post_status      = 'publish'
    AND wp_term_taxonomy.taxonomy = 'category'
    AND wp_term_taxonomy.term_id  = 106;

Select * from Page where Page.page_title = 'AccessibleComputing'

WITH times as (
SELECT    t3.EmplID
        , t3.EmplName
        , min(t1.RecTime) AS InTime
        , max(t2.RecTime) AS [TimeOut]
        , cast(min(t1.RecTime) as datetime) AS InTimeSub
        , cast(max(t2.RecTime) as datetime) AS TimeOutSub
        , xx.RecDate AS [DateVisited]
        , CASE WHEN max(t1.EmplID) is null and max(t2.EmplID) is NULL 
                      then 'Yes' else 'No' END IsAbsent
FROM  HrEmployee t3 
CROSS JOIN
(SELECT DISTINCT RecDate FROM AtdRecord) xx
LEFT JOIN  AtdRecord t1 
ON    t3.EmplID = t1.EmplID 
      and t1.RecDate = xx.RecDate
LEFT JOIN
      AtdRecord t2 
ON    t3.EmplID = t2.EmplID 
AND   t1.RecDate = t2.RecDate
AND   t1.RecTime < t2.RecTime
AND   t2.RecDate = xx.RecDate
group by 
          t3.EmplID
        , t3.EmplName
        , xx.RecDate
)
SELECT EmplID
,EmplName
,InTime
,[TimeOut]
,[DateVisited]
,convert(char(5),cast([TimeOutSub] - InTimeSub as time), 108) totaltime
,convert(char(5), case when TimeOutSub - InTimeSub >= '08:01' then 
cast(TimeOutSub - dateadd(hour, 8, InTimeSub) as time) else '00:00' end, 108) as overtime,
isAbsent
FROM times

for rec in (
    SELECT T.ID ID1,
           U.ID ID2,
           V.EQ
           FROM T 
           FULL OUTER JOIN U ON T.ID = U.ID
           FULL OUTER JOIN (SELECT ID, 1 EQ FROM T NATURAL JOIN U) V ON U.ID = V.ID)
loop
    if rec.id1 is null
    then
        -- row in U but not in T
    elsif rec.id2 is null
    then
        -- row in T but not in U
    elsif rec.eq is null
        -- row present in both tables
        -- but content mismatch
    end if
end loop

DECLARE @RAOID INT, @ORGID INT

SET @ORGID = 28
SET @RAOID = (SELECT RAOID FROM tblOrganisation WHERE ORGID = @ORGID)

PRINT @RAOID

IF @RAOID IS NOT NULL
BEGIN
  SELECT 
    CASE 
      WHEN tblOrganisation.ORGID IS NOT NULL THEN tblOrganisation.ORGID 
      ELSE 'No ORGID' 
    END AS ORGID,
    **CASE isnull(tblOrganisation.Name,'')
      WHEN '' THEN 'No SubSource for this RAO'
      ELSE  tblOrganisation.Name**
    END as SUBSOURCENAME
  FROM tblOrganisation 
  LEFT OUTER JOIN tblSubGroup ON tblOrganisation.SubGroupID = tblSubGroup.SubGroupID
  WHERE
    tblSubGroup.RAOID = @RAOID
END

declare @table_that_changes varchar(100) 
declare @linked_server1 varchar(20)
declare @linked_server2 varchar(20)
declare @DB_onserver1 varchar(100) 
declare @DB_onserver2 varchar(100)
select @linked_server1 = '[server109]',
       @linked_server2 = '[server104]',
       @DB_onserver1 = '[database203434]',
       @DB_onserver2= '[database416541]',
       @table_that_changes = 'LossTable_2191'

declare @sql varchar(1000)

set @sql = 'create view linked1.table1 as select * from ' +
           @linked_server2 + '.' + @DB_onserver1  + '.table1'

exec( @sql)

SELECT 
  SUM(comission), 
  token, 
  DATE(transdate) 
FROM
  t 
GROUP BY 
  token, 
  DATE(transdate)

WHERE UPDATE_TIME 
BETWEEN TIMESTAMP(CHAR(CURRENT DATE,ISO) || ' 06:00:00') - 1 DAY
AND TIMESTAMP(CHAR(CURRENT DATE,ISO) || ' 06:00:00')

select a.mjor, a.course, b.grade 
from degree_plan as a
left join student_record as b on a.course_no=b.course_no and b.id=4455
where a.major='COE'

select t.table_name, p.object_name, count(*)
from user_tables t
cross join user_objects p
join user_source s on s.name = p.object_name
         and s.type = 'PACKAGE BODY'
         and upper(s.text) like '%' || upper(t.table_name) || '%'
where p.object_type = 'PACKAGE BODY'
group by t.table_name, p.object_name
having count(*) > 5;

select * from foo
order by coalesce(created_at, scheduled_at)

SELECT
[Pre].[pfPrefix],
[Pro].[prId],
[Pro].[prName],
(CASE
   WHEN [EnP].[enNumber] IS NULL THEN [EnT].[enNumber]
   ELSE
     (SELECT TOP 1
        [iET].[enNumber]
      FROM
        [SerialsDB].[dbo].[Entries] AS [iET]
        LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [iEP]
        ON (([iEP].[enProduct] IS NULL AND [iET].[enProduct] IS NULL) OR
            ([iEP].[enProduct] = [iET].[enProduct])) AND
           (([iEP].[enOrder] IS NULL AND [iET].[enOrder] IS NULL) OR
            ([iEP].[enOrder] = [iET].[enOrder])) AND
           (([iEP].[enClient] IS NULL AND [iET].[enClient] IS NULL) OR
            ([iEP].[enClient] = [iET].[enClient])) AND
           (([iEP].[enNfe] IS NULL AND [iET].[enNfe] IS NULL) OR
            ([iEP].[enNfe] = [iET].[enNfe])) AND
           (([iEP].[enDate] IS NULL AND [iET].[enDate] IS NULL) OR
            ([iEP].[enDate] = [iET].[enDate])) AND
           (([iEP].[enAuth] IS NULL AND [iET].[enAuth] IS NULL) OR
            ([iEP].[enAuth] = [iET].[enAuth])) AND
           (([iEP].[enStatus] IS NULL AND [iET].[enStatus] IS NULL) OR
            ([iEP].[enStatus] = [iET].[enStatus])) AND
           ([iEP].[enNumber] = ([iET].[enNumber] - 1))
      WHERE
        (([iET].[enProduct] IS NULL AND [EnT].[enProduct] IS NULL) OR
         ([iET].[enProduct] = [EnT].[enProduct])) AND
        (([iET].[enOrder] IS NULL AND [EnT].[enOrder] IS NULL) OR
         ([iET].[enOrder] = [EnT].[enOrder])) AND
        (([iET].[enDate] IS NULL AND [EnT].[enDate] IS NULL) OR
         ([iET].[enDate] = [EnT].[enDate])) AND
        (([iET].[enClient] IS NULL AND [EnT].[enClient] IS NULL) OR
         ([iET].[enClient] = [EnT].[enClient])) AND
        (([iET].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR
         ([iET].[enNfe] = [EnT].[enNfe])) AND
        (([iET].[enAuth] IS NULL AND [EnT].[enAuth] IS NULL) OR
         ([iET].[enAuth] = [EnT].[enAuth])) AND
        (([iET].[enStatus] IS NULL AND [EnT].[enStatus] IS NULL) OR
         ([iET].[enStatus] = [EnT].[enStatus])) AND
        ([iET].[enNumber] <= [EnP].[enNumber]) AND
        ([iEP].[enNumber] IS NULL)
      ORDER BY
        [iET].[enNumber] DESC)
 END) AS [Initial],
[EnT].[enNumber] AS [Final],
[EnT].[enOrder],
[EnT].[enDate],
[EnT].[enNfe],
[EnT].[enClient],
[Cli].[clGroup],
[EnT].[enAuth]
FROM
[SerialsDB].[dbo].Entries AS [EnT]
  LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [EnN]
  ON ([EnN].[enProduct] = [EnT].[enProduct]) AND
     ([EnN].[enOrder] = [EnT].[enOrder]) AND
     ([EnN].[enClient] = [EnT].[enClient]) AND
     (([EnN].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR
      ([EnN].[enNfe] = [EnT].[enNfe])) AND
     ([EnN].[enDate] = [EnT].[enDate]) AND
     ([EnN].[enStatus] = [EnT].[enStatus]) AND
 ([EnN].[enAuth] = [EnT].[enAuth]) AND
 ([EnN].[enNumber] = ([EnT].[enNumber] + 1))
  LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [EnP]
  ON ([EnP].[enProduct] = [EnT].[enProduct]) AND
     ([EnP].[enOrder] = [EnT].[enOrder]) AND
     ([EnP].[enClient] = [EnT].[enClient]) AND
     (([EnP].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR
      ([EnP].[enNfe] = [EnT].[enNfe])) AND
     ([EnP].[enDate] = [EnT].[enDate]) AND
     ([EnP].[enStatus] = [EnT].[enStatus]) AND
 ([EnP].[enAuth] = [EnT].[enAuth]) AND
     ([EnP].[enNumber] = ([EnT].[enNumber] - 1))
  LEFT OUTER JOIN [SerialsDB].[dbo].[Prefixes] AS [Pre]
  ON ([EnT].[enPrefix] = [Pre].[pfId])
  LEFT OUTER JOIN [SerialsDB].[dbo].[Products] AS [Pro]
  ON ([EnT].[enProduct] = [Pro].[prId])
  LEFT OUTER JOIN [SerialsDB].[dbo].[Clients] AS [Cli]
  ON ([EnT].[enClient] = [Cli].[clId])
WHERE
([EnT].[enOrder] IS NOT NULL) AND
([EnT].[enClient] IS NOT NULL) AND
([EnN].[enNumber] IS NULL) AND
([EnT].[enStatus] = 4) AND
([EnT].[enAuth] IS NOT NULL)

SELECT * FROM OpenQuery(PGEXAMPLE, 'select * from yourtable');

WHERE two = 2 AND three = 3 -- no one

R1 <(E M), {E → M}>

R2 <(E L T), {L T → E, E T → L}>

whereString = "LabDate Between #" & myStartDate & "# AND #" & myEndDate & "#"

SELECT 
    t.NAME AS TableName,
    p.rows AS RowCounts
FROM 
    sys.tables t
INNER JOIN 
    sys.partitions p ON t.object_id = p.OBJECT_ID 
WHERE 
    t.NAME NOT LIKE 'dt%' 
    AND t.is_ms_shipped = 0
    AND p.rows = 0
GROUP BY 
    t.Name, p.Rows
ORDER BY 
    t.Name

/*Set up test table*/
DECLARE @T TABLE (
  RowID       INT,
  Employee    CHAR(7),
  [Server]    CHAR(6),
  [timestamp] DATETIME );

INSERT INTO @T
SELECT 5,'E000001','Serv-B',  '20010501' UNION ALL
SELECT 4,'E000001','Serv-A',  '20010401' UNION ALL
SELECT 3,'E000001','Serv-B',  '20010301' UNION ALL
SELECT 2,'E000001','Serv-A',  '20010201' UNION ALL
SELECT 1,'E000001','Serv-A',  '20010101';

WITH cte
     As (SELECT ROW_NUMBER() OVER (PARTITION BY Employee ORDER BY RowID) -
                ROW_NUMBER() OVER (PARTITION BY Employee, Server
                                       ORDER BY RowID) AS Grp,
                *
         FROM   @T),
     cte2
     AS (SELECT *,
                ROW_NUMBER() OVER (PARTITION BY Employee, Grp ORDER BY RowID) AS
                Rn
         FROM   cte)

/* Edit: Actually - You want a SELECT not a DELETE I think?
DELETE FROM cte2 WHERE  Rn > 1*/

SELECT   RowID, Employee, [Server], [timestamp]
FROM cte2
WHERE  Rn = 1

Function GetAccessRecordset(sDatabase As String, sSQL As String) As Variant
    Dim oAccess As Object
    Set oAccess = CreateObject("Access.Application")
    oAccess.OpenCurrentDatabase (sDatabase)
    oAccess.Visible = False
    Dim dbs As Object
    Set dbs = oAccess.CurrentDb.OpenRecordSet(sSQL)
    GetAccessRecordset = dbs.GetRows(dbs.RecordCount)
    dbs.Close
    oAccess.Quit
End Function

UPDATE the_table
SET lastname = (SELECT lastname FROM the_table ORDER BY RAND())

mysql -uroot -p database_name < backup.sql

SELECT
      e.*
FROM employee e
      LEFT JOIN class c
            ON e.emp_id = c.emp_id
WHERE (c.timing <> '3-4'
      OR c.timing IS NULL)
;

SELECT
      *
FROM employee
WHERE NOT EXISTS (
            SELECT 1
            FROM class
            WHERE timing = '3-4'
                  AND class.emp_id = employee.emp_id
      )
;

DECLARE  @Table1 TABLE 
    (id int, text varchar(8), sender varchar(4), datetime varchar(25), hour int)
;

INSERT INTO @Table1
    (id, text, sender, datetime, hour)
VALUES
    (1, 'Hi, John', 'Amy', '2015-12-10 13:37:25 +0000', 13),
    (2, 'Yup', 'Mike', '2015-12-10 15:49:11 +0000', 15)
;

DECLARE @Table2  TABLE 
    (hour int)
;

INSERT INTO @Table2
    (hour)
VALUES
    (0),
    (1),
    (2),
    (3),
    (4),
    (6),
    (7),
    (8),
    (9),
    (13),
    (15),
    (16),
    (23)
;

   Select T.hour,
CASE WHEN cnt <> 0 THEN 
ROW_NUMBER()OVER(PARTITION BY T.cnt 
    ORDER BY (SELECT NULL)) 
ELSE CNT END cnt from (
select TT.hour,
CASE WHEN ISNULL(T.hour,0)<> 0 
THEN 1 ELSE ISNULL(T.hour,0) 
    END cnt  
        from @Table1  T
    FULL JOIN @Table2 TT
    ON TT.hour = T.hour

)T
ORDER BY T.hour

SELECT asset_id, entered_date, max(modified_date)
FROM price_data
GROUP BY asset_id, entered_date

select  row_number() over (partition by Meal order by Time)
,       *
from    YourTable

SELECT Product.*,
       Product_Supplier.quantity
FROM Product
LEFT OUTER JOIN Product_Supplier ON Product.id = Product_Supplier.productId
                                       AND Product_Supplier.supplierId = 1

SQL> select XMLAGG(XMLELEMENT(E, cust_name || ',')).EXTRACT('//text()')
  2   from (SELECT distinct cust_name, cust_addr_type FROM cust_data)
  3  where cust_addr_type ='old_address';

XMLAGG(XMLELEMENT
-----------------
cust1,cust2,

CREATE TABLE ts2 AS SELECT DISTINCT * FROM ts1;

Select 1 
from Friend f
join User u
    on f.FriendID = u.UserID
    and u.UserName = 'friend_user'
where 
    f.UserID = 1;

select l.name, count(*) as numbooks
from library l join
     books b
     on l.id = b.library_id
group by l.name
having count(*) > 1

SELECT DT.starttime
    ,DT.stoptime
    ,FB.fuellevel AS `startfuellevel`
    ,FE.fuellevel AS `stopfuellevel`
    ,(SELECT COUNT(AF.id)
     FROM addingfuel AF
     WHERE AF.timestamp BETWEEN DT.starttime AND DT.stoptime) AS `nbaddingevents
FROM drivingtime DT
INNER JOIN fuel FB ON FB.timestamp = DT.starttime
INNER JOIN fuel FE ON FE.timestamp = DT.stoptime

select  Date
,       GroupId
,       case
        when Comment is not null then Comment
        else
        (
        select  Comment
        from    YourTable yt2
        where   yt1.GroupId = yt2.GroupId
                and yt2.Comment is not null
                and yt2.Date < yt1.Date
                and not exists
                (
                select  *
                from    YourTable yt3
                where   yt1.GroupId = yt2.GroupId
                        and yt2.Comment is not null
                        and yt3.Date < yt2.Date and yt2.Date < yt1.Date
                )
        ) end as Comment
from    YourTable yt1

CREATE INDEX
  "SCHEMA"."INDEX_NAME"
ON
  "SCHEMA"."TABLE_NAME" (
    "COLUMN_NAME")
TABLESPACE
  MY_INDEX_TABLESPACE
LOCAL;

(SELECT * FROM example WHERE type = "A" LIMIT 3)
UNION ALL
(SELECT * FROM example WHERE type = "B" LIMIT 3)
UNION ALL
(SELECT * FROM example WHERE type = "C" LIMIT 3);

create procedure GetCartByEmailId
  @EmailId int
as  

select P.BrandName,
       P.ModelName,
       HR.HardwareName as RamName,
       HR.HardwareCost as RamCost,
       HG.HardwareName as GraphicCard,
       HG.HardwareCost as GraphicCardCost,
       HS.HardwareName as ScreenSize
from Cart as C
  inner join ProductInfo as P
    on C.ProductId = P.ProductId
  left outer join HardwareInfo as HR
    on C.Ram = HR.HardwareID
  left outer join HardwareInfo as HG
    on C.GraphicCard = HG.HardwareID
  left outer join HardwareInfo as HS
    on C.ScreenSize = HS.HardwareID
where C.EmailId = @EmailId

SELECT find.item, find.month, find.year, result.level
FROM AgingData result 
JOIN (
  SELECT original.item, original.month, original.year, max(cast(cast(previous.year as varchar) + '-' + cast(previous.month as varchar) + '-1' as datetime)) previous_date
  FROM AgingData original
  JOIN AgingData previous
    ON original.item = previous.item
     AND ((original.year > previous.year)
         OR (original.year = previous.year AND original.month > previous.month))
  WHERE original.level = 0
    AND previous.level != 0
  GROUP BY original.item, original.month, original.year ) find
ON result.item = find.item
  AND cast(cast(result.year as varchar) + '-' + cast(result.month as varchar) + '-1' as datetime) = find.previous_date

SELECT T1.Column1, T2.Column2, ... 
FROM Table1 AS T1
JOIN Table1 AS T2
    ON T1.Column1 = T2.Column1

select a.active as a_active, b.active as b_active, ... 
  from a join b on a.id = b.id

SELECT to_char(date_col, 'iw') w, trunc(date_col, 'd') st, trunc(date_col, 'd')+6 et
FROM your_table

$title = $post['title'];
$content = $post['content'];
$insertStatement = "INSERT INTO article (title, content, name)  
                    SELECT '$title', '$content', name 
                    FROM users 
                    WHERE id = mySessionId";

COLUMN_XXX + " LIKE '%' || ? || '%' " + ...

SELECT sum(case when amount > 1500 then 1 else 0 end) as GT1500
    , sum(case when amount < 1500 then 1 else 0 end) as LT1500
    , DATEPART(Year, amount.Date) Deposit_Year
    , DATEPART(QUARTER, amount.Date) Deposit_Qtr 
From account 
full outer JOIN amount ON account.AcctNo = amount.AcctNo
group by DATEPART(Year, amount.Date)
    , DATEPART(QUARTER, amount.Date)

select
bookid,
copy_num,
Last_Name,
First_Name,
Date_Due - to_date( '10-OCT-2014') total_days_overdue
from
book_copy bc
inner join customer c on bc.out_to_cid = c.cid
where
Date_Due >'10-OCT-2014'
Order by
bookid, copy_num;

select rank,
       if (@prevrank = rank, @rownum, @rownum := @rownum + 1) AS `myorder`,
       @prevrank := rank
from myRankorder cross join
     (SELECT @rownum := 0, @prevrank := -1) const
order by rank desc;

SELECT *
FROM (SELECT *
      FROM posts
      ORDER BY Date DESC) p
GROUP BY p.AuthorID
ORDER BY Date DESC
LIMIT 5;

SELECT * 
FROM 
(
  SELECT * FROM vehicles
  WHERE visible = 0 
  LIMIT 2
) v 
LEFT JOIN pictures f ON f.vehicles_id = v.id 

;WITH Period AS (
    SELECT      1 AS ReportingPeriod,
                CAST('2013-01-01' AS datetime) AS PeriodStartDate,
                CAST('2013-01-28' AS datetime) AS PeriodEndDate
    UNION ALL
    SELECT      CASE
                    WHEN p.ReportingPeriod = 13 THEN 1
                    ELSE p.ReportingPeriod + 1
                END,
                CASE
                    WHEN p.ReportingPeriod = 13 THEN DATEADD(YEAR,YEAR(p.PeriodStartDate)-1899,'1900-01-01')
                    ELSE DATEADD(DAY,28,p.PeriodStartDate)
                END,
                CASE
                    WHEN p.ReportingPeriod = 12 THEN DATEADD(YEAR,YEAR(p.PeriodStartDate)-1900,'1900-12-31')
                    ELSE DATEADD(DAY,28,p.PeriodEndDate)
                END
    FROM        Period p
    WHERE       p.PeriodStartDate < '2017-12-03'
)

SELECT 
    P.PeriodStartDate
    ,P.PeriodEndDate
    ,COUNT(*) AS Lots
    ,sum(flotSize) as 'Lot Size'
    ,sum(LReject) 'Lots Rejected'
    ,sum(fnumreject) as Rejected
    ,sum(fsampleSize) as 'Sample Size'
    ,sum(BDueDate) as 'Before Due Date'
FROM 
    ReportData  R
INNER JOIN Period P ON R.finspecteddate >= P.PeriodStartDate AND R.finspecteddate <= P.PeriodEndDate
WHERE 
    finspecteddate >= '01-01-2014' 
    AND finspecteddate <= '10-15-2014' 
GROUP BY 
    P.PeriodStartDate
    ,P.PeriodEndDate
ORDER BY 
    P.PeriodStartDate

SELECT customer_id, GROUP_CONCAT(domain_name SEPARATOR ',')
FROM customers_orders
INNER JOIN orders ON order_id = sub_id
GROUP BY customer_id

create table Children
(
  child_id int not null primary key,
  fname varchar(24),
  lname varchar(24),
  phone int,
  grade varchar(24),
  CONSTRAINT chk_Grade check grade IN ('Beginner' ,'Novice' ,'Skilled' ,'Expert')
)
GO

 select Kode_AK, dateTime_entry, Nama
 from (
 select 
 ROW_NUMBER () over ( partition by Kode_AK order by dateTime_entry desc ) rn,
 Kode_AK, Nama,
 dateTime_Entry
 from 
 LOG_NAMA ) A 
 where rn = 1

select date_format(sec_to_time(sum('total')), '%h:%i:%s') from timeSheet

DECLARE
  doc           dbms_xmldom.domdocument;
  l_output_clob CLOB;
BEGIN

  l_output_clob := ' ';
  doc           := dbms_xmldom.newdomdocument;
  dbms_xmldom.setversion(doc, '1.0" encoding="ISO-8859-15');
  dbms_xmldom.writetoclob(doc, l_output_clob);
  dbms_output.put_line(l_output_clob);
END;

 SELECT cs.case_id, cs.child_firstname, gu.*
   FROM tblcases cs 

        LEFT JOIN tblguardians gu
        ON cs.case_id = gu.case_id 
    AND gu.firstname LIKE '%sally%' /* <- this line was moved up from WHERE */

  WHERE cs.child_firstname = '%craig%' 

ORDER BY pf.rownum ASC, pf.CreatedOn DESC 

=Lookup("Cat5",Fields!Category.Value,Fields!Requests.Value,"DataSetName")/
Sum(Fields!Requests.Value,"DataSetName")

SELECT * FROM questions
    LEFT JOIN users_questions ON questions.id = users_questions.question_id AND
              users_questions.user_id = 'some_id'
 WHERE user_questions.questions_id IS NULL
 ORDER BY RAND() LIMIT 1

SELECT sensorid, 
       [00], [01], [02], [03], [04]
FROM MyTable
PIVOT
(
  MAX(value)
  FOR date IN ([00], [01], [02], [03], [04])
) AS PivotTable;

inner join (
        select distinct bartar_patientname
                ,(select top 1 bartar_pastePerMonth from [Bartar_MSCRM].[dbo].[Filteredbartar_callcenterreport] c2 where c2.bartar_patientname = cte.bartar_patientname and c2.bartar_pastePerMonth is not null order by c2.bartar_date desc) as bartar_date
                ,(select top 1 bartar_acc           from [Bartar_MSCRM].[dbo].[Filteredbartar_callcenterreport] c2 where c2.bartar_patientname = cte.bartar_patientname and c2.bartar_acc is not null order by c2.bartar_date desc) as bartar_acc
                ,(select top 1 bartar_insuranceinfo from [Bartar_MSCRM].[dbo].[Filteredbartar_callcenterreport] c2 where c2.bartar_patientname = cte.bartar_patientname and c2.bartar_insuranceinfo is not null order by c2.bartar_date desc) as bartar_insuranceinfo
                ,(select top 1 bartar_brand         from [Bartar_MSCRM].[dbo].[Filteredbartar_callcenterreport] c2 where c2.bartar_patientname = cte.bartar_patientname and c2.bartar_brand is not null order by c2.bartar_date desc) as bartar_brand
        from [Bartar_MSCRM].[dbo].[Filteredbartar_callcenterreport] cte
        ) r

CREATE TABLE site (
  id         INT AUTO_INCREMENT,
  name       VARCHAR(256),
  PRIMARY KEY (id)
)

CREATE TABLE worker (
  id         INT AUTO_INCREMENT,
  name       VARCHAR(256),
  site_id    INT,
  PRIMARY KEY (id, site_id),
  FOREIGN KEY (site_id) REFERENCES site (id)
)

CREATE TABLE group (
  id         INT AUTO_INCREMENT,
  name       VARCHAR(256),
  site_id    INT,
  PRIMARY KEY (id, site_id),
  FOREIGN KEY (site_id) REFERENCES site (id)
)

CREATE TABLE map_worker_group (
  worker_id  INT,
  site_id    INT,
  group_id   INT,
  PRIMARY KEY (worker_id, group_id, site_id),
  FOREIGN KEY (group_id,  site_id) REFERENCES group  (id, site_id),
  FOREIGN KEY (worker_id, site_id) REFERENCES worker (id, site_id)
)

algo$salt$password hash

SELECT * FROM DUAL;
/* Result:
"DUMMY"
"X"
*/

SELECT  COUNT(dummy) FROM DUAL WHERE dummy = 'X';
-- 1

SELECT  COUNT(dummy) FROM DUAL WHERE dummy = ('X');
-- 1

SELECT  COUNT(dummy) FROM DUAL WHERE dummy = (((('X'))));
-- 1

SELECT    COUNT(dummy)
FROM      DUAL
WHERE     dummy = 'X'
OR        dummy = ('X')
OR      ( dummy = 'X' OR dummy = ('X'))
OR      ((dummy = 'X' OR dummy = ('X')) AND (1 = 1 OR (1 = 1 OR (1 = 1))));
-- 1

    SELECT first_name, 
           last_name, 
           ROUND((MONTHS_BETWEEN(SYSDATE, TO_DATE(enrollment_date)) / 12), 2) AS Years
    FROM student
    WHERE phone LIKE '212%'
    ORDER BY years;

select 
    ID, 
    NAME, 
    CASE ROW_NUMBER() OVER(ORDER by NAME) 
        WHEN 1 THEN 'Default Value' 
        ELSE NULL 
    END AS [Other] 
from emp_table
ORDER BY NAME

select from {dbname}.sys.objects

SELECT app_id,transaction_id,mobile_no,
coalesce(tt1.USER_INPUT1,tt2.USER_INPUT1) AS USER_INPUT1,
coalesce(tt1.USER_INPUT3,tt2.USER_INPUT3) AS USER_INPUT3,
coalesce(tt1.USER_INPUT17,tt2.USER_INPUT17) AS USER_INPUT17,
coalesce(tt1.USER_INPUT110,tt2.USER_INPUT110) AS USER_INPUT110,
coalesce(tt1.USER_INPUT61,tt2.USER_INPUT61) AS USER_INPUT61,
coalesce(tt1.USER_INPUT62,tt2.USER_INPUT62) AS USER_INPUT62
 FROM (SELECT T1.app_id,
       T1.transaction_id,
       T1.mobile_no,
       CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 103 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input1,
          CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 105 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input3,
          CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 119 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input17,
          CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 121 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input110,
       CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 169 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input61,
       CONVERT(
          GROUP_CONCAT(
             (CASE T1.node_id
                 WHEN 170 THEN CONCAT(T1.customer_attribute, '~', T2.display_text)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input62
  FROM trn_user_log T1 INNER JOIN mst_node T2 ON T1.APP_ID = T2.APP_ID
 WHERE     T1.app_id = 104
       AND T1.transaction_id = 731
       AND T1.node_id = T2.parent_node_id
       AND T2.`display_seq` = T1.entered_value
--   GROUP BY T1.app_id, T1.transaction_id, T1.mobile_no
--  ORDER BY T1.node_id
) AS tt1

LEFT JOIN

(SELECT T3.app_id,
       T3.transaction_id,
       T3.mobile_no,
       CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 103 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input1,
          CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 105 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input3,
          CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 119 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input17,
          CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 121 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input110,
       CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 169 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input61,
       CONVERT(
          GROUP_CONCAT(
             (CASE T3.node_id
                 WHEN 170 THEN CONCAT(T3.customer_attribute, '~', T3.entered_value)
                 ELSE NULL
              END)) USING LATIN1)
          AS user_input62
FROM trn_user_log T3 INNER JOIN mst_node T4 ON T3.APP_ID = T4.APP_ID
WHERE  T3.app_id = 104
       AND T3.transaction_id = 731
       AND T3.node_id = T4.node_id
       AND  NOT EXISTS (SELECT 1 FROM mst_node b WHERE b.parent_node_id = t4.node_id)

--        GROUP BY T3.app_id, T3.transaction_id, T3.mobile_no
-- ORDER BY T3.node_id
  ) AS tt2 USING (app_id, transaction_id, mobile_no)

select t.range as [profit range], count(*) as [number of occurences]
from (
  select case 
    when profit between  100000000 and  200000000 then '100 million - 200 million'
    when profit between  200000000 and  300000000 then '200 million - 300 million'
    .
    .
    .
    when profit between  1000000000 and  2000000000 then '1000 million - 2000 million'
    else 'Greater then 2000 milions' end as range
    from tbl_profit) t
group by t.range
Order by SUBSTR(t.range,1,LOCATE(‘million’,t.range)-1)

DECLARE
  l_rec_a table_A%ROWTYPE;
  l_rec_b table_B%ROWTYPE;
BEGIN

  FOR i IN (SELECT a.ROWID first
                 , b.ROWID second
                 FROM table_A AS a
                 JOIN table_B AS b on a.id = b.id)
  LOOP
    SELECT * INTO l_rec_a FROM table_A WHERE ROWID = i.first;
    SELECT * INTO l_rec_b FROM table_B WHERE ROWID = i.second;

   /* do something */

  END LOOP;

END;

select min(calen_dt) as first_business_day
      ,max(calen_dt) as last_business_day
  from put_calen
 where calen_dt >= trunc(sysdate,'MM') - interval '1' month
   and calen_dt <= trunc(sysdate,'MM') - interval '1' day
   and business_day_ind = 'Y';

SELECT c.customer_id, c.name, NULL AS parent
  FROM customer AS c
  JOIN customer_product AS p ON c.customer_id = p.customer_id
 WHERE c.type = 'customer' 
  AND p.product_id = 3

UNION

SELECT c2.customer_id, c2.name, c1.customer_id AS parent
 FROM customer_product AS p
 JOIN customer AS c1 ON c1.customer_id = p.customer_id
 JOIN client_assignment AS a ON a.customer_id = c1.customer_id
 JOIN customer AS c2 ON c2.customer_id = a.client_id
WHERE c2.type = 'client'
  AND p.product_id = 3

select
    quantity,
    sum(case when websiteid is null and customergroupid is null
         then price
         end) as sprice,
    sum(case when websiteid is not null and customergroupid is null
        then price
        end) as wprice,
    sum(case when customergroupid is not null
        then price
        end) as cprice
from
  t
group by
  quantity

select
    account.bill_acct,
    account.status,
    account.remarks,
    stage.account_class
from
    registration_account account
    left join registration_profile profile
            on account.profile_id = profile.reg_prof_id
    left join acct_stg stage
            on stage.ecpd_profile_id = profile.ecpd_profile_id
                and stage.bill_acct = account.bill_acct
where
    profile.ecpd_profile_id = ?

using (SqlConncetion conn = new SqlConnection(connstring))
using (SqlCommand cmd = conn.CreateCommand())
{

  cmd.CommandText = "INSERT INTO table(tag) values (@tag)";
  cmd.Parameters.Add("@tag", SqlDbType.VarChar);

  conn.Open();

  foreach(string tag in tags)
  {
    cmd.Parameters["@tag"].Value = Server.HtmlEncode(tag);
    cmd.ExecuteNonQuery();
  }
}

begin 
:test :=  q'<
many many lines
many many lines
>' ;
end; 
/

sOracleOutput = rsOracle(0) & "|" & rsOracle(1) & "|" ...

INSERT INTO CUSTQUOTE (QTE_ID) 
SELECT 1
FROM JOB WHERE JOB_NUMBER = 'EW090800345'

select 
p.post_id,count(*) 'comment_count'
from
fss_post p
left join fss_comment c on p.post_id = c.post_id
group by p.post_id

Update AnotherTable 
Set match = (
                Select he.MyPrimary
                From SomeTable he
                Where he.ColOne = AnotherTable.FooOne
                    And he.ColTwo = AnotherTable.ColTwo
                    And he.ColThree = AnotherTable.FooOne
                    And he.SomeCode = AnotherTable.SomeCode
                    And he.relevancy = 1 
                    And he.ColThree = '2011-01-05' 
                    And he.ColFive = 9
                )
    , FooTwo =  (
                Select he.SomeCode
                From SomeTable he
                Where he.ColOne = AnotherTable.FooOne
                    And he.ColTwo = AnotherTable.ColTwo
                    And he.ColThree = AnotherTable.FooOne
                    And he.SomeCode = AnotherTable.SomeCode
                    And he.relevancy = 1 
                    And he.ColThree = '2011-01-05' 
                    And he.ColFive = 9
                )
    , SomeName =    (
                    Select he.SomeName
                    From SomeTable he
                    Where he.ColOne = AnotherTable.FooOne
                        And he.ColTwo = AnotherTable.ColTwo
                        And he.ColThree = AnotherTable.FooOne
                        And he.SomeCode = AnotherTable.SomeCode
                        And he.relevancy = 1 
                        And he.ColThree = '2011-01-05' 
                        And he.ColFive = 9
                    )
Where Exists    (
                Select 1
                From SomeTable he
                Where he.ColOne = AnotherTable.FooOne
                    And he.ColTwo = AnotherTable.ColTwo
                    And he.ColThree = AnotherTable.FooOne
                    And he.SomeCode = AnotherTable.SomeCode
                    And he.relevancy = 1 
                    And he.ColThree = '2011-01-05' 
                    And he.ColFive = 9
                )

select i.*, p.qn as qn_previous
from info i cross apply
     (select top 1 i2.*
      from info i2
      where i2.storeid = i.storeid and i2.upcode = i.upcode and
            i2.doentry < i.doentry
      order by i2.doentry desc
     ) p;

select EmpId, sum(Amount) as Amount, DateOfProduction 
from ProductionTable
group by EmpId, DateOfProduction.

select year(joining_date), month(joining_date),
       sum(case when department = 'IT' then 1 else 0 end)
from sample 
group by year(joining_date), month(joining_date)
order by 1, 2;

SELECT t.StudentName,
  MAX(CASE WHEN t.Date = '20120920' THEN t.Status END) AS '20-09-2012',
  MAX(CASE WHEN t.Date = '20120921' THEN t.Status END) AS '21-09-2012',
  MAX(CASE WHEN t.Date = '20120922' THEN t.Status END) AS '22-09-2012',
  MAX(CASE WHEN t.Date = '20120923' THEN t.Status END) AS '23-09-2012'
FROM Attendence t
GROUP BY t.StudentName

 ____________________             ____________________
|     Organisms      |           |       Species      |
|--------------------|           |--------------------|
|OrganismId (int, PK)|           |SpeciesId (int, PK) |
|SpeciesId (int, FK) |∞---------1|Name (varchar)      |
|Name (varchar)      |           |____________________|
|____________________|
          1
          |
          |
          1
 ______________________ 
|    HumanOrganism     |
|----------------------|
|OrganismId (int, FK)  |
|Sex      (enum)       |
|Race     (int, FK)    |
|EyeColor (int, FK)    |
|....                  |
|______________________|

select d.id, d.distance, d.time_s,
       (case when d.distance = 0
             then sum(case when d.distance = 0 then d.time_s end) over (partition by grp order by id)
        end) as StopTime
from (select d.*,
             sum(case when distance = 0 then 0 else 1 end) over (order by id) as grp
      from data d
     ) d;

ALTER TABLE      `table_name` 
ADD UNIQUE INDEX (`column1`, `column2`);

SELECT   phonenumber,
         dataplan AS currentplan,
         SUM(datamb) AS value_sum
FROM     maindata
GROUP BY phonenumber, dataplan;

select '      u1.'+column_name+' as customer_'+column_name+','
from Information_Schema.columns
where table_name = 'users' and schema_name = 'dbo';

ALTER TABLE [Course_Enrollment] ALTER COLUMN [enrollment_date] DATETIME NULL;

select ename 
  from emp
 where sal > any (select avg(sal) 
                    from emp 
                  group by 
                         deptno)
and deptno in (select deptno
               from emp
               group by 
               deptno having count(deptno) > 4);

1001
1002
1001
1003
1002

count(person.person.BusinessEntityID) = 5 // all
count(distinct person.person.BusinessEntityID) = 3 //1001, 1002, 1003
min(person.person.BusinessEntityID) = 1001
min( distinct person.person.BusinessEntityID) = 1001

TO_CHAR(date_value, 'DD/MM/YYYY hh24:mi:ss')

var sys  = require('sys');
var exec = require('child_process').exec;
var EOL  = require('os').EOL;

function funGrep(cmd,callback,search,args){
    exec(cmd,function(err,stdout){
        if(!err){
            console.log(err);
            return;
        }
        if(!stdout)
            return;
        var lines = stdout.toString().split(EOL);
        var re = new RegExp(search,args);
        for(var line in lines){
            var results = lines[line].match(re);
            if(results){
                for(var i = 0; i < results.length; i++){
                    callback(results[i]);
                }
            }
        }
    });
}

funGrep("ping -c 3 google.com",console.log,"time=[0-9\.]+ ms");
/*
output on OS X:
time=27.878 ms
time=27.652 ms
time=28.134 ms
*/
//for Windows:
funGrep("ping -t 3 google.com",console.log,"time=[0-9\.]+ ?ms");

select firstname, count(*) 
from members 
join member_photos using(member_id) 
group by firstname

create unique index idx_master_ip_tcp on master(ip, tcp_port);
create unique index idx_master_ip_udp on master(ip, udp_port);

declare @tbl table(numTenants varchar(50))
insert into @tbl values ('0T'), ('1T'),('2T'),('3T'),('4T'),('More than 4T')

;With CTE As
(
 select numTenants, count(codSite) numSites
from (select case count(st1.name) when 0 then '0T'
                       when 1 then '1T' 
                       when 2 then '2T' 
                       when 3 then '3T'
                       when 4 then '4T'
                       else 'More than 4T' end numTenants, os1.siteCode as codSite
    from fl_OperativeSite os1 left join fl_SiteTenant st1
        on st1.fkOperativeSite=os1.pkOperativeSite
    where  os1.siteType='A' and os1.externalInfrastructure=2
    group by os1.siteCode) groups
group by numTenants
order by numTenants
)

select a.numTenants,isnull(s.numSites,0) numSites from @tbl A 
left join CTE S on a.numTenants=s.numTenants

select *,(maths + chemistry + physics ) AS total FROM `student`

DECLARE @DELIMITER1 varchar(1), @DELIMITER2 varchar(1), @MAX_LENGTH int
SET @DELIMITER1 = ','
SET @DELIMITER2 = ' '
SET @MAX_LENGTH = 50

SELECT  [Name],
    SUBSTRING(Name,1,CHARINDEX(@DELIMITER1,Name) -1) AS LastName,                   -- Less one char for @DELIMITER1
    SUBSTRING(Name,CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH) AS FirstAndMiddle,   -- Plus two for @DELIMITER1 and @DELIMITER2
    CASE 
        -- Middle name follows two-name first names like Mary Ann 
        WHEN LEN(SUBSTRING(NAME, CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH)) - LEN(REPLACE(SUBSTRING(NAME, CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH), @DELIMITER2, '')) > 0
            THEN SUBSTRING(Name, LEN(Name) - CHARINDEX(@DELIMITER2, REVERSE(Name))+2, @MAX_LENGTH)
        ELSE NULL
    END AS MiddleName,

    CASE 
        -- Count the number of @DELIMITER2. Choose the string between the @DELIMITER1 and the final @DELIMITER2. 
        WHEN LEN(SUBSTRING(NAME, CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH)) - LEN(REPLACE(SUBSTRING(NAME, CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH), @DELIMITER2, '')) > 0
            Then SUBSTRING(Name, CHARINDEX(@DELIMITER1,Name)+ 2, 
                 (LEN(SUBSTRING(NAME, CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH))
                 - LEN(SUBSTRING(Name, LEN(Name) - CHARINDEX(@DELIMITER2, REVERSE(Name))+2, @MAX_LENGTH))))
        ELSE SUBSTRING(Name,CHARINDEX(@DELIMITER1,Name)+ 2,@MAX_LENGTH)
    END AS FirstName
FROM 
(
    SELECT  [Name] = 'Zzz, A' UNION ALL
    SELECT  'de Zzz, Aaa' UNION ALL
    SELECT  'Zzz, Aaaa' UNION ALL
    SELECT  'Zzz, A B' UNION ALL
    SELECT  'Zzz, Aaaa Bbbb' UNION ALL
    SELECT  'de Zzz, Aaaa' UNION ALL
    SELECT  'de Zzz, Aaaa B' UNION ALL
    SELECT  'van Zzz, Aaaa B' UNION ALL
    SELECT  'Yyy-Zzz, Aaaa B' UNION ALL
    SELECT  'd''Zzz, Aaaa B' UNION ALL
    SELECT  'Zzz, Aaaa Bbbb C' UNION ALL
    SELECT  'Zzz, Aaaa Bbbb Cccc'
) AS X

SELECT  boxid,
        LISTAGG(quantity || ' x ' || name, ',') 
            WITHIN GROUP (ORDER BY boxid) AS items
FROM    tableName
GROUP   BY boxid

MYSCHEMA.PKG_PEOPLE
MYSCHEMA.PKG_PEOPLE_CRUD

// contains the id for each category
$categories = array(1, 4, 5, 6);
$deflin = implode(',', $categories);

// if job_category is a text column you could do like this instead
$categories = array('category1', 'category2', 'category3');
$deflin = implode(',', $categories);    

$awaka = "SELECT *,
( 6371 * acos( cos( radians(?) ) * cos( radians(job_latitude) ) *   
cos(radians(?) - radians(job_longitude) ) + sin( radians(?) ) *   
sin( radians(job_latitude) ) ) ) AS distance FROM job, users   
WHERE job.listee_id = users.user_id AND job.job_category IN ($deflin)   
HAVING distance < 50";

WITH cte AS (
  SELECT CustomerID, Date, 
    DATEADD(DAY, 
            -ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY Date), 
            Date) dt
  FROM trips
)
SELECT CustomerID, Date, 
  DENSE_RANK() OVER (PARTITION BY CustomerID ORDER BY dt)
FROM cte;

class Device
  include DataMapper::Resource
  property :id, Serial
  has n, :locations # You probably want :order => [:time.desc] here too
  has 1, :latest_location, :class_name => Location, :order => [:time.desc]

  def lat
    latest_location.lat
  end
end

select 
 [timestamp],
 case 
   when latitude>0 then latitude
   else (select top 1 latitude 
         from @VehicleData v2
         where 
           latitude > 0 and
           v2.[TimeStamp] < v1.[TimeStamp]
         order by v2.[TimeStamp] desc )
   end
   as latitude
from 
 @VehicleData v1

select * from (
select ID, Type, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Type DESC) rn
FROM #temp
) a where rn = 1

SELECT r1.date, r1.time_spent, sum(r2.time_spent) AS rolling_week_total
FROM rolling_total AS r1 JOIN rolling_total AS r2
    ON datediff(r1.date, r2.date) BETWEEN 0 AND 7
GROUP BY r1.date
ORDER BY r1.date
LIMIT 8

select c.* from category c
where
(
  select count(*) from category as c1
  where c.app_Id = c1.app_Id
  and c.id < c1.id
)<=1
order by c.app_Id;

select * 
  from (select m.col1, 
               m.col2, 
               m.col3, 
               sum(m.col4) sum_c4
          from mytable m
        group by rollup(m.col1, (m.col2, m.col3))
       )
order by case when col1 is null then 1 
              else 0 
         end asc,                                     -- put grand total line at end of entire set
         sum(sum_c4) over (partition by col1) desc,   -- sort subgroups by descending subtotal
         col1,                                        -- tiebreaker for subgroups with same total
         case when col2 is null then 1 
              else 0 
         end asc,                                     -- put subtotal line at end of each group
         sum_c4 desc                                  -- put detail lines in descending order

CREATE SEQUENCE my_seq;

INSERT INTO new_table(Sno, Keywords)
SELECT my_seq.nextval, Name FROM old_table
UNION ALL
SELECT my_seq.nextval, Brand FROM old_table;

DECLARE @Schema XML
SET @Schema = '<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema">
<xs:element name="a">
    <xs:simpleType>
        <xs:list itemType="xs:int" />
    </xs:simpleType>
</xs:element>
</xs:schema>'

CREATE XML SCHEMA COLLECTION exampleschema as @Schema;
GO

DECLARE @XmlDoc AS XML(exampleschema)
SET @XmlDoc = '<a>123 456 789</a>'
select T.ref.value('.', 'int')
from 
(
      select [Xml]=@XmlDoc.query('
            for $i in data(/a) return 
            element temp { $i }
        ')
) A
CROSS APPLY A.Xml.nodes('/temp') T(ref)

DROP XML SCHEMA COLLECTION exampleschema
GO

    SELECT  CASE    CHARINDEX(']',RIGHT(text,LEN(text)-25), PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 11)
                WHEN 0 THEN SUBSTRING(RIGHT(text,LEN(text)-25), PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 10, CHARINDEX(' ',RIGHT(text,LEN(text)-25), PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 11)- (PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 10))
                ELSE  SUBSTRING(RIGHT(text,LEN(text)-25), PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 11, CHARINDEX(']',RIGHT(text,LEN(text)-25), PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 11)- (PATINDEX('%FROM__dbo__%',RIGHT(text,LEN(text)-25)) + 10)) END AS [nolock],
        name,
        type, text
FROM sys.sysobjects so with (nolock) INNER JOIN sys.syscomments sc with (nolock) ON so.id=sc.id 
where type='p' 
and PATINDEX('%FROM__dbo__%',text) > 0

UNION

SELECT  CASE    CHARINDEX(']',RIGHT(text,LEN(text)-25), PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 11)
                WHEN 0 THEN SUBSTRING(RIGHT(text,LEN(text)-25), PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 10, CHARINDEX(' ',RIGHT(text,LEN(text)-25), PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 11) - (PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 10))
                ELSE  SUBSTRING(RIGHT(text,LEN(text)-25), PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 11, CHARINDEX(']',RIGHT(text,LEN(text)-25), PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 11) - (PATINDEX('%JOIN__dbo__%',RIGHT(text,LEN(text)-25)) + 10)) END  AS [nolock],
        name,
        type, text
FROM sys.sysobjects so with (nolock) INNER JOIN sys.syscomments sc with (nolock) ON so.id=sc.id 
where type='p' 
and PATINDEX('%JOIN__dbo__%',text) > 0

select  parent.name as Category
,       child.name as SubCategory
from    (
        select  name
        ,       parent_id
        ,       @rn := if(@cur = parent_id, @rn+1, 1) as rn
        ,       @cur := parent_id
        from    product_category pc
        join    (select @rn := 0, @cur := '') i
        where   level = 2
        order by
                parent_id
        ,       id
        ) as child
join    product_category as parent
on      child.parent_id = parent.id
where   child.rn < 3

select username
from users
group by username
having count(distinct businessId) > 1
and max(salary) > 90000 

SELECT `stores`.`division`, 
SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`)   as `scheduled`,
sum(`ontime`), 
concat(round(( sum(`ontime`)/SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`) * 100 ),2),'%') AS ontime_percentage, 
sum(`completed`)-sum(`ontime`), 
concat(round(( (sum(`completed`)-sum(`ontime`))/SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`) * 100 ),2),'%') AS completed_percentage, 
(SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`)-sum(`completed`)) as `missed`, 
concat(round(( (SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`)-sum(`completed`)) /SUM(DATEDIFF(LEAST(IFNULL(`till`,CURDATE()),'$till'),GREATEST(`from`,'$from')) DIV `freq`) * 100 ),2),'%') AS missed_percentage from `stores` 
left join `jobs` on `stores`.`id`=`jobs`.`client` 
left join (select count(`user`) as `completed`,`job_id` from `job_hist` where `job_hist`.`last`>='$from' and `job_hist`.`last`<='$till' group by `job_id`) as `myquery` on `myquery`.`job_id`=`jobs`.`job_id` 
left join (select count(`name`) as `ontime`,`job_hist`.`job_id` from `job_hist` left join `jobs` on `jobs`.`job_id`=`job_hist`.`job_id` where `job_hist`.`last`>='$from' and `job_hist`.`last`<='$till' and `job_hist`.`days`<=`jobs`.`freq` group by `job_id`) as `myquery2` on `myquery2`.`job_id`=`jobs`.`job_id` 
where `stores`.`owner`='$group' 
group by `stores`.`division`

SELECT COUNT(keyword) AS cnt, keyword
FROM interested
GROUP BY keyword
ORDER BY cnt

 PRIMARY_KEY(Name, Time)

Select T1.Col1,T1.Col2,T2.Id,T2.Title
From Table1 T1
    cross apply  (Select top 1 Id, Title
                   From Table2
                   Where Ref=T1.Id
                   Order By Date Desc) AS T2

SELECT @dynsql AS [processing-instruction(x)] FOR XML PATH('')

declare @sql nvarchar(max);

select @sql = (select ', '+
                      (case when FieldName = 'Food' then 'Foods.DisplayName'
                            when FieldName = 'AnimalAge' then 'Animals.Age'
                         . . .
                       end)
               from @fields
               for xml path ('')
              );

select @sql = 'select [Animals].[AnimalID] AS [AnimalID], [Animals].[name] AS [AnimalName]'+@sql+RESTOFQUERY;

exec(@sql);

select f.*, strftime('%w', `date`) AS `weekday`
from (SELECT `year`, `month`, `day`, `hour`, `minute`, `value`,
             substr('000' || year, -4) || '-' || substr('0' || month, -2) || '-' || substr('0' || day, -2) AS `date`
      from foo
     ) t

select distinct person_info.person_name
     t2.value,
     t3.value,
     t4.value,
     t5.value
from person_info
    left join (select t.*, row_number() over (partition by person_name order by timestamp_column desc) rowno from table2 t) t2 
         on t2.person_name=person_info.person_name and t2.rowno=1
    left join (select t.*, row_number() over (partition by person_name order by timestamp_column desc) rowno from table3 t) t3
         on t3.person_name=person_info.person_name and t3.rowno=1
    left join (select t.*, row_number() over (partition by person_name order by timestamp_column desc) rowno from table4 t) t4
         on t4.person_name=person_info.person_name and t4.rowno=1
    left join (select t.*, row_number() over (partition by person_name order by timestamp_column desc) rowno from table5 t) t5
         on t5.person_name=person_info.person_name and t5.rowno=1;

SELECT c.*, count(p.id) people
FROM users p
LEFT JOIN apps c
ON c.id = p.app
WHERE c.status='1'
GROUP BY p.app
HAVING count(p.id) < 50
ORDER BY c.id DESC

create table ref (id serial primary key, name text);
create table points_to_ref(fk int references ref(id));
insert into ref(name) values('foobar');
-- more queries here...
-- now get back at what we inserted first
select id as id_xyz from ref where name='foobar';
\gset
insert into points_to_ref values (:id_xyz);

AND table.datum BETWEEN sysdate-7 and sysdate
AND TO_CHAR(to_date(substr(table.datum,1,10), 'DD-MM-YYYY'),
                         'D', 'NLS_DATE_LANGUAGE=ENGLISH') NOT IN ('1', '7')

    select m.id, m.name, e.name, e.deptno, c.count 
    from emps e join emps m on e.mgr = m.id
    join (select mgr,deptno, count(*) count from emps where mgr is not null
                             group by mgr, deptno) c
    on e.mgr = c.mgr and e.deptno = c.deptno

    SQL> /
            ID NAME   NAME       DEPTNO      COUNT
    ---------- ------ ------ ---------- ----------
             4 MESSI  JORDAN         20          2
             4 MESSI  JAMES          20          2
             4 MESSI  AYEW           10          1
    3 rows selected.
    Elapsed: 00:00:00.01

SELECT
    (SELECT AVG(x) FROM table1 WHERE x >= 0) AS x,
    (SELECT AVG(y) FROM table1 WHERE y >= 0) AS y,
    (SELECT AVG(z) FROM table1 WHERE z >= 0) AS z

Sub Randomise
    Randomize 
    Set rs = CreateObject("ADODB.Recordset")
    With rs
        .Fields.Append "RandomNumber", 4 

        .Fields.Append "Txt", 201, 5000 
        .Open
        Do Until Inp.AtEndOfStream
            .AddNew
            .Fields("RandomNumber").value = Rnd() * 10000
            .Fields("Txt").value = Inp.readline
            .UpDate
        Loop
        .Sort = "RandomNumber"
        Do While not .EOF
            Outp.writeline .Fields("Txt").Value

            .MoveNext
        Loop
    End With
End Sub

alter table add newcolumn as cast(oldcolumn as varchar(24)) persisted;
create index table_newcolumn on table (newcolumn);

SELECT DATEDIFF(SELECT DATE_ADD(start_date,INTERVAL 1 DAY),end_date);

 CREATE UNIQUE INDEX question_id_nonprivate ON question(id) WHERE (private = false)

SELECT  ADD_MONTHS( TRUNC(PARAM.start_date, 'Q'), 3*(LEVEL-1) )   AS qstart
    ,   ADD_MONTHS( TRUNC(PARAM.start_date, 'Q'), 3*(LEVEL) ) -1  AS qend
FROM    (   SELECT  TO_DATE('&start_date')  AS start_date
                ,   TO_DATE('&end_date')    AS end_date
            FROM    DUAL
        ) PARAM
CONNECT BY ADD_MONTHS( TRUNC(PARAM.start_date, 'Q'), 3*(LEVEL) ) -1
        <= PARAM.end_date

SELECT id FROM mytable WHERE start_date = (SELECT MAX(start_date) FROM mytable)

select  [Item Id]
,       [Lot Number]
,       sum(case when Attribute = 'PPA' then Value end) as PPA
,       sum(case when Attribute = 'PU0' then Value end) as PU0
,       ...
from    YourTable
group by
        [Item Id]
,       [Lot Number]

SELECT GROUP_CONCAT(name,'')
FROM (
  SELECT DISTINCT name
  FROM testtable
  WHERE ID<=10
  ORDER BY name
);

select td.id, listagg(tt.val, ',') within group (order by td.id)
from test_data td left join
     temp_table2 tt
     on td.col like '%,' || tt.col || '%,'
group by td.id;

select *
from all_tab_privs
where table_schema = 'MYSCHEMA'
and table_name = 'ORDERS'
and grantee = 'APP_USER';

-- sample data
DECLARE @StackOverflow TABLE (Unit INT, [TIME] TIME, Locatn VARCHAR(2), Picks INT)
INSERT INTO @StackOVerflow (Unit, [Time], Locatn, Picks) 
SELECT 1,     '11:50','L4',       2 UNION 
SELECT 2,     '11:51','m6',       3 UNION 
SELECT 3,     '12:01','L8',       4 UNION 
SELECT 2,     '12:03','A4',       2 UNION 
SELECT 1,     '12:05','B6',       3 UNION 
SELECT 3,     '12:06','C7',       1 UNION 
SELECT 1,     '12:10','D7',       4

-- confirm sample data
SELECT * FROM @StackOverflow

-- actual output
SELECT 
    DATEPART(HOUR,b.MinTime) StartHour,
    COUNT(DISTINCT a.Unit) Units,
    SUM(a.Picks) Picks
FROM 
    @StackOverflow a
     INNER JOIN 
      (
        SELECT Unit, MIN([TIME]) MinTime
        FROM @StackOverflow
        GROUP BY Unit 
      ) b ON 
        a.Unit = b.Unit
GROUP BY 
    DATEPART(HOUR,b.MinTime)

select * from users where id <= max_id order by id desc limit 0, 20

SELECT remarksDisplay = CASE remarks WHEN '' THEN '0' ELSE remarks END
FROM tableName;

WITH cte AS (
  SELECT supplier, buyer, 
    ROW_NUMBER() OVER (PARTITION BY supplier ORDER BY buyer) rn
  FROM Table1
)
SELECT supplier, 
       MAX(CASE WHEN rn=1 THEN buyer END) buyer1,
       MAX(CASE WHEN rn=2 THEN buyer END) buyer2,
       MAX(CASE WHEN rn=3 THEN buyer END) buyer3
FROM cte
GROUP BY supplier;

select Company.Name, Group_Concat(Employee.id)
from Company inner join Employee
on Company.id = Employee.Company 
group by Company.id

EXPLAIN QUERY PLAN SELECT col FROM YOUR_TABLE

update   YourTable
set      id = 
         (
         select  count(*)
         from    YourTable yt2
         where   yt2.Year <= YourTable.year
         )

select cola from abc
union all
select cola from abc
union all
select cola from abc

select
   Symbol,
   sum([10DayTotalVol]) as 10DayTotalV,
   sum([10DayAvgVol]) as 10DayAvgV,
   sum([15DayTotalVol]) as 15DayTotalV,
   sum([15DayAvgVol]) as 15DayAvgV,
   sum([30DayTotalVol]) as 30DayTotalV,
   sum([30DayAvgVol]) as 30DayAvgV

from (

      select
        Symbol, 
        sum(volume) as 10DayTotalVol, avg(volume) as 10DayAvgVol,
        0 as 15DayTotalVol, 0 as 15DayAvgVol,
        0 as 30DayTotalVol, 0 as 30DayAvgVol
      from
         [tbl-b]
      where
         timestamp >= (select min(ts) from (select distinct top 10 timestamp as ts from [tbl-b] order by timestamp desc ))
      group by
         Symbol   

      UNION

      select
        Symbol, 
        0, 0,
        sum(volume), avg(volume),
        0, 0
      from
         [tbl-b]
      where
         timestamp >= (select min(ts) from (select distinct top 15 timestamp as ts from [tbl-b] order by timestamp desc ))
      group by
         Symbol    

      UNION

      select
        Symbol, 
        0, 0,
        0, 0,
        sum(volume), avg(volume)
      from
         [tbl-b]
      where
         timestamp >= (select min(ts) from (select distinct top 30 timestamp as ts from [tbl-b] order by timestamp desc ))
      group by
         Symbol 
      ) s

group by 
   Symbol

SELECT ISNULL(nick, name) as result FROM table 

SELECT DISTINCT * FROM <table> WHERE <whereClause>

SELECT 
  t1.id,
  t1.c1,
  t1.c2,
  t1.c3
FROM
  your_table t1 
      INNER JOIN your_table t2 ON t1.id = t2.id
WHERE
  t1.c1 <> t2.c1 OR
  t1.c2 <> t2.c2

SELECT FullName, 
SUM(
       (select count(*) from qryItems where Responsible = FullName) + 
       (select count(*) from qryItems where Responsible2 = FullName) +
       (select count(*) from qryItems where Responsible3 = FullName)) 
FROM tblTeam
GROUP BY FullName

DECLARE 
    @CompanyID uniqueidentifier, 
    @CompanyName nvarchar(max), 
    @CEmpRepDesc nvarchar(max)

select top 1 @CompanyID = tbCompany.ID, @CompanyName= tbCompany.CompanyName, @CEmpRepDesc = tbCompany.CEmpRepDesc from tbCompany

select Emp.ID, Emp.SSN, ComputedInfos.CeilingEOS, @CompanyID, @CompanyName, @CEmpRepDesc
from Emp 
left join (select Emp.ID as EmpID, SUM(CeilingEOS) as CeilingEOS from Emp join Payroll_Emp on Payroll_Emp.Employee_Id = Emp.[ID] where @Date >= Emp.HireSince group by Emp.ID) ComputedInfos 
    on ComputedInfos.EmpID = Emp.ID
where @Date >= Emp.HireSince

SELECT  col1
        ,col2
        ,col3
FROM yourTable1 AS t1
INNER JOIN yourTable2 AS t2 ON t1.Id = t2.Id
WHERE col1 = 'aaaa'
AND col2 = 'bbbb'
ORDER BY col1

select job_id from jobs where is_taken_by is null limit 1 for update;
update jobs set is_taken_by = worker_pid where id = job_id;

$queryString = @'
select v.npa || v.calling_number phone_number, v.location, v.customer_name 
from voip_validate v 
left outer join phone_numbers p 
on v.npa || v.calling_number = p.area_code || p.phone_prefix || p.phone_suffix 
left outer join mv_dps_buildings b 
on b.dps_building_number = p.dps_building_number 
where p.area_code is null 
and p.phone_prefix is null 
and p.phone_suffix is null; 
'@

PS>$queryString
select v.npa || v.calling_number phone_number, v.location, v.customer_name
from voip_validate v
left outer join phone_numbers p
on v.npa || v.calling_number = p.area_code || p.phone_prefix || p.phone_suffix
left outer join mv_dps_buildings b
on b.dps_building_number = p.dps_building_number
where p.area_code is null
and p.phone_prefix is null
and p.phone_suffix is null;

SELECT  count(p.type) AS count,
        -- remove this if not necessary
        SUM(IFNULL(acos(sin((18.5236 *pi()/180)) * sin((p.lat*pi()/180))+cos((18.5236 *pi()/180)) * cos((p.lat *pi()/180)) * cos(((73.8478 - p.lng)*pi()/180))) * 6371.009, 0)) AS distance

FROM place AS p
WHERE p.deleted != 1
GROUP BY p.type
HAVING SUM(IFNULL(acos(sin((18.5236 *pi()/180)) * sin((p.lat*pi()/180))+cos((18.5236 *pi()/180)) * cos((p.lat *pi()/180)) * cos(((73.8478 - p.lng)*pi()/180))) * 6371.009, 0)) < 10

INSERT INTO Table1 (column1, column2)
SELECT @value, column2 from @otherTable;

ALTER TABLE tablename NOCHECK CONSTRAINT all

SELECT *
FROM (
  SELECT *,
    @rn:=IF(@prevCat=category_id, @rn + 1,1) rn,
    @prevCat:=category_id
  FROM (
    SELECT sub.entry_id, 
      sum(jud.stage), 
      sub.member_group,
      sub.category_id
    FROM exp_judging AS jud
      LEFT JOIN exp_submissions AS sub ON jud.rel_id = sub.id
    GROUP BY jud.rel_id
    ORDER BY sub.category_id, sum(jud.stage) DESC, sub.entry_id
  ) T
    JOIN (SELECT @rn:=0, @prevCat:=0) T2
) T
WHERE rn <= 3

SELECT *
FROM table
WHERE someColumnA = @searchBarTextVariable
   OR someColumnB = @searchBarTextVariable
   OR someColumnC = @searchBarTextVariable
   OR someColumnD = @searchBarTextVariable

Query query=sessionFactory.getCurrentSession().createQuery("FROM User WHERE " +
                    "pinStatus=:pinStatus AND petName IS NULL AND schoolName IS NULL AND accountType=:accountType")
                    .setString("accountType", "User").setString("pinStatus", "N");
            List<User> userList=query.list();
            Iterator<User> itr = userList.iterator();
              while(itr.hasNext()) {
                 User user = (User) itr.next();
                 long diff=currentDate.getTime() - user.getAccountStartDate().getTime();
                 long diffHours = diff / (60 * 60 * 1000);
                 if(diffHours>=24)
                 {
                     System.out.println("User added "+user.getFirstName());
                     userList1.add(user);
                 }
              } 

 SELECT
 SUM(CASE WHEN s.score < 0 THEN s.score ELSE 0 END) n_sum,
 SUM(CASE WHEN s.score > 0 THEN s.score ELSE 0 END) p_sum,
 SUM(s.score) `sum`
 FROM scores_ofexpert s
   WHERE s.user_id = '30' 

SELECT q.ProductId 
FROM (
SELECT DISTINCT 
    ld.ProductId, ld.UnitPrice 
FROM 
    LandingDetails ld 
JOIN 
    LandingHeaders lh ON ld.LandingId = lh.LandingId
WHERE 
    lh.LandingDate1 BETWEEN '20160313' AND '20160319'
) q 
GROUP BY q.ProductId 
HAVING COUNT(1) >= 2

var inner = from cid in FacebookLikeCategories where cid.UserID = 18 select cid.FacebookLikeCategoryID;
var result = from res in FacebookLikes where inner.Contains(res.UserID) select res.[like];

WHERE numberOfCookies &gt;= 10

select s.representative_id, count(*)
from stl_parliament s
  join 
  (
    select min(id) minid
    from stl_parliament
    group by economy_id
  ) t on s.id = t.minid
group by s.representative_id

select username,
       max(case when role = 'internal' then 1 else 0 end) as internal,
       max(case when role = 'admin' then 1 else 0 end) as admin
from t
where role in ('internal', 'admin')
group by username
having count(*) = 1;

SELECT a.question, a.answer_id, a.user_id, a.totalvotes
FROM
(
    SELECT a.question, b.answer_id, c.user_id, COUNT(d.vote_id) AS totalvotes
    FROM questions a
    LEFT JOIN answers b ON a.question_id = b.question_id
    LEFT JOIN users c ON b.user_id = c.user_id
    LEFT JOIN votes d ON b.answer_id = d.answer_id
    GROUP BY a.question, b.answer_id
    ORDER BY RAND()
) a
GROUP BY a.question

/* create a table to test with*/
declare @log table (event_time datetime, userid varchar(15), compname varchar(15), eventtype int, location int)
/* add some fake data to test with */
insert into @log
select '2014-08-18 10:11:17.000','smith217','library2123',1,13 union
select '2014-08-18 10:12:17.000','smith217','library2123',0,13 union
select '2014-08-18 10:13:17.000','jones217','library2123',1,13 union
select '2014-08-18 10:14:17.000','smith217','library2124',1,13 union
select '2014-08-18 10:15:17.000','hemmingway217','library2125',1,13 union
select '2014-08-18 10:16:17.000','hemmingway217','library2125',0,13

/* CTE = computed table expression */
/* CTE's must be used immediately following creation, and are only good for ONE query */
;with LogCTE AS
(
    /* cte content, is * from @log our test table */
    /* adding a row_number(), in this case partitioned by compname/location in descending order */
    select *,
           ROW_NUMBER() OVER(PARTITION BY COMPNAME, LOCATION ORDER BY EVENT_TIME DESC) AS LastEvent
    from @log
)

/* cte looks like this if you did select * from logcte */
/*
event_time              userid          compname    eventtype   location    LastEvent
2014-08-18 10:13:17.000 jones217        library2123 1           13          1
2014-08-18 10:12:17.000 smith217        library2123 0           13          2
2014-08-18 10:11:17.000 smith217        library2123 1           13          3
2014-08-18 10:14:17.000 smith217        library2124 1           13          1
2014-08-18 10:16:17.000 hemmingway217   library2125 0           13          1
2014-08-18 10:15:17.000 hemmingway217   library2125 1           13          2
*/

/* we only want the last action per PC, so select lastevent=1 and add your other conditions */
select compname, eventtype
from LogCTE
where LastEvent=1
and location=13

--ROLLBACK
SET XACT_ABORT ON
BEGIN TRAN
DECLARE @dsql nvarchar(max) = N''
SELECT @dsql += ' SELECT * INTO NEWDB.dbo.' + name + ' FROM SRCDB.dbo. ' + name + ' WHERE 1 = 2'
FROM sys.tables
--PRINT @dsql
EXEC sp_executesql @dsql

SET @dsql = N''
;WITH cte AS
 (SELECT 1 AS orderForExec, table_name, column_name, constraint_name, ordinal_position, 
         'PRIMARY KEY' AS defConst, NULL AS refTable, NULL AS refCol
  FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE          
  WHERE OBJECTPROPERTY(OBJECT_ID(constraint_name), 'IsPrimaryKey') = 1    
  UNION ALL
  SELECT 2, t3.table_name, t3.column_name, t1.constraint_name, t3.ordinal_position,
          'FOREIGN KEY', t2.table_name, t2.column_name
  FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS as t1
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE t2 ON t1 .UNIQUE_CONSTRAINT_NAME = t2.CONSTRAINT_NAME
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE t3 ON t1.CONSTRAINT_NAME = t3.CONSTRAINT_NAME
          AND t3.ordinal_position = t2.ordinal_position
    )
    SELECT @dsql += ' ALTER TABLE NEWDB.dbo.' + c1.table_name + 
           ' ADD CONSTRAINT ' + c1.constraint_name + ' ' + c1.defConst + ' (' +        
           STUFF((SELECT ',' + c2.column_name
                  FROM cte c2
                  WHERE c2.constraint_name = c1.constraint_name
                  ORDER BY c2.ordinal_position ASC
                  FOR XML PATH(''), TYPE
                  ).value('.', 'nvarchar(max)'), 1, 1, '') + ')' +
                  CASE WHEN defConst = 'FOREIGN KEY' THEN ' REFERENCES ' + c1.refTable + ' (' +
           STUFF((SELECT ',' + c2.refCol
                  FROM cte c2
                  WHERE c2.constraint_name = c1.constraint_name
                  ORDER BY c2.ordinal_position ASC
                  FOR XML PATH(''), TYPE
                  ).value('.', 'nvarchar(max)'), 1, 1, '') + ')' ELSE '' END 
    FROM (SELECT DISTINCT orderForExec, table_name, defConst, constraint_name, refTable FROM cte) AS c1
    ORDER BY orderForExec
    --PRINT @dsql
    EXEC sp_executesql @dsql
COMMIT TRAN

SELECT  AccountNumber
      , SUM(CASE WHEN DATEDIFF(DAY, InvoiceDate, GETDATE()) BETWEEN 271 AND 360
                 THEN QtyShipped
            END * Price) '360 to 271 days ago'
      , SUM(CASE WHEN DATEDIFF(DAY, InvoiceDate, GETDATE()) BETWEEN 181 AND 270
                 THEN QtyShipped
            END * Price) '270 to 181 days ago'
      , SUM(CASE WHEN DATEDIFF(DAY, InvoiceDate, GETDATE()) BETWEEN 91 AND 180
                 THEN QtyShipped
            END * Price) '180 to 91 days ago'
      , SUM(CASE WHEN DATEDIFF(DAY, InvoiceDate, GETDATE()) BETWEEN 0 AND 90
                 THEN QtyShipped
            END * Price) '90 to 0 days ago'
FROM    Datahub..InvoiceHold
WHERE   AccountNumber IN (
        SELECT  customer
        FROM    [Logistics].[dbo].[logistics_distributorgrowth]
        WHERE   [type] = 'customer'
                AND show = 'yes' )
        AND QtyShipped > 0
        AND InvoiceDate >= DATEADD(d, -360, GETDATE())
GROUP BY AccountNumber

SELECT


    name, room_id,

      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 0, price, '')) AS Day1,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 1, price, '')) AS Day2,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 2, price, '')) AS Day3,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 3, price, '')) AS Day4,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 4, price, '')) AS Day5,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 5, price, '')) AS Day6,
      MAX(IF(to_days(bookdate) - to_days('2009-06-24') = 6, price, '')) AS Day7, spots
    FROM `availables`
    GROUP BY name

CREATE PROCEDURE GetAppointmentsByProfessionalName
@ProfessionalName VARCHAR(256)
AS
BEGIN

   SELECT Appointment.AppointmentID AS 'Appointment ID', 
          COALESCE(Client.Name, '{{NO CLIENT}}') AS 'Client NAME',
          CONVERT(VARCHAR(10),Appointment.ProposedDate,111) AS 'Date', 
          CONVERT(CHAR(8), Appointment.ProposedTime, 114)AS  'Time', 
          Appointment.ClientDescription AS 'Client Notes', 
          Appointment.Confirmed AS 'Confirmed Appointment'
     FROM Appointment 
          LEFT OUTER JOIN Client 
             ON Client.ClientID = Appointment.ForClientID
          INNER JOIN aspnet_Users
             ON aspnet_Users.UserId = Appointment.ForProfessionalID
    WHERE aspnet_UsersUserName = @ProfessionalName;

END;

Select tab.email, tab.uname
From(
    Select email, max(credits) as credits
    From tab
    Group by  email
) x join tab on x.email = tab.email and tab.credits = x.credits

UPDATE myTable 
SET id = id + 1 
WHERE id >= 53
ORDER BY id DESC  ;

(--.*)|(((/\*)+?[\w\W]+?(\*/)+))

SELECT ID, GROUP_CONCAT(Other) FROM table GROUP BY ID

select
    ST.ColumnName1,
    JT.ColumnName2,
    SJT.ColumnName3
from 
    SourceTable ST
inner join JoinTable JT on 
    JT.SourceTableID = ST.SourceTableID
inner join SecondJoinTable SJT on 
    ST.SourceTableID = SJT.SourceTableID
where
        ST.SourceTableID = X
    and JT.ColumnName3 = Y
    and JT.Column3 = SJT.Column4

Criteria crit = session.createCriteria(Example.class);
crit.add(Restrictions.eq("name", dsd.getName()));       
crit.createAlias("parent", "parent");
crit.add(Restrictions.eq("parent.name", dsd.getParent().getName()));

SELECT username, value1, uploaded_date
FROM   (SELECT username, value1, uploaded_date,
               RANK() OVER (PARTITION BY username ORDER BY value1 ASC) AS rk
        FROM   test) t
WHERE  rk = 1

SELECT ETL_PRCS_DT, COUNT (*) TOTAL_PRGM_HOLD_DUE_TO_STATION
FROM DEV_AM_EDS_1..AM_HOLD_TV_PROGRAM_INSTANCE D1
LEFT JOIN DEV_AM_EDS_1..AM_STATION TAB2 ON D1.STN_ID = TAB2.STN_ID
WHERE TAB2.STN_ID IS NULL

SELECT  *
FROM (select * from Table1 where subposition is not null) as hasSubPosition
left join (select * from Table1 where subposition is null) AS noSubPosition
on 
hasSubPosition.eventid = noSubPosition.eventid and
hasSubPosition.position = noSubPosition.position and
hasSubPosition.pool = noSubPosition.pool and
hasSubPosition.status = noSubPosition.status and
hasSubPosition.area = noSubPosition.area
where noSubPosition.eventid is null

WITH CTE AS
(
    SELECT ID, RN = ROW_NUMBER() OVER (ORDER BY ID ASC)
    FROM dbo.TableName
)
UPDATE CTE SET ID = RN
WHERE ID <> RN

.. AS nvarchar(30)

select * from t where personid = '1' --needs replacement with personid you run for
union
select * from t where personid in (select personid from t where parentid = '1')
or parentid in (select personid from t where parentid = '1')

declare @dayAfter datetime     --let take 1 day after

set @dayAfter = DateAdd(day,1,'20120314')

SELECT Code,Description FROM Table
WHERE ID= 1 AND 
FromDate >= '20100214' AND 
ToDate <  DateAdd(day, DateDiff(day, 0, @dayAfter ), 0)

select 
  id, 
  location, 
  order_id,
  lag(id) over (order by order_id desc) as next_id
from your_table

SELECT distinct year( convert(datetime,StartDate,105)) 
FROM [kneipp].[dbo].[kn_projects]

select p.P_NO, 
cast(p.P_TITLE as varchar(15)) as P_TITLE, 
p.P_YEAR ,
      (select d.D_TYPE as "TYPE" 
            from DRAMA d 
            where d.D_P_NO=p.P_NO  
      UNION
       select c.C_TYPE as "TYPE" 
            from COMEDY c 
            where c.C_P_NO=p.P_NO  
      UNION    
       select t.T_TYPE as "TYPE" 
            from TRAGEDY t 
            where t.T_P_NO=p.P_NO 
      ) as TYPE
from PLAY p 
order by p.P_YEAR

create table #TableOne (BankCode nvarchar, Amt money)
create table #TableTwo (BankCode nvarchar, Amt money)

INSERT INTO #TableOne EXEC spDisplayBankConsolidate 'pname',@yr=2013
INSERT INTO #TableOne EXEC spDisplayBankConsolidate 'pname',@yr=2013,@equal='Eq'

select
    t1.BankCode, 
    t1.Amt as Opening, 
    t2.Amt as Closing
from #TableOne t1
inner join #TableTwo t2 on t1.BankCode = t2.BankCode

package com.mycorp.common.hibernate;

import org.hibernate.Criteria;
import org.hibernate.HibernateException;
import org.hibernate.criterion.CriteriaQuery;
import org.hibernate.criterion.Order;
import org.hibernate.engine.SessionFactoryImplementor;

import com.mycorp.LocalizationUtil;

public class LocalStringOrder extends Order {
    private static final long serialVersionUID = 1L;

    private boolean ascending;
    private String  propName;

    public LocalStringOrder(String prop, boolean asc) {
        super(prop, asc);
        ascending    = asc;
        propName = prop;
    }

    public String toSqlString(Criteria criteria, CriteriaQuery criteriaQuery) throws HibernateException {
        String[] columns = criteriaQuery.getColumnsUsingProjection(criteria, propName);
        StringBuffer fragment = new StringBuffer();
        for ( int i=0; i<columns.length; i++ ) {
            SessionFactoryImplementor factory = criteriaQuery.getFactory();
            fragment.append( factory.getDialect().getLowercaseFunction() )
            .append('(');
            fragment.append("EXTRACTVALUE(");
            fragment.append( columns[i] );
            fragment.append(", '//value[@lang=\"" + 
                LocalizationUtil.getPreferedLanguage().name() + 
                "\"')");
            fragment.append(')');
            fragment.append( ascending ? " asc" : " desc" );
            if ( i<columns.length-1 ) fragment.append(", ");
        }
        return fragment.toString();
    }

    public static Order asc(String propertyName) {
        return new LocalStringOrder(propertyName, true);
    }


    public static Order desc(String propertyName) {
        return new LocalStringOrder(propertyName, false);
    }
}

select Company,
       Customer,
       to_char(date, 'yyyy-mm') as month,
       count(*) - (case
                     when to_char(min(MinDate), 'yyyy-mm') = to_char(date, 'yyyy-mm')
                     then 1
                     else 0
                   end)
  from (select t.*,
               min(date) over (partition by company, customer) as MinDate
          from t) t
  group by Company, Customer, to_char(date, 'yyyy-mm')

declare @weekno int = 27;
select
    (@weekno-1)*7+v.num+
    dateadd(dd,(datediff(dd,0,dateadd(yy,datediff(yy,0,CURRENT_TIMESTAMP),6))/7)*7,0)
from (values(0),(1),(2),(3),(4),(5),(6))v(num)
order by num

-- results
July, 02 2012 00:00:00+0000
July, 03 2012 00:00:00+0000
July, 04 2012 00:00:00+0000
July, 05 2012 00:00:00+0000
July, 06 2012 00:00:00+0000
July, 07 2012 00:00:00+0000
July, 08 2012 00:00:00+0000

(plant_type.plant_type = :P1_PLANT_TYPE or :P1_PLANT_TYPE IS NULL)
and
(plant.plant_name = :P1_PLANT_NAME or :P1_PLANT_NAME IS NULL)
and
(sunlight_conditions.condition_details = :P3_SUNLIGHT or :P3_SUNLIGHT IS NULL)
and
(soil_conditions.soil_condition = :P3_SOIL or :P3_SOIL IS NULL)

SELECT s.studentid, s.name,notes.courseid ,count(1) CNT
FROM student s
INNER JOIN notes ON s.studentid = notes.studentid
WHERE (notes.note) <  "50"
group by s.studentid, s.name, notes.courseid
ORDER BY student.name

UPDATE ItemTax
SET ID = ID + 1
WHERE ID > 37

RTRIM(avg(ProcTime)/3600) + ':'  + RIGHT(('0'+RTRIM(avg(MTD_ProcTime) % 3600 / 60)),2)

SELECT
  TRUNC(CREATE_DTIME) AS DAY,
  COUNT(PLAYER_ID) AS NEW_USERS,
  COUNT(CASE WHEN TRUNC(INIT_DTIME) >= TRUNC(SYSDATE) - 7 THEN PLAYER_ID ELSE NULL END)     AS RETAINED_USERS
FROM PLAYER
WHERE TRUNC(CREATE_DTIME) >= TO_DATE('2012-Jan-01','yyyy-mon-dd')
GROUP BY TRUNC(CREATE_DTIME)
ORDER BY 1

select count(distinct product_id) from pro_category

select o.OrderNo, OrderDate, ol.Amount,(select sum(oll.Amount * oll.UnitPrice) from OrderLine oll where oll.OrderNo = o.OrderNo) as OrderTotal
....

select p.*, tmp.email
  from persons p, (select person_id, email
                     from emails e1
                    where not exists (
                          select 1
                            from emails e2
                           where e1.person_id = e2.person_id
                             and e1.time_sent < e2.time_sent)) tmp
 where p.id = tmp.person_id;

select * from users u
where NOT exists (select 1 from users_classdetails uc
                  where u.id = uc.userID
                    and dateEntered > current_date - interval'3' year)

SELECT 
    X.value('.','int') as 'TextResult'
FROM Answers as 'a'
     CROSS APPLY a.answer.nodes('/DocumentElement/Screening/TextResult') as answers(X)

SELECT Country, Year, Srcname as combinedCol, Value FROM tbl1
UNION ALL
SELECT Country, Year, Progname as combinedCol, Value FROM tbl2

insert into dbo.AccountTypes (AccountTypeId, AccountTypeName)
values (1, 'Partner''s Capital A/c')

SELECT * FROM table WHERE FIND_IN_SET(`name`, `menu`);

Widget
-------
ID (UNIQUE)
Name
Price
WidgetTypeID (FK to WidgetType.ID)

WidgetType
----------
ID (UNIQUE)
Name

vw_Widgets
----------
SELECT w.ID, w.Name, w.Price, w.WidgetTypeID, wt.Name AS TypeName
FROM Widgets w
LEFT JOIN WidgetType wt
   ON wt.ID = w.WidgetTypeID;

Function GetSomeData(ByVal Table2ID As Integer)
    Dim result As New DataTable

    Dim sql As String = "SELECT Column1,Column2 FROM [Table1] WHERE Table2ID= @Table2ID"

    Using cn As New SqlConnection( GetConnectionString() ), _
    Using cmd As New SqlCommand(sql, cn)

        cmd.Parameters.Add("@Table2ID", SqlDbType.Int).Value = Table2ID

        Using rdr As SqlDataReader = cmd.ExecuteReader()
           result.Load(rdr)
        End Using
    End Using
    return result
End Function

$db = new mysqli('host', 'username', 'password', 'database');

$sql = 'LOAD DATA LOCAL...';
$db->query($sql);

$sql = 'UPDATE tempdirtysi SET ...';
$db->query($sql);


$sql = 'INSERT INTO temploadsi SELECT * FROM tempdirtysi';
$db->query($sql);


$sql = 'TRUNCATE  tempdirtysi';
$db->query($sql);

with t as (<your query here with `to_char(eta, 'YYYY-MM-DD') as eta_yyyymmdd` added>)
select (case when seqnum_eta = 1 then eta else '' end) as eta,
       (case when seqnum_vessel = 1 then vessel else '' end) as vessel,
       (case when seqnum_line = 1 then line else '' end) as line,
       pod, sztyp, qty
from (select t.*, 
             row_number() over (partition by eta order by vessel, line, pod, sztp, qty) as seqnum_eta,
             row_number() over (partition by eta, vessel order by line, pod, sztp, qty) as seqnum_vessel,
             row_number() over (partition by eta, vessel, line order by pod, sztp, qty) as seqnum_line
      from t
     ) t
order by eta_yyyymmdd, t.vessel, t.line, t.pod, t.sztp, t.qty

DELIMITER //
CREATE TRIGGER  user_delete BEFORE UPDATE ON users FOR EACH ROW
BEGIN
    IF NEW.user_status <> OLD.user_status
    THEN 
        IF STRCMP('deleted',NEW.user_status) = 0 THEN
            UPDATE question_status SET question_status = 'deleted' WHERE asker_id = NEW.id;
            UPDATE answers SET answer_status = 'deleted' WHERE who_answer_id = NEW.id;
            UPDATE likes SET like_status = 'deleted' WHERE liker_id = NEW.id;
        END IF;
        IF STRCMP('active',NEW.user_status) = 0 THEN
            UPDATE question_status SET question_status = 'active' WHERE asker_id = NEW.id;
            UPDATE answers SET answer_status = 'active' WHERE who_answer_id = NEW.id;
            UPDATE likes SET like_status = 'active' WHERE liker_id = NEW.id;
        END IF;
    END IF;
END//
DELIMITER ;

SELECT skulist, COUNT(skulist)
FROM (SELECT GROUP_CONCAT(DISTINCT sku ORDER BY sku) as skulist
      FROM sales_flat_order_item items
      GROUP BY order_id
     ) skulists
GROUP BY skulist;

select p.id, ps.pid, ps.sid, s.id
from p cross join
     s left join
     ps
     on p.id=ps.pid s and ps.sid=s.id;

 @Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    // If you need to add a column
    if (newVersion > oldVersion) {
        db.execSQL("ALTER TABLE foo ADD COLUMN new_column INTEGER DEFAULT 0");
    }
}

WHERE REGEXP_LIKE(phone, '^1?[2-9]\d{9}$') and not REGEXP_LIKE(phone, '^1?911')

SELECT Dates
FROM 
    (SELECT * from yourtable) p
UNPIVOT
    (Dates FOR Seq IN 
        ([Date1], [Date2], [Date3], [Date4], [Date5], [Date6])
) AS unpvt

  =IIF(Globals!OverallPageNumber = 1,false, true)

SELECT ID, AVG(number) FROM table GROUP BY ID

SELECT * 
FROM (SELECT * FROM articles LIMIT 10) articles
    INNER JOIN categories
        ON articles.category_id = categories.id
    INNER JOIN articleInfo
        ON articles.id = articleInfo.article_id
    INNER JOIN articleWeights
        ON articles.id = articleWeights.article_id
    INNER JOIN articlePictures
        ON articles.id = articlePictures.article_id
WHERE articleInfo.lang = :lang

SELECT  lo4.*
FROM
    (
    SELECT	CASE WHEN ln.log_id IS NULL THEN lo2.log_id ELSE ln.log_id END AS log_id,
    		ROW_NUMBER() OVER (PARTITION BY lo2.fb_id ORDER BY lo2.cdate) AS rn
    FROM	(
    	SELECT
    		lo.*,
    		(
    		SELECT	TOP 1 log_id
    		FROM	t_log li
    		WHERE	li.fb_id = lo.fb_id
    				AND li.cdate >= lo.cdate
    				AND li.log_id <> lo.log_id
    				AND li.log_name <> lo.log_name
    		ORDER BY
    			cdate, log_id
    		) AS next_id
    	FROM t_log lo
    	) lo2
    LEFT OUTER JOIN
    	t_log ln
    ON ln.log_id = lo2.next_id
    ) lo3, t_log lo4
WHERE lo3.rn = 1
    AND lo4.log_id = lo3.log_id

select 'Test Name', 
    case when foo = 'Result' then 1 else 0 end 
    from bar where baz = (some criteria)

SELECT TITLE, COUNT(*) 
FROM PIECE
GROUP BY TITLE 
HAVING COUNT(*) > 1 
MINUS
SELECT TITLE, count(*)
FROM PIECE P2 
JOIN COMPOSER  C2 ON P2.CNO = C2.CNO 
GROUP BY TITLE, C2.CNO
HAVING COUNT(*) > 1

select * 
  from wp_posts p,
       (select min(ID) as id, post_parent
          from wp_posts 
      group by post_parent) mins
  where p.ID = mins.id and mins.post_parent = p.post_parent

With Combined As
  (
    Select 'A' As TableName, Username, Value
    From TableA
    Union All
    Select 'B', Username, Value
    From TableB
    Union All
    Select 'C', Username, Value
    From TableC
    )
Select C.Username, C.Value
From Combined As C
    Join (
          Select C1.Username
          From Combined As C1
          Group By C1.Username
          Having Count(Distinct C1.TableName) = 3
          ) As Z
      On Z.Username = C.Username
Group By C.Username, C.Value

Select id, total 
From TableA 
Where total < 100
Union
Select 0 as id , sum(total) as total
From TableA
Where Total >=100

SELECT just the fields you need
FROM (
    SELECT companies.company_name, sites.id id
    FROM sites
    INNER JOIN company_sites ON company_sites.site_id = sites.id
    INNER JOIN companies ON companies.id = company_sites.company_id
    WHERE sites.active = 1
    AND sites.stage_id = 5
    GROUP BY sites.id
    ORDER BY RAND()
    LIMIT 1
)A
join channels on channels.site_id = id

SELECT item
FROM `mytable`
GROUP BY item
HAVING SUM(tag = 'amaretto') > 0
   AND SUM(tag = 'blueberry ') > 0
   and sum(tag not in ('amaretto','blueberry ')) = 0

;WITH cte
     AS (SELECT custom, Max(fecha) fecha
         FROM   @sales
         GROUP  BY custom, Datepart(yyyy, fecha), Datepart(mm, fecha))
SELECT b.custom, b.fecha, Sum(b.sales) [Sum]
FROM   cte a
       JOIN @sales b
         ON a.custom = b.custom
            AND a.fecha = b.fecha
GROUP  BY b.custom, b.fecha 

update YourTable
    set NewColumn = substring(OldColumn, patindex('%T[0-9][0-9]%', OldColumn) + 1, 2)
    where patindex('%T[0-9][0-9]%', OldColumn) <> 0

INSERT PersonCity (PersonID, CityID)
SELECT  p.PersonID, c.CityID
FROM    OriginalTable o
        INNER JOIN Person p
            ON p.PersonName = o.Personname
        INNER JOIN City c
            ON c.CityName = o.CityName
            AND c.CityState = o.CityState
            AND c.CityCountry = o.CityCountry;

Up to 16 columns can be combined into a single composite index key. All the columns in a composite index key must be in the same table or view. The maximum allowable size of the combined index values is 900 bytes.

Columns that are of the large object (LOB) data types ntext, text, varchar(max), nvarchar(max), varbinary(max), xml, or image cannot be specified as key columns for an index.

SELECT amount FROM mytable1 WHERE @var = 1
UNION
SELECT amount FROM mytable2 WHERE @var = 0

select p.product_id,
       p.product_id,
       p.product_code,
       p.product_name,
       SUM(io.quantity) as physical_quantity,
       SUM(case when in_out=1 then io.quantity else 0 END) - 
       SUM(case when in_out=0 then io.quantity else 0 END) AS Difference
from products as p 
Join in_out_products as io 
on p.product_id=io.product_id 
Where io.deleted_at is null 
and in_out=1 
group by p.product_id;

select * from Foo where firstname = 'xyz' and
    (@Active = 0 or Active = <filter condition>)

SELECT al.*
FROM album al
WHERE EXISTS (SELECT 1 FROM artist al WHERE a.artist_id = al.artist_id)

SELECT p.PurchActvtyID, a1.name AS billName, a1.address1 AS billAddress1, a2.name AS shipName, a2.address1 AS shipAddress1
FROM arrc_PurchaseActivity p
LEFT OUTER JOIN jos_customers_addresses a1 ON p.AcctID = a1.customer_id
LEFT OUTER JOIN jos_customers_addresses a2 ON p.ShipAddrID = a2.id
GROUP BY p.PurchActvtyID
ORDER BY p.PurchActvtyID ASC

Select * from crosstab1
inner join crosstab2 on crosstab1.lngVehicleID=crosstab1.lngVehicleID
order by crosstab1.lngVehicleID

SELECT
  homepage_queue.photo
FROM
  homepage_queue
INNER JOIN
  photos
    ON photos.id = homepage_queue.photo
LEFT JOIN
  (SELECT photographer, COUNT(*) AS occurances FROM last_five GROUP BY photographer) AS last_five
    ON last_five.photographer = photos.photographer
ORDER BY
  last_five.occurances ASC,
  homepage_queue.queued_time
LIMIT
  1

insert into goodTable 
select
bt.id,
(select bt1.value from badTable bt1 where bt1.info = 'firstname' and bt1.id = bt.id),
(select bt1.value from badTable bt1 where bt1.info = 'lastname' and bt1.id = bt.id),
(select bt1.value from badTable bt1 where bt1.info = 'phone' and bt1.id = bt.id)
from
 badTable bt
group by id ;

update sometable set x=1 where y =2; update sometable set x = 5 where y = 6; etc...

SQL> CREATE OR REPLACE TYPE t_strarray IS TABLE OF VARCHAR2(30);
  2  /
Type created.

SQL> CREATE TABLE mytable (field1 VARCHAR2(30));
Table created.

SQL> INSERT INTO mytable VALUES ('A');
1 row created.

SQL> INSERT INTO mytable VALUES ('D');
1 row created.

SQL> CREATE OR REPLACE PROCEDURE getstuff(p_list IN t_strarray,
  2                                       io_cursor OUT SYS_REFCURSOR) IS
  3  BEGIN
  4     OPEN io_cursor FOR
  5        SELECT *
  6          FROM mytable
  7         WHERE mytable.field1 IN (SELECT COLUMN_VALUE FROM TABLE(p_list));
  8  END;
  9  /
Procedure created.

SQL> VARIABLE cc REFCURSOR;
SQL> EXEC getstuff (t_strarray('A', 'B', 'C'), :cc);    
PL/SQL procedure successfully completed.

SQL> print cc

FIELD1
------------------------------
A

SELECT
   P.ProductID,
   CASE WHEN COUNT(R.FirstProductID) > 0
        THEN 'Linked'
        ELSE 'Not Linked'
   END Relation
FROM Product P
   LEFT JOIN ProductRelation R
      ON P.ProductID = R.FirstProductID
        OR P.ProductID = R.SecondProductID
GROUP BY P.ProductID

/^\%(.*\<\%(<C-r>=join(readfile('database.txt'),'\|')<CR>\)\>\)\@!.*$<CR>

SELECT cid,fname,iname, userid, qid, category, `desc` 
 FROM table1 inner join table2 on table1.cid = table2.ckid order by fname

DECLARE @tbl TABLE(data VARCHAR(MAX))
INSERT INTO @tbl VALUES
    ('<FirstNode>Something</><SecondNode>Something Else</>'),
    ('<SecondNode>Something Else</><FirstNode>More Something</>'),
    ('<BadNoe>Something</><SecondNode>Something Else</>')

DECLARE @fnd VARCHAR(64)
DECLARE @end VARCHAR(64)
SET @fnd = '<FirstNode>'
SET @end = '</>'

SELECT SUBSTRING(a.[data], a.[start] + LEN(@fnd), a.[end] - (a.[start] + LEN(@fnd)))
FROM (SELECT data [data], CHARINDEX(@fnd, data, 0) [start], CHARINDEX(@end, data, CHARINDEX(@fnd, data, 0)) [end] FROM @tbl) a
WHERE a.[start] > 0

SELECT color, SUM(price*discount) as total_discount
FROM 
    orderitem o
INNER JOIN
    (SELECT order_ID, final_price / base_price as discount
    FROM orders) d
ON o.order_ID = d.order_ID
GROUP BY color;

SELECT  *
FROM    table FORCE INDEX (myindex)

SELECT u_joinee.fb_id joinee_fb_id ,u_referer.fb_id referer_fb_id, u_joinee.name joinee_name, u_referer.name referer_name
FROM users AS u_joinee
LEFT JOIN referral AS r ON r.joinee = u_joinee.fb_id
LEFT JOIN users AS u_referer ON r.referred_by = u_referer.fb_id

SELECT UNIX_TIMESTAMP()

Select Coalesce(People.name, Companies.name) As Name
    , Referrers.name
    , Min(Case When EventKinds.name = 'Phoned' Then Events.created_at End) As Phoned
    , Min(Case When EventKinds.name = 'Promised' Then Events.created_at End) As Promised
    , Min(Case When EventKinds.name = 'Donated' Then Events.created_at End) As Donated
From Events
    Join EventKinds
        On EventKinds.id = Events.event_kind_id
    Left Join People As Referrers
        On Referrers.id = Events.referrer_id
    Left Join People
        On People.id = Events.person_id
    Left Join Companies
        On Companies.id = Events.company_id
-- Where Companies.Name Like 'foo%'
Group By Coalesce(People.name, Companies.name), Referrers.name

select * from yourtable a
inner join (
    select sid 
    from yourtable
    where email = "john.smith@gmail.com"
) b on b.sid = a.sid

select *
from t
where CompanyId = 333 or CompanyName = 'Name1'
order by (case when companyId = 333 and CompanyName = 'Name1' then 1
               else 0
          end) desc

SELECT computer, user, count(*) AS count
FROM login
GROUP BY computer, user

SELECT *
FROM (
        Select  I.InterfaceName                 as IName
               ,CS.ConnectionStringDescription  as Descr
               ,CS.ConnectionStringValue        as Value
        from ConnectionStrings CS
        JOIN InterfaceConnectionStrings ICS
        on CS.ConnectionStringDescription = ICS.ConnectionStringDescription
        JOIN Interfaces I
        on ICS.InterfaceName = I.InterfaceName
        where InterfaceName = @InterfaceName
     ) t
PIVOT (MAX(Value)
       FOR Descr
       IN ([CSDescr1],[CSDescr2],[CSDescr3])
      )p

SELECT * FROM Items WHERE Name in ('MyProduct', 'My Stuff', 'Super Product')

 SELECT * from
 (
 select m.*, rownum r
 from maps006 m
 )
 where r > 49 and r < 101

drop type &tablespaceName..my_user_tab;

DELETE FROM project.cart WHERE isbn = ? and ROWNUM=1;

select a, sum(b)
from (
    select a, b
    from c
    order by a 
    ) d
group by a

SELECT m.id, away.name, home.name
FROM match m
INNER JOIN team away ON away.id = m.awayteam_id
INNER JOIN team home ON home.id = m.hometeam_id

C:\Program Files\Microsoft SQL Server\MSSQL\Reporting Services\Samples\Applications\ReportViewer 

using System;
using System.Runtime.InteropServices;


namespace MyCompany.MyTechnology.Framework.CrossDomain.GuidExtend
{
    public static class Guid
    {

        /*

        Original Reference for Code:
        http://www.pinvoke.net/default.aspx/rpcrt4/UuidCreateSequential.html

        */


        [DllImport("rpcrt4.dll", SetLastError = true)]
        static extern int UuidCreateSequential(out System.Guid guid);

        public static System.Guid NewGuid()
        {
            return CreateSequentialUuid();
        }


        public static System.Guid CreateSequentialUuid()
        {
            const int RPC_S_OK = 0;
            System.Guid g;
            int hr = UuidCreateSequential(out g);
            if (hr != RPC_S_OK)
                throw new ApplicationException("UuidCreateSequential failed: " + hr);
            return g;
        }


        /*

        Text From URL above:

        UuidCreateSequential (rpcrt4)

        Type a page name and press Enter. You'll jump to the page if it exists, or you can create it if it doesn't.
        To create a page in a module other than rpcrt4, prefix the name with the module name and a period.
        . Summary
        Creates a new UUID 
        C# Signature:
        [DllImport("rpcrt4.dll", SetLastError=true)]
        static extern int UuidCreateSequential(out Guid guid);


        VB Signature:
        Declare Function UuidCreateSequential Lib "rpcrt4.dll" (ByRef id As Guid) As Integer


        User-Defined Types:
        None.

        Notes:
        Microsoft changed the UuidCreate function so it no longer uses the machine's MAC address as part of the UUID. Since CoCreateGuid calls UuidCreate to get its GUID, its output also changed. If you still like the GUIDs to be generated in sequential order (helpful for keeping a related group of GUIDs together in the system registry), you can use the UuidCreateSequential function.

        CoCreateGuid generates random-looking GUIDs like these:

        92E60A8A-2A99-4F53-9A71-AC69BD7E4D75
        BB88FD63-DAC2-4B15-8ADF-1D502E64B92F
        28F8800C-C804-4F0F-B6F1-24BFC4D4EE80
        EBD133A6-6CF3-4ADA-B723-A8177B70D268
        B10A35C0-F012-4EC1-9D24-3CC91D2B7122



        UuidCreateSequential generates sequential GUIDs like these:

        19F287B4-8830-11D9-8BFC-000CF1ADC5B7
        19F287B5-8830-11D9-8BFC-000CF1ADC5B7
        19F287B6-8830-11D9-8BFC-000CF1ADC5B7
        19F287B7-8830-11D9-8BFC-000CF1ADC5B7
        19F287B8-8830-11D9-8BFC-000CF1ADC5B7



        Here is a summary of the differences in the output of UuidCreateSequential:

        The last six bytes reveal your MAC address 
        Several GUIDs generated in a row are sequential 
        Tips & Tricks:
        Please add some!

        Sample Code in C#:
        static Guid UuidCreateSequential()
        {
           const int RPC_S_OK = 0;
           Guid g;
           int hr = UuidCreateSequential(out g);
           if (hr != RPC_S_OK)
             throw new ApplicationException
               ("UuidCreateSequential failed: " + hr);
           return g;
        }



        Sample Code in VB:
        Sub Main()
           Dim myId As Guid
           Dim code As Integer
           code = UuidCreateSequential(myId)
           If code <> 0 Then
             Console.WriteLine("UuidCreateSequential failed: {0}", code)
           Else
             Console.WriteLine(myId)
           End If
        End Sub




        */








    }
}

with to_update as (
     select itemNumber, QtyOnHand, TransBal
     from t
)
update tb_table
    set offset = TransBal - QtyOnHand
    from to_update
    where to_udpate.itemNumber = tb_table.itemNumber

select sum(case when trancode = 'sales' then -prodqty else prodqty end)
from stock
where barcode = ?

SELECT t.col1,
      (SELECT s.another_col1 FROM Table1 s WHERE s.date = t.col1) as some_col
FROM table1 t
ORDER BY t.id

 WHERE ((CASE WHEN installment IS NOT NULL THEN (amount-installment) 
               ELSE(amount) END)> 0 )

DELETE FROM mytablet1
WHERE t1.field > 0
   -- don't need this self-join if {field,field2}
   -- are a candidate key for mytable
   -- (in that case, the exists-subquery would detect _exactly_ the
   -- same tuples as the ones to be deleted, which always succeeds)
-- AND EXISTS (
--     SELECT *
--     FROM mytable t2 
--     WHERE t1.field = t2.field
--     AND t1.field2  = t2.field2
--    )
    ;

WITH enrollment AS (
SELECT c_id, c_title, c_enrolcap,
(SELECT COUNT(e_id) AS enrol FROM enrollments WHERE e_c_id = c_id) AS enrolled

FROM classes AS c)
SELECT c_id, c_title, c_enrolcap, enrolled, c_enrolcap - enrolled AS avail
FROM enrollment

if current_user is not in blocked_user_table
then
    insert in table b
end

SELECT t1.*
FROM Table t1
JOIN (SELECT EntryID, MAX(version) maxversion
      FROM Table
      WHERE EntryID IN (212, 451)
      GROUP BY EntryID) t2
ON t1.EntryID = t2.EntryID AND t1.version = t2.maxversion

WITH    t1 AS 
( SELECT DISTINCT
            VehicleSpecs.SubmittedById ,
            COUNT(VehicleSpecs.SubmittedById) AS NumCars ,
            aspnet_Users.UserName
   FROM     VehicleSpecs
            INNER JOIN aspnet_Users ON VehicleSpecs.SubmittedById = aspnet_Users.UserId
   WHERE    ( LEN(VehicleSpecs.SubmittedById) > 0 )
   GROUP BY VehicleSpecs.SubmittedById ,
            aspnet_Users.UserName
)
SELECT  ROW_NUMBER() OVER ( ORDER BY NumCars ), *
FROM    t1
ORDER BY NumCars

SELECT person, category, amount
FROM (
  SELECT person, category, amount,
         @rn := IF(@cat = category, @rn+1,
                   IF(@cat := category, 1, 1)) AS rn
  FROM mytable
  CROSS JOIN (SELECT @rn := 0, @cat := '') AS vars
  ORDER BY category, amount DESC) AS t
WHERE t.rn <= 10

delimiter @
create trigger FreeRooms1
after update on incidents
for each row
begin
 if (old.export_day IS NULL and new.export_day IS NOT NULL)
 then
   update sections
   set free_rooms = free_rooms + 1   
   where sections.section_code = NEW.section_code;
 end if;
end;
@

select p.id,
       p.name,
       ifnull(d.name, 'Unknown') DepName,
       ifnull(m.workInfo, 'Unknown') workInfo
  from personel p
       left outer join match_dept_per m
           on p.id = m.pers_id
       left outer join department d
           on d.id = m.dept_id

select name,thedate,theaction,prev_action,prev_date from 
 (
 select name,thedate,theaction,
 lag(theaction) over (partition by name order by thedate,theaction) as prev_action,
lag(thedate) over (partition by name order by thedate,theaction) as prev_date
from table1 
order by name,thedate,theaction
)
where theaction = 'action1' and prev_action = 'action2'
;

coalesce( SUM( IF( userId = '123456', amount, 0 ) ),0 )

declare @d nvarchar(256) = '12-MAR-15 04.07.36.000000000 PM'

SELECT CONVERT(DATETIME, 
        STUFF(
         REPLACE(REPLACE(
          STUFF(@d, 23, 7, ''), '-',' '),'.',':'), 8,0,'20')  )

select * from user_tablespaces;

Dim i, j As Integer

Dim xlApp As Excel.Application
Dim xlWorkBook As Excel.Workbook
Dim xlWorkSheet As Excel.Worksheet
Dim misValue As Object = System.Reflection.Missing.Value

xlApp = New Excel.Application
xlWorkBook = xlApp.Workbooks.Add(misValue)
xlWorkSheet = xlWorkBook.Sheets("sheet1")
Dim innerCount = 0

For i = 0 To table1.Rows.Count - 1
    For j = 0 To table1.Columns.Count - 1
        xlWorkSheet.Cells(i + innerCount + 2, j + 1) = table2.Rows(i).Item(j)

    Next
    Dim productsForBrand = innertabledata.[Select]("brandID=" & table1.Rows(i).Item("ID")).CopyToDataTable()
    If productsForBrand .Rows.Count > 0 Then
        For k = 0 To productsForBrand .Rows.Count - 1
            For l = 0 To productsForBrand .Columns.Count - 1
                xlWorkSheet.Cells(i + k + innerCount + 3, l + 1) = productsForBrand .Rows(k).Item(l)
            Next
        Next

    End If

    innerCount = innerCount + productsForBrand .Rows.Count
Next

xlWorkSheet.SaveAs("D:\vbexcel.xlsx")
xlWorkBook.Close()
xlApp.Quit()

SELECT 
    M.* 
    ,R.*
FROM (
    SELECT P1.*
    FROM Plans P1
    WHERE id_vendor = @id_vendor
) P

INNER JOIN Plans_Restrictions PR
ON P.plan_id = PR.plan_id

INNER JOIN Restrictions R
ON PR.property = R.property

INNER JOIN Model_Restrictions MR
ON R.property = MR.property

INNER JOIN Model M
ON MR.model_id = M.model_id

SELECT c.DepartmentId, c.Name, c.Hired from Customer c,
(SELECT DepartmentId, MAX(Hired) as MaxHired
  FROM Customer
 GROUP BY DepartmentId) as sub
WHERE c.DepartmentId = sub.DepartmentId AND c.Hired = sub.MaxHired

WITH CTE AS(
    SELECT *,
        RN = DATEADD(DAY, - ROW_NUMBER() OVER(PARTITION BY Car_reg, External_Damages ORDER BY [Date]), [Date])
    FROM #stable_periods
)
SELECT
    Car_Reg,
    FromDate = MIN([Date]),
    ToDate = MAX([Date]) ,
    External_Damages,
    Change =
            CASE 
                WHEN MAX(External_Damages) IS NULL THEN NULL
                WHEN COUNT(DISTINCT Internal_Damages) > 1 THEN 'Yes' 
                ELSE 'No' 
            END     
FROM CTE c
GROUP BY Car_Reg, External_Damages, RN
ORDER BY Car_Reg, ToDate DESC

begin tran

declare @sum int

select @sum = sum(DisplaySeq)
from CustomCatalogForm
where CustomCatalogFormId in (1,2)

update CustomCatalogForm
set DisplaySeq = @sum - DisplaySeq
where CustomCatalogFormId in (1,2)

commit tran

CREATE TABLE stats
(
    id int,          -- same id as used in the norms table
    sten int,
    percentile int,
    t-score int
);

ALTER TABLE [Companies]  WITH CHECK ADD  CONSTRAINT [FK_ParentCompanu] FOREIGN KEY([Parent_Company])
REFERENCES [Companies] ([ID_Company])

SELECT DISTINCT a.Code, a.Description,  a.Quantity, 'Table_321' as tableName FROM Table_321 AS a
                        WHERE NOT EXISTS (SELECT * FROM Components where Components.Code = a.Code)
                        UNION ALL
SELECT DISTINCT a.Code, a.Description, a.Quantity, 'Table_333' as tableName FROM Table_333 AS a
                        WHERE NOT EXISTS (SELECT * FROM Components where Components.Code = a.Code)
                        UNION ALL
                        .............
                        .............
                        order by Code

SELECT G.id, G.name
FROM Galaxy G LEFT OUTER JOIN
     SolarSystem SS
     ON G.id = SS.id_galaxy LEFT OUTER JOIN
     Planet P
     ON SS.id = P.id_solar_system
group by g_id, g.name
having max(P.id) IS NULL

select 1 as hrs, 4 as end , name, 1 as class from theTable WHERE class=3
UNION
select 4  as hrs, 8 as end, name, 2 as class from theTable WHERE class=3

SQL> create table foo( col1 number );

Table created.

SQL> create table make_application_slow(
  2    dummy varchar2(1)
  3  );

Table created.

SQL> insert into make_application_slow values( 'A' );

1 row created.

SQL> ed
Wrote file afiedt.buf

  1  create or replace trigger trg_foo_before_stmt
  2    before insert on foo
  3  declare
  4    l_dummy varchar2(1);
  5  begin
  6    -- Ensure that only one session can ever be inserting data
  7    -- at any time.  This is a great way to turn a beefy multi-core
  8    -- server into a highly overloaded server with one effective
  9    -- core.
 10    select dummy
 11      into l_dummy
 12      from make_application_slow
 13       for update;
 14* end;
SQL> /

Trigger created.

SQL> create or replace trigger trg_foo_after_stmt
  2    after insert on foo
  3  declare
  4    l_cnt pls_integer;
  5  begin
  6    select count(*)
  7      into l_cnt
  8      from( select col1, count(*)
  9              from foo
 10             group by col1
 11            having count(*) > 1 );
 12
 13    if( l_cnt > 0 )
 14    then
 15      raise_application_error( -20001, 'Duplicate data in foo is not allowed.' );
 16    end if;
 17  end;
 18  /

select T2.ID AS T2ID
,T2.Name as T2Name
,T2.Orders
,T1.ID AS T1ID
,T1.Name As T1Name
,T1Sum.Price
FROM @t2 T2
INNER JOIN (
    SELECT Rel.t2ID
        ,Rel.t1ID
 --       ,MAX(Rel.t1ID)AS t1ID 
-- the MAX returns an arbitrary ID, what i need is: 
      ,ROW_NUMBER()OVER(Partition By Rel.t2ID Order By Price DESC)As PriceList
        ,SUM(Price)OVER(PARTITION BY Rel.t2ID) AS Price
        FROM @t1 T1 
        INNER JOIN @relation Rel ON Rel.t1ID=T1.ID
--        GROUP BY Rel.t2ID
)AS T1Sum ON  T1Sum.t2ID = T2.ID
INNER JOIN @t1 T1 ON T1Sum.t1ID=T1.ID
where t1Sum.PriceList = 1

select
  so.name,
  sc.text
from
  sysobjects so inner join syscomments sc on so.id = sc.id
where
  sc.text like '%INSERT INTO xyz%'
  or sc.text like '%UPDATE xyz%'

select  (((datepart(HOUR,getdate())-6)*2)-1)+
         case when datepart(MI,getdate())>30 then 1 
              else 0 end [timeSlot_number]

SQL> select a
  2       , b
  3       , c
  4    from dual
  5   model
  6         dimension by (0 i)
  7         measures (0 a, 0 b, 0 c)
  8         rules iterate (5)
  9         ( a[iteration_number] = nvl(c[iteration_number-1],1)
 10         , b[iteration_number] = ceil(dbms_random.value(0,10))
 11         , c[iteration_number] = a[iteration_number] + b[iteration_number]
 12         )
 13   order by i
 14  /

         A          B          C
---------- ---------- ----------
         1          4          5
         5          8         13
        13          8         21
        21          2         23
        23         10         33

5 rows selected.

from django.db import models

class Food(models.Model):
    name = models.CharField(max_length=30)

    def __str__(self):
        return self.name

class Recipe(models.Model):
    title = models.CharField(max_length=100)
    description = models.TextField()
    ingredients = models.ManyToManyField(Food)

    def __str__(self):
        return self.title

CREATE OR REPLACE PROCEDURE read_and_increment (number_just_read OUT NUMBER)
IS
BEGIN
   DECLARE
      stored_number   NUMBER DEFAULT NULL;
   BEGIN
      SELECT number
        INTO stored_number
        FROM _numbers
       WHERE ROWNUM = 1;

      number_just_read := stored_number;

      UPDATE _numbers
         SET number = number + 1;

      COMMIT;
   END;
END read_and_increment;

SELECT username
FROM users
WHERE ST_Distance(currentlocation, $1) = 20; -- careful with units

    string[] statuses = new string[] { "Parts Arr", "NA", "New Call", "Parts Ord", "Parts Req", "F Work" };
    var x = (from ro in db.tbl_repair_order
             where ro.contract == "con"
                && statuses.Contains(ro.status)
             group 0 by ro.status into grouping
             select new { Status = grouping.Key, Count = grouping.Count() });

select  sys_context('USERENV','OS_USER')  from dual

SELECT TOP 1 Id, Description
FROM Record
ORDER BY CREATED DESC

create procedure ExistingProc(output1 out number) is
begin
  insert into someTable values ('some values')
  RETURNING someCol INTO output1;
end;

create procedure MyProc(args ....) is
  Result1 number;  --output from existingProc
begin
  ExistingProc(result1);
  -- Use Result1 as needed
  Update stuff ...
  where id = Resutl1;
  commit;
end;

SELECT
  *
FROM
  car_prices
INNER JOIN
(
  SELECT
    make, model, year, MAX(created_at) as created_at
  FROM
    car_prices
  GROUP BY
    make, model, year
)
  AS most_recent
    ON  car_prices.make       = most_recent.make
    AND car_prices.model      = most_recent.model
    AND car_prices.year       = most_recent.year
    AND car_prices.created_at = most_recent.created_at
WHERE
      most_recent.make  = 'honda'
  AND most_recent.model = 'accord'

  SELECT a.prjid,
         wm_concat(b.userid) AS userids
    FROM TABLE_1 a
    JOIN TABLE_2 b ON b.prjid = a.prjid
GROUP BY a.prjid

SELECT O.name, GROUP_CONCAT(SO.name) subOptionName
FROM Options O 
LEFT JOIN SubOptions SO ON O.id = SO.option_id 
GROUP BY O.name;

SELECT 
    VAD.*
FROM 
VitalAlarmDetails VAD JOIN
        VitalPatientDetails VPD ON VAD.PatientDetailsId  = VPD.PatientDetailsId 

select entity.*
     , count(*) as relevance 
  from entities
     , tags
     , entity_tags
 where entities.id=entity_tags.entity_id 
   and tags.id=entity_tags.tag_id
   and tags.name in ('fruit', 'organic', 'item')
group by entity.id  having count(entities.id) > 1
order by relevance

SELECT date
   , SUM(CASE status WHEN 'Active'     THEN cnt ELSE 0 END) AS a
   , SUM(CASE status WHEN 'Processing' THEN cnt ELSE 0 END) AS p
   , SUM(CASE status WHEN 'Closed'     THEN cnt ELSE 0 END) AS c
FROM 
  ( SELECT date, status, COUNT(DISTINCT name) AS cnt
    FROM accounts
    GROUP BY date, status
  ) grp
GROUP BY date
ORDER BY date

SELECT c.id AS cid
    ,customer_group_id AS cgid
    ,c.NAME
    ,.......
FROM customer c
JOIN customer_group cg
    ON c.group_id = cg.id

SELECT Customers.* 
FROM Customers C 
INNER JOIN 
(
    SELECT ZIPCODE,( 3959 * ACOS( COS( RADIANS( $la ) ) * COS( RADIANS( LAT ) ) * COS( RADIANS( LNG ) - RADIANS( $lo ) ) + SIN( RADIANS( $la ) ) * SIN( RADIANS( LAT ) ) ) ) AS distance 
    FROM ZipCodes 
    HAVING distance <$rad 
    ORDER BY distance LIMIT 0 , 20
) as RelevantCodes 
  ON (C.ZipCode=RelevantCodes.ZipCode)

SELECT 
        a.FullName
FROM
        Employee a
WHERE
        a.FullName LIKE CONCAT('%', a.Name, '%')

Select
    Test_Name As 'Test Case Name',
    Table_Bird.Animal AS 'Birds',
    Table_Mammal.Animal AS 'Mammal',
    Table_Reptile.Animal AS 'Reptile,
    Table_Fish.Animal AS 'Fish'
From Table_One
LEFT JOIN TABLE_Two AS Table_Bird ON Table_One.TestID = Table_Bird.TestID AND Table_Bird.Type LIKE 'Birds'
LEFT JOIN TABLE_Two AS Table_Mammal ON Table_One.TestID = Table_Mammal.TestID AND Table_Mammal.Type LIKE 'Mammals'
LEFT JOIN TABLE_Two AS Table_Reptile ON Table_One.TestID = Table_Reptile.TestID AND Table_Reptile.Type LIKE 'Reptiles'
LEFT JOIN TABLE_Two AS Table_Fish ON Table_One.TestID = Table_Fish.TestID AND Table_Fish.Type LIKE 'Fish' 

select  distinct
    person.SERVICE_NO as Service_No, 
    person.CNIC_NO as CNIC, person.NAME as NAME , 
    card.CPLC_SERIAL_NO as Card_Number,
    child_dc.NAME as Child_DC, 
    root_dc.NAME as Root_DC, person.OU as OU, 
    person.EMAIL as Email
from

     person_card inner join person
     on person_card.PERSON_ID = person.ID
     inner join card
     on person_card.CARD_ID = card.ID
        left outer join child_dc 
     on person.CHILD_DC_ID = child_dc.ID
        left outer join root_dc
    on child_dc.ID = root_dc.ID;

SELECT * 
FROM (tableA A INNER JOIN tableB B ON A.cust_id=B.cust_id)

INNER JOIN  tableE E ON E.product_id=A.prod_id
INNER JOIN (tableC C INNER JOIN tabldeD D ON D.country_id)
ON D.country_code = E.country_code1
WHERE A.statusCode IN(1,2,3)

CREATE VIEW CostCategoriesSum
AS
SELECT  CostCategories.ID,
        CostCategories.Name,
        SUM(COALESCE(Costs.PlanValue, 0)) AS Planned,
        SUM(COALESCE(Costs.DoneValue, 0)) AS Done
FROM    CostCategories
        LEFT JOIN Costs
            ON Costs.ID_CostCategory = CostCategories.ID
GROUP BY CostCategories.ID, CostCategories.Name;

SELECT * FROM Products t1

LEFT JOIN myBridgeTable t2
ON t1.ProductID = t2.ProductID

LEFT JOIN Shops t3
ON t2.ShopID = t3.ShopID

select *
from tblPhone
where 
substring(replace(PhoneNo,'+',''),1,len(replace(PhoneNo,'+',''))-1) 
= substring(replace(PhoneNo,'+',''),2,len(replace(PhoneNo,'+','')))

select [month], sum([load]) as GrandTotal,
       sum( case when [onpeak] =0 then [load] end) as OnPeakTotalLoad,
       sum( case when [onpeak] =1 then [load] end) as OffPeakTotalLoad,
       max( case when [onpeak] =0 then [load] end) as OnPeakMaxLoad,
       max( case when [onpeak] =1 then [load] end) as OffPeakMaxLoad
from ReadingMonthPeak
group by [month]
order by [month]

SELECT tablesite.name,
        tablesite.family,
        tablesite.phone_number,
        COUNT(action.service_provider_id)
        FROM tablesite
        LEFT JOIN action
        ON tablesite.id_user=action.service_provider_id and action.vote !='' AND action.customer_comment =''
        GROUP BY name, family, phone_number

ListView1.SelectedItems(0)

SELECT
    m.medianame,
    COUNT(as.advId) as Total
FROM    a_mediatype as m
INNER JOIN a_advertise as a ON a.mediaTypeId = m.mediaTypeId
INNER JOIN  a_ad_display as ad ON ad.advId = a.advertiseId
GROUP BY m.mediaTypeId

select * from ( 
  select top 500 * from (
    select top 1000 * FROM Records WHERE EntityType='Business' ORDER BY ID DESC 
  ) x
  order by id 
) y 
order by id desc 

UPDATE TBL$TEMPLATE_PARAM
SET    NAME='new_name'
WHERE  NAME='old_name' AND 
       FIXED_VALUE='some_value' AND
       TBL$TEMPLATE_PARAM.TEMPLATE_ID IN (SELECT ID
                                          FROM   TBL$TEMPLATE
                                          WHERE  BEAN_NAME='bean')

psql -qAt ....

update personnel
set personnel_number = 'xyz'
where person_id = 1001
and not exists (select * from personnel where personnel_number = 'xyz');

select g.GroupID,
       g.GroupTitle,
       m.MemberID,
       m.MemberName,
       case when mg.MembersGroupID is null then 'No' else 'Yes' end as IsPartOfGroup
from GROUPS g
cross join MEMBERS m
left join MEMBER_GROUPS mg on g.GroupID = mg.GroupID and m.MemberID = mg.MemberID

Data Source=Scott-PC;Initial Catalog=DatabseName;User Id=Scott;Password=password;

SELECT User, Topic, Date 
FROM   Comments c1
where not exists (select 1 from Comments c2
                  where c2.topic = c1.topic
                    and c2.date > c1.date)
order by date desc

session.SaveOrUpdate(parent);
session.Flush();
// (...)
query.ExecuteUpdate();

Player -> contains player specific items such as size, right-handed, age, etc
PlayerStats-> contains player id, year (of current season), and aggregated stats... you could +1 to this table for scores and penalties for example

Teams -> contains player id, and venue id, team name
Venue -> Items about the arena such as location, average indoor temperature, etc
Games -> contains a home team id (id from teams table) and away team (id from teams table), venue_id, home_box_score, and away_box_score, game_date
PlayerGames -> contains player id, game id, and the game specific goals... For example any player that was in the game goes in here. If some one scores you +1 their score in this table AND the PlayerStats

SELECT `type`, SUM(price) AS total 
FROM table   
GROUP BY `type`
HAVING COUNT(CASE WHEN `limit` = 0 THEN 1 END) = 0

 SELECT childId,parentId FROM
(SELECT
     @row_number1:=@row_number1+1 AS RowNumber1,
     childId
FROM Child, (SELECT @row_number1:=0)AS x ORDER BY childId) AS A
INNER JOIN
(SELECT
     @row_number2:=@row_number2+1 AS RowNumber2,
     parentId
FROM Parent, (SELECT @row_number2:=0)AS y ORDER BY parentId) AS B
ON A.RowNumber1=B.RowNumber2

SELECT
    sub.F_Name AS A,
    sub.Project_Name AS B,
    sub.C,
    sub.D,
    ((sub.C / sub.D) * 100) AS E
FROM
    (
        SELECT
            Emp.F_Name,
            Proj.Project_Name,
            Count(att.Act_ID) AS C,
            Sum(IIf(att.Status IN ('New', 'InProcess'), 1, 0)) AS D
        FROM
            (ATT_Table AS att
            INNER JOIN Employee_Table AS Emp
            ON Emp.Emp_ID = att.Assigned_To_ID)
            INNER JOIN Project_Table AS Proj
            ON Proj.Project_ID = att.Project_ID 
        GROUP BY
            Emp.F_Name,
            Proj.Project_Name
    ) AS sub;

SELECT 1 FROM DUAL WHERE 'A' = 'a';

WITH CTE AS(
    SELECT 
        a.ID, 
        a.Name, 
        b.Value,
        Rn = ROW_NUMBER() OVER(PARTITION BY a.ID ORDER BY (SELECT NULL))
    FROM Table1 a 
    LEFT JOIN Table2 b 
        ON a.ID = b.Table1_ID
)
SELECT
    ID  = CASE WHEN Rn = 1 THEN CONVERT(VARCHAR(10), a.ID) ELSE '' END),
    Name = CASE WHEN Rn = 1 THEN Name ELSE '' END),
    Value
FROM CTE

SELECT * /*But list columns explicitly*/
FROM   Orange o
       CROSS APPLY (SELECT TOP 1 *
                    FROM   Blue b
                    WHERE  b.datecreate >= '20110901'
                           AND b.datecreate < '20111001'
                           AND o.RecordID = b.Record_ID2
                    ORDER  BY b.datecreate  DESC) b 

SELECT *
    FROM @Temp
    ORDER BY CASE WHEN LastName IS NULL THEN 1 ELSE 0 END, LastName

dbms_datapump.METADATA_FILTER(
  handle = your_handle_here,
  name = 'EXCLUDE_PATH_LIST',
  value = 'STATISTICS'
);

SELECT  TOP 10
        a.Event as 'First Event', 
        b.event as 'Second Event',
        ABS(CAST((a.timefield - b.timefield) as INT)) as 'Time Apart'
FROM MYtable a
INNER JOIN Mytable B
    ON a.IDField <> b.IDField
WHERE (ABS(CAST((a.timefield - b.timefield) as INT)) <= 5

insert into table1(a,b) 
select a1,b1 from table2
UNION ALL
select a2,b2 from table2;

 BACKUP DATABASE mydbname TO disk = 'd:\bak'

SELECT ... FROM Table1
INNER JOIN (SELECT MemberId, SUM(Amount2) FROM Table2 GROUP BY MemberId) Agg
ON Table1.MemberId = Agg.MemberId

insert into table2 (transno, Emp_code, PanNo, panid, panext, entdt_pan, 
                    banknm, cancel_checqe, chqExt, entDt_bnk, Acc_No, 
                    IFSC, Cheque_nm, status_pan1, status_pan, 
                    status_bnk1, status_bnk, userid, entdt, panModify_by, 
                    panModify_on, bnkModify_by, bnkModify_on) 
    select 
        transno, Emp_code, PanNo, @imagepan, panext, entdt_pan, 
        banknm, @imagecheque, chqExt, entDt_bnk, Acc_No, 
        IFSC, Cheque_nm, status_pan1, status_pan, 
        status_bnk1, status_bnk, userid, entdt, panModify_by, 
        panModify_on, bnkModify_by, bnkModify_on 
    from 
        table1 
    where 
        Emp_code = 'E001';

select c.*, o.LastOrderDate
from customers c
LEFT JOIN
(select customers_id, max(purchase_date) as LastOrderDate
from orders
group by customers_id) o on o.customers_id=c.customers_id

SELECT
    c.*, COUNT(u.cid) AS count
FROM
    cars c
LEFT JOIN 
    uploads u
ON
    u.cid=c.customer
WHERE
    u.customer = 11;
GROUP BY c.cid

SET @sql = NULL;
SELECT
  GROUP_CONCAT(DISTINCT
    CONCAT(
      'GROUP_CONCAT(case when Start_time = ''',
      Start_time,
      ''' then Student ELSE NULL end) AS ',
      CONCAT('`',Start_time,'`')
    )
  ) INTO @sql
FROM Table1;

SET @sql = CONCAT('SELECT Instructor, ', @sql, ' 
                   FROM Table1 
                   GROUP BY Instructor');

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

DECLARE @input VARCHAR(50)
SET @input = 'test'

SET NOCOUNT ON
DECLARE @tblLookup TABLE (ID INT IDENTITY(0,1) NOT NULL, Value BIGINT)
INSERT INTO @tblLookup VALUES (0)
INSERT INTO @tblLookup VALUES (1996959894)
INSERT INTO @tblLookup VALUES (3993919788)
INSERT INTO @tblLookup VALUES (2567524794)
INSERT INTO @tblLookup VALUES (124634137)
INSERT INTO @tblLookup VALUES (1886057615)
INSERT INTO @tblLookup VALUES (3915621685)
INSERT INTO @tblLookup VALUES (2657392035)
INSERT INTO @tblLookup VALUES (249268274)
INSERT INTO @tblLookup VALUES (2044508324)
INSERT INTO @tblLookup VALUES (3772115230)
INSERT INTO @tblLookup VALUES (2547177864)
INSERT INTO @tblLookup VALUES (162941995)
INSERT INTO @tblLookup VALUES (2125561021)
INSERT INTO @tblLookup VALUES (3887607047)
INSERT INTO @tblLookup VALUES (2428444049)
INSERT INTO @tblLookup VALUES (498536548)
INSERT INTO @tblLookup VALUES (1789927666)
INSERT INTO @tblLookup VALUES (4089016648)
INSERT INTO @tblLookup VALUES (2227061214)
INSERT INTO @tblLookup VALUES (450548861)
INSERT INTO @tblLookup VALUES (1843258603)
INSERT INTO @tblLookup VALUES (4107580753)
INSERT INTO @tblLookup VALUES (2211677639)
INSERT INTO @tblLookup VALUES (325883990)
INSERT INTO @tblLookup VALUES (1684777152)
INSERT INTO @tblLookup VALUES (4251122042)
INSERT INTO @tblLookup VALUES (2321926636)
INSERT INTO @tblLookup VALUES (335633487)
INSERT INTO @tblLookup VALUES (1661365465)
INSERT INTO @tblLookup VALUES (4195302755)
INSERT INTO @tblLookup VALUES (2366115317)
INSERT INTO @tblLookup VALUES (997073096)
INSERT INTO @tblLookup VALUES (1281953886)
INSERT INTO @tblLookup VALUES (3579855332)
INSERT INTO @tblLookup VALUES (2724688242)
INSERT INTO @tblLookup VALUES (1006888145)
INSERT INTO @tblLookup VALUES (1258607687)
INSERT INTO @tblLookup VALUES (3524101629)
INSERT INTO @tblLookup VALUES (2768942443)
INSERT INTO @tblLookup VALUES (901097722)
INSERT INTO @tblLookup VALUES (1119000684)
INSERT INTO @tblLookup VALUES (3686517206)
INSERT INTO @tblLookup VALUES (2898065728)
INSERT INTO @tblLookup VALUES (853044451)
INSERT INTO @tblLookup VALUES (1172266101)
INSERT INTO @tblLookup VALUES (3705015759)
INSERT INTO @tblLookup VALUES (2882616665)
INSERT INTO @tblLookup VALUES (651767980)
INSERT INTO @tblLookup VALUES (1373503546)
INSERT INTO @tblLookup VALUES (3369554304)
INSERT INTO @tblLookup VALUES (3218104598)
INSERT INTO @tblLookup VALUES (565507253)
INSERT INTO @tblLookup VALUES (1454621731)
INSERT INTO @tblLookup VALUES (3485111705)
INSERT INTO @tblLookup VALUES (3099436303)
INSERT INTO @tblLookup VALUES (671266974)
INSERT INTO @tblLookup VALUES (1594198024)
INSERT INTO @tblLookup VALUES (3322730930)
INSERT INTO @tblLookup VALUES (2970347812)
INSERT INTO @tblLookup VALUES (795835527)
INSERT INTO @tblLookup VALUES (1483230225)
INSERT INTO @tblLookup VALUES (3244367275)
INSERT INTO @tblLookup VALUES (3060149565)
INSERT INTO @tblLookup VALUES (1994146192)
INSERT INTO @tblLookup VALUES (31158534)
INSERT INTO @tblLookup VALUES (2563907772)
INSERT INTO @tblLookup VALUES (4023717930)
INSERT INTO @tblLookup VALUES (1907459465)
INSERT INTO @tblLookup VALUES (112637215)
INSERT INTO @tblLookup VALUES (2680153253)
INSERT INTO @tblLookup VALUES (3904427059)
INSERT INTO @tblLookup VALUES (2013776290)
INSERT INTO @tblLookup VALUES (251722036)
INSERT INTO @tblLookup VALUES (2517215374)
INSERT INTO @tblLookup VALUES (3775830040)
INSERT INTO @tblLookup VALUES (2137656763)
INSERT INTO @tblLookup VALUES (141376813)
INSERT INTO @tblLookup VALUES (2439277719)
INSERT INTO @tblLookup VALUES (3865271297)
INSERT INTO @tblLookup VALUES (1802195444)
INSERT INTO @tblLookup VALUES (476864866)
INSERT INTO @tblLookup VALUES (2238001368)
INSERT INTO @tblLookup VALUES (4066508878)
INSERT INTO @tblLookup VALUES (1812370925)
INSERT INTO @tblLookup VALUES (453092731)
INSERT INTO @tblLookup VALUES (2181625025)
INSERT INTO @tblLookup VALUES (4111451223)
INSERT INTO @tblLookup VALUES (1706088902)
INSERT INTO @tblLookup VALUES (314042704)
INSERT INTO @tblLookup VALUES (2344532202)
INSERT INTO @tblLookup VALUES (4240017532)
INSERT INTO @tblLookup VALUES (1658658271)
INSERT INTO @tblLookup VALUES (366619977)
INSERT INTO @tblLookup VALUES (2362670323)
INSERT INTO @tblLookup VALUES (4224994405)
INSERT INTO @tblLookup VALUES (1303535960)
INSERT INTO @tblLookup VALUES (984961486)
INSERT INTO @tblLookup VALUES (2747007092)
INSERT INTO @tblLookup VALUES (3569037538)
INSERT INTO @tblLookup VALUES (1256170817)
INSERT INTO @tblLookup VALUES (1037604311)
INSERT INTO @tblLookup VALUES (2765210733)
INSERT INTO @tblLookup VALUES (3554079995)
INSERT INTO @tblLookup VALUES (1131014506)
INSERT INTO @tblLookup VALUES (879679996)
INSERT INTO @tblLookup VALUES (2909243462)
INSERT INTO @tblLookup VALUES (3663771856)
INSERT INTO @tblLookup VALUES (1141124467)
INSERT INTO @tblLookup VALUES (855842277)
INSERT INTO @tblLookup VALUES (2852801631)
INSERT INTO @tblLookup VALUES (3708648649)
INSERT INTO @tblLookup VALUES (1342533948)
INSERT INTO @tblLookup VALUES (654459306)
INSERT INTO @tblLookup VALUES (3188396048)
INSERT INTO @tblLookup VALUES (3373015174)
INSERT INTO @tblLookup VALUES (1466479909)
INSERT INTO @tblLookup VALUES (544179635)
INSERT INTO @tblLookup VALUES (3110523913)
INSERT INTO @tblLookup VALUES (3462522015)
INSERT INTO @tblLookup VALUES (1591671054)
INSERT INTO @tblLookup VALUES (702138776)
INSERT INTO @tblLookup VALUES (2966460450)
INSERT INTO @tblLookup VALUES (3352799412)
INSERT INTO @tblLookup VALUES (1504918807)
INSERT INTO @tblLookup VALUES (783551873)
INSERT INTO @tblLookup VALUES (3082640443)
INSERT INTO @tblLookup VALUES (3233442989)
INSERT INTO @tblLookup VALUES (3988292384)
INSERT INTO @tblLookup VALUES (2596254646)
INSERT INTO @tblLookup VALUES (62317068)
INSERT INTO @tblLookup VALUES (1957810842)
INSERT INTO @tblLookup VALUES (3939845945)
INSERT INTO @tblLookup VALUES (2647816111)
INSERT INTO @tblLookup VALUES (81470997)
INSERT INTO @tblLookup VALUES (1943803523)
INSERT INTO @tblLookup VALUES (3814918930)
INSERT INTO @tblLookup VALUES (2489596804)
INSERT INTO @tblLookup VALUES (225274430)
INSERT INTO @tblLookup VALUES (2053790376)
INSERT INTO @tblLookup VALUES (3826175755)
INSERT INTO @tblLookup VALUES (2466906013)
INSERT INTO @tblLookup VALUES (167816743)
INSERT INTO @tblLookup VALUES (2097651377)
INSERT INTO @tblLookup VALUES (4027552580)
INSERT INTO @tblLookup VALUES (2265490386)
INSERT INTO @tblLookup VALUES (503444072)
INSERT INTO @tblLookup VALUES (1762050814)
INSERT INTO @tblLookup VALUES (4150417245)
INSERT INTO @tblLookup VALUES (2154129355)
INSERT INTO @tblLookup VALUES (426522225)
INSERT INTO @tblLookup VALUES (1852507879)
INSERT INTO @tblLookup VALUES (4275313526)
INSERT INTO @tblLookup VALUES (2312317920)
INSERT INTO @tblLookup VALUES (282753626)
INSERT INTO @tblLookup VALUES (1742555852)
INSERT INTO @tblLookup VALUES (4189708143)
INSERT INTO @tblLookup VALUES (2394877945)
INSERT INTO @tblLookup VALUES (397917763)
INSERT INTO @tblLookup VALUES (1622183637)
INSERT INTO @tblLookup VALUES (3604390888)
INSERT INTO @tblLookup VALUES (2714866558)
INSERT INTO @tblLookup VALUES (953729732)
INSERT INTO @tblLookup VALUES (1340076626)
INSERT INTO @tblLookup VALUES (3518719985)
INSERT INTO @tblLookup VALUES (2797360999)
INSERT INTO @tblLookup VALUES (1068828381)
INSERT INTO @tblLookup VALUES (1219638859)
INSERT INTO @tblLookup VALUES (3624741850)
INSERT INTO @tblLookup VALUES (2936675148)
INSERT INTO @tblLookup VALUES (906185462)
INSERT INTO @tblLookup VALUES (1090812512)
INSERT INTO @tblLookup VALUES (3747672003)
INSERT INTO @tblLookup VALUES (2825379669)
INSERT INTO @tblLookup VALUES (829329135)
INSERT INTO @tblLookup VALUES (1181335161)
INSERT INTO @tblLookup VALUES (3412177804)
INSERT INTO @tblLookup VALUES (3160834842)
INSERT INTO @tblLookup VALUES (628085408)
INSERT INTO @tblLookup VALUES (1382605366)
INSERT INTO @tblLookup VALUES (3423369109)
INSERT INTO @tblLookup VALUES (3138078467)
INSERT INTO @tblLookup VALUES (570562233)
INSERT INTO @tblLookup VALUES (1426400815)
INSERT INTO @tblLookup VALUES (3317316542)
INSERT INTO @tblLookup VALUES (2998733608)
INSERT INTO @tblLookup VALUES (733239954)
INSERT INTO @tblLookup VALUES (1555261956)
INSERT INTO @tblLookup VALUES (3268935591)
INSERT INTO @tblLookup VALUES (3050360625)
INSERT INTO @tblLookup VALUES (752459403)
INSERT INTO @tblLookup VALUES (1541320221)
INSERT INTO @tblLookup VALUES (2607071920)
INSERT INTO @tblLookup VALUES (3965973030)
INSERT INTO @tblLookup VALUES (1969922972)
INSERT INTO @tblLookup VALUES (40735498)
INSERT INTO @tblLookup VALUES (2617837225)
INSERT INTO @tblLookup VALUES (3943577151)
INSERT INTO @tblLookup VALUES (1913087877)
INSERT INTO @tblLookup VALUES (83908371)
INSERT INTO @tblLookup VALUES (2512341634)
INSERT INTO @tblLookup VALUES (3803740692)
INSERT INTO @tblLookup VALUES (2075208622)
INSERT INTO @tblLookup VALUES (213261112)
INSERT INTO @tblLookup VALUES (2463272603)
INSERT INTO @tblLookup VALUES (3855990285)
INSERT INTO @tblLookup VALUES (2094854071)
INSERT INTO @tblLookup VALUES (198958881)
INSERT INTO @tblLookup VALUES (2262029012)
INSERT INTO @tblLookup VALUES (4057260610)
INSERT INTO @tblLookup VALUES (1759359992)
INSERT INTO @tblLookup VALUES (534414190)
INSERT INTO @tblLookup VALUES (2176718541)
INSERT INTO @tblLookup VALUES (4139329115)
INSERT INTO @tblLookup VALUES (1873836001)
INSERT INTO @tblLookup VALUES (414664567)
INSERT INTO @tblLookup VALUES (2282248934)
INSERT INTO @tblLookup VALUES (4279200368)
INSERT INTO @tblLookup VALUES (1711684554)
INSERT INTO @tblLookup VALUES (285281116)
INSERT INTO @tblLookup VALUES (2405801727)
INSERT INTO @tblLookup VALUES (4167216745)
INSERT INTO @tblLookup VALUES (1634467795)
INSERT INTO @tblLookup VALUES (376229701)
INSERT INTO @tblLookup VALUES (2685067896)
INSERT INTO @tblLookup VALUES (3608007406)
INSERT INTO @tblLookup VALUES (1308918612)
INSERT INTO @tblLookup VALUES (956543938)
INSERT INTO @tblLookup VALUES (2808555105)
INSERT INTO @tblLookup VALUES (3495958263)
INSERT INTO @tblLookup VALUES (1231636301)
INSERT INTO @tblLookup VALUES (1047427035)
INSERT INTO @tblLookup VALUES (2932959818)
INSERT INTO @tblLookup VALUES (3654703836)
INSERT INTO @tblLookup VALUES (1088359270)
INSERT INTO @tblLookup VALUES (936918000)
INSERT INTO @tblLookup VALUES (2847714899)
INSERT INTO @tblLookup VALUES (3736837829)
INSERT INTO @tblLookup VALUES (1202900863)
INSERT INTO @tblLookup VALUES (817233897)
INSERT INTO @tblLookup VALUES (3183342108)
INSERT INTO @tblLookup VALUES (3401237130)
INSERT INTO @tblLookup VALUES (1404277552)
INSERT INTO @tblLookup VALUES (615818150)
INSERT INTO @tblLookup VALUES (3134207493)
INSERT INTO @tblLookup VALUES (3453421203)
INSERT INTO @tblLookup VALUES (1423857449)
INSERT INTO @tblLookup VALUES (601450431)
INSERT INTO @tblLookup VALUES (3009837614)
INSERT INTO @tblLookup VALUES (3294710456)
INSERT INTO @tblLookup VALUES (1567103746)
INSERT INTO @tblLookup VALUES (711928724)
INSERT INTO @tblLookup VALUES (3020668471)
INSERT INTO @tblLookup VALUES (3272380065)
INSERT INTO @tblLookup VALUES (1510334235)
INSERT INTO @tblLookup VALUES (755167117)

DECLARE @crc BIGINT, @len INT, @i INT, @index INT
DECLARE @tblval BIGINT
SET @crc = 0xFFFFFFFF
SET @len = LEN(@input)
SET @i = 1

WHILE @i <= @len
BEGIN
    SET @index = ((@crc & 0xff) ^ ASCII(SUBSTRING(@input, @i, 1)))	
    SET @tblval = (SELECT Value FROM @tblLookup WHERE ID = @Index)
    SET @crc = (@crc / 256) ^ @tblval	
    SET @i = @i + 1	
END
SET @crc = ~@crc

SELECT @crc as CRC32, CONVERT(VARBINARY(4), @crc) as CRC32Hex

select
    case when <android-condition> then Substr(Uuid,1,17)
         else Substr(uuid,1,42)
    end
  , count(player_id)
From Play
Where Trunc(Create_Dtime) >= To_Date('2012-mar-01','yyyy-mon-dd')
Group By
    case when <android-condition> then Substr(Uuid,1,17)
         else Substr(uuid,1,42)
    end
Having Count(*) > 5
Order By Count(Player_Id) Desc


select t1.*
from t1
inner join
(
  select 1 as id, 1 as num
  union all select 5, 2
  union all select 3, 3
) ids on t1.id = ids.id
order by ids.num

declare @date1 datetime, 
    @date2 datetime, 
    @date  datetime, 
    @month integer, 
    @nm_bulan varchar(20) 

create table #month_tmp 
    ( bulan integer null, keterangan varchar(20) null ) 

select @date1 = '2000-01-01', 
       @date2 = '2000-12-31' 

select @month = month(@date1) 

while (@month < 13) 
Begin 
    IF @month = 1 
    Begin 
       SELECT @date  = CAST( CONVERT(VARCHAR(25),DATEADD(dd,-(DAY(DATEADD(mm,0,@date1))-1),DATEADD(mm,0,@date1)),111) + ' 00:00:00' as DATETIME ) 
    End
    ELSE
    Begin
       SELECT @date  = CAST( CONVERT(VARCHAR(25),DATEADD(dd,-(DAY(DATEADD(mm,@month -1,@date1))-1),DATEADD(mm,@month -1,@date1)),111) + ' 00:00:00' as DATETIME ) 
    End
    select @nm_bulan = DATENAME(MM, @date)

    insert into #month_tmp
    select @month as nilai, @nm_bulan as nama 

    select @month = @month + 1
End 

select * from #month_tmp 
drop table #month_tmp 
go

SELECT job_name, CONCAT(fname,' ',lname) AS name,  
   SUM(disposition_category = 'Attempts') as Attempts,
   SUM(disposition_category = 'RPC') AS RPC,
   SUM(disposition_category = 'Contacts') AS Contacts,
   SUM(disposition_category = 'Voted') AS Voted,
   SUM(disposition_category = 'RPC and Voted') AS 'RPC and Voted',
   SUM(disposition_category = 'Other') AS Other,
   SUM(disposition_category = 'Directory Assistance') AS 'Directory Assistance'
FROM list_details ld
JOIN users u ON u.id = ld.id
JOIN dispositions d ON d.id = u.id
WHERE security_level = 1
GROUP BY u.id;

DECLARE @tblName varchar(50)

DECLARE process_cursor CURSOR FOR 
    SELECT source 
    FROM tmpTableNames

OPEN process_cursor

FETCH NEXT FROM processcursor 
INTO @tblName

WHILE @@FETCH_STATUS = 0
BEGIN
    DECLARE @sql NVARCHAR(500)

    SELECT @sql = 'UPDATE [' + @tbleName + '] SET itemid = r.itemid FROM [' + @tbleName + '] v, itemref r WHERE r.ilditemid = v.itemid'

    EXEC sp_executesql @sql
    FETCH NEXT FROM process_cursor
    INTO @tblName

END
CLOSE processcursor
DEALLOCATE processcursor

=ERROR REPORT==== 18-Aug-2011::10:04:04 ===
Error in process <0.31775.138> with exit value: {system_limit,[{erlang,spawn_link,    [erlang,apply,[#Fun<shell.3.130303173>,[]]]},{erlang,spawn_link,1},{shell,get_command,5},    {shell,server_loop,7}]}

SELECT 
    s1.Id, s1.Name, s1.Parent, s2.Id as Child, MAX(s2.Mark) as Mark, m.Ranking 

FROM 
    Students s1
    INNER JOIN Students s2 ON (s1.id = s2.parent AND s2.Mark >= 20) 
    LEFT JOIN Marks m ON (s1.name = m.name) 

GROUP BY 
    s1.Id, s1.Name, s1.Parent, Child, Ranking;

SELECT * FROM Table1 t1
WHERE NOT EXISTS (SELECT 1
                  FROM Table2 t2
                  WHERE t1.TableID = t2.TableID
                   AND  t2.Column2 = 'C')

order by case when !a || b then 0 else 1 end

SELECT col1, col2, ..., coln, COUNT(*)
FROM your_table
GROUP BY col1, col2, ..., coln
HAVING COUNT(*) > 1

create function hun_first_letter(name in varchar2) return varchar2 as
begin
  if substr(upper(name),1,3) in ('DZS') then
    return substr(name,1,3);
  elsif substr(upper(name),1,2) in ('CS','DZ','LY','NY','SZ','TY','ZS','GY') then
    return substr(name,1,2);
  else
    return substr(name,1,1);
  end if;
end;

with t as (
  select 1 id, 'NoGeneticMutant' marker from dual union all
  select 2, 'HalfGeneticMutant' marker from dual union all
  select 3, 'GeneticMutant' marker from dual union all
  select 4, 'AnotherGeneticMutant' marker from dual union all
  select 5, 'DifferentGeneticMutant' marker from dual union all
  select 6, 'GeneticMutant' marker from dual union all
  select 7, 'AmazingGeneticMutant' marker from dual union all
  select 8, 'UltimateGeneticMutant' marker from dual union all
  select 9, 'GeneticMutant' marker from dual
)
select t.*
  from t
     , (select id
             , marker
             , lag(marker) OVER(order by id) prev_marker 
          from t
       ) t1
 where t.marker = t1.prev_marker
   and t1.marker = 'GeneticMutant'

ID  MARKER
2   HalfGeneticMutant
5   DifferentGeneticMutant
8   UltimateGeneticMutant

CREATE TRIGGER TRG_Stock_Decrease
    ON SaleItem
AFTER INSERT
AS
    UPDATE P 
    SET ProdStockQuantity=ProdStockQuantity-i.SaleQuantity,
        ProdNoOfSold =ProdNoOfSold+i.SaleQuantity 
    FROM Product P
    INNER JOIN inserted i
        ON P.ProdId=i.ProdId


    DELETE B
    FROM Basket B
    INNER JOIN inserted i
        ON i.ProdId = B.ProdId

SELECT CONVERT(VARCHAR(24),UploadedDate,103)
FROM table

SQL> drop table so_tgt;

Table dropped.

SQL> 
SQL> create table so_src (
  2   c1 varchar2(6)
  3  ,c2 varchar2(6)
  4  ,c3 varchar2(6)
  5  );

Table created.

SQL> 
SQL> insert into so_src values ( 'foo','bar','moo' );

1 row created.

SQL> 
SQL> create table so_tgt as select * from so_src where 1 = 0;

Table created.

SQL> 
SQL> /* Test for existing row insert */
SQL> insert into so_tgt
  2  with x as ( select s.*, 1 as r
  3          from so_src s
  4          where c1='foo'
  5          union
  6          select 'x','y','z',0 as r /* DEFAULT VALUES */
  7          from dual )
  8  select c1,c2,c3
  9  from x
 10  where r = ( select max(r) from x ) ;

1 row created.

SQL> 
SQL> select * from so_tgt;

C1     C2     C3
------ ------ ------
foo    bar    moo

SQL> truncate table so_tgt;

Table truncated.

SQL> 
SQL> /* Test for default row insert */
SQL> insert into so_tgt
  2  with x as ( select s.*, 1 as r
  3          from so_src s
  4          where c1='far'
  5          union
  6          select 'x','y','z',0 as r /* DEFAULT VALUES */
  7          from dual )
  8  select c1,c2,c3
  9  from x
 10  where r = ( select max(r) from x ) ;

1 row created.

SQL> 
SQL> select * from so_tgt;

C1     C2     C3
------ ------ ------
x      y      z

SQL> truncate table so_tgt ;

Table truncated.

SELECT a.id_album, a.name, count(p.id_photo) AS photos, p.id_photo, p.image 
FROM album a
LEFT JOIN photo p ON a.id_album = p.album 
GROUP BY a.id_album 
HAVING photos > 0;

SELECT * FROM table WHERE downloaded=0 ORDER BY RANDOM() LIMIT 1;

SELECT
  EN_NO,
  PROD_KEY,
  CASE WHEN (EN_NO < 4) AND (LEFT(PROD_KEY, 6) = 'Prod_A') THEN PROD_KEY ELSE NULL END AS Prod_A,
  CASE WHEN (EN_NO < 4) AND (LEFT(PROD_KEY, 6) = 'Prod_B') THEN PROD_KEY ELSE NULL END AS Prod_B,
  CASE WHEN (EN_NO < 4) AND (LEFT(PROD_KEY, 6) = 'Prod_C') THEN PROD_KEY ELSE NULL END AS Prod_C,
  PROD_QTY
FROM
  yourTable

SELECT price
  FROM code
 WHERE '11220' LIKE REPLACE(code, '*', '_')
 ORDER BY CHAR_LENGTH(REPLACE(code, '*', '')) DESC
 LIMIT 1

SELECT o.value, d.date FROM day_table o left join other_table d on o.date=d.date and key = "bar" group by d.date;

grant debug connect session to <schema> 

SELECT u.UserID,
    SUM(CASE WHEN Success = 1 THEN 1 ELSE 0 END) AS Successful,
    SUM(CASE WHEN Success = 0 THEN 1 ELSE 0 END) AS Unsuccessful,
    MAX(LoginDate) AS LastLogin
FROM Users u
INNER JOIN Logins l on u.UserID = l.UserID
GROUP BY u.UserID

    INSERT INTO structure (id_struct,id_typo,id_country) 
    SELECT x.id_struct,y.id_typo, z.id_country,
    FROM brut AS x 
    left join typology AS y on trim(x.name_typology) = trim(y.name_typology)
    left join country AS z on trim(x.name_country) = trim(z.name_country)

SELECT TOP 3 col
     , COUNT(col)
FROM (
    SELECT PCM AS col FROM tbl
     UNION ALL
    SELECT M4 FROM tbl
     UNION ALL
    SELECT DS FROM tbl
     UNION ALL
    SELECT VR1 FROM tbl ) t
GROUP BY col
ORDER BY COUNT(col) DESC

valid_state_logic=paste0("(",paste0("'",state.abb,"'", collapse=","),")")

print(valid_state_logic)
[1] "('DC','AL','AK','AZ','AR','CA','CO','CT','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME','MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI','SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY')"

Select * from Table
order by 
Case when sortcolumn<0 then 1 else 0 end
,sortcolumn

 Create table Projects_QAs(ProjectID int not null,QuestionID int not null,
 primary key(ProjectID,QuestionID)
 )

SELECT id from users where timemodified >= UNIX_TIMESTAMP(SUBDATE(curdate(), 28))

select
    FirstName, count(*)
from Table1
group by FirstName

   SELECT o.order_id, o.order_no, o.person_id, p.name
     FROM `order` o
LEFT JOIN person p
       ON p.person_id = o.person_id AND p.FIRST_NAME IS NOT NULL

$ TZ=America/New_York sqlite3 dbfile "select datetime('now','localtime');"
2010-01-06 09:53:28

$ TZ=America/Los_Angeles sqlite3 dbfile "select datetime('now','localtime');"
2010-01-06 06:53:41

SELECT
    from_unixtime(
        avg(
            unix_timestamp(date_one)-unix_timestamp(date_two)
        )
    )
FROM
    some_table
WHERE
    some-restriction-applies

select Price, Date,
       sum(case when code = 'B' then Qty when code = 'S' then -QTY end) as diff
from Table
where Type = 'A' and Acct = 'CLOSED'
group by Price, Date
order by Price, Date;

select n.name, count(*)
from names n, mark m
where n.nameID = m.nameID and m.child = '1'
group by n.name

SELECT   person, COUNT(*) AS votes
FROM     (SELECT vote1 AS person
          FROM   mytable
          UNION ALL
          SELECT vote2 AS person
          FROM   mytable) t
GROUP BY person

SELECT  *
FROM    tableName
WHERE   timeStart > (SELECT MAX(timeStart) + INTERVAL -1 SECOND FROM tableName)

SELECT date, COUNT(id) FROM users GROUP BY MONTH(date_registered).

  SELECT g.genre_name, 
         count(distinct(d.director_id))
    FROM genre g, 
         director d, 
         movie m
   WHERE g.genre_id=m.genre_id 
         AND m.director_id=d.director_id
GROUP BY g.genre_name;   

SELECT 
    post_author         AS  Author,
    COUNT(*)            AS  Posts,
    ( SELECT   p2.post_title
      FROM     wp_posts AS p2
      WHERE    p2.post_author = p1.post_author
        AND    p2.post_type = 'post'
        AND    p2.post_status = 'publish' 
      ORDER BY p2.post_date DESC
        LIMIT 1
    )                   AS  Title
FROM 
    wp_posts AS p1
WHERE
    post_type   =   'post'
AND
    post_status =   'publish'
GROUP BY
    post_author
ORDER BY
    Posts   DESC
LIMIT
    2 ;

SELECT id, 
       dt, 
       val, 
       (
        SELECT SUM(val)/12 
        FROM mytable t2 
        WHERE t2.id = t.id
          AND t2.dt > DATEADD(mm, -12, t.dt) 
          AND t2.dt < t.dt
       ) val12MonthAvg 
FROM mytable t

CREATE TABLE Test
(
    T0 INT Not NULL,
    T1 INT NUll 
)

INSERT INTO Test VALUES(1, NULL) -- Works!

ALTER TABLE Test
    WITH NOCHECK
        ADD CONSTRAINT N_null_test CHECK (T1 IS NOT NULL)

    ALTER COLUMN T1 int NOT NULL 

INSERT INTO Test VALUES(1, NULL) -- Doesn't work now!

WITH frt AS
(
  SELECT rt.Product, rt.Defect, rt.[Length]
  FROM RejectTransaction rt
  WHERE
   rt.TranDate >= '20120620 00:00:00.000'
   AND rt.TranDate <= '20120620 23:59:59.000'
)
SELECT fp.Product, fd.Defect, SUM(ISNULL(frt.[Length], 0)) AS [Length]
FROM
    (SELECT DISTINCT frt.Product
     FROM frt
     ) AS fp -- Filtered Products
     CROSS JOIN
    (SELECT DISTINCT Defect
      FROM frt
     ) AS fd -- Filtered Defects
     LEFT OUTER JOIN frt  -- Filtered Reject Transaction
     ON frt.Product = fp.Product
     AND frt.Defect = fd.Defect
GROUP BY fp.Product, fd.Defect 
ORDER BY fp.Product, fd.Defect;

SELECT
  t1.col1,
  t1.col2,
  t2.col3
FROM LINKEDSERVER1...table1 t1 JOIN LINKEDSERVER2...table2 t2 ON t1.col1 = t2.col1

CREATE TABLE IF NOT EXISTS `course` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `code` varchar(10) NOT NULL,
  `description` varchar(500) DEFAULT NULL,
  `hours` tinyint(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

CREATE TABLE IF NOT EXISTS `course_semester_xref` (
  `course_id` int(11) NOT NULL,
  `semester_id` int(11) NOT NULL,
  PRIMARY KEY (`course_id`,`semester_id`),
  KEY `semester_id` (`semester_id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

CREATE TABLE IF NOT EXISTS `major` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `description` varchar(500) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

CREATE TABLE IF NOT EXISTS `major_course_xref` (
  `major_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  PRIMARY KEY (`major_id`,`course_id`),
  KEY `course_id` (`course_id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;

CREATE TABLE IF NOT EXISTS `semester` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `year` smallint(6) NOT NULL,
  `semester` tinyint(4) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 AUTO_INCREMENT=1 ;

ALTER TABLE `course_semester_xref`
  ADD CONSTRAINT `course_semester_xref_ibfk_2` FOREIGN KEY (`semester_id`) REFERENCES `semester` (`id`),
  ADD CONSTRAINT `course_semester_xref_ibfk_1` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`);

ALTER TABLE `major_course_xref`
  ADD CONSTRAINT `major_course_xref_ibfk_2` FOREIGN KEY (`course_id`) REFERENCES `course` (`id`),
  ADD CONSTRAINT `major_course_xref_ibfk_1` FOREIGN KEY (`major_id`) REFERENCES `major` (`id`);

SELECT ROW_NUMBER() OVER (ORDER BY [PostedDate] Desc)AS RowNumber,[Products].[Id], [Name],  [Description], [PostedDate], 
   ISNULL(AVG([Rating].[RatingValue]), 0) AverageRating, 
   SUM(case  when (Rating.RatingValue) is null then 0 else 1 END) RatingCount
   INTO #DealResults1
   FROM [Products]
   LEFT OUTER  JOIN [Rating] ON [Product].[Id] = [Rating].[ProductId]
   WHERE [City] = CASE WHEN @CityId IS NULL THEN [City] ELSE @CityId END 
   AND [Description] IS NOT NULL  
   Group by [Products].[Id], [Name], [Description], [PostedDate]
   ORDER BY [PostedDate] Desc

SELECT EXTRACT(HOUR FROM NUMTODSINTERVAL(SUM(HOURS_WORKED), 'HOUR'))||':'
   ||EXTRACT(MINUTE FROM NUMTODSINTERVAL(SUM(HOURS_WORKED), 'HOUR')) AS TOTAL_HOURS
FROM (...

select empid,empname, salary, grp.groupname from employee emp left
outer join  groupname grp 
on ( emp.age > grp.[min] and emp.age <
grp.[max])

SELECT fundName, sum(numShares * price) / sum(numShares) AS avgSharePrice  
FROM table GROUP BY fundName;

SELECT the_day, price, amount
  FROM year_days LEFT JOIN (SELECT sale_date, SUM(price) price
                              FROM sales
                             GROUP BY sale_date) ON the_day = sale_date
                 LEFT JOIN (SELECT expense_date, SUM(expenses) amount
                              FROM expenses
                             GROUP BY expense_date) ON the_day = expense_date
 ORDER BY the_day;

THE_DAY        PRICE     AMOUNT
--------- ---------- ----------
...
01-DEC-11
02-DEC-11
03-DEC-11
04-DEC-11
05-DEC-11       2000
06-DEC-11                   300
07-DEC-11
08-DEC-11
09-DEC-11
10-DEC-11
11-DEC-11        800        500
12-DEC-11
13-DEC-11
14-DEC-11
15-DEC-11                  1100
16-DEC-11
17-DEC-11       2400
18-DEC-11
...

CREATE TRIGGER tr_io_iu_Logging ON Logging
INSTEAD OF INSERT, UPDATE
AS
BEGIN
    IF UPDATE(ParentID) BEGIN
        IF NOT EXISTS(SELECT 1 FROM Inserted i LEFT JOIN TableOne t1 ON i.ParentID = t1.ID WHERE i.ParentType=1 AND t1.ID IS NULL)
            /* perform the insert */
        ELSE 
           /* raise error */

        IF NOT EXISTS(SELECT 1 FROM Inserted i LEFT JOIN TableTwo t2 ON i.ParentID = t2.ID WHERE i.ParentType=2 AND t2.ID IS NULL)
            /* perform the insert */
        ELSE 
           /* raise error */
    END /* IF */    
END /* trigger */

INSERT INTO customer_alerts
  (message, customer_id) 
SELECT 'Message HERE', c.id 
  FROM CUSTOMERS c

select  p1.*
,       (
        select  count(*) 
        from    People as p2
        where   p2.age > p1.age
        ) as AgeRank
from    People as p1
where   p1.Name = 'Juju bear'

SELECT LNAME, COUNT(*) as NUMSTUDENTS
FROM STUDENT
WHERE NATIONALITY = 'GERMAN'
GROUP BY LNAME
ORDER BY COUNT(*) DESC, LNAME

INSERT INTO myTable
SELECT 'foo'
UNION ALL
SELECT 'bar'

select c1.col1, c2.col2, count(t.col1)
from (select distinct col1 from table) c1 cross join
     (select distinct col2 from table) c2 left join
     table t
     on t.col1 = c1.col1 and t.col2 = c2.col2
group by c1.col1, c2.col2;

select table_name.*,
       case score1 when -1 then 1 else 0 end +
       case score2 when -1 then 1 else 0 end +
       case score3 when -1 then 1 else 0 end +
       case score4 when -1 then 1 else 0 end +
       case score5 when -1 then 1 else 0 end
        as score_count
  from table_name;

EXEC [ServerName].[DatabaseName].dbo.sp_help 'tbl_act'

DECLARE @Names nvarchar(max);

SELECT @Names = ISNULL(@Names + '
','') + Names
FROM YourTable;

PRINT @Names;

def rank
  User.where("points > ?", points).count + 1
end

[(APP) Your System]---------[(DB) Catalog ]
           |       \              |
           |        --------      |
           |                \     |
[(FileSystem) Files]--------[(App) Indexer]

select coalesce(
      max(case when id2=4 then id end),
      max(case when id2=1 then id end)
    ) id,
    product
from mytable
where id2 in (4,1)
group by product

SELECT t.event_id,'home' as selection,home_odds as odds FROM YourTable t
UNION ALL
SELECT t.event_id,'away',away_odds FROM YourTable t
UNION ALL
SELECT t.event_id,'draw',draw_odds FROM YourTable t

;WITH FlavorsList
AS
( 
    //Your query here
    SELECT 
      fc.flavorid,
      fc.flavorname,
    CASE 
      WHEN sa.flavorid IS NULL THEN 'No'
      ELSE 'Yes' END ) IsEaten
    CASE 
      WHEN t.tempid IS NULL THEN 'No' 
      ELSE 'Yes' END ) IsWarm

  FROM [poptart] p

    LEFT JOIN [diet] d ON d.Active = 1
    LEFT JOIN [toaster] ts ON p.poptartid = ts.poptartid 
                           AND d.dietname = ts.dietname
    LEFT JOIN [flavor] fl ON fl.poptartid = ts.poptartid
    LEFT JOIN [flavorcolor] fc ON fc.flavorid = fl.flavorid

    LEFT OUTER JOIN [stomach] sa ON sa.flavorid = fc.flavorid

    LEFT JOIN [poptart] p2 ON ts.poptartid = p2.poptartid
    LEFT JOIN [temp] t ON t.tempid = p2.tempid AND t.Active = 1

  GROUP BY fc.flavorid,fc.flavorname,sa.flavorid,t.tempid
)
SELECT fl.flavorid, fl.flavorname, fl.IsEaten, Max(fl.IsWarm)
FROM FlavorsList fl
GROUP BY fl.flavorid, fl.flavorname, fl.IsEaten
ORDER BY fl.flavorname

<comment> ::= <simple comment> | <bracketed comment>

<simple comment> ::=
    <simple comment introducer> [ <comment character> ... ] <newline>

<simple comment introducer> ::=
    <minus sign> <minus sign> [ <minus sign> ... ]

<bracketed comment> ::=
    <bracketed comment introducer> <bracketed comment contents>
    <bracketed comment terminator>

<bracketed comment introducer> ::= <slash> <asterisk>

<bracketed comment terminator> ::= <asterisk> <slash>

<bracketed comment contents> ::= [ { <comment character> | <separator> }... ]

<comment character> ::= <nonquote character> | <quote>

UPDATE table_name SET FIELD2 = NULL

SELECT DATE(MAX(logDate)) INTO @prev_date FROM EmotionsDB.`Log`;
SELECT DATE(MAX(logDate)) INTO @prev_date_outerLoop FROM EmotionsDB.`Log`;

SELECT MAX(AwardDescriptions.aID) as aID, CostCentres.cCC 
FROM  AwardDescriptions INNER JOIN
      CostCentres
      ON AwardDescriptions.aID = CostCentres.cNumber 
GROUP BY CostCentres.cCC
ORDER BY CostCentres.cCC;

CREATE TABLE ##SQLFiles ( SQLFileName VARCHAR(2000))
GO

INSERT INTO ##SQLFiles
EXECUTE master.dbo.xp_cmdshell 'dir /b "C:\SQL Scripts\*.sql"'
GO

DECLARE cFiles CURSOR LOCAL FOR
    SELECT DISTINCT [SQLFileName]
    FROM ##SQLFiles
    WHERE [SQLFileName] IS NOT NULL AND
          [SQLFileName] != 'NULL'
    ORDER BY [SQLFileName]

DECLARE @vFileName            VARCHAR(200)
DECLARE @vSQLStmt             VARCHAR(4000)

OPEN cFiles
FETCH NEXT FROM cFiles INTO @vFileName
WHILE @@FETCH_STATUS = 0
BEGIN
    -- The following SET command must be on a single line or else an error will be generated.
    -- It is split in this script for readability purposes.
    SET @vSQLStmt = 'master.dbo.xp_cmdshell ''osql -S Server Name -U User Name -P Password
                     -d Database Name -i "C:\SQL Scripts\' + @vFileName + '"'''
    EXECUTE (@vSQLStmt)

    FETCH NEXT FROM cFiles INTO @vFileName
END

CLOSE cFiles
DEALLOCATE cFiles
GO

DROP TABLE ##SQLFiles
GO

with cte as
(
    select 'p.G12_V14insR' as AA_SYNTAX from dual
)

select 
    REGEXP_SUBSTR(AA_SYNTAX,'p\.[[:alpha:]]+([[:digit:]]+)', 1, 1, NULL, 1) as Bottom 
    ,REGEXP_SUBSTR(AA_SYNTAX,'\_[[:alpha:]]+([[:digit:]]+)', 1, 1, NULL, 1) as Top 
from cte

select staffNo,
(Select avg(staffsalary) from staff) as avgSalary,
(select staffSalary from staff where staffNo = S.StaffNo) as Salary,
(Select staffSalary - (select avg(staffSalary) from staff) from staff where staffNo = S.staffNo ) as salDiff
from staff S
where staffSalary > (Select avg(staffSalary) from staff)

-- Sample data from the question.
declare @x table ([UID] bigint, [Value] nchar(1), [ParentID] bigint);
insert @x values 
    (1, N'A', null),
    (2, N'B', 1),
    (3, N'C', 2),
    (4, N'D', 1),
    (5, N'E', null);

with [PathCTE] as
(
    -- Base case: any entry with no parent is its own path.
    select 
        *, 
        [Path] = convert(nvarchar(max), N'|' + convert(nvarchar, [UID]) + N'|')
    from
        @x
    where
        [ParentID] is null

    union all

    -- Recursive case: for any entry whose parent is already in the result set,
    -- we can construct the path by appending a single value to the parent path.
    select
        [Child].*,
        [Path] = convert(nvarchar(max), [Parent].[Path] + convert(nvarchar, [Child].[UID]) + N'|')
    from
        @x [Child]
        inner join [PathCTE] [Parent] on [Child].[ParentID] = [Parent].[UID]
)

select * from [PathCTE] order by [UID];

CREATE TABLE test1
(
    ID int IDENTITY UNIQUE,
    length int not null,
    constraint UQ_test1_Length_XRef UNIQUE (ID,Length)
)
go
CREATE TABLE _test2
(
    ID int IDENTITY UNIQUE,
    test1number int references test1(ID),
    _test1length int not null,
    distance int not null,
    constraint FK_test2_test1_length_xref foreign key (test1number,_test1length) 
            references test1 (ID,length) on update cascade,
    constraint CK_length_distance CHECK (distance <= _test1length)
)
go
create view test2
as
    select ID,test1number,distance from _test2
go
create trigger T_I_t2 on test2
instead of insert
as
    insert into _test2(test1number,_test1length,distance)
    select test1number,length,distance
    from inserted i inner join test1 t on i.test1number = t.id
go

SELECT
  *
FROM
  per_all_assignments_m paam
WHERE
  paam.effective_start_date =
    (
      CASE
        WHEN
          paam.effective_start_date =
            (
              SELECT
                MAX(paam1.effective_start_date)
              FROM
                per_all_assignments_m paam1
              WHERE
                paam1.person_id = paam.person_id AND
                paam.assignment_id = paam1.assignment_id AND
                paam1.action_code <> 'TRANSFER' AND
                paa1.effective_latest_change = 'N'
            )
        THEN paam.effective_start_date
        ELSE
          (
            SELECT
              MAX(paam1.effective_stat_date)
            FROM
              per_all_assignments_m paam1
            WHERE
              paam.person_id = paam1.person_id AND
              paam.assignment_id = paam1.assignment_id AND
              paam1.effective_start_date <
              (
                SELECT
                  MAX(paam2.effective_start_date)
                FROM
                  per_all_assignments_m paam2
                WHERE
                  paam2.action_code = 'TRANSFER' AND
                  paam1.person_id = paam2.person_id AND
                  paam1.assignment_id = paam2.assignment_id
              )
          )
       END -- closing END for case when..
    )

SELECT price
FROM groceries
GROUP BY price
HAVING COUNT(*) = 1

CREATE TABLE dbo.Tbl1(id INT PRIMARY KEY, val1 INT, val2 INT)

INSERT INTO dbo.Tbl1(id, val1, val2)
VALUES((SELECT ISNULL(MAX(id)+1,0) FROM dbo.Tbl1 WITH(SERIALIZABLE, UPDLOCK)), 42, 47);

SELECT * FROM dbo.Tbl1;

SELECT "URL", "SIZE", "MODDATE", "MODTIME"
FROM
(
SELECT "URL", "SIZE", "MODDATE", "MODTIME",
       ROW_NUMBER() OVER ( PARTITION BY "URL" order by "MODDATE" desc, "MODTIME" desc) as seq
FROM Table1
) T
Where T.seq =1

ORDER BY baseData = '', CAST(`baseData` AS DECIMAL(10,2)) {$dir} ";

SELECT m.title,
       IFNULL(GROUP_CONCAT(g.name), "") genres
FROM Movie m
LEFT JOIN Movie_Genre mg ON m.id = mg.movie_id
JOIN Genre g ON g.id = mg.genre_id
GROUP BY m.id

select column, count(*) from table group by column

DECLARE @myTable TABLE
  (
    clientID INT ,
    code VARCHAR(10) ,
    cName VARCHAR(10) ,
    sub INT
  );

INSERT  @myTable ( [clientID], [code], [cName], [sub] )
VALUES  ( 1, 'STK', 'StackOver', 0 ),
        ( 2, 'GOGL', 'Google', 0 ),
        ( 3, 'MSFT', 'Microsoft', 1 );


WITH  t ( clientId, code, cname, rootId )
        AS (
             SELECT clientID, code, cName, clientID AS rootId
             FROM   @myTable AS [mt]
             WHERE  [sub] = 0
             UNION ALL
             SELECT mt.clientID, mt.code, mt.cName, t.[rootId]
             FROM   @myTable AS [mt]
             INNER JOIN t ON t.clientId = mt.[sub]
           ),
      roots
        AS (
             SELECT rootId
             FROM   t
             WHERE  cname LIKE '%Stack%' OR
                    code LIKE '%Stack%'
           )
  SELECT  [t].[code], [t].[cname]
  FROM    t
  INNER JOIN roots rt ON [rt].[rootId] = [t].[rootId];

UPDATE DP
SET 
   DP.[Description] = SP.[Description]
   ................................
   ................................
   ................................
    ,[LastModificationDateUtc] = GETUTCDATE()
FROM    
    [dbo].[BaseProducts] DP
CROSS JOIN 
    [dbo].[BaseProducts] SP
WHERE   
    SP.Id = @SourceBaseProductId
    AND DP.Id = @DestinationBaseProductId;

connectionString = @"Server=myServerName\theInstanceName;Database=myDataBase;..."

SELECT C.ID, C.TEXT, C.ROOMID, U.USERNAME, U2.USERNAME 
FROM  COMMENT C 
INNER JOIN COMMENTRATE CR ON C.ID = CR.COMMENTID
INNER JOIN  USERS U ON C.USERID = U.ID
INNER JOIN  USERS U2 ON CR.USERID = U2.ID
WHERE U.USERNAME IN ('username1', 'username2')
ORDER BY C.ROOMID

SELECT
    A.Item,
    A.Option,
    CASE 
    WHEN Option = 'A' THEN 'S'   // A will always be S
    WHEN Option = `B` 
        CASE
        WHEN EXISTS(SELECT null FROM table WHERE Item = A.Item AND Option = 'A')
            THEN 'O'
        ELSE 'S'
        END
    END AS Recipe
 FROM table

SELECT P1.* 
  from parts P1
  join parts P2 on
       P1.weight > P2.weight
 WHERE P2.name = 'tape drive'

$ drush --uri=example.com php-eval "<?php module_invoke_all('comment', 'update', array('your'=>'dummy', 'comment'=>'here'); ?>"

DECLARE

  v_bid B.b_id%TYPE;

BEGIN
   FOR rec IN (SELECT id
                 FROM A
                WHERE group_id = 7)
   LOOP
     INSERT INTO B (b_id, thing2, ...stuff...) RETURNING b_id INTO v_bid;

     INSERT INTO C (rec.id, /* new ID generated by previous insert statement */
     COMMIT;
   END LOOP;
END;

SELECT  [DETAIL INFO, no need to MAX or GROUP BY]
FROM Pat_spell AS IPS
LEFT JOIN PATIENT PAT       WITH (NOLOCK) ON PAT.DIM_PATIENT_ID = IPS.DIM_PATIENT_ID
LEFT JOIN SPECIALTY SPEC    WITH (NOLOCK) ON SPEC.DIM_SPECIALTY_ID = IPS.DIM_DIS_SPECT_ID
LEFT JOIN SERVICE_UNIT DSSU WITH (NOLOCK) ON IPS.DIM_DIS_WARD_ID = DSSU.DIM_SSU_ID
INNER JOIN (
    SELECT PatientID, MAX(IPS.disch_dttm) AS DischargeDt
    FROM [AllMyTables]
    WHERE (IPS.DISCH_DTTM <= PAT.DEATH_DTTM + 30)
    AND IPS.DIM_DIS_SPECT_ID = '7195'
    AND IPS.DISCH_DTTM BETWEEN '01/01/2014' AND '30/06/2014'
) t1 ON PAT.PatientID = t1.PatientID AND IPS.disch_dttm = t1.DischargeDt
ORDER BY pat.PAS_ID

select m.*
from
(
  select 
    least(from_id, to_id) as lesser_id, 
    greatest(from_id, to_id) as greater_id, 
    min(send_time) as sortkey
  from mytable
  group by least(from_id, to_id), greatest(from_id, to_id)
) thread
join mytable m on least(m.from_id, m.to_id) = thread.lesser_id
               and greatest(m.from_id, m.to_id) = thread.greater_id
order by thread.sort_key, thread.lesser_id, thread.greater_id, m.send_time;

SELECT *
FROM have AS h
WHERE h.flag IS NULL
   OR h.flag IN (1, 11);

SELECT EmployeeID, 
       SUM(PayAmount) as TotalPaid, 
       DATEADD(YEAR, DATEDIFF(YEAR,0, Paydate), 0)  as Year
FROM Table1
GROUP BY EmployeeID, DATEADD(YEAR, DATEDIFF(YEAR,0, Paydate), 0) 
HAVING YEAR(DATEADD(YEAR, DATEDIFF(YEAR,0, Paydate), 0)) =2004

DECLARE
  CURSOR ora_obj_rows IS (SELECT * FROM ALL_OBJECTS WHERE OWNER = '&owner_user' AND OBJECT_NAME LIKE 'ORA_ASPNET%' AND OBJECT_TYPE IN ('TABLE', 'PACKAGE', 'FUNCTION'));
BEGIN
FOR ora_obj IN ora_obj_rows
LOOP
  EXECUTE IMMEDIATE 'CREATE SYNONYM "' || '&login_user' || '"."' || ora_obj.OBJECT_NAME || '" FOR "' || '&owner_user' || '"."' || ora_obj.OBJECT_NAME || '"';
END LOOP;
END;
/

$fromDate = '2016-03-01 00:00:00';
$toDate = '2016-03-31 23:59:59';

$orders = Mage::getModel('sales/order')->getCollection()
    ->addAttributeToSelect('created_at')
    ->addAttributeToFilter('created_at', array('gteq'=>$fromDate))
    ->addAttributeToFilter('created_at', array('lteq'=>$toDate));

$orders->getSelect()
    ->columns( 'COUNT(*) AS orders_count' )
    ->group( 'DATE_FORMAT(created_at, "%d-%m-%y")' );

foreach($orders as $order) {
    // logic
}

mysql_connect('localhost', 'username', 'password');
mysql_select_db('database name');

$sql = "SELECT * FROM table WHERE product_name LIKE '%" . mysql_real_escape_string($_GET['search_query']) . "%'";

$result = mysql_query($sql) or die("Error in query $sql: " . mysql_error());
while ($row = mysql_fetch_array($result)) {
    echo "Product: " . $row['product_name'] . "<br />";
}

INSERT INTO
  @itteration_results
EXEC
  st_getCall @room_id

use master;
go

set nocount on;
go

if db_id('test') is not null
begin
    alter database test set single_user with rollback immediate;
    drop database test;
end
go

create database test;
go

use test;
go

create table data (id int identity(1,1) not null primary key, 
    data1 varchar(38),
    data2 bigint,
    created_at datetime not null default getdate());
go  

declare @i int = 0;
begin transaction   
while @i < 1000000
begin
    insert into data (data1, data2) values (newid(), @i);
    set @i += 1;
    if @i % 1000 = 0
    begin
        commit;
        raiserror (N'Inserted %d', 0, 0, @i);
        begin tran;
    end
end
commit  
raiserror (N'Inserted %d', 0, 0, @i);
go

backup database test to disk='c:\temp\test.bak' with init;
go

if db_id('copy') is not null
begin
    alter database copy set single_user with rollback immediate;
    drop database copy;
end
go

restore database copy from disk='c:\temp\test.bak'
with move 'test' to 'c:\temp\copy.mdf', move 'test_log' to 'c:\temp\copy_log.ldf';
go

-- create some differences
--
update test..data set data1 = newid() where id = cast(rand()*1000000 as int)
update copy..data set data1 = newid() where id = cast(rand()*1000000 as int)

delete from test..data where id = cast(rand()*1000000 as int);
insert into copy..data (data1, data2) values (newid(), -1);


-- do the check
--
declare @id int = 0;
while @id < 1010000
begin
    declare @chk1 int, @chk2 int;
    select @chk1 = checksum_agg(binary_checksum(*)) from test..data where id >= @id and id < @id + 10000
    select @chk2 = checksum_agg(binary_checksum(*)) from copy..data where id >= @id and id < @id + 10000
    if @chk1 != @chk2
    begin
        -- locate the different row(s)
        --
        select t.id, binary_checksum(*) as chk
            from test..data t
            where t.id >= @id and t.id < @id + 10000
        except
        select id, binary_checksum(*) as chk
            from copy..data c
            where c.id >= @id and c.id < @id + 10000;

        select t.id, binary_checksum(*) as chk
            from copy..data t
            where id >= @id and id < @id + 10000
        except
        select id, binary_checksum(*) as chk
            from test..data c
            where c.id >= @id and c.id < @id + 10000;
    end
    else
    begin
        raiserror (N'Range %d is OK', 0,0, @id);
    end
    set @id += 10000;
end

SELECT * 
FROM myTable 
ORDER BY appointment_time ASC

scalar_expression { = | < > | ! = | > | > = | ! > | < | < = | ! < } 
     { SOME | ANY } ( subquery ) 

SELECT A.id, B.full_name, C.full_name, D.full_name, E.pet_name, A.date, A.some_text
FROM RESULTS AS A 
LEFT OUTER JOIN USER AS B ON A.USER_ID1 = B.ID
LEFT OUTER JOIN USER AS C ON A.USER_ID2 = C.ID
LEFT OUTER JOIN USER AS D ON A.USER_ID3 = D.ID
LEFT OUTER JOIN PET AS E ON A.PET_ID = E.ID
WHERE A.id = 3

SELECT name, velocity, COUNT(*) AS count, 
COUNT(CASE WHEN category = 'A' AND id = 1 THEN 1 END)
FROM section 
GROUP BY name, velocity

create synonym [otherDb].[tbl_a] for [DatabaseB].[schemaB].[tbl_a]
create synonym [otherDb].[tbl_b] for [DatabaseB].[schemaB].[tbl_b]
create synonym [otherDb].[tbl_c] for [DatabaseB].[schemaB].[tbl_c]

RETURN EXISTS SELECT SESSION_ID FROM 
SESSION_TEST
WHERE TEST_ID = @id
AND ORDINAL = 1
AND SESSION_ID NOT IN (SELECT SESSION_ID FROM SESSION_TEST WHERE ORDINAL > 1);

select ...
        ,(cast(SC.[service_code_reported] as varchar(4)) +char(10)+ rd.service_code_description) [service_code_reported]
      ,(cast(SC.[service_code_actual1] as varchar(4)) +char(10)+ ad.service_code_description) [service_code_actual1]
       ....
from SC_Data sc
join lkup_Service_Code_Definition rd
on sc.service_code_reported = rd.system_code
join lkup_Service_Code_Definition ad
on sc.service_code_actual1 = ad.system_code
where  ...

select distinct b.company, 
       b.priority, 
       x.concom, 
       x.totalwithoutnew, 
       x.totalallid 
FROM    (
            SELECT i.concom, 
                   Coalesce (SUM(CASE 
                                   WHEN c.category_id = '30' THEN 0 
                                   ELSE t.logmins 
                                 END), 0)       AS totalwithoutnew, 
                   Coalesce (SUM(t.logmins), 0) AS totalallid 
            FROM   helpdesk3.dbo.inquiry AS i 
                   INNER JOIN timelog AS t 
                     ON t.inquiry_id = i.inquiry_id 
                   INNER JOIN prod AS p 
                     ON i.prod_id = p.prod_id 
                   INNER JOIN category AS c 
                     ON p.category_id = c.category_id 
            WHERE  ( Datepart(yyyy, escdate) = 2011 ) 
            GROUP  BY i.concom 
            ) x
INNER JOIN [Check].[dbo].[tbl_companies] AS b 
          ON x.concom = b.company COLLATE sql_latin1_general_cp1_ci_as 

ORDER  BY x.totalwithoutnew DESC, 
          b.priority DESC  

SELECT * FROM table ORDER BY RAND() LIMIT 10

INSERT INTO dbo.HistoryLog
(
  ItemDATE, ItemTIME, 
  SITENAME, SERIAL_NO, 
  RPM, Power, Voltage1, Voltage2
)
SELECT 
  ItemDATE, ItemTIME, 
  SITENAME, SERIAL_NO, 
  RPM, Power, Voltage1, Voltage2
FROM 
(
  SELECT 
    ItemDATE, ItemTIME, 
    SITENAME, SERIAL_NO, 
    RPM, Power, Voltage1, Voltage2,
    rn = ROW_NUMBER() OVER 
    (
      PARTITION BY ItemDATE, ItemTIME, 
        SITENAME, SERIAL_NO
      ORDER BY RPM DESC
    )
  FROM dbo.RTCU
) AS RTCU
WHERE rn = 1
AND NOT EXISTS 
(
  SELECT 1 FROM dbo.HistoryLog
    WHERE ItemDATE  = rtcu.ItemDATE
      AND ItemTIME  = rtcu.ItemTIME
      AND SITENAME  = rtcu.SITENAME 
      AND SERIAL_NO = rtcu.SERIAL_NO
);

SELECT t.*
FROM table1 t
ORDER BY (SELECT customOrder FROM orderoftbl1 ot WHERE t.c1 = ot.c1)

select id 
  from tab 
 where (modify_date - creation_date) >=  NUMTODSINTERVAL(5, 'Minute');

WITH  cte
    AS ( SELECT   InboxID,
                  ParentID
         FROM     BIZZBOX
         WHERE    InboxID = @inboxID
         UNION ALL
         SELECT   prev.InboxID,
                  prev.ParentID
         FROM     BIZZBOX prev
         INNER JOIN cte curr ON prev.InboxID = curr.ParentID ),
     cte1
   AS ( SELECT   InboxID,
                 ParentID
        FROM     BIZZBOX
        WHERE    InboxID = @inboxID
        UNION ALL
        SELECT   prev.InboxID,
                 prev.ParentID
        FROM     BIZZBOX prev
        INNER JOIN cte1 curr ON prev.ParentID = curr.InboxID )
SELECT  * FROM    cte
UNION
SELECT  * FROM    cte1

$query = Price::latest('id')->whereHas('user', function ($query) {
    $query->whereHas('role', function ($query) {
        $query->where('name', 'retailer');
    });
});

$price = $query->value('price');

select 
    rate_table_name, 
    rate_table_extra_id, 
    rate_extra
from 
    RateTableUsed rtu
    inner join RateTable rt on
        rtu.rate_table_id = rt.rate_table_id
    cross join RateExtra re
    left outer join RateTableExtra rte on 
        rte.rate_table_id = rt.rate_table_id
        and rte.rate_extra_id = re.rate_extra_id
order by rt.rate_table_name, re.rate_extra_id

SELECT CustomerID
      ,COUNT(CASE WHEN TransactionType     = 'ESL' 
               AND TransactionLocation = 'WBEE' THEN 1 ELSE NULL END) AS WBEEESL
      ,COUNT(CASE WHEN TransactionType     = 'LOTE' 
               AND TransactionLocation = 'WBEE' THEN 1 ELSE NULL END) AS WBELOTE
      ,COUNT(CASE WHEN TransactionType     = 'ESL' 
               AND TransactionLocation = 'VALE' THEN 1 ELSE NULL END) AS VALEESL
      ,COUNT(CASE WHEN TransactionType     = 'LOTE' 
               AND TransactionLocation = 'VALE' THEN 1 ELSE NULL END) AS VALELOTE
FROM TABLE_NAME
GROUP BY CustomerID

where id like '123%'
or id like '% 123%'

DECLARE @t TABLE
(UserId TINYINT
,StartWeek TINYINT
,EndWeek TINYINT
,TYPE CHAR(1)
)

INSERT @t
      SELECT 1,1,3,'A'
UNION SELECT 1,4,5,'A'
UNION SELECT 1,6,10,'A'
UNION SELECT 1,11,13,'B'
UNION SELECT 1,14,16,'A'
UNION SELECT 2,1,5,'A'
UNION SELECT 2,6,9,'A'
UNION SELECT 2,10,16,'B'

;WITH srcCTE
AS
(
        SELECT *
               ,ROW_NUMBER() OVER (PARTITION BY t1.UserID, t1.Type
                                   ORDER BY t1.EndWeek
                                   ) AS rn 
        FROM @t AS t1
)
,recCTE
AS
(
        SELECT *
               ,0 AS grp
        FROM srcCTE
        WHERE rn = 1

        UNION ALL

        SELECT s.UserId
               ,s.StartWeek
               ,s.EndWeek 
               ,s.TYPE 
               ,s.rn
               ,CASE WHEN s.StartWeek - 1 = r.EndWeek
                     THEN r.grp 
                     ELSE r.grp+ 1
                END AS GRP
        FROM srcCTE AS s
        JOIN recCTE AS r
        ON   r.UserId = s.UserId
        AND  r.TYPE   = s.TYPE
        AND  r.rn     = s.rn - 1
)
SELECT UserId
       ,MIN(StartWeek) AS StartWeek
       ,MAX(EndWeek)   AS EndWeek
       ,TYPE
FROM recCTE AS s1
GROUP BY UserId
         ,TYPE
         ,grp

with times as (
SELECT    t1.EmplID
        , t3.EmplName
        , min(t1.RecTime) AS InTime
        , max(t2.RecTime) AS [TimeOut]
        , cast(min(t1.RecTime) as datetime) AS InTimeSub
        , cast(max(t2.RecTime) as datetime) AS TimeOutSub
        , t1.RecDate AS [DateVisited]
FROM  AtdRecord t1 
INNER JOIN 
      AtdRecord t2 
ON    t1.EmplID = t2.EmplID 
AND   t1.RecDate = t2.RecDate
AND   t1.RecTime < t2.RecTime
inner join 
      HrEmployee t3 
ON    t3.EmplID = t1.EmplID 
group by 
          t1.EmplID
        , t3.EmplName
        , t1.RecDate
)
SELECT EmplID
,EmplName
,InTime
,[TimeOut]
,[DateVisited]
,convert(char(5),cast([TimeOutSub] - InTimeSub as time), 108) totaltime
,convert(char(5), case when TimeOutSub - InTimeSub >= '08:01' then 
cast(TimeOutSub - dateadd(hour, 8, InTimeSub) as time) else '00:00' end, 108) as overtime
FROM times

DECLARE @Month INT = 11
DECLARE @YEAR INT = 2012
DECLARE @Graceperiod INT = 2 

SELECT 
      [Construct Date] = DATEADD(mm, (@YEAR - 1900) * 12 + @Month - 1 , DAY(GETDATE()) - 1) --construct date
      ,[Add Grace period] =DATEADD(mm,@Graceperiod,DATEADD(mm, (@YEAR - 1900) * 12 + @Month - 1 , DAY(GETDATE()) - 1)) --add grace month
      ,[DateDiff] = DATEDIFF(
                        DAY,
                        DATEADD(mm,@Graceperiod,DATEADD(mm, (@YEAR - 1900) * 12 + @Month - 1 , DAY(GETDATE()) - 1)),
                        GETDATE()
                  ) -- datediff

for index, row in enumerate(c):
    if index%2 == 0: # Odd numbered row (since index starts from 0)
        # row contains out_time
        print row
    else:
        # row contains in_time
        print row

alter table messages add column user text;

create table log
(
    id integer primary key autoincrement, 
    information text    
);

SET NOCOUNT ON;
GO

---------------------------------------------
-- #1 Dynamic SQL to update DATETIME values with UTC offset
DECLARE @t TABLE(TABLE_CATALOG VARCHAR(128), TABLE_SCHEMA VARCHAR(128), TABLE_NAME VARCHAR(128), COLUMN_NAME VARCHAR(128));

INSERT @t
EXEC sp_msforeachdb 'select db = "?"
, s.name
, t.name
, c.name
FROM [?].sys.tables t
JOIN [?].sys.columns c ON c.object_id = t.object_id
JOIN [?].sys.types y ON y.user_type_id = c.user_type_id
JOIN [?].sys.schemas s ON s.schema_id = t.schema_id
WHERE t.[type] = ''U''
AND y.name = ''DATETIME''
AND "?" NOT IN (''master'', ''tempdb'', ''model'', ''msdb'')';

DECLARE @Offset INT;
SET @Offset = - DATEPART(TZOFFSET, SYSDATETIMEOFFSET());

SELECT [SQL] = 'UPDATE ['+ C.TABLE_CATALOG +'].[' + C.TABLE_SCHEMA + '].[' + C.TABLE_NAME + '] SET [' + C.COLUMN_NAME + '] = DATEADD(MINUTE,' + CAST(@Offset AS VARCHAR(5)) + ',[' + C.COLUMN_NAME + ']);' 
FROM @t C;
GO

---------------------------------------------
-- #2 Dynamic SQL to change DATETIME column defaults to SYSUTCDATETIME
DECLARE @t TABLE([SQL] VARCHAR(MAX));
DECLARE @SQL VARCHAR(MAX);

INSERT @t   
EXEC sp_msforeachdb 'SELECT [SQL] = ''---------------------------------------------'' + CHAR(13) + CHAR(10)
    + ''-- [?].[''+s.name+''].[''+t.name+''].['' + c.name + '']'' + CHAR(13) + CHAR(10)
    + ''ALTER TABLE [?].[''+s.name+''].[''+t.name+'']'' + CHAR(13) + CHAR(10)
    + ''DROP CONSTRAINT [''+d.name + '']'' + CHAR(13) + CHAR(10)
    + ''GO'' + CHAR(13) + CHAR(10)
    + ''ALTER TABLE [?].[''+s.name+''].[''+t.name+''] ADD CONSTRAINT'' + CHAR(13) + CHAR(10)
    + ''[''+d.name+''] DEFAULT (SYSUTCDATETIME()) FOR [''+c.name + '']'' + CHAR(13) + CHAR(10)
    + ''GO'' + CHAR(13) + CHAR(10) + CHAR(13) + CHAR(10)
    FROM [?].sys.default_constraints d
    JOIN [?].sys.columns c  ON  c.default_object_id = d.object_id
    JOIN [?].sys.types y ON y.user_type_id = c.user_type_id
    JOIN [?].sys.tables t ON t.object_id = d.parent_object_id AND t.[type] = ''U''
    JOIN [?].sys.schemas s ON s.schema_id = t.schema_id
    WHERE y.name = ''datetime''
    AND "?" NOT IN (''master'', ''tempdb'', ''model'', ''msdb'')';

DECLARE C CURSOR FOR 
SELECT * FROM @t

OPEN C
FETCH NEXT FROM C INTO @SQL;
WHILE @@FETCH_STATUS = 0 BEGIN
    PRINT @SQL;
    FETCH NEXT FROM C INTO @SQL;
END

CLOSE C;
DEALLOCATE C;
GO

SELECT *
FROM (
    SELECT i.*, IFNULL(iset.set_id, UUID()) AS the_set FROM img_ref i
    LEFT JOIN image_set iset ON iset.img_id = i.id
) SQ
GROUP BY the_set

SELECT p, SUM(conta) AS conta 
FROM (
  SELECT s.proprietario_id as p, COUNT(*) as conta
  FROM sn_like_spotted s
  GROUP BY s.proprietario_id  
  UNION ALL
  SELECT s.proprietario_id as p, COUNT(*) as conta2
  FROM sn_like_risposta s
  GROUP BY s.proprietario_id  
) AS baseview
GROUP BY p
ORDER BY conta DESC, p ASC

with q as (select '   ABC   ' as c1,'      DEF' as c2 from dual
 union all select 'ABC      ', '      DEF' from dual
 union all select '   DEF   ', 'ABC      ' from dual
 union all select '      DEF', '   ABC   ' from dual
 union all select 'ABC      ', '   DEF   ' from dual
 union all select '      DEF', 'ABC      ' from dual
)
select c1, c2,
       GREATEST(SUBSTR(c1, 1, 3), SUBSTR(c2, 1, 3)) ||
       GREATEST(SUBSTR(c1, 4, 3), SUBSTR(c2, 4, 3)) ||
       GREATEST(SUBSTR(c1, 7, 3), SUBSTR(c2, 7, 3)) mrg
from q;


C1        C2        MRG       
--------- --------- --------- 
   ABC          DEF    ABCDEF 
ABC             DEF ABC   DEF 
   DEF    ABC       ABCDEF    
      DEF    ABC       ABCDEF 
ABC          DEF    ABCDEF    
      DEF ABC       ABC   DEF 

6 rows selected

procedure alterExtTableFileName(a_tableName varchar2, a_filename varchar2) is
    pragma autonomous_transaction;
begin

    dbms_output.put_line('alterExtTableFileName(TableName=' || a_tableName || ' FileName=' || a_filename || ')');

    execute immediate 'alter table ' || a_tableName || ' LOCATION (''' || a_filename || ''')';
    commit;

exception when others then
    rollback;
    raise;

end alterExtTableFileName;

--Synchronize source data with target
MERGE INTO dbo.tbl_Target AS t
    USING dbo.tbl_Source AS s    
        ON t.id = s.id
    WHEN MATCHED AND (t.name != s.name OR t.qty!= s.qty) THEN
        --Row exists and data is different
        UPDATE SET t.name = s.name, t.qty = s.qty
    WHEN NOT MATCHED BY TARGET THEN 
        --Row exists in source but not in target
        INSERT VALUES (s.id, s.name, s.qty) 
    WHEN NOT MATCHED BY SOURCE THEN 
        --Row exists in target but not in source
        DELETE OUTPUT$action, inserted.id, deleted.id

SELECT y.id
     , y.name  
  FROM my_table x 
  JOIN my_table y 
    ON y.name = x.name 
 GROUP 
    BY name
     , id 
 ORDER 
    BY MAX(x.id) DESC
     , id DESC;

VARCHAR_FORMAT(DATE, 'MON DD YYYY')

SELECT t.`id`,t.`name`,
       IFNULL(cpd.status,0) AS resultStatus,
       IFNULL(cpd.added_date,CURDATE()) AS added_date
FROM `teams` t
INNER JOIN cpd  ON (cpd.team_id = t.id AND cpd.status = 0) 
WHERE t.`sub_cat_id` = 19 
      OR 
      cpd.added_date = CURDATE()

select itemid,title,description,cat,fibre,washing,colours,promo,
       isnull(max(case when seqnum = 1 then chm_sizegrouping end),'') as sizes_1,
       isnull(max(case when seqnum = 2 then chm_sizegrouping end),'') as sizes_2,
........

YYYY-MM-DD
YYYY-MM-DD HH:MM
YYYY-MM-DD HH:MM:SS
YYYY-MM-DD HH:MM:SS.SSS
YYYY-MM-DDTHH:MM
YYYY-MM-DDTHH:MM:SS
YYYY-MM-DDTHH:MM:SS.SSS

SELECT id, value, MIN(Signal), MIN(Read), MIN(Firmware), MIN(Date), MIN(Time)
FROM
  ...
GROUP BY
  ID, Value

GRANT SELECT ON SYS.DBA_JOBS_RUNNING TO <user-that-owns-proc>;

merge into A w
using(select a.id_a
           , b.id_2
       from a 
       join rf on (a.id_a = rf.id_a)
       join b   on (b.id_b = rf.id_b) 
     ) q
  on (q.id_a = w.id_a )
when matched then
  update 
     set w.id_2 = q.id_2

select SUBSTRING(ImportCount,13,patindex('% schedule items%',ImportCount)-13) from table name

SELECT REPLACE (ENTITY_KEY, 'rss_user_name=CN=', '')
 FROM    (select * --or relevant columns
          from AUDIT_TRAIL_ARCHIVE AU
          union all
          select * 
          from AUDIT_TRAIL AU
           ) AU
   INNER JOIN
      (SELECT RSS_USER_NAME
         FROM RSS_USER
        WHERE RSS_NAME = 'rmad'
              AND ADD_INFO_MASTER LIKE '%__47__UPN=%@richemont.com%') FALSCH
   ON REPLACE (AU.ENTITY_KEY, 'rss_user_name=CN=', '') =
         FALSCH.RSS_USER_NAME
WHERE     AU.RSS_NAME = 'rmad'
   AND AU.TABLE_NAME = 'rss_user'
   AND AU.ACTION = 'Insert'
   AND AU.ENTITY_KEY LIKE 'rss_user_name=CN=%'
   AND AU.ORIGIN != 'RSS'

select * 
from SalesLT.Product 
where 
    (@sizeParam = 1 and Size is null) or
    (@sizeParam = 2 and Size is not null) or
    (@sizeParam = 3)

SQL> SELECT a.*
  2  FROM dual a
  3       JOIN (SELECT * FROM dual WHERE 1=1) b
  4       ON (1=1);

D
-
X

SQL> quit
Disconnected from Oracle9i Enterprise Edition Release 9.2.0.8.0 - Production
With the OLAP and Oracle Data Mining options
JServer Release 9.2.0.8.0 - Production

select t.id, r.name, u.email
from track t
inner join resource r on r.task = 2 and r.track = t.id
inner join users u on u.id = r.name
where t.name LIKE 'html';

SELECT DISTINCT s.PLATFORM_ID, l.GAME_ID
FROM Games g 
LEFT JOIN Links l ON g.ID = l.GAME_ID
INNER JOIN Stores ON l.STORE_ID = s.STORE_ID
INNER JOIN PLATFORMS p ON s.PLATFORM_ID = p.ID

SQL> ed
Wrote file afiedt.buf

  1  SELECT TO_CHAR (TRUNC (SYSDATE), 'FMMonth dd, yyyy fmhh:MI AM') result_two
  2*   FROM DUAL
SQL> /

RESULT_TWO
------------------------------------------------------
December 4, 2012 12:00 AM

declare @colors table (
    id int,
    color nvarchar(100),
    shade nvarchar(100)
)

insert into @colors
        select 23, 'red', 'dark10'
union all select 525, 'red', 'light-10'
union all select 23, 'green', 'light-10'
union all select 324, 'green', 'light-10'

select c.*
from @colors c
inner join (
    select color, shade
    from @colors 
    group by color, shade
    having COUNT(*) > 1
) x
    on x.color = c.color
    and x.shade <> c.shade

select sum(oi.quantity), sum(o.total) as total, 
       o.employee_id as empl 
from orders o join
     (select oi.order_id, sum(oi.quantity) as quantity 
      from order_items oi
      group by oi.order_id
     ) oi
     on oi.order_id = o.id 
group by o.employee_id;

select @strs = name from companies where ...

select 
Col1, 
Col2, 
Col3, 
Col4, 
Col5,
max(isnull(Col6,0)),
max(isnull(Col7,0)),
max(isnull(Col8,0)),
max(isnull(Col9,0))
from table1
group by Col1, Col2, Col3, Col4, Col5

 data want ;
   merge table1(in=in1) table2(in=in2);
   by class student course;
   if in1 ;
   flag=in2;
 run;

WITH cte AS (
  SELECT id, code, 
    MIN(CASE WHEN code='A' THEN 1 WHEN code='B' THEN 2 ELSE 3 END)
    OVER (PARTITION BY id) rank
FROM mytable 
)
SELECT * FROM cte
ORDER BY rank, id, code

select week,
  max(date) max_date,
  min(date) mind_date
from yourtable
group by week;

ALTER DATABASE dbName 
   ADD FILEGROUP ReadOnlyFG;
GO

ALTER DATABASE dbName 
   ADD FILE (
    NAME = ...,
    FILENAME = '...')
   TO FILEGROUP ReadOnlyFG;
GO

ALTER TABLE tableName MOVE TO ReadOnlyFG;
GO

ALTER DATABASE dbName
   MODIFY FILEGROUP ReadOnlyFG READONLY;

OracleCommand command = new OracleCommand(query, connection) 
    { CommandType = CommandType.Text, BindByName = true };

select
  Name = XCol.value('../@Index','varchar(25)'),
  Cat = XCol.value('../@Name','varchar(25)'),
  [Index] = XCol.value('@Index','varchar(25)'),
  Slot = XCol.value('@Slot','varchar(25)')
from
  @input.nodes('/ItemList/Section/Item') AS test(XCol)

select items.id, tags.id
from items
left join itemTags on (items.id=itemTags.itemId)
left join tags on (tags.id=itemTags.tagId)
where not exists(
   select 1 from tagSearch
   left join itemTags on (itemTags.tagId=tagSearch.tagId)
   where itemTags.tagId is null and tagSearch.searchId=?
)

SELECT 
    evt.evt_id,
    evt.name,
    content.content_id,
    content.content_text
FROM t_evt as evt 
  INNER JOIN t_content AS content
     ON evt.evt_id = content.content_evt_fk
  INNER JOIN 
  (
    select content_evt_fk, max(t_content.content_id) content_id
      from t_content
     group by content_evt_fk
  ) last_content
    ON content.content_id = last_content.content_id
--  This is not necessary here, but if you do this sort of thing on 
--  columns other than id, you will have to join this part too
    and content.content_evt_fk = last_content.content_evt_fk

CREATE TABLE TEST_PART
(
  COBDATE                  NUMBER(9)    
)

PARTITION BY RANGE (COBDATE)
SUBPARTITION BY RANGE (COBDATE)
(  
  PARTITION P_2014 VALUES LESS THAN (20150101)
         ( SUBPARTITION P_2014_JAN_01 VALUES LESS THAN (20140102)      TABLESPACE TBS_NAME,
           SUBPARTITION P_2014_JAN_02 VALUES LESS THAN (20140103)      TABLESPACE TBS_NAME,
           .
           .
           .
           SUBPARTITION P_2014_DEC_31 VALUES LESS THAN (20150101)      TABLESPACE TBS_NAME)

 )
NOCACHE            
PARALLEL        
MONITORING;  

WITH RECURSIVE search AS (
   SELECT id, link, data, ARRAY[g.id] AS path, (link = id) AS cycle
   FROM   graph g
   WHERE  NOT EXISTS (
      SELECT 1
      FROM   graph
      WHERE  link = g.id
      )

   UNION ALL
   SELECT g.id, g.link, g.data, s.path || g.id, g.link = ANY(s.path)
   FROM   search s
   JOIN   graph g ON g.id = s.link
   WHERE  NOT s.cycle
   )
SELECT *
FROM   search
WHERE cycle;
-- WHERE cycle IS NOT FALSE;  -- alternative if link can be NULL

select #, name, id
from table
group by #, name, id
having count(*) > 0

select rpad('$', round(salary/1000), '$') as "Graphic" from employees

  (CASE WHEN ISDATE (invoice_date) = 1 
             THEN convert(datetime, cast([invoice_date] as char(8)))
             END) AS Invoice_Date

SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(name, '/', 3), '/', -1)
FROM   my_table

SELECT p.*, s.*
FROM products p CROSS APPLY
     (SELECT TOP(1) s.*
      FROM StockEntries s
      WHERE s.ProductID = p.ProductID
      ORDER BY s.EntryDate DESC
     ) s;

IF EXISTS (
  SELECT 1
  FROM PRESTAMO_SALA PS
  WHERE PS.START_TIME <= @END_TIME 
      AND PS.END_TIME >= @START_TIME 
      AND PS.[DATE] = @DATE
      AND PS.ID_SALA = @ID_SALA 
      )

--DO SOME STUFF

ELSE
--DO SOMETHING ELSE

salesGroupLinked
================
uId
groupId
PerformanceScore

SELECT a.id, a.regname, COUNT(1)
  FROM reg_table a, details_table b,
    details_table c
 WHERE b.replyid=10
   AND b.regid = a.id
     AND c.regid = a.id
GROUP   BY a.id, a.regname

select 
   "(" + DatabaseOpenHelper.KEY_ROW_ID + " - 1)/4 + 1" as field
from 
   table
where 
   field not like '%.%'

SELECT a.PersonID
    ,a.Suranme
    ,a.Forenames
    ,a.DOB
    ,b.FolderRef
    ,c.DateEnded
    ,c.GrossEarnings
FROM Person a
JOIN Folder b ON a.FolderID = b.FolderID
JOIN (
    SELECT e.FolderID
        ,e.DateEnded
        ,e.GrossEarnings
    FROM Earnings e
    JOIN (
        SELECT FolderID
            ,MAX(DateEnded) DateEnded
        FROM Earnings
        GROUP BY FolderID
        ) m ON e.FolderID = m.FolderID
        AND e.DateEnded = m.DateEnded
    ) c ON a.FolderID = c.FolderID

ALTER TABLE Table ALTER COLUMN Field COUNTER(1000000,1)

select employeeID, count(*) from table group by employeeID having count(distinct storeID) > 1

UPDATE conn1.table1
SET table1.USERNAME = 
            (
              SELECT MSUSERNAME  
              FROM conn2.table2@database_link
              WHERE conn2.table2.ID = conn1.table1.USER_ID
            )
;

select sp.name, sum(op.orderQuantity) AS totalQty 
from sm_orderedproduct op
    inner join sm_payment p ON op.orderID = p.orderID 
    inner join sm_product pr ON op.productID = pr.productID
    inner join sm_sellerproduct sp ON sp.productID = pr.productID
where MONTH(str_to_date( dateOfPurchase, '%d/%m/%Y' )) = 7
group by sp.name
order by sum(op.orderQuantity) desc 
limit 4;

SELECT StringColumn, len(StringColumn) AS Length
FROM YourTable
ORDER BY len(StringColumn) DESC

CREATE TABLE Branch_TB(
Branch_Id int NULL,
Branch_Name varchar(50) NULL
)

go
--drop table BranchCity
create table BranchCity(abc varchar(20))

go

create TRIGGER dbo.AddCol
ON Branch_TB
AFTER INSERT AS
BEGIN
    DECLARE @NewVal VARCHAR(20)
    DECLARE @AlterSQL VARCHAR(100)

    CREATE TABLE #New
    (
    VAL VARCHAR(20)
    )

INSERT INTO #New
select Branch_Name from inserted

select @NewVal = Val from #New

SET @AlterSQL = 'ALTER TABLE BranchCity add ' + @NewVal + ' VARCHAR(20)'
exec(@AlterSQL)


END

go

insert into Branch_Tb
values(1, 'City1')

go

insert into Branch_Tb
values(2, 'City2')

INSERT INTO actions(Action) VALUES ('Go to the pub');
SET @aid = LAST_INSERT_ID();

INSERT INTO statements(statement, Language) VALUES ('Have a pint', 'English');
SET @sid = LAST_INSERT_ID();

INSERT INTO Relationships(SID,AID) VALUES (@sid,@aid);

SELECT  'test1' AS [@class]
    , ( SELECT  'test2' as [@class]
        , (SELECT 'Name' FOR XML PATH(''))
        FOR XML PATH('td'), type)
    ,(SELECT  'test3' as [@class]
        , (SELECT 'Value' FOR XML PATH(''))
        FOR XML PATH('td'), type) 
FOR XML PATH('tr'), type

SELECT * FROM TableName WHERE ISDATE(ColumnName) != 1

SELECT t.first_name
FROM `User` `t` 
WHERE FIND_IN_SET('50', `keywords`) > 0
  AND FIND_IN_SET('52', `keywords`) > 0
  AND FIND_IN_SET('53', `keywords`) > 0
  AND FIND_IN_SET('51', `keywords`) = 0;

select y.bar_id, x.baz_id, x.foo_id, x.some_field
from (
    select a.foo_id, a.some_field, b.baz_id
    -- Cross foo_id with all baz_id
    from tbl_foo as a, tbl_baz as b
) as x
    -- Get the bar_id where it exists for each foo_id/baz_id combo
    left join tbl_bar as y on x.foo_id = y.foo_id
        and x.baz_id = y.baz_id
order by x.baz_id, x.foo_id

begin 
    temp_proc;
end;

select count(distinct (COMPONENT_ID || PACKAGE_ID))
  from BILL;

select session_id "sid",SERIAL#  "Serial",
 substr(object_name,1,20) "Object",
 substr(os_user_name,1,10) "Terminal",
 substr(oracle_username,1,10) "Locker",
 nvl(lockwait,'active') "Wait",
 decode(locked_mode,
        2, 'row share',
        3, 'row exclusive',
        4, 'share',
        5, 'share row exclusive',
        6, 'exclusive',  'unknown') "Lockmode",
 OBJECT_TYPE "Type"
 ,ctime "locked_time"
FROM
 SYS.V_$LOCKED_OBJECT A,
 SYS.ALL_OBJECTS B,
 SYS.V_$SESSION c,
 V$LOCK d
WHERE
 A.OBJECT_ID = B.OBJECT_ID AND
 C.SID = A.SESSION_ID
 AND d.sid =A.session_id
ORDER BY 1 ASC, 5 Desc
/

SELECT DISTINCT files.*
FROM
  files INNER JOIN transfers t1
  ON files.id = t1.file_id AND t1.status='failed'
  LEFT JOIN transfers t2
  ON file.id = t2.file_id AND t2.status<>'failed'
WHERE
  t2.id IS NULL

substring(location, locate(',', location)+1)

create global temporary table tmp_stage (
    dwh_key         <your_dwh_key_type@to_devstg>,
    serial_number   <your_serial_number_type@@to_devstg>
) on commit preserve rows;

insert into tmp_stage
select dwh_key, serial_number
from TableA@to_devstg sd
where sd.dwh_key = s.dwh_key;


/* index (PK on dwh_key) your temporary table if necessary ...*/

update (select
         src.dwh_key src_key,
         tgt.dwh_key tgt_key,
         src.serial_number src_serial_number,
         tgt.serial_number tgt_serial_number
       from tmp_stage src
       join TableA tgt
         on src.dwh_key = tgt.dwh_key
       )
  set src_serial_number = tgt_serial_number;

SELECT 
    count(*), 
    tblReplies.repID
FROM 
    tblReplies, 
    tblQuestions, 
    tblUsers
WHERE
    tblQuestions.queID = tblReplies.repQuestionID AND
    tblQuestions.queCompanyID = tblUsers.uCompanyID AND
    tblUser.uID = tblReplies.repUserID AND
    tblUsers.uCompanyID = 1 AND 
    tblQuestions.queID = 68 

GROUP BY tblReplies.repID

UPDATE inventory SET total = (price * quantity)

where @ServiceTypes is null or
      charindex(','+cast(ServiceEntryPart.ServiceTypeIDs as varchar(255)+',',
                ','+@ServiceTypes+',') > 0

private int contextViewId;

@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
    super.onCreateContextMenu(menu, v, menuInfo);
    getMenuInflater().inflate(R.menu.context_menu, menu);
    contextViewId = v.getId();
}

@Override
public boolean onContextItemSelected(MenuItem item) {
    // use contextViewId
}

select f.* 
from Farm f 
left outer join (
    select FarmID 
    from Animal 
    where Name = 'pig'    
) a on f.ID = a.FarmID 
where a.ID is null

Select f1.name as Fighter-1, 
       f2.name as Fighter-2, 
       f3.name as Winner
From 
       battel b,
       fighters f1,
       fighters f2,
       fighters f3
Where
       b.res1 = f1.id AND
       b.res2 = f2.id AND
       b.winner = f3.id AND 
       (f1.id = 225 OR f2.id=225)      

CREATE OR REPLACE TYPE NUMBER_TABLE_TYPE AS TABLE OF NUMBER;


CREATE OR REPLACE PACKAGE BODY IP_Utility AS

    BASE_BIN CONSTANT PLS_INTEGER := 2;
    BASE_OCT CONSTANT PLS_INTEGER := 8;
    BASE_DEC CONSTANT PLS_INTEGER := 10;
    BASE_HEX CONSTANT PLS_INTEGER := 16;

    NUMERIC_OVERFLOW EXCEPTION;
    PRAGMA EXCEPTION_INIT(NUMERIC_OVERFLOW, -1426);

/**
* Function translate a array to PL/SQL Table
* @param Sperator String that separates elements, e.g. ';'
* @return Table of elements (NUMBER)
*/
FUNCTION SplitNumber(LIST IN VARCHAR2, Separator IN VARCHAR2) RETURN NUMBER_TABLE_TYPE IS
    OutTable NUMBER_TABLE_TYPE := NUMBER_TABLE_TYPE();
    ItemEnd PLS_INTEGER;
    ItemStart PLS_INTEGER := 1;

BEGIN
    IF LIST IS NULL THEN
        RETURN NULL;
    END IF;     
    IF LENGTH(LIST) > 0 THEN
        LOOP
            ItemEnd := INSTR(LIST, Separator, ItemStart);
            EXIT WHEN ItemEnd = 0;
            OutTable.EXTEND;
            OutTable(OutTable.LAST) := TRIM(SUBSTR(LIST, ItemStart, ItemEnd-ItemStart));
            ItemStart := ItemEnd + 1;
        END LOOP;           
        OutTable.EXTEND;
        OutTable(OutTable.LAST) := TRIM(SUBSTR(LIST, ItemStart)); -- Append the last element
        RETURN OutTable;
    ELSE
        RETURN NULL;
    END IF;         
END SplitNumber;


/**
* Convert a decimal nubmer into a binary/octal/hex string 
* @param DecN Integer decimal number
* @param Base The binary base (BASE_BIN, BASE_OCT, BASE_HEX)  
* @return The binary/octal/hex string
*/  
FUNCTION Dec2Base(DecN IN INTEGER, Base IN PLS_INTEGER DEFAULT BASE_HEX) RETURN VARCHAR2 DETERMINISTIC IS
    HexString CONSTANT CHAR(16) := '0123456789ABCDEF';
    DecNumber INTEGER := DecN;
    BaseString VARCHAR2(128) := NULL;
BEGIN
    IF DecN IS NULL THEN
        RETURN NULL;
    END IF;
    IF Base > 16 THEN 
        RAISE NUMERIC_OVERFLOW;
    END IF;
    LOOP
        BaseString := SUBSTR(HexString, MOD(DecNumber, Base) + 1, 1 ) || BaseString;
        DecNumber := TRUNC(DecNumber / Base);
        EXIT WHEN DecNumber = 0;
    END LOOP;
    RETURN BaseString;
END Dec2Base;


/**
* Convert a binary/octal/hex number into a decimal value 
* @param BaseString The binary/octal/hex string
* @param Base The binary base (BASE_BIN, BASE_OCT, BASE_HEX)  
* @return The decimal number    
*/
FUNCTION Base2Dec(BaseString IN VARCHAR2, Base IN PLS_INTEGER DEFAULT BASE_HEX) RETURN INTEGER DETERMINISTIC IS
    BaseNumber INTEGER := 0;
    HexString CONSTANT CHAR(16) := '0123456789ABCDEF';
BEGIN
    IF Base > 16 THEN 
        RAISE NUMERIC_OVERFLOW;
    END IF;
    IF BaseString IS NULL THEN
        RETURN NULL;
    END IF;
    FOR i IN 1..LENGTH(BaseString) LOOP
        BaseNumber := BaseNumber * Base + INSTR(HexString, UPPER(SUBSTR(BaseString, i, 1))) - 1;
    END LOOP;
    RETURN BaseNumber;
END Base2Dec;



/**
* Returns SubnetMask of given IP Address
* @param Ip IP-Address with CIDR, e.g. '10.152.10.17/27'
* @return SubnetMask The Subnet Mask in IPv4 Format, e.g. '255.255.255.224'
*/
FUNCTION GetSubnetMask(Ip IN VARCHAR2) RETURN VARCHAR2 DETERMINISTIC IS
    SubnetMask VARCHAR2(16);
    MaskBin VARCHAR2(32);
BEGIN
    IF Ip IS NULL OR NOT REGEXP_LIKE(Ip, '/\d+$') THEN
        RETURN NULL;
    END IF;
    FOR i IN 1..REGEXP_REPLACE(Ip, '.+/') LOOP
        MaskBin := MaskBin || '1';
    END LOOP;
    MaskBin := RPAD(MaskBin, 32, '0');
    FOR i IN 1..4 LOOP
        SubnetMask := SubnetMask ||'.'||Base2Dec(SUBSTR(MaskBin, 8*(i-1)+1, 8 ), BASE_BIN);
    END LOOP;
    SubnetMask := SUBSTR(SubnetMask, 2);
    RETURN SubnetMask;  
END GetSubnetMask;



/**
* Returns Subnet and Broadcast-IP of given IP Address  
* @param Ip IP-Address, e.g. 10.152.10.17
* @param SubnetMask The SubnetMask, e.g. 255.255.255.240  
* @param Subnet Subnet-IP: e.g. 10.152.10.16  
* @param BroadcastIp Broadcast-IP: e.g. 10.152.10.31
*/
PROCEDURE GetIpSubnet(Ip IN VARCHAR2, SubnetMask IN VARCHAR2, Subnet OUT VARCHAR2, BroadcastIp OUT VARCHAR2) IS
    SubnetBin VARCHAR2(8);
    BroadcastBin VARCHAR2(8);
    Ip_Array NUMBER_TABLE_TYPE;
    Mask_Array NUMBER_TABLE_TYPE;
BEGIN
    IF SubnetMask IS NULL OR Ip IS NULL THEN
        RETURN;
    END IF;
    Ip_Array := SplitNumber(Ip, '.');
    Mask_Array := SplitNumber(SubnetMask, '.');
    FOR i IN 1..4 LOOP
        SubnetBin := NULL;
        BroadcastBin := NULL;
        FOR m IN 1..8 LOOP
            IF SUBSTR(LPAD(Dec2Base(Ip_Array(i), BASE_BIN), 8, '0'), m, 1) = 1 
                AND SUBSTR(LPAD(Dec2Base(Mask_Array(i), BASE_BIN), 8, '0'), m, 1) = 1 THEN
                SubnetBin := SubnetBin ||'1';
            ELSE
                SubnetBin := SubnetBin ||'0';
            END IF;         
            IF SUBSTR(LPAD(Dec2Base(Mask_Array(i), BASE_BIN), 8, '0'), m, 1) = 1 THEN
                BroadcastBin := SubnetBin;
            ELSE
                BroadcastBin := BroadcastBin ||'1';
            END IF;         
        END LOOP;
        Subnet := Subnet ||'.'||Base2Dec(SubnetBin, BASE_BIN);
        BroadcastIp := BroadcastIp ||'.'||Base2Dec(BroadcastBin, BASE_BIN);
    END LOOP;
    Subnet := SUBSTR(Subnet, 2);
    BroadcastIp := SUBSTR(BroadcastIp, 2);  
END GetIpSubnet;




END IP_Utility;
/

SELECT s.stats_host,
  h.host_name,
  s.stats_avgcpu,
  s.stats_avgmem,
  s.stats_avgswap,
  s.stats_avgiowait,
  s7.7dayavgcpu,
  s7.7dayavgmem,
  s7.7dayavgswap,
  s7.7dayavgiowait,
  s30.30dayavgcpu,
  s30.30dayavgmem,
  s30.30dayavgswap,
  s30.30dayavgiowait
FROM sar_stats s
INNER JOIN sar_hosts h
  on s.stats_host = h.host_id
INNER JOIN sar_appgroups a
  on h.host_appgroup = a.group_id
  and a.group_name = 'Pervasive'
INNER JOIN sar_environments e
  on h.host_environment = e.env_id
  and e.env_name = 'Staging 2'
LEFT JOIN
(
  SELECT s.stats_host,
    AVG(s.stats_avgcpu) AS '7dayavgcpu',
    AVG(s.stats_avgmem) AS '7dayavgmem',
    AVG(s.stats_avgswap) AS '7dayavgswap',
    AVG(s.stats_avgiowait) AS '7dayavgiowait'
  FROM sar_stats s
  WHERE DATE(stats_report_time) BETWEEN DATE_SUB(curdate(), INTERVAL 8 DAY) AND DATE_SUB(curdate(), INTERVAL 1 DAY)
  GROUP BY s.stats_host
) s7
  on s.stats_host = s7.stats_host
LEFT JOIN
(
  SELECT s.stats_host,
    AVG(s.stats_avgcpu) AS '30dayavgcpu',
    AVG(s.stats_avgmem) AS '30dayavgmem',
    AVG(s.stats_avgswap) AS '30dayavgswap',
    AVG(s.stats_avgiowait) AS '30dayavgiowait'
  FROM sar_stats s
  WHERE DATE(s.stats_report_time) BETWEEN DATE_SUB(curdate(), INTERVAL 31 DAY) AND DATE_SUB(curdate(), INTERVAL 1 DAY)
  GROUP BY s.stats_host
) s30
  on s.stats_host = s30.stats_host
WHERE DATE(s.stats_report_time) =  DATE_SUB(curdate(), INTERVAL 1 DAY);

exp userid=ronr tables=COMM_SCHEDULE_DELIVERY,COMM_SCHEDULE_DETAIL,COMM_SCHEDULE_HEADER file=z.dmp
...
...

imp userid=imp fromuser=ronr touser=imp tables=COMM_SCHEDULE_HEADER,COMM_SCHEDULE_DETAIL,COMM_SCHEDULE_DELIVERY file=z.dmp
Import: Release 11.2.0.3.0 - Production on Tue Aug 7 16:53:34 2012

Copyright (c) 1982, 2011, Oracle and/or its affiliates.  All rights reserved.

Password: 

Connected to: Oracle Database 11g Enterprise Edition Release 11.2.0.3.0 - 64bit Production
With the Partitioning, Real Application Clusters, Automatic Storage Management, OLAP,
Data Mining and Real Application Tes

Export file created by EXPORT:V11.02.00 via conventional path

Warning: the objects were exported by RONR, not by you

import done in US7ASCII character set and AL16UTF16 NCHAR character set
import server uses AL32UTF8 character set (possible charset conversion)
. importing RONR's objects into IMP
. . importing table       "COMM_SCHEDULE_DELIVERY"          0 rows imported
. . importing table         "COMM_SCHEDULE_DETAIL"          0 rows imported
. . importing table         "COMM_SCHEDULE_HEADER"          0 rows imported
Import terminated successfully without warnings.

UPDATE Mytable t
   SET column = REPLACE(t.U_MSG, ', CALL HELPDESK', ' CALL HELPDESK')

/* get list of objects in the database */
SELECT name, 
       type 
FROM  sysobjects
ORDER BY type, name

/* get list of columns in each table / parameters for each stored procedure */
SELECT so.name, 
       so.type, 
       sc.name, 
       sc.number, 
       sc.colid, 
       sc.status, 
       sc.type, 
       sc.length, 
       sc.usertype , 
       sc.scale 
FROM   sysobjects  so , 
       syscolumns  sc 
WHERE  so.id = sc.id 
ORDER BY so.type, so.name, sc.name

/* get definition of each stored procedure */
SELECT so.name, 
       so.type, 
       sc.number, 
       sc.text 
FROM   sysobjects  so , 
       syscomments sc 
WHERE  so.id = sc.id 
ORDER BY so.type, so.name, sc.number 

SELECT Name, City, Birthyear, COUNT(*) AS ct
FROM table
WHERE Birthyear IN (SELECT MIN(Birthyear)
               FROM table
               GROUP by City)
GROUP BY City
ORDER BY Birthyear DESC LIMIT 3;

+-----------------+-------------+------+----+
| name            | city        | year | ct |
+-----------------+-------------+------+----+
| Henry Jones     | Chicago     | 1899 | 1  |
| Mac Taylor      | New York    | 1955 | 1  |
| Sarah Connor    | Los Angeles | 1959 | 1  |
+-----------------+-------------+------+----+

select *
  from (SELECT root as per_id2,
               per_id1,
               PER_LEVEL,
               (case
                 when max(connect_by_root start_dt) >= max(start_dt) then
                  max(connect_by_root start_dt)
                 else
                  max(start_dt)
               end) as max_start,
               (case
                 when min(connect_by_root end_dt) <= min(end_dt) then
                  min(connect_by_root end_dt)
                 else
                  min(end_dt)
               end) AS min_end
          FROM (SELECT connect_by_root per_id2 AS root,
                       per_id1,
                       per_id2,
                       level as per_level,
                       (case
                         when connect_by_root start_dt >= start_dt then
                          connect_by_root start_dt
                         else
                          start_dt
                       end) as start_dt,
                       (case
                         when connect_by_root end_dt <= end_dt then
                          connect_by_root end_dt
                         else
                          end_dt
                       end) as end_dt
                  FROM ci_per_per
                CONNECT BY NOCYCLE PRIOR per_id1 = per_id2)
        CONNECT BY NOCYCLE PRIOR per_id1 = per_id2
               and PRIOR root = root
         GROUP BY per_id1, per_id2, root, per_level)
 where max_start <= min_end 

select a.*
from (select limit 10000 PhoneNumber, max(ApplicationId) as maxaid
      from Application a
      group by PhoneNumber
      order by max(aid) desc
     ) list join
     Application a
     on a.ApplicationId = list.maxaid
order by ApplicationId desc;

    SET NOCOUNT ON
    DECLARE @User TABLE
    (
        id      sysname NOT NULL
        ,title  sysname NOT NULL
    )
    DECLARE @Groups TABLE
    (
        id      sysname NOT NULL
        ,title  sysname NOT NULL
    )
    DECLARE @Membership TABLE
    (
        id      INT NOT NULL
        ,groupid    sysname NOT NULL
        ,memberid   sysname NOT NULL
    )

    INSERT INTO @User( id, title ) SELECT 'myuser1','John' UNION ALL SELECT 'myuser2','Leo'
    INSERT into @Groups( id, title ) SELECT 'myG1','Group1' UNION ALL SELECT 'myG2','Group2'
    INSERT into @Membership( id, groupid, memberid ) SELECT 1,'myG1','myuser1' UNION ALL SELECT 2,'myG1','myG2' UNION ALL SELECT 3,'myG2','myuser2'



    DECLARE @SearchUsergroup sysname='myUser2'
    ;WITH mType(id,title,mType)
    AS
    (
        SELECT id,title,'user' AS mType
        FROM @User
        UNION ALL
        SELECT id,title,'Group' AS mType
        FROM @Groups
    ),
    Ugroups(id,mType,mLevel)
    AS
    (
        SELECT groupid,'Group' as mType, 1 AS mLevel
        FROM @Membership
        WHERE memberid = @SearchUsergroup

        UNION ALL
        SELECT ms.groupid,'Group' as mType, ug.mLevel+1 AS mLevel
        FROM mType mt
        JOIN Ugroups ug
            ON mt.id=ug.id AND ug.mType='Group'
        JOIN @Membership ms
            ON ms.memberid=ug.id
    )
    SELECT id AS GroupID,mLevel AS MembershipLevel
    FROM Ugroups

CAST(REPLACE(CubeNumber,'AA-','') as INT) BETWEEN 1 AND 20;

ALTER TABLE x ADD COLUMN y uniqueIdentifier null
GO
UPDATE TABLE x SET y = NEWID() --Or NEWSEQUENTIALID() if its safe
GO
ALTER TABLE x ALTER COLUMN y uniqueIdentifier NOT NULL
GO
ALTER TABLE x DROP CONSTRAINT PK_PrimaryKeyConstraintName
GO
ALTER TABLE x DROP COLUMN PrimaryKeyColumn
GO
ALTER TABLE x ADD CONSTRAINT PK_NewPrimaryKeyConstraint PRIMARY KEY CLUSTERED 
( 
    y ASC 
)
GO

    update t1
    set t1.curr_value_datetime = t2.curr_value_datetime
    from #temp t1
       join #temp t2
          on t1.curr_value_datetime - 1 = t2.curr_value_datetime

SELECT 
    `newel_inventoryKeywordIdDictionaryId`.`inventoryId`
FROM 
    `newel_inventoryKeywordIdDictionaryId`
    , `newel_inventoryDictionary`
WHERE 
    `newel_inventoryKeywordIdDictionaryId`.`dicId` = `newel_inventoryDictionary`.`dicId` 
    AND ( 
        `newel_inventoryDictionary`.`word` = 'alabaster' OR `newel_inventoryDictionary`.`word` = 'chess'
    ) 
GROUP BY inventoryId 
ORDER BY COUNT(`newel_inventoryKeywordIdDictionaryId`.`inventoryId`) DESC;

SELECT ISNULL(CAST(INT_FIELD as nvarchar(100),'') + ' ' + ISNULL(SOME_OTHER_FIELD,'')
FROM SOME_TABLE;

SELECT version
FROM version_sorting
ORDER BY LENGTH(version),  version;

select t0.*,
  concat(
      case coalesce(t4.parent_id, 0) 
        when 0 then ''
        else concat(cast(t4.parent_id as char), '\\')
      end,
      case coalesce(t3.parent_id, 0) 
        when 0 then ''
        else concat(cast(t3.parent_id as char), '\\')
      end,
      case coalesce(t2.parent_id, 0) 
        when 0 then ''
        else concat(cast(t2.parent_id as char), '\\')
      end,
      case coalesce(t1.parent_id, 0) 
        when 0 then ''
        else concat(cast(t1.parent_id as char), '\\')
      end,
      case coalesce(t0.parent_id, 0) 
        when 0 then ''
        else concat(cast(t0.parent_id as char), '\\')
      end,
      cast(t0.id as char)
    ) as path
from mytable t0
    left join mytable t1 on t0.parent_id = t1.Id
    left join mytable t2 on t1.parent_id = t2.Id
    left join mytable t3 on t2.parent_id = t3.Id
    left join mytable t4 on t3.parent_id = t4.Id
order by 
  concat(
      case coalesce(t4.parent_id, 0) 
        when 0 then ''
        else concat(cast(t4.parent_id as char), '\\')
      end,
      case coalesce(t3.parent_id, 0) 
        when 0 then ''
        else concat(cast(t3.parent_id as char), '\\')
      end,
      case coalesce(t2.parent_id, 0) 
        when 0 then ''
        else concat(cast(t2.parent_id as char), '\\')
      end,
      case coalesce(t1.parent_id, 0) 
        when 0 then ''
        else concat(cast(t1.parent_id as char), '\\')
      end,
      case coalesce(t0.parent_id, 0) 
        when 0 then ''
        else concat(cast(t0.parent_id as char), '\\')
      end,
      cast(t0.id as char)
    )

SELECT COUNT(*) AS Counter 
FROM Groups_Users gu 
JOIN Groups g ON gu.GroupID = g.GroupID 
WHERE
(   
    (    gu.UserID = 3 
     AND gu.IsAdmin = 1 
     AND g.GroupID = 395
    ) 
    OR EXISTS 
        (   SELECT 1 
            FROM Organizations_Users ou 
            WHERE ou.UserID = 3 
              AND ou.IsAdmin = 1 
              AND ou.organizationid = g.organizationid
        ) 
)

sql.eachRow( someQuery, someParams ){ row ->
  render row as JSON
}

Select OSTotal as RevenueDaily, systemlastedittime as
 Lastedittime from AccTransactionHeader where
 CAST(systemlastedittime as DATE) ='2015-02-09'

Product(id, active, allow_new)

pVariable_type(id, name) 

pVariable_data(id, product_fk, pvariable_fk, non_typed_value, bool, int, etc)

SELECT TransDate AS [Transaction Date], Brand, Quantity, Total
FROM DailySalesReport
WHERE SalesmanID = ? AND TransDate = (
    SELECT MAX(TransDate)
    FROM DailySalesReport
    WHERE SalesmanID = ?)

DECLARE @Table TABLE (F FLOAT, D DECIMAL(19,7))

INSERT INTO @Table (F,D)
VALUES(1,1)

INSERT INTO @Table (F,D)
VALUES(1.74269E-06,1.74269E-06)

-- I can see the float here in exponential format
SELECT F,D FROM @Table

-- I can see it here in decimal format
SELECT CONVERT(DECIMAL(19,7),F),D FROM @Table

-- But if I cast to INT it disappears.
SELECT CONVERT(INT,F),D FROM @Table

SELECT i.* FROM items i LEFT OUTER JOIN cart c 
ON i.id = c.item_id WHERE c.sessID=MY_SESSION_ID AND 
c.item_id is not null ORDER BY c.id 

SELECT tc.*, inml.ItemName
FROM ItemCategories tc left outer join
     (select inml.*, row_number() over (partition by inml.ItemId order by hasname, langId) as seqnum
      from ItemNameMultiLang
     ) inml
     on tc.ItemItem = inml.ItemId and
        inml.seqnum = 1
ORDER BY tc.ItemId;

INSERT INTO dummy  (code, invno, ven, invdate, amon, accno, amnt, jno, saccno, ckno)
SELECT
    RES.*
FROM
    (
        SELECT code, invno, ven, invdate, amon, accno, amnt, jno, saccno, ckno 
        FROM accnt 
        UNION ALL
        SELECT code, invno, ven, invdate, amon, accno, amnt, jno, saccno, ckno 
        FROM jobcost 
        UNION ALL
        SELECT code, invno, ven, invdate, amon, accno, amnt, jno, saccno, ckno 
        FROM servic15 
    ) RES
INNER JOIN Mmay M ON RES.jno BETWEEN M.jnost AND M.jnofn

SQL> SELECT name,
  2    status,
  3    xml_configparamdb_id,
  4    xml_configuration_id
  5  FROM
  6    ( SELECT t.*, row_number() over (partition BY name order by status) rn FROM t
  7    )
  8  WHERE rn = 1
  9  ORDER BY xml_configuration_id
 10  /

NAM STATUS   XML_CONFIGPARAMDB_ID XML_CONFIGURATION_ID
--- -------- -------------------- --------------------
STO ACTIVE                      1                    2
BOS ACTIVE                      1                    3
KYC INACTIVE                    1                    4
ACC ACTIVE                      1                    6

SQL>

Create Table Temp (ID BigInt, value Computed_Column_DataType)
Go
Insert Temp(ID, Value)
Select ID, ComputedColumnName
       From Your_Table
Go
Alter Table Your_Table Drop Column ComputedColumnName
Go
Alter Table Your_Table Add ComputedColumnName Computed_Column_DataType
Go
Update Your_Table Set ComputedColumnName = A.Value From Temp A Where A.ID = YourTable.ID

select s.id as student_id, c.id as course_id
from Courses as c
cross join Students as s
left join Student_Course as sc on sc.student_id = s.id and sc.course_id = c.id
where sc.course_id is null -- any sc field defined as "not null"

data expand;
   set <data-name>;
   do time_id = 1 to total_months;
      output;
      end;
   run;

select T1.N.value('@name', 'varchar(max)') as Portal,
       T2.N.value('.', 'varchar(max)') as [Indes]
from @T as T
  cross apply XMLCol.nodes('/Queue/Portal') as T1(N)
  cross apply T1.N.nodes('IndexesForSelect/Index') as T2(N)

SELECT sfo.order_id, sfo.order_number, sfo.item_status, shipping.city, comments.comment
FROM nam_order_items AS sfo
JOIN sales_flat_order_address AS shipping ON shipping.parent_id = sfo.order_id
AND shipping.address_type =  'shipping'
JOIN
(
  select
    parent_id,
    group_concat(concat(created_at, ' - ', comment) order by entity_id asc separator ' ') as comment
  from
    sales_flat_order_status_history
  group by
    parent_id
) comments ON 
  comments.parent_id = sfo.order_id

table_name%RowType

select
    t1.AGENCY_ID,
    ISNULL(t1.LOCAL_ID,t2.LOCAL_ID)LOCAL_ID,
    ISNULL(t1.CLASS,t2.CLASS)CLASS,
    t1.LRS_ID
from table1 t1 
left join table2 t2 on
    t1.LRS_ID = t2.LRS_ID

Select  shipment_no
From    Package
Group BY shipment_no
Having Count(Distinct Truck_No) > 1

select case when (cast('2014-06-14 T11:01:50.000' as datetimeoffset) > getutcdate()) then '1' else '0'end
select case when (cast('2014-06-14' as datetime) > getutcdate()) then '1' else '0'end

SELECT [s? or maybe p?].pid
FROM swapping s INNER JOIN post p ON p.postid=s.postid
WHERE s.mid = '2'
ORDER BY date DESC
LIMIT(0,1)

WHERE dateposted BETWEEN DATE_ADD(NOW(), INTERVAL -7 DAY) AND NOW()

with
tel(sprtele_pidm, mx) as ( SELECT    sprtele_pidm, MAX(SPRTELE_SEQNO) as "mx"
                    FROM      SATURN.SPRTELE where saturn.sprtele.sprtele_tele_code ='CU'
                    GROUP BY sprtele_pidm
                  ) 
SELECT SPRIDEN.SPRIDEN_ID AS Student_ID,
saradap.SARADAP_APST_CODE,
saradap.SARADAP_PIDM,
spriden.spriden_first_name,
spriden.spriden_last_name,
saradap.saradap_program_1,
spraddr.SPRADDR_STREET_LINE1,
spraddr.spraddr_city,
spraddr.spraddr_zip,
spraddr.spraddr_stat_code,
null as STAVAPDC_DESC,
saradap.SARADAP_APPL_DATE,
'Null' AS remove_reason,
'Individual'         AS Account_Name,
saradap.SARADAP_CAMP_CODE,
CONCAT(sprtele_phone_area,
sprtele_phone_number) "Phone",
sprtele_tele_code,
sorcont_ctyp_code,
sorcont_contact_date,
sorcont.sorcont_activity_date
FROM saradap
left join spriden on saradap.saradap_pidm            = spriden_pidm
left join spraddr on  saradap.saradap_pidm      = spraddr.spraddr_pidm
left join tel on saradap.saradap_pidm = tel.sprtele_pidm
left join sprtele ON saradap.saradap_pidm=sprtele.sprtele_pidm and sprtele.sprtele_pidm = tel.sprtele_pidm and sprtele.sprtele_seqno=tel.mx and sprtele.sprtele_tele_code = 'CU'
left join sorcont ON saradap.saradap_pidm = sorcont.sorcont_pidm
WHERE
spriden.spriden_change_ind     IS NULL
AND (saradap.SARADAP_CAMP_CODE       = 'D' or saradap.SARADAP_CAMP_CODE       = 'JD')
AND saradap.saradap_appl_date > SYSDATE - 7
AND spraddr.spraddr_seqno     =
(SELECT MAX(spraddr.spraddr_seqno)
FROM spraddr
WHERE saradap.SARADAP_PIDM    = spraddr.spraddr_pidm
AND spraddr.spraddr_atyp_code = 'CU'
)
AND spraddr.spraddr_atyp_code = 'CU'

SQR( ((X - [User Input for X]) ^ 2) + ((Y - [User Input for Y]) ^ 2) )

select rowid, 
       dbms_rowid.rowid_relative_fno(rowid) as rel_fno,
       dbms_rowid.rowid_row_number(rowid) as row_num,
       dbms_rowid.rowid_block_number(rowid) as block_num, 
       dbms_rowid.rowid_object(rowid)
from points 
order by rowid

SELECT Column1, MIN(Column2)
FROM table
GROUP BY Column1;

SELECT DOW, HH24, AVG(SV_REQUESTS)
  FROM
    (SELECT
      COUNT(*) AS SV_REQUESTS,  
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'MM') AS MM,
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'DD') AS DD,
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'HH24') AS HH24,
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'D-DAY') AS DOW
    FROM ACTIVITY_ACCUMULATOR
    WHERE TIMESTAMP > to_date('01-08-2015','DD-MM-YYYY')
    GROUP BY
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'HH24'),
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'MM'),
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'DD'),
      TO_CHAR(TO_DATE(TIMESTAMP,'DD-MM-YYYY HH24:MI:SS'),'D-DAY'))
GROUP BY DOW, HH24;

DECLARE @WebUrl VARCHAR(35);
SET @WebUrl = 'http://stackoverflow.com/questions/ask?title=trim'

SELECT @WebUrl AS 'WebsiteURL',
       LEFT(SUBSTRING(@WebUrl, 
       (CASE WHEN CHARINDEX('//',@WebUrl)=0 
            THEN 5 
            ELSE  CHARINDEX('//',@WebUrl) + 2
            END), 35),
       (CASE 
       WHEN CHARINDEX('/', SUBSTRING(@WebUrl, CHARINDEX('//', @WebUrl) + 2, 35))=0 
       THEN LEN(@WebUrl) 
       else CHARINDEX('/', SUBSTRING(@WebUrl, CHARINDEX('//', @WebUrl) + 2, 35))- 1
       END)
       ) AS 'Domain

';

COUNT(DISTINCT CASE WHEN [amount] < 1500 THEN AcctNo_PKey END)

LOAD DATA LOCAL INFILE 'C:\\path\\to\\windows\\file.CSV'
INTO TABLE table_name
FIELDS TERMINATED BY ','
LINES TERMINATED BY '\n'
(field1, field2, field3, @fieldx)
SET fieldx = str_to_date(@fieldx, "%d-%m-%Y");

SELECT * FROM table WHERE lower(NAME) like 'john%doe%'

SELECT MIN(id) AS id,
       docID,
       docTypeID,
       CASE WHEN COUNT(1) > 1
            THEN 'multiple makes found'
            ELSE MIN(makeID)
        END AS makeID,
       MIN(desc) AS desc
  FROM simplified_mysql_table
 GROUP
    BY docID,
       docTypeID
       CASE WHEN docTypeID = 1
            THEN 0
            ELSE id
        END
;

CREATE TABLE TestJobSetTable
(
    ID INT IDENTITY(1,1) not null PRIMARY KEY,
    JobID INT not null,
    DateCompleted DATETIME not null
);

--Create some test data
DECLARE @iX INT;
SET @iX = 0
WHILE(@iX < 15)
BEGIN
    INSERT INTO TestJobSetTable(JobID,DateCompleted) VALUES(1,getDate())
    INSERT INTO TestJobSetTable(JobID,DateCompleted) VALUES(34,getDate())
    SET @iX = @iX + 1;
        WAITFOR DELAY '00:00:0:01'
END
--Create some more test data, for when there may be job groups with less than 10 records.
SET @iX = 0
WHILE(@iX < 6)
BEGIN
    INSERT INTO TestJobSetTable(JobID,DateCompleted) VALUES(23,getDate())
    SET @iX = @iX + 1;
        WAITFOR DELAY '00:00:0:01'
END

--Review the data set
SELECT * FROM TestJobSetTable;


--Apply the deletion to the remainder of the data set.
WITH TenMostRecentCompletedJobs AS
(

    SELECT ID, JobID, DateCompleted
    FROM TestJobSetTable A
    WHERE ID in
    (   
        SELECT TOP 10 ID 
        FROM TestJobSetTable
        WHERE JobID = A.JobID
        ORDER BY DateCompleted DESC
    )
)
--SELECT * FROM TenMostRecentCompletedJobs ORDER BY JobID,DateCompleted desc;
DELETE FROM TestJobSetTable 
WHERE ID NOT IN(SELECT ID FROM TenMostRecentCompletedJobs)

--Now only data of interest remains
SELECT * FROM TestJobSetTable

DROP TABLE TestJobSetTable;

SELECT importantfieldOriginal = C1.importantfield COLLATE latin1_general_bin, 
       importantfieldWithOutMask = dbo.Removemask(C1.importantfield, table5.parameter1 , table5.parameter2, table5.parameter2)  COLLATE latin1_general_bin, 
       C1.desc_cuenta COLLATE latin1_general_bin 
FROM   table4 C1 
       JOIN (SELECT TOP 1 * 
             FROM   table2 
             ORDER  BY [date] DESC) C2 
         ON C2.somefield = 'SomeData' 
INNER JOIN table5 ON 1 = 1 

START TRANSACTION;

SELECT * FROM table WHERE id = 1 FOR UPDATE; -- lock rows
-- Or call this select to insert and lock rows
-- INSERT INTO table_output SELECT * FROM table WHERE id = 1 FOR UPDATE;

-- Make modifications
UPDATE table SET column1 = '111' WHERE id = 1;

COMMIT;

 SELECT * FROM users AS u 
 WHERE u.username NOT IN 
 (
     SELECT f.username FROM friends as f
     WHERE f.username = 'kyle'
     OR f.friend = 'kyle'
 )

SELECT TOP 1 S.STREET_NAME,COUNT(a.*) AS dangerous_street 
FROM ACCIDENTS_STREETS A 
inner Join STREET S on S.ID = A.STREET_ID 
GROUP BY S.STREET_NAME ORDER BY dangerous_street DESC

select
  the_date,
  amount,
  (
    select v.interest
    from value v
    where v.the_date <= h.the_date
    order by v.the_date desc
    limit 1
  ) as interest
from history h;

SELECT idPost, Name FROM Posts
INNER JOIN Users ON Poster = idUser

///////////////////////////////////////
// Inside wp-config.php
///////////////////////////////////////

// Get as fancy as you need to in determining your environment
if($_SERVER['HTTP_HOST'] == 'localhost') {
    define('DB_NAME', 'my_local_database');
    define('DB_USER', 'root');
    define('DB_PASSWORD', '');
    define('DB_HOST', 'localhost');
}
else {
    define('DB_NAME', 'my_other_database');
    define('DB_USER', 'username');
    define('DB_PASSWORD', 'password');
    define('DB_HOST', 'path_to_other_host');
}

SELECT AVG(Value)
FROM
(
  SELECT TOP (10) Value
  FROM YourTable
  WHERE ...
  ORDER BY DateColumn DESC
) AS s
;

SELECT user.steamid, user.name, COALESCE(winners.nrwon,0) as nrwon, COALESCE(nrgiveaways.nrgiven,0) as nrgiven
FROM user
LEFT JOIN (SELECT winnerid, COUNT(*) as nrwon FROM giveaway WHERE winnerid IS NOT NULL GROUP BY winnerid) as winners on winners.winnerid = user.steamid
LEFT JOIN (SELECT userid, COUNT(*) as nrgiven FROM giveaway GROUP BY userid) as nrgiveaways on nrgiveaways.userid = user.steamid
WHERE roleid in (1,2,3,4)

select e.entry_id, e.date, e.engineer, e.project, 
       group_concat(a.allowance_name) as allowances
from entries e join
     entries_allowances_map f
     on e.entry_id = eam.entry_id 
     allowances a
     on eam.allowance_id = a.allowance_id
group by e.entry_id;

FOREIGN KEY (user_id) REFERENCES users (user_id) ON DELETE CASCADE ON UPDATE CASCADE

SELECT * 
FROM test
WHERE textnumber >= 'a64'
  AND textnumber <= 'a64.3';

SELECT Field1, OrderFor, Writeback, Actshipdate, Orderstatus, receivedate, receivetime
    FROM orderinfo, shippinginfo
    WHERE orderinfo.orderid = shippinginfo.orderid
    AND shippinginfo.custid = '37782'
    AND receivedate =  DATE(NOW())
     AND receivetime > DATEADD(HOUR, -1, GETDATE())

select
    vendorid, productid, NumSales
from
(
    select
        vendorid, productid, NumSales,
        @r := IF(@g=vendorid,@r+1,1) RowNum,
        @g := vendorid
    from (select @g:=null) initvars
    CROSS JOIN 
    (
        SELECT COUNT(oi.price) AS NumSales, 
               p.productid, 
               p.vendorid
        FROM products p
        INNER JOIN vendors v ON (p.vendorid = v.vendorid)
        INNER JOIN orders_items oi ON (p.productid = oi.productid)
        INNER JOIN orders o ON (oi.orderid = o.orderid)
        WHERE (p.Approved = 1 AND p.Active = 1 AND p.Deleted = 0)
        AND (v.Approved = 1 AND v.Active = 1 AND v.Deleted = 0)
        AND o.`Status` = 'SETTLED'
        AND o.Deleted = 0
        GROUP BY p.vendorid, p.productid
        ORDER BY p.vendorid, NumSales DESC
    ) T
) U
WHERE RowNum <= 3
ORDER BY NumSales DESC
LIMIT 100;

SELECT *
FROM images     
ORDER BY hits DESC
LIMIT 5

select user_id, 
    count(distinct department_id) as dept_count, 
    count(distinct car_id) as car_count,
from (
    select ud.user_id, ud.department_id, c.car_id
    from user_departments ud
    join cars c on c.department_id = ud.department_id
    UNION ALL
    select u.user_id, v.department_id, v.car_id
    from user u
    cross join (
        select d.department_id, c.car_id
        from department d
        join cars c on c.department_id = d.department_id
    ) v
    where not exists (
        select 1 from user_departments ud 
        where ud.user_id = u.user_id
    )
)
group by user_id

SELECT * FROM messages WHERE MessageId IN
(
   SELECT DISTINCT
   CASE WHEN m2.MessageId IS NULL THEN m1.MessageId
   WHEN m1.MessageId > m2.MessageId THEN m1.MessageId ELSE m2.MessageId END
   FROM messages m1
   LEFT JOIN messages m2 ON
   (m1.FROMUSERID = m2.ToUserId
   AND m2.FROMUSERID = m1.ToUserId
   AND m1.MessageId != m2.MessageId)
)
-- AND (messages.FROMUSERID = 123 or messages.ToUserId = 123)

SELECT  Team.teamID 
FROM    Team
WHERE   (@teamid = 0 AND Team.teamID > 0)
        OR (@teamid <> 0 AND Team.teamID = @teamid)

... WHERE path REGEXP '^articles/[^/]+'

WITH T1 as 
(SELECT id,
        parentId,
        NULL as EnabledParentId, 
        ParentID as NextParent 
        FROM T
        WHERE ParentID is not null
UNION ALL
SELECT T1.id, 
       T1.parentId, 
       CASE WHEN T.enabled = 1 
            THEN T.ID 
            ELSE NULL END 
              as EnabledParentId,
       T.ParentID as NextParent
 FROM T1 
 JOIN T ON T1.NextParent = T.Id
 WHERE (nextParent is not Null) and (EnabledParentId IS NULL)
)
SELECT ID,
       ParentID,
       EnabledParentID 
       FROM T1 
       WHERE EnabledParentId IS NOT NULL 
             OR NextParent IS NULL
       ORDER BY ID;

SQL> create table your_table(
  2    tab_id number primary key,
  3    col    number
  4  )
  5  ;

Table created

SQL> create sequence gen_id;

Sequence created

SQL> create trigger TR_PK_your_table
  2  before insert on your_table
  3  for each row
  4  begin
  5    :new.tab_id := gen_id.nextval; -- This kind of assignment is allowed in 11g  
  6  end;                             -- and higher, in version prior to 11g 
  7  /                                -- conventional select statement is used

Trigger created

SQL> insert into your_table(col)
  2  select level 
  3    from dual
  4  connect by level <=7;

7 rows inserted

SQL> commit;

Commit complete

SQL> select *
  2    from your_table;

    TAB_ID        COL
---------- ----------
         1          1
         2          2
         3          3
         4          4
         5          5
         6          6
         7          7

7 rows selected

SQL> create or replace view V_your_table
  2  as
  3  select tab_id
  4       , col
  5       , rownum as num
  6    from your_table
  7  ;

View created

SQL> select *
  2    from v_your_table;

    TAB_ID        COL        NUM
---------- ---------- ----------
         1          1          1
         2          2          2
         3          3          3
         4          4          4
         5          5          5
         6          6          6
         7          7          7

7 rows selected

SQL> delete from your_table where tab_id in (3,5,6);

3 rows deleted

SQL> commit;

Commit complete

SQL> select *
  2    from your_table;

    TAB_ID        COL
---------- ----------
         1          1
         2          2
         4          4
         7          7

SQL> select *
  2    from v_your_table;

    TAB_ID        COL        NUM
---------- ---------- ----------
         1          1          1
         2          2          2
         4          4          3
         7          7          4

SQL> 

WITH recordList 
AS
(
    SELECT  a.Product_TypeID,
            a.ProductID,
            a.Product_Category,
            b.Priority,
            ROW_NUMBER() OVER (PARTITION BY a.ProductID
                                ORDER BY b.Priority) RN
    FROM    Product_Types a
            INNER JOIN Product_Categories b
                ON a.Product_Category = b.Product_Category
)
SELECT      Product_TypeID,
            ProductID,
            Product_Category,
            Priority
FROM    recordList
WHERE   RN = 1

SELECT NULL AS DisplayBox, NULL AS id, NULL AS item
UNION ALL
SELECT CONCAT(id, '   ', item)As DisplayBox, id, item FROM table

SELECT * FROM `userchannels` 
WHERE userID in (user ids comma ceparated) group by channelID
HAVING count(userId)=<amount of user ids>

DELIMITER $$

create trigger my_trigger
AFTER UPDATE on my_update_table
for each row
begin

    DECLARE P1,P2 VARCHAR(50);

    SELECT PRICENAME INTO P1 FROM PRICEIES WHERE PRICEID=OLD.PRICEID;
    SELECT PRICENAME INTO P2 FROM PRICEIES WHERE PRICEID=NEW.PRICEID;
    INSERT INTO AUDITLOG(OLDVALUE, NEWVALUE) VALUES (P1,P2);

end $$

DELIMITER ;

select t.*, 
from (select t.*, lag(dt, 6) over (partition by employeeId order by dt) as ord6dt
      from t
     ) t
where dt - ord6dt < 4.0/24

SELECT COUNT(user_id), user_id, MAX(lastLogin)
FROM login_table
WHERE lastlogin BETWEEN @start AND @end
GROUP BY user_id

select 
    m.sup_email, r.sup_rating 
from 
    (select substr(value, 1, length(value) - length('_email') as sup_name, info as sup_email from table where value like '%_email') as m 
left join 
    (select substr(value, 1, length(value) - length('_rating') as sup_name), info as sub_rating from table where value like '%_rating') as r on m.sup_name = r.sup_name 
order by 
   sup_rating desc 
limit 
    1;

;WITH mytable AS (
   SELECT v2_admin.adminid, 
       v2_admin.adminname, 
       v2_admin.login, 
       v2_admin.email, 
       v2_roles.id 
   FROM   v2_admin 
       INNER JOIN v2_admin_roles 
               ON v2_admin.adminid = v2_admin_roles.adminid 
       INNER JOIN v2_roles 
               ON v2_admin_roles.roleid = v2_roles.id 
   WHERE  v2_admin.adminid = 2 
)

SELECT t1.adminid,t1.adminname, t1.login, t1.email,
       roleIds =REPLACE( (SELECT convert(varchar,id) AS [data()]
                FROM mytable t2
                WHERE t2.adminid = t1.adminid
                --ORDER BY t2.adminid
                FOR XML PATH('')
            ), ' ', ' , ')
FROM mytable t1
GROUP BY t1.adminid,t1.adminname, t1.login, t1.email ;

SELECT
    cc.contact_id,
    cc.name,
    GROUP_CONCAT(ct.name SEPARATOR ', ') AS contact_type
FROM
    contacts AS c
    LEFT JOIN contact_companies AS cc ON c.contact_id = cc.contact_id
    LEFT JOIN contacts_to_types AS ctt ON cc.contact_id = ctt.contact_id
    LEFT JOIN contact_types AS ct ON ctt.contact_type_id = ct.contact_type_id
WHERE
     cc.name LIKE '%p%'
GROUP BY cc.contact_id
ORDER BY name, contact_id

DELETE FROM
  TableA a_
where
  a_.id not in (select number from func$intlist_to_tbl(@idList))

SELECT CASE WHEN t1.id IS NULL THEN t2.id ELSE t1.id END AS id,
    t2.count as count2, t1.count as count1
FROM t1
    FULL OUTER JOIN t2 ON t2.id = t1.id

CREATE VIEW TEST_VIEW AS
    SELECT DEPT, SALES,
           '' AS BLANK_COLUMN, 'Some Text' AS CONSTANT_TEXT_VALUE
    FROM SOME_TABLE;

CREATE OR REPLACE
FUNCTION GET_COST(
  p_parametr1    IN NUMBER DEFAULT NULL,
  p_parametr2  IN NUMBER DEFAULT NULL,
  p_parametr3 IN NUMBER DEFAULT NULL
) RETURN NUMBER
AS
  BEGIN
   RETURN CASE 
    WHEN p_parametr1 = 1 THEN p_parametr2 * 0.1
    WHEN p_parametr1 = 2 THEN p_parametr2 * 0.2
    WHEN p_parametr1 = 3 THEN p_parametr2 * 0.4
    WHEN p_parametr1 = 4 THEN p_parametr2 * 0.6
    WHEN p_parametr1 = 5 THEN p_parametr2 * 0.8
  ELSE NULL
END;
END GET_COST;

select id, perCent, 
       @curRank := if(parent = @prevParent, @curRank + 1, 1) AS rank,
       @prevParent := parent
from (
    select child.id, child.perCent, child.parent
    from likesd parent
    join likesd child
       on parent.id = child.parent
    where parent.type = 3
    order by parent.id, child.perCent desc) x
cross join (SELECT @curRank := 0, @prevParent := null) r

WITH dummy_data AS
  ( SELECT '-1.0' AS txt FROM dual
  UNION ALL
  SELECT '+.0' FROM dual
  UNION ALL
  SELECT '-.1' FROM dual
  UNION ALL
  SELECT '+1,2034.89.0' FROM dual
  UNION ALL
  SELECT '+1,2034.89' FROM dual
  UNION ALL
  SELECT 'Deva +21' FROM dual
  UNION ALL
  SELECT 'DeVA 234 Deva' FROM dual
  UNION ALL
  SELECT '1023' FROM dual
  )
SELECT to_number(REPLACE(txt,',')),
  REGEXP_COUNT(txt,'.')
FROM dummy_data
WHERE REGEXP_LIKE (txt,'^[-+]*')
AND NOT REGEXP_LIKE (TRANSLATE(txt,'+,-.','0000'),'[^[:digit:]]')
AND REGEXP_COUNT(txt,',')  <= 1
AND REGEXP_COUNT(txt,'\+') <= 1
AND REGEXP_COUNT(txt,'\-') <= 1
AND REGEXP_COUNT(txt,'\.') <= 1;

replace(Convert(VARCHAR(20), DATEADD(HOUR, 3, tablename.Created), 120), ' ', ' | ')

SELECT ID, 
    MIN(CASE WHEN STATUS = 1 THEN TIME_UNIX ELSE NULL END) AS FIRST_ENABLE_TIME, 
    MAX(CASE WHEN STATUS = 0 THEN TIME_UNIX ELSE NULL END) AS LAST_DISABLE_TIME,
    TIME_DDMMYY_HHMMSS AS DDMMYYY
FROM MyTable
GROUP BY ID, TIME_DDMMYY_HHMMSS

SELECT sub.entry_id
FROM exp_judging AS jud
LEFT JOIN exp_submissions AS sub ON jud.rel_id = sub.id 
WHERE jud.stage_2 IS NULL
AND jud.stage_1 = 1 
AND sub.member_group = 5
GROUP BY jud.rel_id
HAVING COUNT(*) >= 2

SELECT c.forum_cat_id,
       COUNT(p.fk_forum_cat_id),
       MAX(p.date_added), 
      (SELECT p2.post_title
           FROM forum_post AS p2 
           WHERE p2.forum_cat_id = c.forum_cat_id
           ORDER BY date_added DESC
           LIMIT 1)
    FROM forum_cat AS c INNER JOIN 
               forum_post AS p ON p.fk_forum_cat_id = c.forum_cat_id
    GROUP BY c.forum_cat_id;

SELECT t1.name AS Name, CASE WHEN t1.Interest > 0 THEN Interest ELSE 0 END AS Interest
FROM (select name, (sum(case when TransTypeName like 'credit%' then amount else 0 end) - sum(case when TransTypeName like 'Debit%' then amount else 0 end)) *5/100 as Interest from ...........) as t1

 Dim strSQL As String
 Dim NewTableName As String

 NewTableName = "[Process Order-Oven " & Format(Date, "DD-MM-YYYY") & "]"

 strSQL = "SELECT [Run No], [Product ID], [Process No], [Product Description], " & _
          "[Good Product Produced] INTO " & NewTableName & _
          " FROM [Process Order] WHERE [Process No] = " & txtProc

 CurrentDb.Execute strSQL, dbFailOnError

SELECT DISTINCT a_id
FROM relation_table
WHERE a_id NOT IN (SELECT a_id FROM relation_table WHERE status != 1);

SELECT
   house.*
FROM
   house
   JOIN town ON town.id = house.town
   JOIN state ON state.id = town.state
WHERE state.name = 'Alaska'

-- Just play
use tempdb;
go

-- Drop table
if object_id('abnormal_form') > 0
drop table abnormal_form
go

-- Create table
create table abnormal_form
(
    Id int,
    Category int,
    Name varchar(50)
);

-- Load store products
insert into abnormal_form values
(1, 1, 'Bike'),
(2, 1, 'Bat'),
(3, 1, 'Ball'),
(4, 2, 'Pot'),
(5, 2, 'Pan'),
(6, 2, 'Spoon');

-- Sporting Goods
select * from abnormal_form where Category = 1

-- Home Goods
select * from abnormal_form where Category = 2

-- Does not mean anything to me
select Id1, Id2 from
(select ROW_NUMBER () OVER (ORDER BY ID) AS Rid1, Id as Id1 
 from abnormal_form where Category = 1) as s
join
(select ROW_NUMBER () OVER (ORDER BY ID) AS Rid2, Id as Id2 
 from abnormal_form where Category = 2) as h
on s.Rid1 = h.Rid2

DECLARE @QuestionList nvarchar(max);
SELECT @QuestionList = STUFF(
(SELECT ', ' + quotename(question_id)
FROM YourTable
GROUP BY question_id
ORDER BY question_id
FOR XML PATH(''))
, 1, 2, '');

DECLARE @qry nvarchar(max);
SET @qry = '
SELECT author_id, review_id, ' + @QuestionList + 
FROM (SELECT author_id, review_id, question_id, answer_id
      FROM YourTable
     ) 
PIVOT
(MAX(AnswerID) FOR question_id IN (' + @QuestionList + ')) pvt
ORDER BY author_id, review_id;';

exec sp_executesql @qry;

SELECT temp.inst_id, 
       gv.instance_name,
         CASE WHEN component IS NULL THEN 'others' ELSE component END component,
         ROUND (SUM (size_mb), 1) size_mb,
         ROUND (SUM (used_mb), 1) used_mb
    FROM (SELECT inst_id,
                 CASE
                    WHEN name = 'buffer_cache' THEN 'db_buffer_cache'
                    WHEN name = 'log_buffer' THEN 'log_buffer'
                    ELSE pool
                 END
                    component,
                 ( (bytes / 1024) / 1024) size_mb,
                 CASE
                    WHEN name = 'buffer_cache'
                    THEN
                       (  (  (  bytes
                              -   (SELECT COUNT (*)
                                     FROM gv$bh
                                    WHERE     inst_id = x.inst_id
                                          AND status = 'free')
                                * (SELECT t.VALUE
                                     FROM gv$parameter t
                                    WHERE     t.inst_id = x.inst_id
                                          AND t.name = 'db_block_size'))
                           / 1024)
                        / 1024)
                    WHEN name != 'free memory'
                    THEN
                       ( (bytes / 1024) / 1024)
                 END
                    used_mb
            FROM gv$sgastat x) temp, gv$instance gv
where gv.inst_id = temp.inst_id 
GROUP BY component, gv.inst_id, gv.instance_name
ORDER BY gv.inst_id

MERGE INTO 
...
...
WHEN MATCHED THEN
  UPDATE SET
    NC.A = CASE WHEN NC.status = 'D' THEN OC.Date ELSE NC.A END,
    NC.B = CASE WHEN NC.STATUS = 'O' THEN OC.Date ELSE NC.B END;

update orders o1
join orders o2 on o2.id = o1.parent_id
set o1.paid = now()
where o2.paid <> '0000-00-00 00:00:00'

Delete FROM ALERT_LOGS WHERE TIMESTAMP < DATE '2015-09-01' ;

INSERT INTO TableB
    SELECT *
    FROM (SELECT TOP 10 * FROM TableA ORDER BY NEWID()) AS tmp

(SELECT * FROM table1 WHERE criteria ORDER BY views DESC LIMIT 15)
UNION
(SELECT * FROM table1 WHERE criteria AND id NOT IN(SELECT id FROM table1 WHERE criteria LIMIT 15) ORDER BY date_upload DESC LIMIT 15)

SELECT col1, col2 FROM tbl WHERE col3=:myParam

$ ./mongodump --host prod.example.com
connected to: prod.example.com
all dbs
DATABASE: log    to   dump/log
        log.errors to dump/log/errors.bson
                713 objects
        log.analytics to dump/log/analytics.bson
                234810 objects
DATABASE: blog    to    dump/blog
        blog.posts to dump/log/blog.posts.bson
                59 objects
DATABASE: admin    to    dump/admin

UPDATE t1
SET t1.StageID = 
        (SELECT TOP 1 StageID 
         FROM [RANKING_TABLE] t2 
         WHERE t1.ArticlePoints + t1.PhotoPoints >= t2.MinimumPoints 
         ORDER BY t2.MinimumPoints DESC)
FROM [USER_TABLE] t1

DECLARE @PivotData table(grade int, listening float, speaking float, reading float, writing float)
INSERT into @PivotData
SELECT 0, 0.0, 0.0, 0.0, 0.0 UNION ALL
SELECT 1, 399.4, 423.8, 0.0, 0.0 UNION ALL
SELECT 2, 461.6, 508.4, 424.4, 431.5 UNION ALL
SELECT 3, 501.0, 525.9, 492.8, 491.3

SELECT TestType, [0] As gr0, [1] as gr1, [2] as gr2, [3] as gr3
FROM
(
    SELECT grade, TestType, score
    FROM 
    (
        SELECT grade, listening, speaking, reading, writing from @PivotData
    ) PivotData
    UNPIVOT
    (
        score for TestType IN (listening, speaking, reading, writing)
    ) as initialUnPivot
) as PivotSource
PIVOT 
(
    max(score) FOR grade IN ([0], [1], [2], [3])
) as PivotedData

insert  into `films_genres_temp`
    (`id`,`film_id`,`genre_id`,`num`) 
    values 
    (1,1,1,1),
    (2,1,17,2),
    (3,2,1,1),
    ...

insert into `films_genres`
    (`film_id`,`genre_id`)
    select `film_id`,`genre_id`
        from `films_genres_temp`

select o.o_id 
from owner o
join vehicles v on o.v_id = v.v_id
where v.v_type = 'bike'
group by o.o_id 
having count(distinct v.v_id) = (select count(*) from vehicles where v_type = 'bike')

table userinfo (
     user,
     email,
     address,
     primary key(user),
     CONSTRAINT tb_uq UNIQUE (email)
);

SELECT MAX(PRODUCTID) AS PRODUCTID, UPC
FROM Products
GROUP BY UPC
HAVING COUNT(UPC) > 1

 SELECT *
   FROM events ev 

  WHERE CASE alarm_type WHEN 'set_date' THEN FIND_IN_SET('2014-09-25',event_alarm_date)>0 
                        WHEN 'days' THEN FIND_IN_SET('Mon',alarm_days) > 0 
                        WHEN 'monthly' THEN FIND_IN_SET('2',monthly_alarm_days) > 0 
        END = 1
  ORDER 
     BY start_time;

public function getAuthPassword()
{
     return $this->attributes['passwordFieldinYourTable'];//change the 'passwordFieldinYourTable' with the name of your field in the table
}

Set DateFormat DMY
GO
Select Cast(Stuff(Stuff(SomeValue, 3, 0, '-'), 6, 0, '-') As datetime)
From MyData

...
Group by ...
Having max(date) <= someValue and min(date) >= someValue

INSERT INTO SklepZaloha
    (`Time`, Boiler, Zpatecka, Vymnenik)
  SELECT i1.`Time`, i1.Value, i2.Value, i3.Value
    FROM Item1 i1
    INNER JOIN Item2 i2
      ON i1.`Time` = i2.`Time`
    INNER JOIN Item3 i3
      ON i1.`Time` = i3.`Time`;

SELECT 1.Label, COUNT(2.values)
FROM Table1 1
    LEFT JOIN Table2 2 ON 1.fk = 1.pk and
              2.Date BETWEEN 1/1/2010 AND 12/31/2010    
GROUP BY 1.Label

 SELECT id, TYPE FROM (
   SELECT id, TYPE, 
   IF(@myvar = 0 OR @myvar = TYPE, @counter := @counter + 1, @counter := 1) sequence,  
   @myvar := TYPE FROM mytable 
   JOIN (SELECT @myvar := 0, @counter := 0 ) a
   ORDER BY TYPE DESC, id) b 
ORDER BY sequence, TYPE DESC,  id

SELECT [Purchased Product], sum(CONVERT(INT, [Purchased Quantity])) as [Purchased Quantity],
       datename(month, [Purchased Date])  AS [Purchased Date]
from StudentPurchasedHistoryTable
WHERE DATENAME(month, [Purchased Date]) = 'August'
group by [Purchased Product], datename(month, [Purchased Date]);

SELECT  ID, 
        UserID, 
        Ranks
FROM
    (
        SELECT  id,
                userid,
                @group:=CASE WHEN @temp <> userid THEN 1 ELSE @group+1 END AS ranks,
                @temp:=userid AS clset
        FROM    (SELECT @group:= 0) s,
                (SELECT @temp:= 0) c,
                (SELECT * FROM hits ORDER BY userid, id) t
    ) x
ORDER   BY ID

SELECT `t`.`Status`. FROM `t`

Select custs.*, Sum(dem.amnt * (1 - dem.paid)) As balance
FROM custs
LEFT JOIN dem
On custs.name = dem.c_name 
GROUP BY custs.name

(select max(load_control_id)
from edw.dbo.load_control
Where package_name = ?)

SELECT st_contains(a.way, b.way)
FROM yourtable AS a, yourtable AS b
WHERE 
    a.gid = yourfirstid
    AND b.gid = yoursecondid

UPDATE ingredient_aliases
SET a.ingredient_id = 
     (SELECT MAX(ingredient_id) AS max_id
      FROM ingredient_aliases
      WHERE name LIKE '%WATER%'
        AND ingredient_id IS NOT NULL)
WHERE name LIKE '%WATER%' 
    AND ingredient_id IS NULL

DECLARE @CheckDate DATE
SET @CheckDate='2014/5/13'
SELECT DATEPART(hh, DespositDate), COUNT(1)
FROM table t
WHERE account = 'XYZ' AND CAST(DepositDate AS DATE)=@CheckDate
GROUP BY DATEPART(hh, DespositDate)

SELECT b.* 
FROM follow a 
INNER JOIN position b 
  ON a.user_id = b.follow_id 
INNER JOIN
(
    select max(date) MaxDate, follow_id
    from position
    group by follow_id
) b1
    on b.follow_id = b1.follow_id
    and b.date = b1.MaxDate
INNER JOIN referent_follow c 
  ON a.user_id = c.follow 
WHERE c.referent = 14 
ORDER BY b.date DESC

delete t1
from yourtable t1
    join yourtable t2 on t1.id > t2.id
        and t1.name = t2.name 
        and t1.foreignkey = t2.foreignkey

INSERT INTO student(first_name,school_id)
SELECT first_name, 1 FROM `TABLE 13`

SELECT People.IDPerson, People.NAME
FROM
(
    -- Selects people that never made a sticker transaction

    SELECT p.IDPerson, p.NAME
    FROM Person p
    LEFT JOIN StickerTransaction sT
    ON p.IDPerson = sT.IDPerson
    WHERE sT.IDPerson IS NULL

    UNION

    -- Selects people that have currently 0 sticker

    SELECT p.IDPerson, p.NAME
    FROM Person p
    JOIN     (
                SELECT sT.IDPerson, SUM(NbStickers) AS NbStickers
                FROM (

                       SELECT (sT.NbStickersReceived - sT.NbStickersGiven) AS NbStickers
                       FROM StickerTransaction sT

                     UNION ALL

                       SELECT pu.NbStickersBought AS NbStickers
                       FROM Purchase pu
                     ) dt
                GROUP BY sT.IDPerson
                HAVING SUM(NbStickers) = 0
             ) sT
    ON sT.IDPerson = p.IDPerson

) People

select
replace(replace(replace([type],'/',''),'PS',''),'\','')
from
table1 
where 
[Type] like '%PS%'

SELECT attendance_date, 
       SUM(CASE WHEN attendance_status = 19 THEN 1 ELSE 0 END) AS total_cars_dispatched, 
       SUM(CASE WHEN attendance_status = 4 THEN 1 ELSE 0 END) AS attendance_status_4
FROM driver_attendance da 
LEFT JOIN collectible co ON da.driver_attendance_id=co.driver_attendance_id
LEFT JOIN driver_pondo dp ON dp.collectible_id=co.collectible_id
WHERE company_id=84 
GROUP BY attendance_date DESC;

UPDATE dbo.User_Data
SET name = N'Kramarić'
WHERE User_PKID= 3047

INSERT INTO _YourSecondTableName_  (feed_id,title,description,item_link,item_updated,item_id,created_at,updated_at,is_hidden)  
SELECT feed_id,title,description,item_link,item_updated,item_id,created_at,updated_at,is_hidden  
FROM _YourFirstTableName_  
ORDER BY created_at ASC

SQL>  rename old_table to something_else;
SQL>  rename new_table to old_table;
SQL>  drop table something_else;

select t.receiver as person, count(t.day) as LastReceiverTotal from Throws t
inner join (SELECT MAX(thrownum) AS LastThrowNum, day FROM Throws GROUP BY day) a on a.LastThrowNum = t.thrownum and a.day = t.day
group by t.receiver

SELECT reservation.reservation_id, customer.customer_id, customer.name, 
count(ordered_services.reservation_id) AS num_of_ordered_services,
(SELECT count(*) FROM payments WHERE reservation.reservation_id=payments.reservation_id) AS num_of_payments
FROM reservations
JOIN customers ON reservations.customer_id = customer.customer_id
LEFT JOIN ordered_services ON reservations.reservation_id = ordered_services.reservation_id
GROUP BY reservation.reservation_id, customer.customer_id, customer.name
ORDER BY reservation.reservation_id

Declare @Nousager           As Int = 3
Declare @tableVerification  As Table
(
    id  Int,
    Nom Varchar (50)
)

Insert Into @tableVerification
Select  Distinct c.id, c.Nom 
From    Categorie_Equipement    c
Join    Utilisateurs            u   on  u.id = @Nousager
Join    Utilisateurs_Groupe     ug  on  ug.NoUsager = u.id
Join    Groupe_Equipements      ge  on  ge.noGroupe = ug.noGroupe

If Not Exists (Select * From @tableVerification)
Begin
    Insert  @tableVerification
    Select  id, Nom 
    From    Categorie_Equipement
End

SELECT * FROM db WHERE (ID = id AND Text != text) OR Text = text

SELECT t.TABLE_NAME As 'Table Name',
       Keys.COLUMN_NAME AS 'Primary Key'
FROM INFORMATION_SCHEMA.TABLES t left outer join
     INFORMATION_SCHEMA.TABLE_CONSTRAINTS Constraints
     on t.TABLE_NAME = Constraints.Table_name and
        t.Table_Schema = Constraints.Table_Schema left outer join
     INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS Keys 
     ON Constraints.TABLE_NAME = Keys.TABLE_NAME and
        Constraints.CONSTRAINT_NAME = Keys.CONSTRAINT_NAME and
        Constraints.CONSTRAINT_TYPE = 'PRIMARY KEY'

CREATE OR REPLACE FUNCTION GET_RANDOM_STRING(v_length NUMBER) RETURN VARCHAR2
IS
    lKey VARCHAR2(4000);
BEGIN
   FOR I IN 1..v_length LOOP
      lKey := lKey || substr( 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', mod(abs(dbms_random.random), 62)+1, 1);
   END LOOP;

   RETURN lKey;
END;
/

select count(case when T.Name = 0 then 1 end) as NameCount,
       count(case when T.Dept = 0 then 1 end) as DeptCount,
       count(case when T.Project = 0 then 1 end) as ProjectCount
from YourTable as T

SELECT COALESCE(a.SERIES1,b.SERIES2)
FROM TABLE1 a
FULL OUTER JOIN TABLE2 b ON a.CODE = b.CODE

select o.id [tableid], o.name [tableName], c.name [columnName], c.status [columnStatus] t.name [columnType] from sysobjects o
inner join syscolumns c on c.id = o.id
inner join systypes t on t.usertype = c.usertype
where o.type = 'U' and o.name in (tablename)

@h_Startdate = IIf(@year=Empty, @Startdate, convert(datetime, @year+'-01-01', 120))
@h_Enddate = IIf(@year=Empty, @Enddate, convert(datetime, @year+'-12-31', 120))

INSERT INTO {$this->db->dbprefix('term_response')}
SELECT `Crs Code`, 'my term_id value', 'my st_id value'
FROM {$this->db->dbprefix('EnrolmentsList')}
WHERE `Person ID` = 12345;

SELECT
    id,
    -- Usage one
    CASE [fieldToCheck]
        WHEN [value1] THEN [result if the field equals to value1]
        WHEN [value2] THEN [result if the field equals to value2]
        ELSE [If all the above was false]
    END AS [alias]

    -- Usage two
    CASE
        WHEN fieldToCheck = [value1] THEN [result if the condition is true]
        WHEN fieldToCheck = [value2] THEN [result if the condition is true]
        WHEN fieldToCheck = [value3] THEN [result if the condition is true]
        WHEN fieldToCheck = [value4] OR anotherField = [anotherValue] THEN [result if the condition is true]
        ELSE [If all the above was false]
    END
FROM
    [table]

for x in (
            SELECT DISTINCT column_id
            FROM table
            WHERE column_id in (
            SELECT DISTINCT regexp_substr(in_column_ids,'[^,]+', 1, LEVEL) FROM DUAL
            CONNECT BY regexp_substr(in_column_ids, '[^,]+', 1, LEVEL) IS NOT NULL
            )          
            /* WHERE column_id in (15,16,17) =>works */
            /* => in_column_ids is a varchar type which 
                  holds comma separated value */
            and column_title=in_column_title /* works */
    )

SELECT c.CaseNo,
       i.InvFees,
       t.Fees
FROM   tblCases AS c
       INNER JOIN (SELECT CaseNo,
                          Sum(InvFees) AS InvFees
                   FROM   tblInvoices
                   GROUP  BY CaseNo) AS i
         ON c.CaseNo = i.CaseNo
       INNER JOIN (SELECT CaseNo,
                          Sum(Fees) AS Fees
                   FROM   tblTimesheetEntries
                   GROUP  BY CaseNo) AS t
         ON c.CaseNo = t.CaseNo
ORDER  BY c.CaseNo; 

SELECT students.id,students.name,courses.teacher
FROM students
LEFT JOIN (select * from courses WHERE courses.period = '1') courses
ON students.id = courses.student_id

SELECT node.title AS node_title, node.nid AS nid, node.created AS node_created
    FROM {node} node
        WHERE node.status = '1'
            AND node.type = 'portfolio'
            AND node.nid IN  
            (
                SELECT tn.nid AS nid
                FROM {taxonomy_index} tn
                WHERE tn.tid = '1'
            )
            AND upper(node.title) like '%<whatever>%'
            ORDER BY node_created

select top(1) with ties InstructorNo, COUNT(InstCourses.CourseNo) as NoTeachableCourses
from
...
group by InstructorNo
order by NoTeachableCourses desc;

String hql =  "from Segment where segment_number = :segment_number and file = :file";
Query query = session.createQuery(hql).
                 setParameter('segment_number', segment_number).
                 setParameter('file', file, File.class);
List result = query.list()

SELECT t1.ID, t1.RN
FROM Table1 t1
INNER JOIN Table2 t2
    ON t1.RN >= t2.FromRN AND t1.RN <= t2.ToRN

SELECT DISTINCT * 
FROM searchproduct
JOIN part ON searchproduct.id = part.searchproduct_id
INNER JOIN part_attribute p0 ON part.id = p0.part_id
INNER JOIN part_attribute P1 ON p.id = P1.part_attributeheader_id
WHERE (p0.name = 'Colour' AND p0.value IN ('Black')) 
AND (P1.name = 'Size' AND P1.value IN ('11'));

select to_char(res_date, 'FMDAY'), wine 
from DSS_TEST
where to_char(res_date, 'FMDAY', 'NLS_DATE_LANGUAGE=AMERICAN') = 'TUESDAY';

SELECT tblUsers.user_id, tblUsers.user_username, 
       tblUsers.user_password, tblUsers.user_name, 
       tblUsers.user_surname, tblUsers.user_email,
       count(1)
  FROM tblRoles INNER JOIN
       tblUserRole ON tblRoles.role_id = tblUserRole.role_id INNER JOIN
       tblUsers ON tblUserRole.user_id = tblUsers.user_id
 GROUP BY tblUsers.user_id, tblUsers.user_username, 
       tblUsers.user_password, tblUsers.user_name, 
       tblUsers.user_surname, tblUsers.user_email
HAVING count(1) = 1

Select Max(B) as MAXB, Min(B) as MinB, User_ID 
from TableName
group by User_ID   

;WITH summary_table_cte
     AS (SELECT Date,
                Custid,
                CreditDebit,
                Units,
                sum(value) AS [Value]
         FROM   YourTable
         GROUP  BY Date,
                   Custid,
                   CreditDebit,
                   Units)
SELECT *
FROM   summary_table_cte; 

on(
   t1.secondary === t2.id and
   (if(hasFallback.isDefined) t1.fallback.isNotNull else 1 === 1.inhibitWhen(true))
)

select distinct rid,imgpath,rid from(
select imgpath=(select imgpath + ', ' AS 'data()' 
FROM tbl_Temp 
where tbl_Temp.rid=rid   FOR XML PATH('')  ) 
,id,cmpyname,rid from tbl_Temp
) as temp

DECLARE @Start DATETIME = DATEADD(Hour, DATEDIFF(Hour, 0, GETDATE()), 0)
DECLARE @End DATETIME = DATEADD(Hour, 2, @Start)

SELECT dbo.Computer.ComputerName, dbo.Planned.DatePlanned
FROM dbo.Computer 
    INNER JOIN dbo.Planned ON 
        dbo.Computer.ComputerID = dbo.Planned.ComputerID
WHERE dbo.Planned.DatePlanned 
BETWEEN @Start AND @End

Select [Employee ID], Name, @Year As [Year],
IsNull(January, 0)  As January,  IsNull(February, 0)  As February,  IsNull(March, 0)      As March,
IsNull(April, 0)    As April,    IsNull(May, 0)       As May,       IsNull(June, 0)       As June,
IsNull(July, 0)     As July,     IsNull(August, 0)    As August,    IsNull(September, 0)  As September,
IsNull(October, 0)  As October,  IsNull(November, 0)  As November,  IsNull(December, 0)   As December
From 

SET @month_AP = DATENAME(Month, @DATE_AP)

select fName, sName, 
    sum(convert(int, awards)) as awards,
    sum(convert(int, smart)) as smart,
    max([date]) as maxdate
from tablename 
group by fName, sName

SELECT
  name,
  MAX(number) AS number
FROM
  yourTable
GROUP BY
  name

case
    when evaluation in (1,2) then 'bad'
    when evaluation = 3 then 'ok'
    when evaluation = 4 then 'good'
    when evaluation = 5 then 'excellent'
    else 'not filled in'
end

insert into myTable
    values(mybigtype('foo', 'bar', 'fizzle', myarrayoflittletypes(
        (select ref(S)
        from anotherTable S
        where S.stname='dingle'),
        (select ref(S)
         from anotherTable S
         where S.stname='fangle'))));

select a.id, a.val1, a.val2,
       max(case when b.pos = 1 then b.val5 end) as bval1,
       max(case when b.pos = 2 then b.val5 end) as bval2,
       max(case when b.pos = 3 then b.val5 end) as bval3
from a join
     b
     on a.id = b.id
group by a.id, a.val1, a.val2;

SELECT bu.Email,
       MAX(iv.Code) AS Code,
       ex.ExNumber
FROM   Invoices AS iv
       INNER JOIN Clients AS cs
         ON iv.Code = cs.Code
       INNER JOIN BusinessUser_ExNumbers AS ex
         ON cs.ExNumber = ex.ExNumber
       INNER JOIN BusinessUsers AS bu
         ON ex.Userid = bu.Id
WHERE  iv.BatchId = '74b43669-c80f-4b44-999c-a1dfe5695844'
GROUP  BY bu.Email,
          ex.ExNumber  

with CTECount AS (
                  select a.ReportId, a.AttendeeName, 
                        ROW_NUMBER() OVER (PARTITION BY A.ReportId ORDER BY A.AttendeeName) [RowNum],
                        COUNT(A.AttendeeName) OVER (PARTITION BY A.ReportId) [AttendeeCount],
                        CAST(c.TotalExpenseAmount / (COUNT(A.AttendeeName) OVER (PARTITION BY A.ReportId)) AS DECIMAL(10,2)) [PerAmount]
                  FROM @Customer C INNER JOIN @Attendee A ON A.ReportId = C.ReportID 

                  )
SELECT CT.ReportID, CT.CustomerId, AT.AttendeeName, 
       CASE WHEN CC.RowNum = 1 THEN  CT.TotalExpenseAmount - CC.PerAmount *              (CC.AttendeeCount - 1)
            ELSE CC.PerAmount END [AttendeeAmount]
FROM @Customer CT INNER JOIN @Attendee AT 
        ON CT.ReportID = AT.ReportId 
    INNER JOIN CTECount CC 
        ON CC.ReportId = CT.ReportID AND CC.AttendeeName = AT.AttendeeName

select * from
(select discussions.created_at, 
        discussions.title, 
        users.username as discussion_created_by, 
        count(distinct threads.id) over (partition by discussions.created_at, 
                                                      discussions.title, 
                                                      users.username) AS replies, 
        count(distinct discussion_views.time) 
             over (partition by discussions.created_at, 
                                discussions.title, 
                                users.username) AS "views",
        threads.user_id AS latest_post_by,
        threads.updated_at AS latest_post_at,
        row_number() over (partition by discussions.created_at, 
                                        discussions.title, 
                                        users.username
                           order by threads.id desc) AS rn
 from discussions
 left join threads on discussions.id=threads.discussion_id
 left join discussion_views on discussions.id=discussion_views.discussion_id
 join users on users.id=discussions.user_id) sq
where rn=1
order by created_at desc

SELECT a.Name AS ActivityName, c.Name AS ParentName, c.Id AS ParentId
FROM Category c
JOIN Activity a
ON c.Id = a.CategoryId
WHERE a.ParentActivityId IS NULL

UNION 

SELECT a.Name AS ActivityName, c.Name AS ParentName, c.Id AS ParentId
FROM Activity c
JOIN Activity a
ON c.Id = a.ParentActivityId

Restrictions.sqlRestriction("regexp_like({alias}.NODE_1, ?)", re, Hibernate.STRING)

UPDATE Departments
SET numberOfEmployees=(SELECT COUNT(Employees.nameOfEmployee)
FROM Employees
WHERE Departments.numberOfDepartment=Employees.numberOfDepartment)

create index idx_t_id1 on t(id1) include id2

SELECT 
    right('0' + convert(float,AVG(datediff (second, callstartdt,endstartdt))/ 60 % 60), 2) + ':' 
  + right('0' + convert(float,AVG(datediff (second, callstartdt,endstartdt))% 60),2)  as total_time
FROM times

WITH cte AS (
  SELECT id, date, SUM(amount) OVER (ORDER BY date,id) totalamount 
  FROM mytable
)
SELECT TOP 1 totalamount, date 
FROM cte 
WHERE totalamount >= 5000 
ORDER BY date, id;

select dateadd(month,(@YEAR-1900)* 12 + @MONTH - 1,0) + (@DAY-1)

select c.firstname, c.lastname,
       list_agg(p.product||'-'||p.desc, ' , ') within group (order by p.id) as product_and_desc
from customer c join
     product p
     on c.id = p.customer_id
group by c.firstname, c.lastname;

$ mysql -v -e 'select * from barmar_test';
--------------
select * from barmar_test
--------------

+-----------+-----------+---------+------+------+---------------------+------+
| username  | timestamp | partner | e    | en   | t                   | ttx  |
+-----------+-----------+---------+------+------+---------------------+------+
| foo       | NULL      | abc     | N1   | NULL | 2013-07-03 23:27:47 | NULL |
| foo       | NULL      | abc     | 1    | NULL | 2013-07-03 23:25:12 | NULL |
| NULL      | NULL      | abc     | 12   | NULL | 2013-07-03 23:25:12 | NULL |
| foo       | NULL      | abc     | NULL | NULL | 2013-08-30 15:01:39 | NULL |
| foobarbaz | NULL      | abc     | NULL | NULL | 2013-09-02 13:04:00 | NULL |
+-----------+-----------+---------+------+------+---------------------+------+

$rs->search(...)->update({
    bar => \'bar + 1',
});

select TOP 3 * 
from featuredtypes_v F
where
    case
        when @featuretype = 'mobile' then F.MobilePage
        when @featuretype = 'login' then F.LoginPage
        when @featuretype = 'index' then F.IndexPage
    end
    = 1

SELECT SUM(<ColoumnTitle>) As <newColoumnTitle>
FROM <TableName>;

;WITH XMLNAMESPACES (default 'http://www.oliol.com')

UPDATE s
SET s.date_of_birth = (
  SELECT top 1 date_of_birth
  FROM student
  WHERE batch = s.batch
  GROUP BY date_of_birth
  ORDER BY count(*) desc
)
FROM student s
WHERE s.date_of_birth IS NULL

select 'table_A' as table_name, No, date, data from table_A
where No = 1
union all
select 'table_B', No, date, data from table_B
where No = 1
union all
select 'table_C', No, date, data from table_C
where No = 1;

SELECT COUNT(*) AS repetitions, max(ID) FROM users GROUP BY Name, Phone, State HAVING repetitions > 1 ORDER BY ID DESC

SELECT
  M.MID, 
  [Count] = CASE COUNT(*) OVER (PARTITION BY R.RefundID)
    WHEN 1 THEN 'One'
    ELSE 'Many'
  END
FROM #temp T
JOIN Refund R ON R.RefundID = T.RefundID

SELECT 'COLUMN1NAME','COLUMN2NAME'
UNION
SELECT * FROM TableName;

with apcc as (select distinct account id from AccountsPerCostCenters),
a as (
  select id, name, decode(level, 1, 1, -level) l, connect_by_root(id) root
    from accounts 
    connect by prior parent_id = id
    start with id in (select id from apcc)
  union
  select id, name, level l, connect_by_root(id) root
    from accounts 
    connect by parent_id = prior id
    start with id in (select id from apcc) )
select id, name, 
    rank() over (partition by root order by l) lvl, root cost_center
  from a order by root, l

DECLARE @Case TABLE
(
    [CaseDate] datetime,
    [CaseName]  varchar(100),
    [GroupName] varchar(100),
    [ResponsibleName] varchar(100),
    [ResponsibleID] int
)

--get all your case details
INSERT INTO @Case( [CaseDate],[CaseName],
                   [GroupName],[ResponsibleName],[ResponsibleID])
SELECT 
   Case.Date,
   Case.Name,
   Group.Name,
   Responsible.Name
   Responsible.ResponsibleID
FROM      Case
INNER JOIN Group ON Group.GroupID=Case.GroupID
INNER JOIN Responsible ON Responsible.ResponsibleID=Group.ResponsibleID
WHERE CaseID=@CaseID


--now get the Action details for the previous case; 
--are we absolutely sure there is only one row? then an INNER JOIN 
SELECT A.*  
FROM   Action  AS [A] 
INNER JOIN @Case AS C ON A.ResponsibleID=C.ResponsibleID

-- or guard against multiple results in @Case
SELECT A.* FROM Action AS [A] 
WHERE A.ResponsibleID = (SELECT TOP 1 ResponsibleID FROM @Case) 

<script>
function heartBeat() {
    setTimeout(function(){ 
      $.get("heartBeat?id="+mySessionId, function( data ) {
         // you may want to add sanity checks here, e.g. what with invalid session ids?
         heartBeat();   // next call to heartBeat after OK response
      }
    }, 10000);
}
heartBeat();  // first call to heartBeat
</script>

SELECT C.AwardId, C.ProgramName, Count(ClientId) as Intakes 
FROM Client C
LEFT JOIN UserRoleEntity URE ON C.AwardId = URE.EntityId 
LEFT JOIN UserRole UR ON URE.UserRoleId = UR.Id AND UR.CDPUserId = @UserId
WHERE C.Id = @ClientId
 AND (   testFunction(@UserId) = 0
      OR (testFunction(@UserId) <> 0 AND URE.AwardID IS NOT NULL AND UR.ID IS NOT NULL))
GROUP BY C.AwardId, C.ProgramName

select
    sum(Counter),
    datediff(day, @FromDate, CDate) / 7 as ddiff
from WeekDate
-- if you need to filter out rows
where CDate >= @FromDate and CDate <= @ToDate
group by datediff(day, @FromDate, CDate) / 7

with cte
As
(
Select Row_Number() Over(Partition By [Start DATE]
                         Order By Datediff(dd,[Start Date],[End Date]) Asc
) as RNo, [Start Date], [End Date]  from yourtablename )
Select [Start Date],[End Date] from Cte where RNo =1;

WHERE (e.TotalCount = 1 OR e.LastThreeMonths = 1)
     AND OINV.[TaxDate] >= (GETDATE() - 7)

SELECT DISTINCT c.* FROM categories c, categories p
WHERE c.status<>0 and (c.parent_id = 0 OR (c.parent_id=p.id and p.parent_id=0))
ORDER BY c.id,c.position

SELECT STUFF((SELECT ', ' + '<' + NAME + '>'
          FROM   [sys].[login_token]
          ORDER  BY NAME
          FOR XML PATH(''), type).value('.','NVARCHAR(MAX)')
          , 1, 2, '') AS Logins; 

select username,SUM(Total) , DATE
(
    SELECT M.username, count(*) as Total, date(status_date) as Date FROM com_result_b 
       LEFT JOIN members as M on M.member_id = com_result.member_id  
    GROUP BY date(status_date), com_result.member_id  
   UNION ALL
   SELECT M.username, count(*) as Total, date(status_date) as Date FROM com_result_b   
      LEFT JOIN members as M on M.member_id = com_result_b.member_id    
   GROUP BY date(status_date), com_result_b.member_id 
) v

group by username, date

SELECT
 sum("ATD_AMOUNT") AS CREDIT_SUM,
 0 AS DEBIT_SUM,
 "ATD_ACCOUNT_MST_ID",
 "AAD_OPEN_AMOUNT",
 "AAM_ACCOUNT_NAME",
 "AAM_ACCOUNT_CODE",
 "AAD_YEAR_ID"
FROM
 db_accounts."ACC_TRANSACTION_DET" LEFT OUTER JOIN db_accounts."ACC_TRANSACTION_MST"
 ON
   "ATD_TRANSACTION_MST_ID"=
   "ATM_TRANSACTION_MST_ID" LEFT OUTER JOIN db_accounts."ACC_ACCOUNT_MST" ON "ATD_ACCOUNT_MST_ID" = "AAM_ACCOUNT_MST_ID" LEFT OUTER JOIN db_accounts."ACC_ACCOUNT_DET" ON
    "AAM_ACCOUNT_MST_ID" = "AAD_ACCOUNT_MST_ID"
  AND
   "AAD_YEAR_ID"=
   (
    SELECT "AAY_YEAR_ID"
    FROM db_accounts."ACC_ACCOUNT_YEAR"
    WHERE "AAY_IS_CURRENT_YEAR"=true
   )
WHERE
  "ATM_TRANSACTION_DATE"<=$1
 AND
  "ATM_TRANSACTION_DATE">=
  (
   SELECT "AAY_START_DATE"
   FROM db_accounts."ACC_ACCOUNT_YEAR"
   WHERE "AAY_IS_CURRENT_YEAR"=true
  )
 AND
  "ATM_ON_REVERSE_PARENT_TRANSACTION_ID" is null
 AND
  "ATM_IS_CANCELLED"=false
 AND
  "AAM_DEL_FLAG"=false
 AND
  "ATD_CREDIT_DEBIT_TRANSACTION"='CREDIT'
GROUP BY "ATD_ACCOUNT_MST_ID","AAD_OPEN_AMOUNT","AAM_ACCOUNT_NAME","AAM_ACCOUNT_CODE","AAD_YEAR_ID

 SELECT U.Username, COUNT(SC.message) AS comment_count
 FROM song_comments SC JOIN 
      users U ON U.id=SC.user_id
 WHERE U.user_id = 7
 GROUP BY U.Username

SELECT b.bankname, b.city, a.robberydate, AVG(shares)
FROM banks b
join accomplices a on b.bankname = a.bankname
WHERE a.city = 'Chicago' and b.city ='Chicago'
group by b.bankname, b.city, a.robberydate

SELECT 
  p.p_pid, 
  p.p_name, 
  p.p_url 
FROM products p 
INNER JOIN activity a on p.p_pid = a.a_pid 
WHERE 
  a.a_uid= ".$uid_int." 
GROUP BY 
  p_pid, p_name, p_url
ORDER BY 
  max(a.a_time) DESC 
  LIMIT 6

UPDATE wp_posts SET post_date = FROM_UNIXTIME(UNIX_TIMESTAMP('2011-05-02')),
       post_date_gmt = FROM_UNIXTIME(UNIX_TIMESTAMP('2011-05-02'))
       WHERE post_date ="0000-00-00 00:00:00" 

select col1, -- column of table
       col2, -- column of table
       'some text' custom_column -- custom column that will contain text "some text" 
                                 -- in every row
from my_table

select productID
from ProductAttributeValues pav
group by productID
having sum(case when ProductAttributeValues.attrbuteid = X and ProductAttributeValues.Value = X 
                then 1 else 0 end) > 0 and
       sum(case when ProductAttributeValues.attrbuteid = Y and ProductAttributeValues.Value = Y
                then 1 else 0 end) > 0 and
       . . .

SELECT name
FROM   person
WHERE  personnelnumber IN (SELECT   personnelnumber
                           FROM     skillmapping
                           WHERE    (skillid = 2 AND skilllevel = 3) OR
                                    (skillid = 4 AND skilllevel = 5) OR
                                    (skillid = 8 AND skilllevel = 2) 
                           GROUP BY personnelnumber
                           HAVING   COUNT(*) = 3)

PRAGMA foreign_keys = on;

ATTACH DATABASE 'db1.sqlite' AS db1;

ATTACH DATABASE 'db2.sqlite' AS db2;

BEGIN;

CREATE TABLE Fruit      (
                          id            INTEGER PRIMARY KEY NOT NULL,
                          name          TEXT    UNIQUE ON CONFLICT IGNORE
                          )
                          ;

CREATE TABLE Juice      (
                          id            INTEGER PRIMARY KEY NOT NULL,
                          name          TEXT    UNIQUE ON CONFLICT IGNORE
                        )
                        ;

CREATE TABLE Recipe     (
                          id            INTEGER PRIMARY KEY NOT NULL,
                          juice_id      INTEGER NOT NULL,
                          fruit_id      INTEGER NOT NULL,
                          FOREIGN KEY   ( juice_id ) REFERENCES Juice ( id )
                                        ON UPDATE CASCADE
                                        ON DELETE CASCADE,
                          FOREIGN KEY   ( fruit_id ) REFERENCES Fruit ( id )
                                        ON UPDATE CASCADE
                                        ON DELETE CASCADE
                        )
                        ;


INSERT INTO Fruit  ( id, name )               SELECT id, name FROM db1.Fruit;
INSERT INTO Juice  ( id, name )               SELECT id, name FROM db1.Juice;
INSERT INTO Recipe ( id, juice_id, fruit_id ) SELECT id, juice_id, fruit_id FROM db1.Recipe;

INSERT INTO Fruit ( name ) SELECT name FROM db2.Fruit;
INSERT INTO Juice ( name ) SELECT name FROM db2.Juice;

CREATE TEMPORARY TABLE Recipe_tmp AS
                                    SELECT Juice.name AS j_name, Fruit.name AS f_name
                                      FROM db2.Recipe, db2.Fruit, db2.Juice
                                        WHERE db2.Recipe.juice_id = db2.Juice.id AND db2.Recipe.fruit_id = db2.Fruit.id
;

INSERT INTO Recipe ( juice_id, fruit_id ) SELECT j.id, f.id
                                            FROM Recipe_tmp AS r, Juice AS j, Fruit AS f
                                              WHERE r.j_name = j.name AND r.f_name = f.name
;


DROP TABLE Recipe_tmp;

COMMIT;

DETACH DATABASE db1;
DETACH DATABASE db2;

select  b.id
,       b.body
,       count(c.commentid)
from    blog b
left join
        comments c
on      b.id = c.blogid
where   b.status = 'publish'
group by
        b.id
,       b.body
order by
        b.id desc

There is a simple way to populate the NewID column

declare @id int
set @id = 0
update MyTable set NewID=@id, @id=@id+1

TYPE t_record IS
(
    field_1,
    ...
    field_n,
    status VARCHAR2(30)
);

TYPE t_table IS TABLE OF t_record;

FUNCTION insert_records
(
    p_rows_to_insert IN SYS_REFCURSOR
)
    RETURN t_table;

;WITH CTE_Links AS 
(
    SELECT Article1, MIN(Article2) Article2
    FROM dbo.LinkBetweenArticles
    GROUP BY Article1
    HAVING Article1 > MIN(Article2)
)
SELECT a.* 
FROM dbo.ArticlePlacedBySeller a
LEFT JOIN CTE_Links l ON a.Id = l.Article1
WHERE l.Article2 IS NULL

from historyEntry in db.History
join device in db.Devices on history.SerialNumber equals device.SerialNumber
where device.DeviceType == 0
group historyEntry by historyEntry.SerialNumber into historyGroup
select new { ID = historyGroup.Max(entry => entry.ID), SerialNumber = historyGroup.Key }

SELECT XMLQuery(
' for $id in distinct-values(ora:view("SALARIES_LOG")/pay_rise/employee_id)
  let $pay_rises := ora:view("SALARIES_LOG")/pay_rise[employee_id = $id]
  where count($pay_rises) > 1
  return $pay_rises[last()]' 
RETURNING CONTENT) FROM dual;

  qualify 
        ROW_NUMBER() OVER (PARTITION BY Unique_SQL_ID
                               ORDER BY impactCPU DESC
                          )
                             = 1

declare @Start datetime = '2011-05-18T12:00:00'

;with cte as
(
  select Value,
    row_number() over(order by ID) as rn
  from YourTable 
)
update cte set
  Value = dateadd(s, 15*(rn-1), @Start)

SELECT * FROM VALID_LIST WHERE NOT EXISTS 
  (SELECT * FROM PREFIX_LIST WHERE VALID_LIST.Part1 LIKE '%' || Item || '%')
  AND NOT EXISTS
  (SELECT * FROM SUFFIX_LIST WHERE VALID_LIST.Part2 LIKE '%' || Item || '%')

SELECT UMEMBERID, FIRSTNAME, LASTNAME, BIRTHDATE, MAX(PUBLICATIONDT)
FROM MY_TABLE
WHERE INDENTIFIER IN ('GROUP1') 
AND PUBLICATIONDT >= DATE'2014-01-01'
AND PUBLICATIONDT <= DATE'2014-12-31'
GROUP BY UMEMBERID, FIRSTNAME, LASTNAME, BIRTHDATE;

UPDATE YourTable
SET YourIntCol = 2
WHERE YourOtherCol LIKE '%abc%'

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SELECT ename, sal, deptno 
FROM emp a 
WHERE not exists (
  SELECT * 
  FROM emp 
  WHERE deptno=a.deptno 
    and sal >= a.sal 
    and ename != a.ename)
ORDER BY sal;

SELECT
  m.ID as MainID,
  m.WhenDate as MainWhenDate, 
  m.InfoText, 
  m.StatusID,
  st.StatusText,
  m.TypeID,
  s.WhenDate as SecondaryWhenDate,
  CASE WHEN s.MainID IS NULL THEN 
    m.WhenDate 
  ELSE 
    s.WhenDate 
  END AS ActualWhenDate
FROM
  Main m
  INNER JOIN Status st ON st.ID = m.StatusID
  LEFT JOIN Secondary s ON s.MainID = m.ID
WHERE
  ( s.MainID IS NULL AND m.WhenDate = <YourDate>
    OR
    s.MainID IS NOT NULL AND s.WhenDate = <YourDate> )
  AND TypeId = <TypeFilter>
  AND ... other filters, if you need any ...

select min(a.rowindx)rowindx, b.rowindx rowindx1 
from dedupinitial a,
dedupinitial b 
where a.rowindx < b.rowindx --and a.rowindx 
 and a.poivalue = b.poivalue 
group by b.rowindx
order by 1;

select distinct id,name
 from table1
 where (id like '%1%' or name like '%c%') and id <> 'A1002'

UPDATE report.TEST target
SET    is Deleted = 'Y'
WHERE  NOT EXISTS (SELECT 1
                   FROM   main.TEST source
                   WHERE  source.ID = target.ID);

SELECT   group, 
         MIN(date) || '..' || MAX(date) AS date_range, 
         MAX(date) - MIN(date) AS days_between
FROM     mytable
GROUP BY group

Update table one
set column = case 
                     when column = a then z 
                     when column = b then y  
                     .....
                     when column = l then O
                     else column 
                end

SELECT CONVERT(VARCHAR,CAST(STUFF(STUFF(ColumnName,3,0,':'),6,0,':') AS TIME),100)

update digitalassetcontent 
set content = REPLACE(content,0x0D0A09090909090909090909,0x)

insert into persons(id, name, city)
     select st.id, st.name, c.d
     from #StagingTable st left join
          cities c
          on st.city = c.name;

select id, name
from table
where name like 'Ba%' or name like '% Ba%'

select ((floor(finish_time/100)*60)+mod(finish_time,floor(finish_time/100)*100))-((floor(start_time/100)*60)+mod(start_time,floor(start_time/100)*100)) from table;

SELECT iv.*, 
       DATE_FORMAT(_date, '%M') AS month,
       COUNT(1) AS days, 
       ((iv.invoice_amount * count(1)) / (TIMESTAMPDIFF(DAY, iv.start_date, iv.end_date) + 1)) as monthly_amount
FROM (
        SELECT CURDATE() - INTERVAL (a.a + (10 * b.a) + (100 * c.a) + (1000 * d.a) + (10000 * e.a)) DAY AS _date
        FROM (SELECT 0 AS a UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS a
        CROSS JOIN (SELECT 0 AS a UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS b
        CROSS JOIN (SELECT 0 AS a UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS c
        CROSS JOIN (SELECT 0 AS a UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS d
        CROSS JOIN (SELECT 0 AS a UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) AS e
     ) a INNER JOIN invoice iv
WHERE _date BETWEEN iv.start_date AND iv.end_date
group by iv.id, MONTH(_date)
ORDER BY iv.id, MONTH(_date);

update yourTable
set (your XML column).modify('insert <processingData id="guid" someAttrib="x" /> as last into /someData[1]')
where .......

select * from tablename t1
where not exists (select 1 from tablename t2
                  where t1.MobileNO = t2.MobileNO
                    and t2.service <> 'abc')

regexp_replace(col1, E'[^a-z0-9:/\\s]', 'gi')

SELECT * FROM table
   WHERE MONTH(datecolumn) = 1

UPDATE Record
SET IsDuplicateRecord = 1
WHERE Id NOT IN (
    SELECT MIN(Id)
    FROM Record
    GROUP BY ForeignId
)

FROM Users u JOIN Registry r on u.id = r.uid 
LEFT JOIN Cities ci ON u.cityid = ci.id
LEFT JOIN Countries co ON u.countryid = co.id
WHERE u.id = 1 LIMIT 1

SELECT t.A, t2.A FROM table t, table t2 
WHERE t.A < t2.A AND <OLD_CONDITION>

CREATE OR REPLACE function DEMO_FN
(object_type varchar2, table_name varchar2) return varchar2 
is 

v_longstrings varchar2(32223);
c_doublequote      constant char(1)  := '"';  
begin 
v_longstrings := dbms_metadata.get_ddl(object_type,table_name);

-- Remove double quotes from DDL string:
v_longstrings := replace(v_longstrings, c_doublequote || user || c_doublequote || '.','');

-- Remove the following from DDL string:
          -- 1) "new line" characters (chr(10))
          -- 2) leading and trailing spaces
v_longstrings := ltrim(rtrim(replace(v_longstrings, chr(10), '')));
return v_longstrings; 
end;
/

begin
for r in (
  Select DISTINCT (SO.ID),SIM.ICC,SIM.ASSIGNED_ANUMBER_ID,SO.SERVICE_ID,SO.PRODUCT_OPTION_ID,SO.STATUS_ID,SO.END_DATE,DCR.SHOP_ORDER_NUMBER
  FROM SIMCARD@FONIC_RETAIL SIM 
  JOIN SERVICE_OPTION@FONIC_RETAIL SO ON SO.SERVICE_ID=SIM.ASSIGNED_TO_SERVICE_ID
  JOIN DANGAARD_CONFIRM_RECORD@FONIC_RETAIL DCR ON DCR.ICC = SIM.ICC
  where SO.STATUS_ID IN (20,40)
    and SO.ID < to_char(SYSDATE - numtodsinterval (  1,'MINUTE' ), 'YYYYMMDDHH24MISS')||'0000'
    and SO.ID > to_char(SYSDATE - numtodsinterval ( 1, 'HOUR' ), 'YYYYMMDDHH24MISS')||'0000'
) loop
  INSERT INTO TEMP_SERVICE_OPTION_EXTRACTION(ID,ICC,ASSIGNED_ANUMBER_ID,SERVICE_ID,PRODUCT_OPTION_ID,STATUS_ID,END_DATE,ORDER_NUMBER)
  VALUES (r.ID,r.ICC,r.ASSIGNED_ANUMBER_ID,r.SERVICE_ID,r.PRODUCT_OPTION_ID,r.STATUS_ID,r.END_DATE,r.SHOP_ORDER_NUMBER);
  COMMIT;
end loop;
end;

with mycte as
(
    SELECT 0 AS MyHour
    UNION ALL
    SELECT MyHour + 1
    FROM mycte 
    WHERE MyHour + 1 < 24
)
SELECT mycte.MyHour, COALESCE(OrderCount,0) FROM mycte
LEFT JOIN 
(
    SELECT  COUNT(dbo.Uputa.ID) AS OrderCount,{ fn HOUR(dbo.Orders.Date) } AS MyHour
    FROM    Orders       
    WHERE   dbo.Orders.Date BETWEEN '2011-05-01' AND '2011-05-26' 
    GROUP BY { fn HOUR(dbo.Orders.Date) }
) h
ON
  h.MyHour = mycte.MyHour;

UPDATE A
SET    NumberOfShares = B.[Weighted average shares outstanding (Diluted)]
FROM   YahooStockData A
       JOIN (SELECT [Weighted average shares outstanding (Diluted)],
                    derived_2.MorningstarTicker
             FROM   (SELECT *,
                            Row_number() OVER ( partition BY  derived_1.MorningstarTicker, derived_1.[date]
                                ORDER BY derived_1.AsOfDate DESC) AS RN
                     FROM   (SELECT Yahoostockdata.YahooTicker,
                                    IncomeStatement.MorningstarTicker,
                                    yahoostockdata.[Date],
                                    AsOfDate,
                                    Incomestatement.[Weighted average shares outstanding (Diluted)]
                             FROM   IncomeStatement
                                    INNER JOIN YahooStockData
                                            ON IncomeStatement.MorningstarTicker = YahooStockData.MorningstarTicker
                             WHERE  YahooStockData.[Date] >= AsOfDate) AS derived_1) AS derived_2
             WHERE  RN = 1) B
         ON A.MorningstarTicker = B.MorningstarTicker 

String newval=Ecia.getText().toString();

String name_s = c.getString(3);

setMyField(name_s , newval);

public int setMyField(String currvalue , String newvalue)  {
    SQLiteDatabase db = this.getWritableDatabase();
    ContentValues values = new ContentValues();
    values.put(Table1.ABC, newvalue);
    // updating row
    return db.update(Table1.TABLE_NAME, values, Table1.ABC + " = ?",
            new String[] { currvalue });
}

    SELECT a.cat1,
           a.cat2,
           a.cat3,
           a.value1,
           b.value2
    FROM tab1 a
    LEFT OUTER JOIN
      (SELECT cat1,
              cat2,
              cat3,
              max(value2) value2
       FROM tab2
       GROUP BY cat1,
                cat2,
                cat3) b ON a.cat1 = b.cat1
    AND a.cat2 = b.cat2
    AND a.cat3 = b.cat3;

delete 
from table1
where cm_id IN (select um_id from table2 where order_num between 518 and 520)

DECLARE @ret int;
EXECUTE @ret = MyStoredProcedure;

IF (@ret = 0)

...

CREATE EVENT myevent
ON SCHEDULE EVERY HOUR 
DO
UPDATE mytable 
SET status = 0, username = null
where status = 2;

INSERT INTO prod_users (user_id, first_name, last_name)
SELECT ID, FIRST_NAME, LAST_NAME
FROM test_users

UPDATE JAN07
SET ANTE_POST = CASE WHEN TEMPO_INTERCORSO > 0 THEN 1 ELSE 0 END

SELECT *
FROM Video
WHERE visible = 1 
ORDER BY votesUp / IF(votesDown = 0, 1, votesDown) DESC

name.each do |row|
    puts row['firstname']
end

insert into mytable (
    Version, Yr_Varient, Period, CoA, Company, Item, Mvt, Ptnr_Co, Investee,
    FY, GC, LC
) select
    Version, Yr_Varient, Period, CoA, Company, Item, Mvt, Ptnr_Co, Investee,
    2011, GC*1.1, LC*1.1
    from mytable
    where Mvt = 60200
    -- and FY = 2010

UPDATE dbo.invoices
SET    credittotal = credittotal + 100
WHERE  DATEPART (dy, invoices) = 1

SELECT a,b,c from (SELECT a,b,c,d from myTable order by d)

CREATE TABLE #T
(
a varchar(10),
b varchar(10),
c varchar(10)
)

INSERT INTO #T
SELECT 'a ' as a, 'b' as b, 'c ' as c union all
SELECT 'a' as a, 'b' as b, 'c ' as c

SELECT DISTINCT a, b, c  
FROM #T /*1 result*/

SELECT DISTINCT a + '|' + b + '|' + c + '|'   
FROM #T /*2 results*/


SELECT DISTINCT LTRIM(RTRIM(a)) + '|' + LTRIM(RTRIM(b)) + '|' +
                LTRIM(RTRIM(c)) + '|'   
FROM #T /*1 result*/

SQL> with t (ord_qty, item_bkd_qty) as (
  2  select 10, 2 from dual union all
  3  select 10, 3 from dual union all
  4  select 13, 13 from dual union all
  5  select 33, 11 from dual
  6  )
  7  SELECT ord_qty,
  8         item_bkd_qty,
  9         (ord_qty / item_bkd_qty) do_math,
 10         CASE WHEN trunc(ord_qty / item_bkd_qty) = (ord_qty / item_bkd_qty)
 11              THEN          'IS NOT DECIMAL' END case_test
 12    FROM t;
   ORD_QTY ITEM_BKD_QTY    DO_MATH CASE_TEST
---------- ------------ ---------- --------------
        10            2          5 IS NOT DECIMAL
        10            3 3,33333333 
        13           13          1 IS NOT DECIMAL
        33           11          3 IS NOT DECIMAL

INSERT INTO article_rel (x_id, y_id)
  SELECT 12, id
  FROM table_name
  WHERE name = 'string'

SELECT SUBSTRING(Code, LEN(Code)-1,1)

SELECT table1.*, GROUP_CONCAT(table2.job), GROUP_CONCAT(table2.date)
FROM table1
INNER JOIN table2 ON (t1.id = t2.finished_by)
GROUP BY t1.id

SELECT id 
FROM tableA 
WHERE tags LIKE '%1%'

CREATE TABLE #Prod
(
    ID INT IDENTITY(1,1),
    Cat INT,
    Size Int
)

INSERT #Prod SELECT 1,1
INSERT #Prod SELECT 1,1
INSERT #Prod SELECT 1,2
INSERT #Prod SELECT 1,3
INSERT #Prod SELECT 1,3
INSERT #Prod SELECT 1,3
INSERT #Prod SELECT 2,1
INSERT #Prod SELECT 2,2
INSERT #Prod SELECT 2,2
INSERT #Prod SELECT 2,3
INSERT #Prod SELECT 2,3
INSERT #Prod SELECT 2,3

SELECT 
COUNT(*)
FROM #Prod
GROUP BY Cat, Size WITH ROLLUP

SELECT 
COUNT(*)
FROM #Prod
GROUP BY Size , Cat WITH ROLLUP

SELECT inv.Id AS Id, COUNT(s.Id) AS Total, MIN(i.Name) AS Asset
FROM SerialAssets AS s
RIGHT JOIN Inventories AS inv ON s.InventoryId = inv.Id
         AND s.Active = 1
INNER JOIN Items AS i ON inv.ItemId = i.Id
WHERE i.Serialised = 1
GROUP BY inv.Id

Select
c.name as "Name", e.email as "Email"
From
CONT_EMAIL ce
JOIN CONTACTS c on c.ID = ce.name_ID
JOIN EMAILS e on e.ID = ce.email_ID

SELECT * FROM table WHERE 'xyz' IN (akey1, bkey2, ckey3)

textBox1.DataBindings.Add(new System.Windows.Forms.Binding("Text", n.ADataSet, "Table.date", true, System.Windows.Forms.DataSourceUpdateMode.OnValidation, null, "yyyy-MM-dd"));

SELECT  ID, firstname, lastName, Gender,
        STUFF((SELECT ',' + Tag
              FROM TableName
              WHERE ID = a.ID
              FOR XML PATH ('')) , 1, 1, '')  AS TagList
FROM    TableName AS a
WHERE   EXISTS
        (
            SELECT 1
            FROM tableName b
            WHERE b.ID = a.ID
            GROUP BY b.id, b.tag
            HAVING COUNT(*) > 1
        )
GROUP   BY ID, firstname, lastName, Gender

COALESCE(SeriePolita, '') + COALESCE(CAST(CAST(NumarPolita AS numeric) AS NVARCHAR), '') as NrSeriePolita 

drop table test;
create table test (
  n integer not null,
  tf boolean not null default false,
  primary key (n)
);
-- Starts false, set to true.
insert into test values (1, false);
insert into test values (1, false) on duplicate key update tf = (tf or true);
-- Starts false, does not set to true.
insert into test values (2, false);
insert into test values (2, false) on duplicate key update tf = (tf or false);
-- Starts true, set to true.
insert into test values (3, true);
insert into test values (3, true) on duplicate key update tf = (tf or true);
-- Starts true, does not set to false.
insert into test values (4, true);
insert into test values (4, true) on duplicate key update tf = (tf or true);

select * from test;

SELECT DAYNAME(DATE_SUB(CURDATE(), INTERVAL Days.n DAY)) AS `day`,
       COUNT(r.list_date) AS `total`
FROM (SELECT 1 as n UNION ALL SELECT 2 as n UNION ALL 
      SELECT 3 as n UNION ALL SELECT 4 as n UNION ALL
      SELECT 5 as n UNION ALL SELECT 6 as n UNION ALL
      SELECT 7 as n
     ) Days LEFT JOIN
     returns r
     ON r.list_date = DATE_SUB(CURDATE(), INTERVAL Days.n DAY))
GROUP BY Days.n
ORDER BY Days.n;

ORDER BY
   id = 1 DESC, id = 100 DESC, id = 50 DESC

UPDATE Allocation_plan
SET HasClone = 0
WHERE allocation_plan_id IN (
    SELECT Allocation_plan_details_Clone.Allocation_plan_id
    FROM Allocation_plan_details_Clone
    WHERE DATEDIFF(hour, start_date, GETDATE()) > 72
)

    SELECT 
orders.id, orders.date, 
SUM(order_details.qty * order_details.cost) AS amount, 
SUM(order_details.qty) AS qty
FROM  orders  
LEFT JOIN order_details ON  order_details.order_id=orders.id 
AND orders.customer_id = 1 
GROUP BY orders.date
HAVING amount is not null AND qty is not null

SELECT 
    COUNT(*) as Count, 
    sum(sch.HomeTeamID = 34) AS Hawaii_home_count
...

WITH merged_history AS (
    SELECT item_id, SUM(history_volume) AS history_volume,
        (SUM(history_medianprice * history_volume) / SUM(history_volume)) AS history_medianprice,
        history_timestamp::date
    FROM prices_history
    WHERE history_timestamp < NOW()::date - INTERVAL '1 month'
    GROUP BY item_id, history_timestamp::date),
upsert AS ( 
    UPDATE prices_history AS h
    SET history_volume = mh.history_volume, history_medianprice = mh.history_medianprice
    FROM merged_history AS mh
    WHERE h.item_id = mh.item_id AND h.history_timestamp = mh.history_timestamp RETURNING h.*)
INSERT INTO prices_history
SELECT item_id, history_volume, history_medianprice, history_timestamp
FROM merged_history
WHERE NOT EXISTS (
    SELECT 1 FROM upsert AS u, merged_history AS mh
    WHERE u.item_id = mh.item_id AND u.history_timestamp = mh.history_timestamp);

DELETE FROM prices_history
WHERE history_timestamp != history_timestamp::date
    AND history_timestamp < NOW()::date - INTERVAL '1 month';

SELECT
    p.ID,
    p.title,
    p.body,
    p.c_date,
    GROUP_CONCAT(DISTINCT CONCAT_WS('|', 
                                    CAST(t.ID AS CHAR), 
                                    t.title) SEPARATOR ';') AS tags,
    COUNT(DISTINCT c.ID) AS comments
FROM Post p
    LEFT JOIN Comment  AS c  ON p.ID      = c.id_post
    LEFT JOIN Post_Tag AS pt ON p.ID      = pt.id_post
    LEFT JOIN Tag      AS  t ON pt.id_tag = t.ID
GROUP BY p.ID, 
         p.title, 
         p.body, 
         p.c_date;
ORDER BY p.c_date DESC

SELECT hrs.h AS `HOUR`, IFNULL(l.cnt, 0) AS lead_count FROM
(SELECT 0 AS h UNION ALL SELECT 1 AS h UNION ALL SELECT 2 AS h UNION ALL SELECT 3 AS h UNION ALL SELECT 4 AS h UNION ALL SELECT 5 AS h UNION ALL SELECT 6 AS h UNION ALL SELECT 7 AS h UNION ALL SELECT 8 AS h UNION ALL SELECT 9 AS h UNION ALL SELECT 10 AS h UNION ALL SELECT 11 AS h UNION ALL SELECT 12 AS h UNION ALL SELECT 13 AS h UNION ALL SELECT 14 AS h UNION ALL SELECT 15 AS h UNION ALL SELECT 16 AS h UNION ALL SELECT 17 AS h UNION ALL SELECT 18 AS h UNION ALL SELECT 19 AS h UNION ALL SELECT 20 AS h UNION ALL SELECT 21 AS h UNION ALL SELECT 22 AS h UNION ALL SELECT 23 AS h UNION ALL SELECT 24 AS h) hrs
LEFT OUTER JOIN
(SELECT HOUR(created) AS h, COUNT(*) AS cnt FROM lead WHERE created >= CONCAT(CURDATE(), ' 00:00:00') GROUP BY 1) l ON l.h = hrs.h

INSERT INTO Payment (EventCode, EventInstance, EventCount, InvoiceNumber) 
    OUTPUT INSERTED.EventCode, INSERTED.EventInstance, 
           INSERTED.EventCount, INSERTED.InvoiceNumber
    SELECT @EventCode, @EventInstance, 
           isnull(max(EventCount),-1) + 1,
           EventCode + EventInstance + CONVERT(VARCHAR(10), isnull(max(EventCount),-1) + 1)
    FROM   Payment 
    WHERE (EventCode = @EventCode AND
        EventInstance = @EventInstance)

select id,
       fruit,
       subject
  from(select t1.*,
              t2.cnt,
              row_number() over (partition by t1.fruit, t1.subject
                                     order by dbms_random.value) rnk
         from table_1 t1
              join table_2 t2
                on( t1.fruit   = t2.fruit and
                    t1.subject = t2.subject ))
 where rnk <= cnt

CREATE INDEX (Loan_Number, Load_Date) ORDER BY HASH(Loan_Number) ON Loan_Table;

SELECT * 
  FROM Loan_Table AS t1
 WHERE Load_Date = 
  ( SELECT MAX(Load_Date ) 
    FROM Loan_Table AS t2
    WHERE t1.Loan_Number = t2.Loan_Number 
      AND Load_Date  <= DATE '2016-04-30'
  )

declare @wids table ( wid INT PRIMARY KEY )

insert into @wids ( wid )
values ( 64 ), ( 70 ) 

;with xmlnamespaces(default 'http://www.example.com') 
select 
    m.Subject, 
    m.MessageId, 
    m.WordIndex.query(' 
        return 
            <word_list> 
            { 
                for $w in /wi/w
                where $w/@wid = sql:column("w.wid")
                return <word wid="{$w/@wid}" pos="{data($w/p)}"/> 
            } 
            </word_list> 
        ') as WordPosition 
from 
    Message as m
    cross apply @wids w 
where m.WordIndex.exist('wi/w[@wid=sql:column("w.wid")]') = 1

=Sum(Fields!Deposits.Value)

select t.group_id, t.record_id
from [your_table] t
group by t.group_id, t.record_id
having count(*) > 1

--Bye Users!
FOR i IN (SELECT t.username
            FROM DBA_USERS t
           WHERE t.username LIKE 'WIN%') LOOP
  EXECUTE IMMEDIATE 'drop user '|| i.username ||'';
END LOOP;

SELECT
  s.timestamp,
  v.user_id,
  (
   SELECT COUNT(*) FROM user_item_views 
    WHERE timestamp BETWEEN s.timestamp AND ADDTIME(s.timestamp, '00:00:59')
          AND user_id = v.user_id
  ) item_count
FROM
  every_second s
  LEFT JOIN user_item_views v ON v.timestamp = s.timestamp
GROUP BY
  s.timestamp, 
  v.user_id

SELECT Q1.customer_name, Q1.order_date, Q1.price, 
       (
        SELECT COUNT(*) + 1
          FROM MyQuery AS Q2
         WHERE Q2.customer_name = Q1.customer_name
               AND Q2.order_date < Q1.order_date
       ) AS pivot_id
  FROM MyQuery AS Q1;

SELECT id
     , CASE WHEN date1 IS NULL THEN 'date1'
            WHEN date2 IS NULL THEN 'date2'
            WHEN date3 IS NULL THEN 'date3'
            WHEN date4 IS NULL THEN 'date4'
       END AS first_null_date
FROM tbl

Dim ResultTable = From x In Table1 _
                  Group x By x.PKID, x.FID Into grp = Group _
                  Select New With {PKID, FID , .Record = (From x In grp Order By x.DATA Descending).FirstOrDefault()})

select enterprise.loginid,list.name 
from  enterprise
inner join eformdynamic on enterprise.userid = eformdynamic.userid
inner join list on eformdynamic.field12 = list.itemid

select DATEADD(MINUTE,-15,Starttime) from Employees where EmployeeID = 18

select t.*
from `tbl` t
where ( select count(*)
        from `tbl`
        where `team` = t.`team` and `result` >= t.`result` ) < 3

CASE WHEN managerID IS NULL THEN 'SelfManaged' ELSE 'Managed' END  AS Type

SELECT count(*) FROM window...

ALTER TRIGGER [dbo].[trg_Inclusion_Delete]
    ON [dbo].[Inclusion]
    AFTER DELETE
AS 
BEGIN
SET NOCOUNT ON;

    UPDATE Email
    SET NoErrors = -1
    FROM DELETED
    WHERE Email.IssueId = DELETED.IssueId
        AND NOT EXISTS
        (
            SELECT 'x' FROM Inclusion 
            WHERE Inclusion.IssueId = DELETED.IssueId
        )
END

select e.name
from employee e 
inner join customer c on substr(e.telephone, 1, 3) = substr(c.telephone, 1, 3)

select distinct t1.destination,
                      t1.digitsmin,
                      t1.digitsmax,
                      t2.destination,
                      t2.digitsmin,
                      t2.digitsmax,
                      'S'
        from my_codes t1
        join my_codes t2
          on t1.rownumber <> t2.rownumber
         and t1.typ = t2.typ
       WHERE t1.mycarr= 73
         and t1.typ = 'S'
         and t1.digitsmax >= t2.digitsmin
         and t1.digitsmin <= t2.digitsmax;

SELECT * FROM table WHERE DAYNAME(date) = 'Tuesday'

entity --class Foo
field string --fieldName FooBar --column fooBar

CREATE TABLE product_color (
    color_name VARCHAR2(100),
    CONSTRAINT color_pk PRIMARY KEY (color_name)
);

CREATE TABLE product (
    product_id NUMBER,
    product_name VARCHAR2(100),
    color_name VARCHAR2(100),
    CONSTRAINT product_pk PRIMARY KEY (product_id),
    CONSTRAINT color_fk FOREIGN KEY (color_name) 
        REFERENCES product_color (color_name),
    CONSTRAINT product_uk UNIQUE (product_name, color_name)
);

with s as (
    select *,
        count(scm = 0 or null) over w z
    from (
        select *,
            sum(value) over w as scm
        from mytable
        window w as (partition by "user", stock order by id asc)
    ) s
    window w as (partition by "user", stock order by id asc)
)
select *
from
    s
    inner join
    (
        select max(z) z, "user", stock
        from s
        group by "user", stock
    ) z using (z, "user", stock)
where scm > 0
order by s.user, s.stock, id

select case when c.ReplyId is not null then '        ' else '' end
     + UserName + ': ' + c.content Line
  from Comment c
 order by IsNull(c.ReplyId, c.CommentId), c.commentId

drop user "USER1;" cascade;

USE DATABASE_NAME
GO

declare @cmd varchar(4000)
declare cmds cursor for 

select 'DROP TABLE [' + Table_Name + ']'
from INFORMATION_SCHEMA.TABLES
where Table_Name like 'taggregate_temp_%'

open cmds
while 1=1
begin
    fetch cmds into @cmd
    if @@fetch_status != 0 break
    exec(@cmd)
end
close cmds;
deallocate cmds

SELECT ID, COUNT( DISTINCT IP ) AS 'NUM' 
FROM table
GROUP BY ID

select email, 
    CASE language_id WHEN 0 THEN 'English'
                     WHEN 1 THEN 'Japanese'
                     ELSE 'Unknown'
    END as Language
from tgf_mobileuser 
where email is not null;

Use Test;

DECLARE @InvoiceIdSet AS TBIGINT
--INSERT  INTO @InvoiceIdSet
--VALUES  ( 1 ),
--        ( 2 ),
--        ( 3 ),
--        ( 4 )
INSERT  INTO @InvoiceIdSet VALUES  ( -1 )

SELECT TOP 100
        I.Id ,
        Number ,
        DueDate ,
        IssuedDate ,
        Amount ,
        Test3
FROM    dbo.Invoices I
WHERE   I.ID IN ( SELECT    S.ID
                  FROM      @InvoiceIdSet S
                  WHERE     NOT EXISTS ( SELECT NULL
                                         FROM   @InvoiceIdSet
                                         WHERE  ID = -1 )
                  UNION ALL
                  SELECT    S.ID
                  FROM      dbo.Invoices S
                  WHERE     EXISTS ( SELECT NULL
                                     FROM   @InvoiceIdSet
                                     WHERE  ID = -1 ) )

SELECT * FROM tSQLt.Info()

SELECT
  (SELECT SUM(value) FROM credit_balance) + (SELECT SUM(value) FROM debit_balance)

UPDATE tablename
SET
  url =
  CONCAT(
    'http://my.domain.com/wordpress/wp-content/uploads/',
    REPLACE(
      REPLACE(
        SUBSTRING_INDEX(
          SUBSTRING_INDEX(url, '/', -3),
          '-',
          3),
        'temp-',
        ''),
      '-',
      '/'),
    '/',
    SUBSTRING_INDEX(url, '/', -1));

SELECT * FROM TableA
UNION ALL
SELECT B.Order1,A.Response From 
   (
    (SELECT ROW_NUMBER()OVER(ORDER BY Response)PK,* FROM TableB) A Left Join 
    (SELECT ROW_NUMBER()OVER(ORDER BY Order1)PK,* FROM TableA) B On A.PK=B.PK 
   )
Where Response IS NOT NULL

DECLARE
 VAR1 VARCHAR2(500);
 CUR1 SYs_REFCURSOR;
 QUERY_STRING VARCHAR2(2000) := 'SELECT T.COL1 FROM TABLE1 T WHERE T.COL1 IN';

 MYREC IS RECORD 
 (
   COL1 VARCHAR(1000);
 );

 myrecord MYREC;

 BEGIN
  VAR1 := q'['V1','V2']';
  QUERY_STRING:= QUERY_STRING||'('||VAR1||')';

  OPEN CUR1 FOR QUERy_STRING;

    LOOP
      FETCH CUR1 INTO myrecord;
      DBMS_OUTPUT.PUT_LINE(myrecord.COL1);
      EXIT WHEN v_my_ref_cursor%NOTFOUND;
        ..
      -- your processing
    END LOOP;

  CLOSE CUR1;

END;

select city, sum(clients) as clients, sum(staff) as staff
from 
(
  select city, count() as clients, null as staff from clients group by city
  union all 
  select city, null, count() from staff group by city
) tmp
group by city

select coalesce(department, '-')
from table t

select *
from users
order by id, cast(email as varchar2(50))  -- or whatever length you want.

select [Date],Latitude,Longitude,StopName,StopLat,StopLon, dbo.Haversine(Latitude,Longitude,StopLat,StopLon) as distance 
INTO #Distances 
from GPS,STOPS;

select * from #Distances d
join 
(
select [Date],min(distance) minDist from #Distances group by [Date]
) B on (d.[date]=B.[date]) and (d.distance=b.minDist);

select friend_user_id from friends
where user_id = ?
union
select f2.friend_user_id from friends f1
join friends f2 on f2.user_id = f1.friend_user_id
where f1.user_id = ?

 DELETE FROM db.schema.trade_document
 WHERE document_id IN (SELECT document_id
                       FROM document
                       WHERE created_date > 11/10/15);


 DELETE FROM db.schema.document
 WHERE created_date > 11/10/15);

IF NOT EXISTS arenas (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR(40), UNIQUE KEY (name))
begin
    INSERT INTO arenas (name) VALUES ("BigBoy")
end
IF NOT EXISTS players (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR(20), UNIQUE KEY (name))
begin
    INSERT INTO players (name) VALUES ("Mary")
end

INSERT INTO points (playerID, arenaID, points) 
VALUES 
(
    (SELECT players.id FROM players WHERE players.name LIKE "Mary"),
    (SELECT arenas.id FROM arenas WHERE arenas.name LIKE "BigBoy"),
    200
) ON DUPLICATE KEY UPDATE points.points = LEAST(points.points, VALUES(points.points));

declare @cust_tbl table
(
    CustomerId bigint not null 
    ,CustomerName nvarchar(16) not null
    ,Phone nvarchar(32) not null
    ,PhoneType nchar(1) check(PhoneType in ('H','M','W'))
)

insert @cust_tbl
select 1, 'ABC', '123','H'
union select 1, 'ABC', '232','M'
union select 2, 'XXX', '987','W'

select CustomerName Customer
, coalesce([H],'none') PhoneH
, coalesce([W],'none') PhoneW
, coalesce([M],'none') PhoneM
from @cust_tbl
pivot (
    max(Phone) for phonetype in ([H],[W],[M])
) pvt
order by Customer 

SELECT [t].*,
       [d].[Description] AS [Name],
       [d2].[Description] AS [Description]
FROM   [TrainerClass] AS [t] join [DescriptionTranslation] AS [d] on [t].[Code] = [d].[Code]
       join [DescriptionTranslation] AS [d2] on [t].[Code] = [d2].[Code]
WHERE  [d].[TableName] = 'TrainerClass' AND 
       [d].[FieldName] = 'Name' AND 
       [d].[Language] = 'en-EN' AND
       [d2].[FieldName] = 'Description'

case 
    when regexp_like(A, 'XXX/MOSCOW/XXXMSX/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]')
    then 'true' 
    else 'false' 
end

select id, roomid, inv_date, count(room)
from room_inventory
group by id, roomid, inv_date
having count(room) > 1;

SELECT a.*, 
   COALESCE(b.name, c.name), 
   COALESCE(b.field1, c.field1),
   COALESCE(b.field2, c.field2)
FROM events a
...

Select 
    ( select name from items where id = ol.itemid ) as itemname, 
    ol.quantity as quantity_ordered,
    ( select sum(quantity) from deliverylines dl where dl.olid = ol.id ) as quantity_delivered
from orderlines ol 
where orderid = <id>;

select inL.name from dbo.[inventoryLocalization] inL 
where not exists
    (select 1 from fnSplitString(N'red green blue',' ') words 
    where (inL.name NOT LIKE '%'+ words.item +'%'))

select distinct browser from (
select REPLACE (REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE 
(browser, '0', ''),'1', ''),'2', ''),'3', ''),'4', ''),'5', ''),
          '6', ''),'7', ''),'8', ''),'9', '') as  browser
 from  TestTable  group by  browser)  temp

SET @val = -99999  -- or some other value that will never occur in the table
SELECT @val = measurement FROM tbl_data WHERE persid = @curpersid AND yr = @curyear

select
    a, 
    b, 
    c, 
    left(case when t.b > t.c then t.b else isnull(t.c, t.b) end + @f, 10) as d
from
    #myTable t
order by
    someCriteria

DROP C;
DROP B;
DROP A;

SELECT .. FOR UPDATE

SELECT PR.*, 
(
  SELECT PM.image FROM project_media PM
  WHERE PR.project_id = PM.project_id
  ORDER BY PM.project_media_id DESC
  LIMIT 1
) AS image
FROM 
(
  SELECT P.project_id, P.completed 
  FROM project P
  ORDER BY P.completed DESC
  LIMIT 5
) AS PR

CREATE PROC dbo.Answers
@Username nvarchar(20),
@Name nvarchar(20)
AS

declare  @Name2 nvarchar(20)
set @Name2 = ISNULL(@Name, '00')

SELECT *  
FROM dbo.tbl_answer
WHERE an_del = 1 AND ( u_username LIKE ISNULL('%' + @Username + '%', u_username)
  AND  
ISNULL(u_name,'00') LIKE  '%' + @Name2 + '%' )

create view vw_afternoon as
    select id, field_a, field_b, date_field, value_field
    from (select t.*,
                 row_number() over (partition by field_a, field_b, date_field
                                    order by id desc
                                   ) as seqnum
          from t
         ) t
    where seqnum = 1;

create table #t (FEID int, Student_Name char(4), Subject_Name char(5), Marks_Obtained int, 
Result char(5), Result_Code int, NCID char(5), Exam_Name char(12))
go
insert #t values
(  2, 'roof',       'VB   ',   100,       'First',  NULL,   '1234 ',   'ist semester'),
(  2, 'roof',       'VB(P)',   100,       'First',  NULL,   '1234 ',   'ist semester'),
(  2, 'roof',       'C(P) ',   100,       'First',  NULL,   '1234 ',   'ist semester'),
(  2, 'Amir',       'VB   ',   100,       'First',  NULL,   'nbb 8',   'ist semester'),
(  2, 'Amir',       'VB(P)',   100,       'First',  NULL,   'nbb 8',   'ist semester'),
(  2, 'Amir',       'C(P) ',   100,       'First',  NULL,   'nbb 8',   'ist semester')
go

declare @collist nvarchar(max)
SET @collist = stuff((select distinct ',' + QUOTENAME(subject_name) 
            FROM #t -- your table here
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')
select @collist


declare @q nvarchar(max)
set @q = '
select * 
from (
    select 
    Student_Name, subject_name, Marks_Obtained, Exam_Name, Result, NCID, Result_Code
        from (
        select *
        from #t -- your table here
    ) as x
) as source
pivot (
    max(Marks_Obtained)
    for subject_name in (' + @collist + ')
) as pvt
'

exec (@q)

CREATE TABLE a (
    id int,
    other_id int REFERENCES b(id)
);
CREATE TABLE b (
    id int,
    other_id int REFERENCES a(id)
);
INSERT INTO a VALUES (1,1);
INSERT INTO b VALUES (1,1);

with sample_data as (select 5 num from dual union all
                     select 13 num from dual union all
                     select 24 num from dual union all
                     select 1400 num from dual)
select to_char(floor(num/12), 'fm9999909')||to_char(mod(num, 12), 'fm09') yrmn
from   sample_data;

YRMN       
-----------
0005       
0101       
0200       
11608    

CREATE VIEW dbo.VIEW_NAME AS
SELECT a.[no]
    ,a.NAME
    ,a.Sex
    ,a.DBO
    ,a.CaseNo
    ,a.SeqNum
    ,MIN(a.StartDate) StartDate
    ,MAX(b.Admin_1) Admin_1
    ,MAX(b.Admin_2) Admin_2
    ,MAX(b.Admin_3) Admin_3
    ,MAX(c.DisDate) DisDate
    ,MAX(c.DisRea) DisRea
FROM dbo.mem_information AS a
INNER JOIN dbo.auth_information AS b ON b.caseno = a.caseno
    AND b.seqnum = a.seqnum
    AND b.StartDate = a.StartDate
LEFT JOIN dbo.discharge_information AS c ON c.caseno = b.caseno
    AND c.seqnum = b.seqnum
GROUP BY  a.[no]
    ,a.NAME
    ,a.Sex
    ,a.DBO
    ,a.CaseNo
    ,a.SeqNum;

SELECT CUST_ID, CUST_NAME FROM CUSTOMER_TABLE
WHERE CUST_ID IN
(SELECT CUST_ID FROM ORDERS_TBL 
WHERE PROD_ID IN 
(SELECT PROD_ID FROM PRODUCTS_TBL
WHERE COST > 6.5))

SELECT v.*,
       (SELECT avg(r.rate)
        FROM ratings r
        WHERE v.id = r.video_id
       ) as avgrating
FROM videos v;

SELECT * FROM users,room where user_name=concat('tm_',name);

SELECT * FROM fazerem_xius 
WHERE stock_quantity * 1 < minimum_amount * 1
ORDER BY name_products ASC

SELECT * FROM databaseName.INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE 
Where TABLE_NAME='tableName' 

select case
         when column_a = 'Y' then colum_b 
         else colum_d 
       end as name,
       case
          when column_a = 'Y then colum_d
          else column_e
       end as address
from the_table;

SELECT  r.ID,
        r.ProductID,
        r.Rate,
        r.FK_Rate_Category,
        r.Date_Added,
        ar.avgRate
FROM    Rates r
        LEFT JOIN
        (   SELECT  r.Date_Added, 
                    r.FK_Rate_Category, 
                    AVG(r.Rate) AS avgRate
            FROM    Rates r
            GROUP BY r.FK_Rate_Category, r.Date_Added
        ) ar
            ON ar.FK_Rate_Category = r.FK_Rate_Category
            AND ar.Date_Added = r.Date_Added
WHERE   r.ProductID = @ProductID
AND     r.FK_Rate_Category = @FK_Rate_Category;

SELECT finisher.StudentID FROM
(
    SELECT DISTINCT StudentID
    FROM table1 t1
    JOIN table2 t2 ON t2.SubjectID = t1.SubjectID
    WHERE t1.Present = 'yes' AND t1.Type1 = 1
    GROUP BY t1.StudentID, t2.SubjectID
    HAVING COUNT(*) / t2.Number2 >= 0.75
) finisher
JOIN
(
    SELECT DISTINCT t1.StudentID
    FROM table1 t1
    LEFT JOIN
    ( 
        SELECT DISTINCT StudentID 
        FROM table1 
        WHERE Type = 3 AND Present = 'no'
    ) missed ON missed.StudentID = t1.StudentID
    WHERE t1.Type = 3
    AND missed.StudentID IS NULL
) notmissed ON finisher.StudentID = notmissed.StudentID

SELECT PID
FROM tblChild

SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED
SELECT [TBL].[OTHERCOLUMNS], REPLACE([TBL].[URL],'foo.com','bar.org')
INTO ReplacementTBL
FROM [SOURCETBL] [TBL]

GO
SP_RENAME 'schema.SOURCETBL', SOURCETBL_OLD
GO
SP_RENAME 'schema.ReplacementTBL', SOURCETBL

SELECT time
     , @tot_qty := @tot_qty+qty AS tot_qty
FROM Table1 
JOIN (SELECT @tot_qty := 0) d
order by time

SQL> create table test(name varchar2(20), gender number(1));

Table created.

SQL> insert into test values ('Paul', 0);

1 row created.

SQL> insert into test values ('Vicky', 1);

1 row created.

SQL> commit;

Commit complete.

SQL> alter table test add (gender_str varchar2(6) generated always as (case gender when 0 then 'Male' when 1 then 'Female' end));

Table altered.

SQL> select * from test;

NAME                                         GENDER GENDER
-------------------- ------------------------------ ------
Paul                                              0 Male
Vicky                                             1 Female

indexed_col1
indexed_col2
...
indexed_colN
row_pointer

SELECT SUM(Sale_Price)
FROM sales
WHERE Sale_Date < DATE '2015-10-12';

class Role
{
    [Key]
    public int Id { get; set; }

    [MaxLength(127)]
    [Index(IsUnique = true)]
    public string Name { get; set; }       

    public virtual ICollection<User> Users { get; set; }
}

SELECT a.b.value('CURRENCY_FLAG[1]','varchar(10)') AS Currency
FROM @XMLdata.nodes('DataSet/diffgr_diffgram/EA_RESULTS/Table1') a(b)

with cte as(
   select 
          id,
          user_id,val,
          row_number() over(partition by way order by val desc) rank,
          val,
          way      
   from test)
   select distinct cte2.user_id,
          (select count(*) from cte where cte.rank=1 and cte.user_id=cte2.user_id) as MAX1,
          (select count(*) from cte where cte.rank=2 and cte.user_id=cte2.user_id) as MAX2,
          (select count(*) from cte where cte.rank=3 and cte.user_id=cte2.user_id) as MAX3
   from cte cte2 where rank<=3
   order by 1

if(c.getInt(11) == 0) 

SELECT 
    t.name,
    count(c.name)
FROM 

    sys.tables t 
    inner join sys.columns c
    ON t.object_id = c.object_id


group by t.name

select  *
from    Authors
outer apply
        (
        select  top 1 *
        from    Articles
        where   Authors.ID = Articles.AuthorId
        order by
                Articles.PublishDate desc
        ) as LastArticle

select CustomerName, Item, Transaction#, Amount
from purchase
where Transaction# in (select Transaction# from purchase
                       where Item in ('Hammer', 'Screw')
                       group by Transaction#
                       having count(distinct Item) = 2)

  and  Item in ('Hammer', 'Screw')

select (case when @string = substring_index(@string, ', ', 3)
             then substring_index(@string, ', ', 3)
             else concat(substring_index(@string, ', ', 3), '...')
        end)

select col1, (select min(col2) from table2 t2 where t2.col1 = t1.col1)
from table1 t1

CREATE INDEX pub_author_idx_1 
    ON pub_author_map (article);

CREATE INDEX publications_idx_1
    ON publications (pubType);

SELECT group_id, count(*) AS always_declines
FROM (SELECT group_id, visitor_id
      FROM customer_actions 
      GROUP BY group_id, visitor_id
      HAVING SUM(outcome <> 'declined') = 0
     ) gv
GROUP BY group_id;

SELECT LEFT(ID, 8) AS nID,
       SUM(Value) AS tot
FROM your_table
GROUP BY LEFT(ID, 8)

SELECT *
FROM (SELECT DISTINCT column1, colum2 
      FROM table.... 
      WHERE....) A
ORDER BY NEWID()

USE master
 GO
 CREATE PROCEDURE sp_FindDependencies
 (
         @ObjectName SYSNAME,
         @ObjectType VARCHAR(5) = NULL
 )
 AS
 BEGIN
     DECLARE @ObjectID AS BIGINT    

         SELECT TOP(1) @ObjectID = object_id
         FROM sys.objects
         WHERE name = @ObjectName
         AND type = ISNULL(@ObjectType, type)    

     SET NOCOUNT ON ;    

       WITH DependentObjectCTE (DependentObjectID, DependentObjectName, ReferencedObjectName, ReferencedObjectID)
         AS
         (
         SELECT DISTINCT
                sd.object_id,
                OBJECT_NAME(sd.object_id),
                ReferencedObject = OBJECT_NAME(sd.referenced_major_id),
                ReferencedObjectID = sd.referenced_major_id
         FROM    
                sys.sql_dependencies sd
                JOIN sys.objects so ON sd.referenced_major_id = so.object_id
         WHERE   
                sd.referenced_major_id = @ObjectID
         UNION ALL
         SELECT
                sd.object_id,
                OBJECT_NAME(sd.object_id),
                OBJECT_NAME(referenced_major_id),
                object_id
         FROM    
                sys.sql_dependencies sd
             JOIN DependentObjectCTE do ON sd.referenced_major_id = do.DependentObjectID       
         WHERE
                sd.referenced_major_id <> sd.object_id     
         )
         SELECT DISTINCT
                DependentObjectName
         FROM   
                DependentObjectCTE c
 END

SELECT p.*,b.brand_name
    FROM portfolio p
      INNER JOIN branding_category b ON p.brand_category = b.id
      INNER JOIN (
        SELECT MAX(id) MaxMsgIDForThread
        FROM portfolio
        WHERE is_active = '1'

        GROUP BY brand_category
      ) g ON p.id = g.MaxMsgIDForThread
    Order by p.id Desc
    LIMIT 10

with tbl_all (rhp) as
(
 select rhp1 from tbl union all
 select rhp2 from tbl union all
 select rhp3 from tbl union all
 select rhp4 from tbl union all
 select rhp5 from tbl 
)
select rhp , count(1) as count_rhp 
from tbl_all 
group by rhp
order by count_rhp Desc 

Select * from (
Select * from Employee where EmployeeID = 1233 and ManagerID = 2222 and LocationID = 3333;
Union 
Select * from Employee where EmployeeID = 1233 and ManagerID is null and LocationID = 3333
Union
Select * from Employee where  EmployeeID = 1233 and ManagerID = 2222 and LocationID = 3333
Union
Select * from Employee where  EmployeeID = 1233 and ManagerID is null and LocationID is null
) z where z.rownum = 1

class User extends Record[User] {
  val name = "name".TEXT.NOT_NULL
  val admin = "admin".BOOLEAN.NOT_NULL.DEFAULT('false')
}

object User extends Table[User] {
  def byName(n: String): Seq[User] = criteria.add(this.name LIKE n).list
}

// example with foreign keys:
class Account extends Record[Account] {
  val accountNumber = "acc_number".BIGINT.NOT_NULL
  val user = "user_id".REFERENCES(User).ON_DELETE(CASCADE)
  val amount = "amount".NUMERIC(10,2).NOT_NULL
}

object Account extends Table[Account]

User:
| Id    | Name      |Location    | Website          | avatarLarge | avatarSmall
----------------------------------------------------------------------
| 2     | iPityDaFu |Dallas, Tx  | www.example.com  | 124.png     | 124_thumb.png


UserMeta:
Id     | UserId    | MetaKey        | MetaValue
-----------------------------------------------
1      | 2         | Status         | Hungry
2      | 2         | Favorite Color | Blue

SELECT id, 
       nr, 
       cost, 
       A.subtotal AS TOTAL 
FROM   table1 
       INNER JOIN (SELECT nr, 
                          Sum(cost) AS subTotal 
                   FROM   table1 
                   GROUP  BY nr) AS A 
               ON table1.nr = A.nr 

SELECT EmailAddress, CustomerName FROM Customers WHERE EmailAddress IN
(SELECT EmailAddress FROM Customers GROUP BY EmailAddress HAVING COUNT(*) > 1)

SELECT
    p.id
,   p.title
,   MIN(o.price) as min_price
,   MAX(o.price) AS max_price
FROM products p
LEFT JOIN offers o ON o.product_id = p.id
GROUP BY p.id, p.title

SELECT  Stores.Store_ID,
        review.AvgRating,
        cv.VisitsLast20days,
        cv.TotalVisits,
        cv.AvgCustomerAge
FROM    Stores
        LEFT JOIN
        (   SELECT  Store_ID, [AvgRating] = AVG(Rating)
            FROM    Reviews
            GROUP BY Store_ID
        ) review
            ON review.Store_ID = Stores.Store_ID
        LEFT JOIN
        (   SELECT  CustomerVisits.Store_ID,
                    [VisitsLast30Days] = COUNT(CASE WHEN CustomerVisits.VisitDate >= DATEADD(DAY, -30, CURRENT_TIMESTAMP) THEN 1 END),
                    [TotalVisits] = COUNT(*),
                    [AvgCustomerAge] = AVG(DATEDIFF(DAY, Customer.BirthDate, CURRENT_TIMESTAMP)) / 365.25
            FROM    CustomerVisits
                    INNER JOIN Customer
                        ON Customer.Customer_ID = CustomerVisits.Customer_ID
            GROUP BY CustomerVisits.Store_ID
        ) cv
            ON cv.Store_ID = Stores.Store_ID;

SELECT
    CUSTOMER.CUSTOMER_ID,
    CUSTOMER.CUSTOMER_NAME,
    (select ATTRIBUTE_VALUE from CUSTOMER_ATTRIBUTE where customer_id = CUSTOMER.CUSTOMER_ID
        and ATTRIBUTE_TYPE_ID='F') AS FAVORITE_FOOD
FROM
    CUSTOMER

CREATE FUNCTION protect_delete() RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    IF OLD.date_birth = 'xx/yy/zz' THEN  -- don't actually use this date format
        RETURN NULL;  -- don't delete
    ELSE
        RETURN OLD;
    END IF;
END;
$$;

CREATE TRIGGER protect_delete BEFORE DELETE ON students FOR EACH ROW
    EXECUTE PROCEDURE protect_delete();

Select distinct column_name, table_name 
from information_schema.COLUMNS 
where table_name in('table1','table2') 
and column_name = 'column_name'

SELECT      coalesce(A.ranking,0) as ranking
            (
                SELECT      coalesce(B.groupName,'') as groupName,
                            (
                                SELECT      C.policy,
                                            C.groupCount
                                FROM        @temp C
                                WHERE       C.ranking = A.ranking
                                AND         C.groupName = B.groupName
                                ORDER BY    C.groupCount desc, C.policy
                                FOR XML PATH(''), ELEMENTS, TYPE
                            ) AS groupName
                FROM        @temp B
                WHERE       B.ranking = A.ranking
                GROUP BY    B.groupName
                ORDER BY    B.groupName
                FOR XML PATH(''), ELEMENTS, TYPE
            )
FROM        @temp A
GROUP BY    A.ranking
ORDER BY    A.ranking
FOR XML PATH('policyRanking'), ELEMENTS, TYPE, ROOT('ranks')

select max(rec_id) from 
(
  (select rec_id from tablea)
 union all
  (select rec_id from tableb)
) combined

SET @start_date = '2011-12-01';
SET @end_date = '2012-01-01';

SELECT * FROM users
WHERE DAYOFYEAR( birthday )
  BETWEEN IF( YEAR( @end_date ) - YEAR( @start_date ) > 1, 1,
    IF( YEAR( @end_date ) - YEAR( @start_date ) > 0,
      IF( DAYOFYEAR( @start_date ) <= DAYOFYEAR( @end_date ), 1,
        DAYOFYEAR( @start_date ) ),
      DAYOFYEAR( @start_date ) ) )
      AND IF( YEAR( @end_date ) - YEAR( @start_date ) > 1, 366,
            IF( YEAR( @end_date ) - YEAR( @start_date ) > 0, 366,
              DAYOFYEAR( @end_date ) ) )
  OR DAYOFYEAR( birthday )
  BETWEEN IF( YEAR( @end_date ) - YEAR( @start_date ) > 1, 1,
    IF( YEAR( @end_date ) - YEAR( @start_date ) > 0, 1,
      DAYOFYEAR( @start_date ) ) )
         AND IF( YEAR( @end_date ) - YEAR( @start_date ) > 1, 366,
               IF( YEAR( @end_date ) - YEAR( @start_date ) > 0,
                 IF( DAYOFYEAR( @start_date ) <= DAYOFYEAR( @end_date ), 366,
                   DAYOFYEAR( @end_date ) ),
                 DAYOFYEAR( @end_date ) ) );

create table TABLE1(
  "ID1"     number not null
  , "A1" varchar(20)
  , "B1" varchar(20)
  , "C1" varchar(20)
  , "D1" varchar(20)
)
/
create or replace trigger TG_BIU_TABLE1
after insert or update on TABLE1
for each row
begin
  update TABLE2
  set A2 = :new.A1
      ,B2 = :new.B1
  where TABLE2.ID2 = :new.ID1;

  update TABLE3
  set A3 = :new.A1
      ,B3 = :new.B1
      ,C3 = :new.C1
      ,D3 = :new.D1
  where TABLE3.ID3 = :new.ID1;
end;
/
create table TABLE2(
  "ID2"     number not null
  , "A2" varchar(20)
  , "B2" varchar(20)
)
/
INSERT INTO TABLE2 (ID2, A2, B2) VALUES (1, 'AAA', 'BBB')
/
create table TABLE3(
  "ID3"     number not null
  , "A3" varchar(20)
  , "B3" varchar(20)
  , "C3" varchar(20)
  , "D3" varchar(20)
)
/
INSERT INTO TABLE3 (ID3, A3, B3, C3, D3) VALUES (1, 'AAA', 'BBB', 'CCC', 'DDD')
/

INSERT INTO TABLE1 (ID1, A1, B1, C1, D1) VALUES (1, 'AAA1', 'BBB1', 'CCC1', 'DDD1')
/

SELECT FROM_UNIXTIME(date_of_registration, '%Y-%m-%d %H:%i:%s') AS user_registeredon, 
        ROUND((renewal_date - date_of_registration)/(60*60*24)) AS expiry_date,
        a.agent_id
 FROM ta_agent a,
      ta_subscription s
 WHERE s.agent_id = a.agent_id

select to_char (datecol, 'FMMM') from mytable;

mDB.update("Results", values, "studentid=? AND testid=?", new String[] { "2","1" }); 

-- this is creating the temporary table which would normally be created by a function.
DECLARE @Temp TABLE (Customer_id int)
INSERT INTO @Temp(Customer_id)
SELECT 1
INSERT INTO @Temp(Customer_id)
SELECT 2
INSERT INTO @Temp(Customer_id)
SELECT 3

-- now do the select statement.
SELECT 
    T.Customer_id,
     C.*
FROM
    Customers C
RIGHT OUTER JOIN
     @Temp T
ON
     T.Customer_id = C.Customer_id

update invalid_characters set col1 = 1;

SELECT 
latitude, 
longitude, 
count(1) as "Count", 
min(timestamp) as "Start",
max(timestamp) as "End"

FROM table 
GROUP BY latitude, longitude
ORDER BY min(timestamp) asc

select a.reqstatusid, a.reqstatus, b.reqstatusid as childreqstatusid,
b.reqstatus as childreqstatus
from table a, table b
where a.reqstatusid <> b.reqstatusid

CREATE PROCEDURE [TestSproc]
    @Param1 INTEGER
AS
BEGIN
DECLARE @Param1_LOCAL INTEGER
SET @Param1_LOCAL = @Param1

SELECT Something
FROM Somewhere
WHERE SomeField = @Param1_LOCAL 
END

select * from T2 where code = 100
and not exists (select NULL from T1 where 
                T1.group = T2.group and
                T1.c1 > 0)

="With Requests as....When request like" + Parameters!QueryCriteria.Value + "Else 'Others'..." 

select #temp.num, count(*)
from #temp
left join  
    (
    SELECT count(membership.memberid) as MembershipCount from Membership, Package
    WHERE membership.PackageId = Package.Id
    AND membership.DiscountPercentage != 100
    AND Package.PackageTypeId != 1
    AND membership.MembershipStateId != 5
    AND Membership.LocationId = 1
    group by memberid
    having count(membership.memberid) > 1
    ) ntm 
on ntm.MembershipCount > #temp.num 
group by #temp.num

...
INNER JOIN features 
  ON home_feature.feature_id = features.feature_id
left outer join bookings b
  on homes.home_id = b.home_id
where (
        (b.booking_end <= to_date('25-Jan-13')
         OR b.booking_end >= to_date('21-Jan-13')
        )
        AND
        (b.booking_start <= to_date('25-Jan-13')
         OR b.booking_start >= to_date('21-Jan-13')
        )
      )
      or b.home_id is null
...

SELECT l.* 
FROM leads l
JOIN keywords k on instr(leads.name, word) > 0 

select * from my_table
where '511132228' like replace(phone_number, 'x', '_')

TO_TIMESTAMP_TZ('2014-01-01 08:16:02 (+00:00)', 'YYYY-MM-DD HH24:MI:SS (TZH:TZM)')

select m.schoolcode, m.schoolname, e_sum, c_sum 
  from dise2k_master m
 inner join
 (
    select schoolcode,
           sum(c1 + c2 + c3 + c4) e_sum
      from dise2k_enrolment09
     where year='2011-12'
       and caste in(1,2,3,4) 
     group by schoolcode
 ) e
    on m.schoolcode=e.schoolcode
 inner join
 (
    select schoolcode,
           sum(rooms) c_sum
      from dise2k_clsbycondition
     where year='2011-12'
       and classid in(7,8)
     group by schoolcode
 ) c
    on m.schoolcode=c.schoolcode
 where m.year='2011-12'

(Sum(Auction) OVER ()) - actual AS Remaining

INSERT
INTO EMPLOYEES
  (
    EMPLOYEE_ID,
    FIRST_NAME,
    LAST_NAME,
    EMAIL,
    PHONE_NUMBER,
    HIRE_DATE,
    JOB_ID,
    SALARY,
    COMMISSION_PCT,
    MANAGER_ID,
    DEPARTMENT_ID
  )
  VALUES
  (
    :v0,
    :v1,
    :v2,
    :v3,
    :v4,
    :v5,
    :v6,
    :v7,
    :v8,
    :v9,
    :v10
  );

with tsize as (
     SELECT p.ItemID,
            p.ItemID + '-' + mli.ItemID AS SizeItemID
     FROM ModifierLists ml INNER JOIN
           ProductModifierLists pml 
           ON ml.ModifierListID = pml.ModifierListID INNER JOIN
           ModifierListItems mli
           ON ml.ModifierListID = mli.ModifierListID INNER JOIN
           Products p
           ON pml.ItemID = Products.ItemID AND
              pml.ManufacturerID = p.ManufacturerID
     WHERE (p.ManufacturerID = 262) AND ModifierListName='Size'
    ),
     tcolor as (
     SELECT  p.ItemID, mli.ItemID AS ColorItemID
     FROM ModifierLists moli INNER JOIN
          ProductModifierLists pml
          ON ml.ModifierListID = pml.ModifierListID INNER JOIN
          ModifierListItems mli
          ON ml.ModifierListID = mli.ModifierListID INNER JOIN
          Products p
          ON pml.ItemID = Products.ItemID AND
             pml.ManufacturerID = p.ManufacturerID
     WHERE     (Products.ManufacturerID = 262) AND ModifierListName='Color'
    )
select SizeItemID+'-'+ColorItemID
from tsize join tcolor
    on tsize.itemid = tcolor.ItemID

SELECT Item.item, 
       MAX(case when variant_order=1 then variant end) as variant1,
       MAX(case when variant_order=2 then variant end) as variant2,
       MAX(case when variant_order=3 then variant end) as variant3
from ItemVariant
LEFT JOIN Item ON Item.item_id = ItemVariant.item_id
GROUP BY Item.item;

(select 'paypal', amount, status, date, transaction_id 
                                                   from paypal_orders limit 15)
union
(select 'cod', amount, status, date, id 
                                     from cod_orders limit 10)

SELECT * --I don't recommend using a * by the way. Expand the column names if possible
FROM LIS_Results R
INNER JOIN LIS_Results_Log L ON L.Order_TestID = R.Order_TestID
WHERE R.SampleID = 1311120001

alter table tbl add email as (Name + '@abc.com');

SELECT  a.Name, b.Description, c.Qty
FROM    Staff a
        CROSS JOIN Services b
        LEFT JOIN StaffServices c
            ON a.ID = c.Staff_ID AND
                b.ID = c.Services_ID
ORDER   BY a.Name, b.Description

SELECT Name
     , GROUP_CONCAT(Stage) AS Stages
     , GROUP_CONCAT(Date) AS Dates
  FROM my_table
GROUP BY Name;

select (title OR fo)

from Foo foo where foo.id in (:fooIds)

    SELECT CASE 
         WHEN T.rank > 1 THEN '' 
         ELSE T.NamaMerk 
       END        AS 'NamaMerk', 
       T.NamaTipe AS 'NamaTipe' 
FROM   (SELECT a.NamaMerk, 
               b.NamaTipe, 
               Row_number() 
                 OVER( 
                   partition BY a.NamaMerk 
                   ORDER BY b.NamaTipe) AS 'RANK' 
        FROM   msmerk AS a 
               INNER JOIN mstipe AS b 
                       ON a.id_merk = b.id_merk 
        WHERE  a.flagactive = 'Y' 
               AND b.flagactive = 'Y' 
               AND a.id_merk = b.id_merk ) T

SELECT somewhere_ID, pp.Last_Name, pp.First, emw.email AS Work_Email, emp.email AS Pers_Email
FROM somewhere pp
JOIN emailarea emp ON emp.email_ID = pp.somewhere_ID
JOIN emailarea emw ON emw.email_ID = pp.somewhere_ID
WHERE emp.type = "PERS"
AND emw.type = "WORK"
AND emp.email LIKE '%my.company.com'
AND emp.email NOT LIKE '%' || pp.Last_Name || '%'

CREATE TABLE #Table (
        ID INT,
        ColumnName VARCHAR(250),
        Value VARCHAR(250)
)

INSERT INTO #Table SELECT 1,'name','Peter' 
INSERT INTO #Table SELECT 1,'phone','12345678' 
INSERT INTO #Table SELECT 1,'email','peter@host.com' 
INSERT INTO #Table SELECT 2,'name','John' 
INSERT INTO #Table SELECT 2,'phone','87654321' 
INSERT INTO #Table SELECT 2,'email','john@host.com' 
INSERT INTO #Table SELECT 3,'name','Sarah' 
INSERT INTO #Table SELECT 3,'phone','55667788' 
INSERT INTO #Table SELECT 3,'email','sarah@host.com' 

---I assumed your tablename as TESTTABLE--- 
DECLARE @cols NVARCHAR(2000) 
DECLARE @query NVARCHAR(4000) 

SELECT  @cols = STUFF(( SELECT DISTINCT TOP 100 PERCENT 
                                '],[' + t.ColumnName 
                        FROM    #Table AS t 
                        --ORDER BY '],[' + t.ID 
                        FOR XML PATH('') 
                      ), 1, 2, '') + ']' 

SELECT  @cols

SET @query = N'SELECT ID,'+ @cols +' FROM 
(SELECT t1.ID,t1.ColumnName , t1.Value FROM #Table AS t1) p 
PIVOT (MAX([Value]) FOR ColumnName IN ( '+ @cols +' )) 
AS pvt;' 

EXECUTE(@query)

DROP TABLE #Table

SELECT TMP.S, TMP.my_count
FROM (
      SELECT T1.something S, COUNT(*) my_count
      FROM table T1, table2 T2
      WHERE T1.value = T2.value
      GROUP BY T1.something 
      ) TMP
Where 
TMP.my_count = (select max(count(*)) from table1 T3 group by t3.something)

declare @var nvarchar(100)='612831408762037_617540318291146';

select 
    LEFT(@var, charindex('_',@var)-1), 
    RIGHT(@var, charindex('_',REVERSE(@var))-1)

my $sql = "SOME QUERY HERE";
$dbh->do("DECLARE csr CURSOR WITH HOLD FOR $sql");
my $sth = $dbh->prepare("fetch 100 from csr");
$sth->execute;

while(my $ref = $sth->fetchrow_hashref()) {     
    //... - processing here
    if ($count % 100 == 0){             
        $sth->execute;
    }
}

SELECT *,
       0 AS t
INTO   #pars_temp -- Intermediate table for parsing each row
FROM   #temp1

DECLARE @sql NVARCHAR(max),
        @id  INT,
        @val VARCHAR(5000)

WHILE EXISTS(SELECT 1
             FROM   #pars_temp
             WHERE  t = 0)-- To check the existence of unparsed row 
  BEGIN
      SELECT TOP 1 @val = value,
                   @id = id
      FROM   #pars_temp
      WHERE  t = 0

      SET @sql ='update #temp1 set value  = ' + @val
                + ' where id = ' + CONVERT(VARCHAR(10), @id) -- update the values

      EXEC Sp_executesql @sql

      UPDATE #pars_temp
      SET    t = 1
      WHERE  id = @id -- To remove the parsed row
  END

SELECT *
FROM   #temp1 

SELECT u.userID, u.username, u.userAvatar, u.accessLevel,  al.titleColor
FROM CMS_AccessLevels al
INNER JOIN CMS_Users u
ON u.accessLevel = al.accessLevel
WHERE u.userID = 3

DECLARE @FilesOnServers TABLE
(
    [ServerName] varchar(128) NOT NULL,
    [FileName] nvarchar(256) NOT NULL,
    [FileHash] varbinary(512) NOT NULL  
)

INSERT INTO @FilesOnServers(ServerName, [FileName], [FileHash])
VALUES
('SRVDB001', 'Address.xsd', 0xCF4658AF674),
('SRVDB002', 'Address.xsd', 0xCF4658AF675),
('SRVDB001', 'Company.xsd', 0xBE6E5C376E3);


SELECT DISTINCT F.FileName
FROM
    @FilesOnServers F
WHERE
    EXISTS (
        SELECT *
        FROM 
            @FilesOnServers F2
        WHERE
            F.[FileName] = F2.[FileName]
            AND F.FileHash <> F2.FileHash
            AND F.ServerName <> F2.ServerName
    )

select
  2.5*((r-i)/(r+(6*i)-(7.5*n)+1)) as tera,
  (r-(2*i)-n)/(r+(2*i)-n) as tera2
from

    (select wavelength, reflectance as r, row_number() over(order by wavelength) as rn
     from test where wavelength between 340 and 345) t1
    join 
    (select wavelength, reflectance as i, row_number() over(order by wavelength) as rn
     from test where wavelength between 350 and 355) t2 using (rn)
    join
    (select wavelength, reflectance as n, row_number() over(order by wavelength) as rn
     from test where wavelength between 360 and 365) t3 using (rn)

SELECT carBrand , carYear ,carModel 
FROM Cars 
GROUP BY carBrand , carYear ,carModel;

SELECT
  id, name
FROM
  data
ORDER BY
  CASE WHEN id IN (4, 5, 8, 10) THEN 0 ELSE 1 END ASC,
  name

CREATE TABLE nums (x INT);

INSERT INTO nums (x) VALUES (0), (1), (2), (3), (4); 

SELECT a.x, b.x, c.x, d.x 
FROM nums AS a 
JOIN nums AS b ON b.x NOT IN (a.x) 
JOIN nums AS c ON c.x NOT IN (a.x, b.x) 
JOIN nums AS d ON d.x NOT IN (a.x, b.x, c.x);

SELECT SUM(case when tblImport.JurisdictionType = 'State' then tblImport.InvoiceAmount else 0 end) as InvoiceAmount, 
      tblImport.State, 
      SUM(tblImport.TaxAmount) as TaxAmount
FROM tblImport
ORDER BY State
GROUP BY State

LEFT('BOB*', LEN('BOB*')-1)

SELECT tbl.id
  FROM table1 tbl
 WHERE ( [some condition] AND tbl.id = [a single id number])
OR ( NOT [some condition] AND tbl.id IN ( SELECT tbl2.id
                                           FROM table2 tbl2
                                          WHERE [some other condition])

  ....
WHERE id IN (3, 9, 100, ...)

select name, sum(cnt1), sum(cnt2), sum(cnt3)
from
(
select col1 as name, count(*) as cnt1 , null as cnt2 , null as cnt3 from t group by col1
union all
select col2, null, count(*), null from t group by col2
union all
select col3, null, null, count(*) from t group by col3
) as dt

If EXISTS (SELECT 1 FROM #tempTable1 table1 
            WHERE NOT EXISTS (SELECT 1 FROM #tempTable2 table2 
                                WHERE table2.id = table1.id))

BEGIN
..
END

CREATE VIEW A
AS
SELECT  *
FROM    A_underlying

CREATE VIEW B
AS
SELECT  *
FROM    B_underlying

UPDATE A 
SET A.IsBiggestState = 1
FROM YourTable A
INNER JOIN (SELECT Company, MAX(TotalRevenue) MaxRevenue FROM YourTable
            GROUP BY Company) B
ON A.Company = B.Company AND A.TotalRevenue = B.MaxRevenue

SELECT TableName = t.NAME
    ,IndexName = ind.NAME
    ,IndexId = ind.index_id
    ,ColumnId = ic.index_column_id
    ,ColumnName = col.NAME
    ,ind.*
    ,ic.*
    ,col.*
FROM sys.indexes ind
INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id
    AND ind.index_id = ic.index_id
INNER JOIN sys.columns col ON ic.object_id = col.object_id
    AND ic.column_id = col.column_id
INNER JOIN sys.tables t ON ind.object_id = t.object_id
WHERE ind.is_primary_key = 0
    AND ind.is_unique = 0
    AND ind.is_unique_constraint = 0
    AND t.is_ms_shipped = 0
    AND t.name=<Your TableName>
ORDER BY t.NAME
    ,ind.NAME
    ,ind.index_id
    ,ic.index_column_id

SELECT 
    ABC.TravelId,
    MAX(ABC.ToStageID) 'STAGE'
FROM
    tbl_HR_TravelStageEvent ABC
GROUP BY
    ABC.TravelId
HAVING
    MAX(ABC.ToStageID) = 3

WHERE AUDIT_LOG IS NOT NULL

ALTER FEDERATION CustomerFederation SWITCH OUT AT (HIGH cid = -9223372036854775808)

SET NOCOUNT ON
DECLARE @Statement NVARCHAR(MAX) = ''
DECLARE @Statement2 NVARCHAR(MAX) = ''
DECLARE @FinalStatement NVARCHAR(MAX) = ''

DECLARE @TABLE_SCHEMA SYSNAME = <SCHEMA_NAME>
DECLARE @TABLE_NAME SYSNAME = <TABLE_NAME>

SELECT
        @Statement = @Statement + 'SUM(CASE WHEN ' + COLUMN_NAME + ' IS NULL THEN 1 ELSE 0 END) AS ' + COLUMN_NAME + ',' + CHAR(13) ,
        @Statement2 = @Statement2 + COLUMN_NAME + '*100 / OverallCount AS ' + COLUMN_NAME + ',' + CHAR(13)
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = @TABLE_NAME 
    AND TABLE_SCHEMA = @TABLE_SCHEMA

IF @@ROWCOUNT = 0
    RAISERROR('TABLE OR VIEW with schema "%s" and name "%s" does not exists or you do not have appropriate permissions.',16,1, @TABLE_SCHEMA, @TABLE_NAME)
ELSE
BEGIN
    SELECT @FinalStatement =
            'SELECT ' + LEFT(@Statement2, LEN(@Statement2) -2) + ' FROM (SELECT ' + LEFT(@Statement, LEN(@Statement) -2) +
            ', COUNT(*) AS OverallCount FROM ' + @TABLE_SCHEMA + '.' + @TABLE_NAME + ') SubQuery'
    EXEC(@FinalStatement)
END

public class DownloadFile : IHttpHandler { // add IRequiresSessionState if needed 
  public bool IsReusable { get { return true; } }

  public void ProcessRequest(HttpContext context) {
    var fileID = context.Request.QueryString["fileID"]; // assuming fileID is a string
    var file = db.Storage.Single(f => f.ID.Equals(fileID)); 
    // set the content type
    context.Response.OutputStream.Write(file.Contents, 0, file.Contents.Length);
  }
}

;WITH d AS ( SELECT TAT = CASE WHEN TAT > 191 THEN 192 ELSE TAT END,
   SUM(CASE WHEN [Month Entered] = 1  THEN 1 ELSE 0 END) AS JAN,
   SUM(CASE WHEN [Month Entered] = 2  THEN 1 ELSE 0 END) AS FEB,
   SUM(CASE WHEN [Month Entered] = 3  THEN 1 ELSE 0 END) AS MAR,
   SUM(CASE WHEN [Month Entered] = 4  THEN 1 ELSE 0 END) AS APR,
   SUM(CASE WHEN [Month Entered] = 5  THEN 1 ELSE 0 END) AS MAY,
   SUM(CASE WHEN [Month Entered] = 6  THEN 1 ELSE 0 END) AS JUN,
   SUM(CASE WHEN [Month Entered] = 7  THEN 1 ELSE 0 END) AS JUL,
   SUM(CASE WHEN [Month Entered] = 8  THEN 1 ELSE 0 END) AS AUG,
   SUM(CASE WHEN [Month Entered] = 9  THEN 1 ELSE 0 END) AS SEP,
   SUM(CASE WHEN [Month Entered] = 10 THEN 1 ELSE 0 END) AS OCT,
   SUM(CASE WHEN [Month Entered] = 11 THEN 1 ELSE 0 END) AS NOV,
   SUM(CASE WHEN [Month Entered] = 12 THEN 1 ELSE 0 END) AS DEC
  FROM [SalesDWH].[dbo].[TurnAround]
  WHERE [datetime entered] >= '20100101'
    AND [datetime entered] <  '20110101'
  GROUP BY CASE WHEN TAT > 191 THEN 192 ELSE TAT END
),
n AS ( SELECT TOP (193) n = ROW_NUMBER() OVER (ORDER BY [object_id]) - 1
  FROM sys.all_columns ORDER BY [object_id]
)
SELECT TAT = n.n,
  JAN = COALESCE(RTRIM(NULLIF(JAN, 0)), ''),
  FEB = COALESCE(RTRIM(NULLIF(FEB, 0)), ''),
  MAR = COALESCE(RTRIM(NULLIF(MAR, 0)), ''),
  APR = COALESCE(RTRIM(NULLIF(APR, 0)), ''),
  MAY = COALESCE(RTRIM(NULLIF(MAY, 0)), ''),
  JUN = COALESCE(RTRIM(NULLIF(JUN, 0)), ''),
  JUL = COALESCE(RTRIM(NULLIF(JUL, 0)), ''),
  AUG = COALESCE(RTRIM(NULLIF(AUG, 0)), ''),
  SEP = COALESCE(RTRIM(NULLIF(SEP, 0)), ''),
  OCT = COALESCE(RTRIM(NULLIF(OCT, 0)), ''),
  NOV = COALESCE(RTRIM(NULLIF(NOV, 0)), ''),
  DEC = COALESCE(RTRIM(NULLIF(DEC, 0)), '')
FROM n LEFT OUTER JOIN d ON n.n = d.TAT 
ORDER BY n.n; -- do not use ordinal numbers for ORDER BY!

select right('000000000'+convert(varchar(9), NUMBER), 9)

Import-Module c:\oracle\WalletCreator\WASP.dll

$WalletCreated = 0

cls
Write-Host "                                                           " -foregroundcolor White -backgroundcolor DarkRed
Write-Host "   Warning: This script will delete your current wallet.   " -foregroundcolor White -backgroundcolor DarkRed
Write-Host "                                                           " -foregroundcolor White -backgroundcolor DarkRed

do {
    #Get credentials
    Write-Host " " 
    Write-Host " New Wallet Entry                                          " -foregroundcolor White -backgroundcolor DarkGreen
    Write-Host "    To exit press return without entering anything.        " -foregroundcolor White -backgroundcolor DarkGreen
    $DB = Read-Host "Connection Name"
    if ($DB -eq "") {
       Return
    }
    $Username = Read-Host "       Username"
    if ($Username -eq "") {
       Return
    }
    $Password = Read-Host -AsSecureString "       Password" 

    #Convert from SecureString to String.
    $BasicString = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($Password)
    $Password = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($BasicString)
    if ($Password -eq "") {
       Return
    }

    if ($WalletCreated -eq 0) {
        #Create folder in case it doesn't exist.
        md c:\oracle\Wallets -Force | Out-Null

        #Delete any wallet in the folder now.
        del c:\oracle\Wallets\*.* | Out-Null

        #Get GUID for wallet password.
        $WalletPassword = [guid]::NewGuid().toString()
        $WalletPassword = $WalletPassword + "`r"

        #Create Wallet.
        Start-Process -FilePath mkstore -ArgumentList "-wrl c:\oracle\Wallets\ -create"
        Start-Sleep -Milliseconds 500
        Select-Window -ProcessName cmd | Select -First 1 | Send-Keys -keys $WalletPassword
        Start-Sleep -Milliseconds 300
        Select-Window -ProcessName cmd | Select -First 1 | Send-Keys -keys $WalletPassword

        $WalletCreated = 1
        Start-Sleep -Milliseconds 1000
    }

    #Create Credential.
    $CC = "-wrl c:\oracle\Wallets\ -createCredential " + $DB + " " 
    $CC = $CC + $Username + " " + $Password
    Start-Process -FilePath mkstore -ArgumentList $CC
    Start-Sleep -Milliseconds 300
    Select-Window -ProcessName cmd | Select -First 1 | Send-Keys -keys $WalletPassword
    Start-Sleep -Milliseconds 1000
} 
until ($DB -eq "")

   empid    sal
   ===============
    1       300
    2        50
    3       400
    4       200
    5       150
   ================

select distinct sal from emp a where 3        --outer query
  >=
 (select count(distinct sal) from emp b             --inner query(correlated)
        where a.sal <= b.sal) order by a.sal desc;

DECLARE @document varchar(64);
SELECT @document = 'CMS/00014456582/693362/004535/JCR_110914_NEW_4535 CMS'
select Substring(@document, CHARINDEX('/', @document,(SELECT CHARINDEX('/', @document)+1))+1,6)

    sysdate(3) returned '2014-01-07 10:52:07.252'

SELECT 1  -- no GROUP BY therefore use a literal
  FROM Locations
HAVING COUNT(a) = 0 
       AND COUNT(*) > 0;

<check-valid-connection-sql>select 1 from dual</check-valid-connection-sql>

select date, hours
from
(
  select id, startdate date, sun hours
  from yourtable
  union all
  select id, dateadd(dd, 1, startdate), mon
  from yourtable
  union all
  select id, dateadd(dd, 2, startdate), tue
  from yourtable
  union all
  select id, dateadd(dd, 3, startdate), wed
  from yourtable
  union all
  select id, dateadd(dd, 4, startdate), thu
  from yourtable
  union all
  select id, dateadd(dd, 5, startdate), fri
  from yourtable
  union all
  select id, dateadd(dd, 6, startdate), sat
  from yourtable
) x
where date between '2012-10-15' and '2012-10-17'

select (case when seqnum = 1 then id else '0' end) as id,
       (case when seqnum = 1 then start else "end" end) as timestamp,
       unit
from (select t.*,
             row_number() over (partition by id, unit order by start) as seqnum,
             count(*) over (partition by id, unit) as cnt
      from table t
     ) t
where seqnum = 1 or seqnum = cnt;

create trigger YourTriggerName on YourTable
after update, delete
as
    /* Deleted table contains the "old" values before the update/delete operation */
    insert into YourLoggingTable
        (UniqueGUID, kod_a, ..., payment, DateModified)
        select UniqueGUID, kod_a, ..., payment, getdate()
            from Deleted 
go

SELECT COUNT(*) * 15
FROM your_table

DECLARE
   dummy package.areacursor;
BEGIN
package.myprocedure (
      12345, dummy
   );
END;

select a.datecreated,a.sale
         from salesummary a
 inner join calendar c
on a.datecreated = c.fulldatekey
 and c.IsLastDayOfMonth = 1
group by a.datecreated,a.sale

ALTER PROCEDURE [usp_debug_mightwork]
    @DATA_DT_ID AS int = 20081130
AS
BEGIN
    DECLARE @IDATA_DT_ID AS int
    SET @IDATA_DT_ID = @DATA_DT_ID
    -- Stuff here that depends on IDATA_DT_ID
END

<?php

require 'app/Mage.php';
Mage::app();

$products = Mage::getModel('catalog/product')->getCollection()->addAttributeToSelect('*');
foreach ($products as $product) {
    if (!$product->hasImage()) continue;
    if (!$product->hasSmallImage()) $product->setSmallImage($product->getImage());
    if (!$product->hasThumbnail()) $product->setThumbnail($product->getImage());
    $product->save();
}

?>Done!

SELECT 
    p.*, 
    s.sCol1 as 's/sCol1', 
    o.oCol1 as 'o/oCol1'
FROM p 
     LEFT OUTER JOIN s on s.UID = p.UID
     LEFT OUTER JOIN o on o.UID = p.UID
FOR XML PATH

GO

INSERT INTO routes VALUES 
  (1,'a','b')
 ,(2,'a','c')
 ,(3,'a','d')
 ,(4,'b','c')
 ,(5,'b','d')
 ,(6,'c','d')
 ,(7,'d','c')

GO

WITH cte AS (
 --anchor
 SELECT id
       ,start
       ,finish
       ,',' + CAST(id AS VARCHAR(MAX)) + ',' route_ids
   FROM routes
  WHERE start = 'a'

  UNION ALL
 --recursive part    
 SELECT a.id
       ,a.start
       ,b.finish
       ,route_ids + CAST(b.id AS VARCHAR(MAX)) + ','
   FROM cte a
        INNER JOIN
        routes b ON a.finish = b.start 
  WHERE CHARINDEX(',' + CAST(b.id AS VARCHAR(MAX)) + ',',a.route_ids,1)  = 0
)
SELECT start,finish,route_ids 
 FROM cte
WHERE finish = 'c'
ORDER BY LEN(route_ids)

DELETE FROM table WHERE id IN (1, 4, 6, 7)

SELECT i1.*
FROM invoice_items i1
LEFT OUTER JOIN invoice_items i2
  ON (i1.invoice_id = i2.invoice_id AND i1.invoice_date < i2.invoice_date)
WHERE i2.invoice_id IS NULL;

SELECT SUM(CASE WHEN Reliquat_id = 1 THEN Poids ELSE 0 END) AS NbrARRNP,
       SUM(CASE WHEN Reliquat_id = 2 THEN Poids ELSE 0 END) AS NbrSTNP,
       SUM(CASE WHEN Reliquat_id = 3 THEN Nombre ELSE 0 END) AS NbrARR,
       SUM(CASE WHEN Reliquat_id = 4 THEN Nombre ELSE 0  END) AS ST,
       SUM(CASE WHEN Reliquat_id = 5 THEN Nombre ELSE 0 END) AS NbrCLASS,
       SUM(CASE WHEN Reliquat_id = 6 THEN Nombre ELSE 0 END)  AS NbrINDEX
FROM datas
WHERE Chantier_id = 4 AND main_id = 1;

SELECT 
ID,
Name,
age,
( 
CASE Name 
WHEN @curType 
THEN @curRow := @curRow + 1 
ELSE @curRow := 1 AND @curType := Name END
) + 1 AS sequence_No

FROM student, (SELECT @curRow := 0, @curType := '') r
ORDER BY  ID,NAME;

SELECT console_msgs.*
FROM   console_msgs NATURAL JOIN (
         SELECT   MAX(time) AS time
         FROM     console_msgs
         WHERE    `to` = $user[id]
         GROUP BY `from`
       ) t
WHERE  `to` = $user[id]

SELECT i.id,
    i.stock AS current_stock,
    COALESCE(SUM(o.quantity), 0) AS orders_last_2_weeks,
    i.stock - COALESCE(SUM(o.quantity), 0) AS stock_after_2_weeks
FROM items AS i
LEFT OUTER JOIN order_items o
    ON o.item_id = i.id
    AND o.created_at > NOW() - INTERVAL 2 WEEK
GROUP BY i.id

DECLARE @x TABLE(item XML)
DECLARE  @schemaname VARCHAR(100)
SET @schemaname = 'GaleriesSchem3'

INSERT into @x
SELECT  '
<GaleriesSchem2>
  <Image_1 OriginalName="Image">4814111.jpg</Image_1>
  <Image_2 OriginalName="Image2">481411.jpg</Image_2>
</GaleriesSchem2>
<GaleriesSchem3>
  <Image_1 OriginalName="Image">4814111_3.jpg</Image_1>
  <Image_2 OriginalName="Image2">481411_3.jpg</Image_2>
</GaleriesSchem3>
'
SELECT rref.value('.', 'varchar(MAX)') AS 'Value'
FROM @x
  CROSS APPLY     
    item.nodes('*[local-name()=sql:variable("@schemaname")]/node()') AS Results(rref)

SELECT 'D' + REPLACE(yourfield, 'DAYS', '') 
FROM YourTable

where priceratio < cast(@input_number as int)

WHERE ROUND(Amount1,2) = Amount1

SELECT full_name, email, users.uid
  FROM cloudsponge
 INNER
  JOIN users
    ON users.uid = cloudsponge.importer_uid
  LEFT
  JOIN users AS users2
    ON cloudsponge.email = users2.mail
 WHERE users2.mail IS NULL

select *,
       (case when b like 'xf%' 
             then sum(c * e) over (partition by a, rnd )
        end) as sumProduct
into #testing3
from #testing2;

select seq, type,
       dense_rank() over (order by grp, type)
from (select t.*, 
             (row_number() over (order by seq) -
              row_number() over (partition by type order by seq)
             ) as grp
      from tbl1 t
     ) t;

SELECT COUNT(*) version
FROM items
WHERE item_id = 2 AND start_date <= '2012-05-31'

declare @T table(Person nvarchar(20), [Day] date)

insert into @T values
('John',    '2011-05-23'),
('John',    '2011-05-24'),
('John',    '2011-05-25'),
('John',    '2011-05-27'),
('John',    '2011-05-28'),
('John',    '2011-05-29'),
('Anna',    '2011-05-02'),
('Anna',    '2011-05-03'),
('Anna',    '2011-05-06')


;WITH cte AS
(
SELECT *,
        DATEDIFF(DAY,0,[Day])-
        ROW_NUMBER() OVER (PARTITION BY Person ORDER BY [Day]) AS Grp
FROM @T  
)
SELECT Person, 
       MIN([Day]) AS DateFrom, 
       MAX([Day]) AS DateTo  
FROM cte 
GROUP BY Person, Grp

UPDATE myTable AS t1
JOIN (SELECT Id,
             MAX(category) AS category,
             MAX(year) AS year,
             MAX(manu) AS manu
      FROM myTable
      WHERE category IS NOT NULL
        AND year IS NOT NULL
        AND manu IS NOT NULL
      GROUP BY Id) AS t2
ON t1.Id = t2.Id
SET t1.category = t2.category,
    t1.year = t2.year,
    t1.manu = t2.manu
WHERE t1.category IS NULL AND t1.year IS NULL AND t1.manu IS NULL

SELECT *
FROM sub_menu
LEFT JOIN root_sub ON sub_menu.id = root_sub.sub_id
LEFT JOIN root_menu ON root_sub.root_id = root_menu.id   

select distinct orders_id, 
       count(orderitems_id) as total 
from orderitems 
group by orders_id 
order by total desc

SELECT storeId,
       LISTAGG(ProductCategory || ':' || '(' || ProductIds || ')', ', ')
            WITHIN GROUP (ORDER BY ProductCategory) as ProductsAndCategories
FROM (SELECT StoreId, ProductCategory,
             LISTAGG(ProductId, ',') WITHIN GROUP (ORDER BY ProductId) as ProductIds
      FROM SUPERMARKET
      GROUP BY StoreId, ProductCategory
     ) s
GROUP BY StoreId;

SELECT d.ip, d.time, d.othercol, b.isbanned FROM details d
LEFT JOIN banlist b on b.ip = d.ip
WHERE d.somefield=X

SELECT  PARTY,
        SUM(CASE WHEN DATEDIFF(DAY,[DATE],GETDATE()) BETWEEN 0 AND 3  THEN (NETAMT - CHQ) ELSE 0 END) AS [0_3_DAYS],
        SUM(CASE WHEN DATEDIFF(DAY,[DATE],GETDATE()) BETWEEN 4 AND 6  THEN (NETAMT - CHQ) ELSE 0 END) AS [4_6_DAYS],
        SUM(CASE WHEN DATEDIFF(DAY,[DATE],GETDATE()) BETWEEN 7 AND 15 THEN (NETAMT - CHQ) ELSE 0 END) AS [7_15_DAYS],
FROM    TABLE1
GROUP BY PARTY

private class AsyncPop extends AsyncTask<Dialog, Integer, ScrollView>
{
    @Override
    protected void onPostExecute( ScrollView result )
    {
        setContentView( result );
        super.onPostExecute( result );
    }

    @Override
    protected ScrollView doInBackground( Dialog... params )
    {
        Dialog d = params[0];

        Connection con = StaticDBHelper.getCon( TabActivityDetail.this.getParent() );
        Statement st = null;

        List<Timestamp> date = new ArrayList<Timestamp>();
        List<String> text = new ArrayList<String>();
        try
        {
            st = con.createStatement();
            String sql = "select activityDateTime, detailText from xfu_ActivityDetail order by activityDateTime desc";
            st.execute( sql );
            ResultSet rs = st.getResultSet();

            while( rs.next() )
            {
                date.add( rs.getTimestamp( "activityDateTime" ) );
                text.add( rs.getString( "detailText" ) );
            }
            rs.close();

        }
        catch( SQLException e )
        {
            //Can't do a whole lot about it right now, should log
        }
        finally
        {
            if( null != st )
            {
                try
                {
                    st.close();
                }
                catch( SQLException e )
                {
                    //Just ignore it, should log
                }
            }
        }
        //Formatting
        ViewGroup.LayoutParams textBoxp1 = new ViewGroup.LayoutParams( 130, ViewGroup.LayoutParams.WRAP_CONTENT );
        ViewGroup.LayoutParams textBoxp2 = new ViewGroup.LayoutParams( ViewGroup.LayoutParams.FILL_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT );
        TableRow.LayoutParams rowp1 = new TableRow.LayoutParams( 130, TableRow.LayoutParams.WRAP_CONTENT );
        TableRow.LayoutParams rowp2 = new TableRow.LayoutParams( TableRow.LayoutParams.FILL_PARENT,
                TableRow.LayoutParams.WRAP_CONTENT );
        TableLayout.LayoutParams table1 = new TableLayout.LayoutParams( TableLayout.LayoutParams.FILL_PARENT,
                TableLayout.LayoutParams.FILL_PARENT );

        TableLayout tableView = new TableLayout( _context );
        tableView.setLayoutParams( table1 );
        if( date.size() == 0 )
        {
            TextView dateView = new TextView( _context );
            dateView.setText( "No activity details availible for given filter" );
            dateView.setTypeface( Typeface.DEFAULT, Typeface.BOLD );

            TableRow row = new TableRow( _context );
            row.setLayoutParams( new LayoutParams( LayoutParams.FILL_PARENT, LayoutParams.WRAP_CONTENT ) );
            row.addView( dateView );
            tableView.addView( row, new TableLayout.LayoutParams( LayoutParams.FILL_PARENT,
                    LayoutParams.WRAP_CONTENT ) );
        }
        else
        {
            for( int index = -1; index < date.size(); index++ )
            {
                TableRow row = new TableRow( _context );
                TextView dateView = new TextView( _context );
                TextView textView = new TextView( _context );

                if( index == -1 )
                {
                    dateView.setText( "Date / Time" );
                    textView.setText( "Detail Text" );
                    dateView.setTypeface( Typeface.DEFAULT, Typeface.BOLD );
                    textView.setTypeface( Typeface.DEFAULT, Typeface.BOLD );
                }
                else
                {
                    dateView.setText( LoaderV5._fm.format( date.get( index ) ) );
                    textView.setText( text.get( index ) );
                }
                dateView.setLayoutParams( textBoxp1 );
                textView.setLayoutParams( textBoxp2 );

                row.setLayoutParams( rowp2 );
                row.addView( dateView, rowp1 );
                row.addView( textView, rowp2 );
                tableView.addView( row, table1 );
            }
        }
        //tableView.setColumnShrinkable( 1, true );

        HorizontalScrollView otherscroller = new HorizontalScrollView( _context );
        otherscroller.addView( tableView );

        ScrollView scroller = new ScrollView( _context );
        scroller.addView( otherscroller );
        scroller.setHorizontalScrollBarEnabled( true );

        d.dismiss();
        return scroller;
    }
}

Activity.update(
    { "_id": activityId, "usersActivities.userId": Meteor.userId() },
    {
        "$set": {
            'usersActivities.$.startDate': start,
            'usersActivities.$.endDate': end
        }
    }
)

SELECT 
    CASE 
        WHEN ISNULL(bloodpressure,'') <> '' THEN bloodpressure
        WHEN ISNULL(sitting,'') <> '' THEN sitting
        WHEN ISNULL(lying,'') <> '' THEN lying
        WHEN ISNULL(standing,'') <> '' THEN standing
    ELSE 
        '0' END AS bloodpressure

SELECT slotnumber, fileid, rank
FROM
(
    SELECT slotnumber, fileid, Schedules.rank, RANK() OVER (PARTITION BY slotnumber ORDER BY Schedules.rank DESC) as rankfunc
    FROM Schedules
    INNER JOIN PlaylistSlots ON Schedules.playlistid = PlaylistSlots.playlistid
) tmp
WHERE rankfunc = 1

SELECT 'name' AS `field`. GROUP_CONCAT(DISTINCT `name`  ORDER BY `name`) AS `value`
FROM product
UNION ALL
SELECT 'category' AS `field`. GROUP_CONCAT(DISTINCT `category` ORDER BY `category`) AS `value`
FROM product
UNION ALL
SELECT 'price' AS `field`. GROUP_CONCAT(DISTINCT `price` ORDER BY `price`) AS `value`
FROM product
UNION ALL
SELECT 'year' AS `field`. GROUP_CONCAT(DISTINCT `year` ORDER BY `year`) AS `value`
FROM product

SELECT ig.section_id, ig.select_textName,
  isl.sec_id, isl.sec_textName,
  issl.item_sub_sec_id, issl.individualItemName
FROM item_groups ig  
JOIN ON items_section_list isl (ig.section_id = isl.section_id)
LEFT JOIN ON items_sub_section_list issl (isl.sec_id = issl.sec_id)
            WHERE issl.item_sub_sec_id>0
            ORDER BY ig.select_textName, isl.sec_textName, issl.individualitemName,   
            issl.item_sub_sec_id ASC

SELECT aID FROM B WHERE C IN(1,2) GROUP BY aID HAVING COUNT(*)=2;

select p.name,
       count(case when p.year=2008 then 1 end) as count 
from table1 p 
group by p.name

UPDATE (
    SELECT ROWNUM+5 AS r, fruit, number FROM TABLE
    WHERE fruit NOT IN ('Apple', 'Mango', 'Coconut', 'Grape', 'Orange')
    UNION
    SELECT 1 AS r, 'Apple' AS fruit, number FROM TABLE
    UNION
    SELECT 2 AS r, 'Mango' AS fruit, number FROM TABLE
    UNION
    SELECT 3 AS r, 'Coconut' AS fruit, number FROM TABLE
    UNION
    SELECT 4 AS r, 'Grape' AS fruit, number FROM TABLE
    UNION
    SELECT 5 AS r, 'Orange' AS fruit, number FROM TABLE
) 
SET number = r;

<many-to-one name="Order" class="Order" lazy="proxy">
  <column name="OCLORDN" not-null="true"/>
  <column name="OCLAMND" not-null="true"/>
  <column name="OCLCOSC" not-null="true"/>
</many-to-one>   

UPDATE table 
SET field = SUBSTRING(field, 1, CHAR_LENGTH(field) - 1) 
WHERE field LIKE '%+'

INSERT INTO word(id, name, describe) SELECT id, name, describe FROM temp 
ON DUPLICATE KEY UPDATE SET word.name = temp.name, word.describe = temp.describe;

DataTable dt;
using(SqlDataReader reader = command.ExecuteReader())
{
  dt = new DataTable();
  dt.Load(dr);
}

create table tbl1 ( ID int, a int, b char(3), d geometry );
create table tbl2 ( ID int, a int, b char(3), d geometry, other float );
insert tbl1 (ID, a, b, d) values
    (1, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))', 0)),
    (2, 3, 3, geometry::STGeomFromText('POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))', 0)),
    (3, 4, 3, geometry::STGeomFromText('POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))', 0)),
    (4, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 250 0, 150 150, 0 150, 0 0))', 0)),
    (5, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 350 0, 150 150, 0 150, 0 0))', 0))
insert tbl2 (ID, a, b, d) values
    (6, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))', 0)), -- same as tbl1.ID=1
    (7, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 950 0, 150 150, 0 150, 0 0))', 0)),
    (8, 2, 3, geometry::STGeomFromText('POLYGON ((0 0, 350 0, 150 150, 0 150, 0 0))', 0)); -- same as tbl1.ID=5

SELECT A, B, cast(c as geometry) c
FROM
(
    Select A,B,cast(D as varbinary(max)) c FROM tbl1
    UNION
    SELECT A,B,cast(D as varbinary(max)) FROM tbl2
) X;

Select Cast(Table.xmlcolumnname.query('/head/instance/tag1') as varchar(max)) 'col';

strace -f -s 1000 -tt sqlite3 newDatabase.db < myschema.sql

declare @str varchar(max)

Select @str = isnull(@str + '|', '') + testing
From temp
Order by testing

Select @str
--Results
Boomerang|Bowling|Boxing|Bull Fighting

SELECT SUBSTRING(s, 
                 CHARINDEX('<#', s) + 2, 
                 CHARINDEX('#/>', s) - CHARINDEX('<#', s) - 2) number
  FROM
(
  SELECT 'What is <#1#/>' s
) q

;WITH cte AS
  (
    SELECT Id, Class, Date,
      row_number() OVER (PARTITION BY Id
                         ORDER BY CASE Class
                                  WHEN 'Red' THEN 1
                                  WHEN 'Blue' THEN 2
                                  WHEN 'Green' THEN 3
                                  ELSE 4 END) as rn
    FROM MyTable
   )

SELECT Id, Class, Date
FROM cte
WHERE rn = 1

SELECT guildmembers.access, guildmembers.guildid, guildmembers.name, players.id, players.level, players.playerclass
FROM guildmembers join players on guildmembers.pid=players.id
ORDER BY guildmembers.name, players.playerclass

ORDER BY
    CASE WHEN (Num % 1) = .5
        THEN Num
        ELSE ROUND(Num,0)
    END

with t1vals as (select distinct checkID from t1),
     t2vals as (select distinct LearnerId from t2)
select t2vals.LearnerId, t1vals.CheckId, t3.CheckId
from t1vals cross join
     t2vals left outer join
     t3
     on t3.LearnerId = t2vals.LearnerId and
        t3.CheckId = t1vals.CheckId

SELECT *
FROM topics AS t
JOIN (SELECT topic_cat, MAX(topic_date) AS topic_date
      FROM topics
      GROUP BY topic_cat) AS maxt USING (topic_cat, topic_date)
RIGHT JOIN categories AS c ON t.topic_cat = c.cat_id

SELECT 
    t1.SomeID as FirstID,
    t2.SomeID as SecondID
FROM
(
    SELECT SomeID, ROW_NUMBER()OVER(ORDER BY SomeID) as Inc
    FROM TABLE
) t1
LEFT JOIN
(
    SELECT SomeID, ROW_NUMBER()OVER(ORDER BY SomeID)-1 as Inc
    FROM TABLE
) t2 ON t2.Inc = t1.Inc

select * from table(sys.odcivarchar2list('a', 'b'))
minus 
select * from table(sys.odcivarchar2list('c'))

TopCount([Dim Area].[Area].[Area], 2, ([Measures].[Count]))

SELECT Replace(REGEXP_SUBSTR(str, '\-([[:alnum:]]\-)+'), '-', ' ') as outstr
FROM (SELECT 'XTT-D-X-K-345ROCKVIEW-CA' AS str FROM dual
  UNION ALL SELECT 'RT-5-345REDE' AS str FROM dual
  UNION ALL SELECT 'FT-5-3-345HOTELWI' AS str FROM dual

select * from (
   select LOAN_NUMBER, DOCUMENT_TYPE, DOCUMENT_ID
   from my_table t
)
pivot 
(
   MIN(DOCUMENT_ID)
   for DOCUMENT_TYPE in ('Voters ID','Pan card','Drivers licence')
)

SELECT *
FROM  (SELECT *
       FROM table1) oldCTE

@script1.sql
@script2.sql
...etc...

Select i.InsuranceCompany, Count(c.InsuranceID) as 'Number of contracts'
from  Contracts c
join paymenttypes p on p.PaymentTypeID = c.PaymentTypeID
join insurancecompanies i on i.InsuranceID = c.InsuranceID
where c.PaymentTypeID = 3 AND p.PaymentTypeID = 3
Group by i.InsuranceCompany

SELECT user_id FROM table GROUP BY(user_id) HAVING COUNT(user_id) = 1

buckets_not_in_my_buckets = all_buckets - my_buckets

SELECT CompanyName, Count(ProductName)
  FROM Suppliers LEFT JOIN Products
    ON Suppliers.SupplierID = Products.SupplierID
 GROUP BY CompanyName;

SELECT DISTINCT
       least(fName, lName) fName,
       greatest (FName, lName) lName
  FROM table

SELECT current_setting('abc.my_var');

insert into Feature (weight, title) values (:w, :t) return @rid

SELECT DISTINCT CITY
FROM STATION
WHERE CITY RLIKE '^[aeiou].*[aeiou]$'

select imagepath from uploadimage
where upvote in (
   select max(upvote) from uploadimage
)

where
   (column1Value is null OR column1 = column1Value)
   and (column2Value is null OR column2 = column2Value)
   ...

SELECT
  Code,
  Name,
  (SELECT State
   FROM dbo.ShiftList 
   WHERE MONTH = cast(year(dateadd(month, 1, getdate())) * 100
                + month(dateadd(month, 1, getdate())) as char(6))
) AS SLNM
FROM dbo.Shops

SELECT id, user, date
FROM OriginalData od
WHERE date = (SELECT MIN(date) 
              FROM OriginalDate od1 
              WHERE od.id = od1.id)

mysqldump --host=host --user=user --password=password --no-data db_name > structure.sql

SELECT SumOfPointsEarned.Points - COALESCE(SumOfPointsOfPurchasesMade.Points, 0) AS CurrentPoints
FROM   
(
    SELECT SUM(Points) AS Points, Recipient_ID 
    FROM   transactions 
            WHERE Recipient_ID= 137642
    GROUP  BY Recipient_ID
) AS SumOfPointsEarned 
    LEFT JOIN 
    (
        SELECT purchases.Student_ID,  SUM(rewards.Cost_to_User) AS Points 
        FROM   purchases 
            INNER JOIN rewards 
            ON purchases.Reward_ID = rewards.Reward_ID 
                    WHERE Student_ID = 137642
        GROUP  BY purchases.Student_ID
    ) AS SumOfPointsOfPurchasesMade 
    ON SumOfPointsEarned.Recipient_ID = SumOfPointsOfPurchasesMade.Student_ID

    1  select sysdate,
    2         trunc(sysdate,'YEAR'),
    3         add_months(trunc(sysdate,'YEAR'),7),
    4         add_months(trunc(sysdate,'YEAR'),7-12)
    5*  from dual
  SQL> /

  SYSDATE     TRUNC(SYSDA ADD_MONTHS( ADD_MONTHS(
  ----------- ----------- ----------- -----------
  31-jul-2015 01-jan-2015 01-aug-2015 01-aug-2014

  SQL>

declare @table table
(period nvarchar(10),num int,cost int,value int)
insert into @table
select 'Jan-16',1,100,100 
union all select 'Feb-16',2,200,200 
union all select 'Mar-16',3,300,300
union all select 'Apr-16',4,400,400 
union all select 'May-16',5,500,500 
union all select 'Jun-16',6,600,600 
union all select 'Jul-16',7,700,700 
union all select 'Aug-16',8,800,800 
union all select 'Sep-16',9,900,900 
union all select 'Oct-16',10,1000,1000 
union all select 'Nov-16',11,1100,1100 
union all select 'Dec-16',12,1200,1200 


--select * from @table 

select 'No of Order' as Period,[Jan-16], [Feb-16],[Mar-16],[Apr-16],[May-16],[Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16],[Dec-16]
from 
(
select period,num from @table) u 
pivot  ( sum(num) for period in ([Jan-16] ,[Feb-16],[Mar-16],[Apr-16], [May-16], [Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16], [Dec-16]))
as pvt

union all
select 'Cost Of Order' as Period,[Jan-16], [Feb-16],[Mar-16],[Apr-16],[May-16],[Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16],[Dec-16]
from 
(
select period,cost from @table) u 
pivot  ( sum(Cost) for period in ([Jan-16] ,[Feb-16],[Mar-16],[Apr-16], [May-16], [Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16], [Dec-16]))
as pvt

union all
select 'Value Of Order' as Period,[Jan-16], [Feb-16],[Mar-16],[Apr-16],[May-16],[Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16],[Dec-16]
from 
(
select period,value from @table) u 
pivot  ( sum(value) for period in ([Jan-16] ,[Feb-16],[Mar-16],[Apr-16], [May-16], [Jun-16],[Jul-16],[Aug-16],[Sep-16],[Oct-16],[Nov-16], [Dec-16]))
as pvt

proc sql;
    create table filled(rename=(sales_filled=sales)) as
    select REGION_ID, STORE_ID, YEAR, max(SALES)/(max(YEAR)-min(YEAR)+1)*(YEAR-min(YEAR)+1) as sales_filled
    from sales_data
    group by REGION_ID, STORE_ID
    order by REGION_ID, STORE_ID, Year;
quit;

trip_hash = bankroll.transactions.group_by(&:trip_id).map {|tr,t| Hash[tr, t.map(&:amount).inject(:+)]}

=>[{0=>#<Money cents:137693 currency:USD>}, {7=>#<Money cents:-39509 currency:USD>}, {10=>#<Money cents:50009 currency:USD>}]

select t.text from topic t 
inner join
 (SELECT topic_id, COUNT(id) tags_count
   FROM tag WHERE id IN (3,4,5,6,7)
   GROUP BY topic_id
 ) tg on tg.topic_id = t.id
ORDER BY tg.tags_count DESC

FLOOR(CONVERT(FLOAT, DATEADD(hour, 5, EventTM))) AS DayNumber

CREATE TABLE [dbo].[#storeTable] (
[path] varchar(1000) not null,
    [nbdays] int,
    [offset] int
) ON [PRIMARY]

declare
   v_buffer varchar2(32767);
   v_offset integer := 5;
   v_xml xmltype;
   v_clob clob;
   v_input clob := 'xxxx<?xml version="1.0" encoding="UTF-8"?><test>This is a test</test>';
   i integer := 0;
begin
   dbms_lob.createtemporary (v_clob,true);
   v_buffer := dbms_lob.substr(v_input,32767,v_offset);
   while length (v_buffer) > 0 loop
      v_clob := v_clob || v_buffer;
      i := i + 1;
      v_buffer := dbms_lob.substr(v_input,32767, v_offset + i * 32767);
   end loop;
   dbms_output.put_line ('x'||v_clob||'x');
   v_xml := xmltype.createXML (v_clob); 
   dbms_lob.freetemporary (v_clob);
   dbms_output.put_line (v_xml.getclobval);
end;

SELECT home, configName, data, active
FROM config

UNION

SELECT ce.home, c.configName, c.data, c.active
FROM config_exceptions ce
INNER JOIN config c ON c.configName = ce.configName
WHERE ce.data <> c.data
AND c.home = 0

SELECT CID,
       SUM(CASE WHEN Delivered = 1 THEN boxes ELSE 0 END) AS Delivered,
       SUM(CASE WHEN Delivered = 0 THEN boxes ELSE 0 END) AS NotDelivered
FROM Dlivr
GROUP BY CID

;WITH YourQuery AS
(
 SELECT code, date1, date2 from Table
)
SELECT 
    T1.stuff, T2.morestuff 
    from YourQuery           T1
        INNER JOIN YourQuery T2 ON T1.code = T2.code and  T1.date1 = T2.date2

ListView listView = getListView();

//set background to color
listView.setBackgroundColor(#FF888888);

//set background to Drawable
listView.setBackgroundDrawable(myDrawable);

//set background to Resource
listView.setBackgroundResouce(R.id.my_res_id);

CREATE DEFINER=`pleb`@`%` PROCEDURE `test`(OUT power float, OUT durationMinutes float)
BEGIN

-- used to break out of the loop --
DECLARE finished INTEGER DEFAULT 0;
-- calculates power...
DECLARE hp float;
DECLARE acOn bool;
-- variables used to track one complete cycle
DECLARE acOffFound bool DEFAULT 0;
DECLARE acOnFound bool DEFAULT 0;
-- cursor should itterate over max 1day of values (5 minutes chunks = 288 chunks per day)
DECLARE sensor_cur CURSOR FOR SELECT heatingPower, inputAcOn FROM `pleb`.`sensordata` ORDER BY timestamp DESC LIMIT 288;
-- if notihing found loop should quit right away
DECLARE CONTINUE HANDLER FOR NOT FOUND SET finished = 1;
-- open the cursor
OPEN sensor_cur;
-- init zero
SET power = 0;
SET durationMinutes = 0;

-- loop over the result set
calculate: LOOP
 -- put into variables
 FETCH sensor_cur INTO hp, acOn;
 -- check if I should stop
 IF finished = 1 THEN 
  LEAVE calculate;
 END IF;
-- if we already found ac off and ac on and its off again get out of loop we are finished
 IF acOffFound = 1 AND acOnFound = 1 AND acOn = 0 THEN
  LEAVE calculate;
 END IF; 
 -- wait until we see power off first
 IF acOffFound = 0 AND acOn = 1 THEN
  ITERATE calculate;
 END IF;
 -- detect if we have seen power off
 IF acOffFound = 0 AND acOn = 0 THEN
  SET acOffFound = 1;
 END IF;
 -- detect if we found an power on
 if acOnFound = 0 AND acOn = 1 THEN
  SET acOnFound = 1;
 END IF;
 -- if its on calculate
 IF acOn = 1 THEN
  SET power = power + ( (hp * 5) / (1000*60) );
  SET durationMinutes = durationMinutes + 5;
 END IF;

 -- next cycle
 END LOOP calculate;


-- get rid of the cursor
CLOSE sensor_cur;
END

Provider=SQLOLEDB;Password="123 ";Persist Security Info=True;User ID=john;Initial Catalog=mydbname;Data Source=127.0.0.1

SELECT cust.nearestbranch,
    COUNT(distinct case when cust.category = 'Engineer' then customer_id end) eng,
    COUNT(distinct case when cust.category = 'Developer'then customer_id end) dev
    FROM customers cust
    LEFT JOIN orders ON cust.id = orders.customer_id
    WHERE DATE_FORMAT(orders.delivery_date, '%Y-%m') = '2014-09'
    GROUP BY cust.nearestbranch

select t21.text as subject, t22.text as description
from table1 t1
join table2 t21 on t1.refidone = t21.id
join table2 t22 on t1.refidtwo = t22.id

SELECT ordinal,YEAR(ceremonydate) as yr 
FROM awardinfo 
ORDER BY ceremonydate DESC LIMIT 1;

CREATE VIEW MyView
AS
 SELECT
   A.ID,
   A.Student1,
   B1.StudentName as Name1,
   A.Student2,
   B2.StudentName as Name2,
   A.Student1_Class,
   A.Student2_Class
 from
   TableA as A
   INNER JOIN
   TableB as B1 ON A.Student1_Class = B1.Class AND A.StudentID = B1.Student2
   INNER JOIN 
   TableB as B2 ON A.Student2_Class = B2.Class AND A.StudentID = B2.Student1 

create table UserCasestudies (
    UserCasestudiesId int not null auto_increment primary key,
    CastStudiesId int not null references Casestudies(CaseStudiesId),
    UserId int not null references Users(UserId),
    ReadDatetime datetime,
    SubmittedDatetime datetime,
    UploadDatetime datetime,
    URL varchar(100)
) ;

DECLARE @maxdate DATETIME
SELECT @maxdate = MAX(ModifiedDate) FROM [yourTable]
SELECT DATEADD(DAY, (DAY(@maxdate) - 1)*(-1), @maxdate)

Declare @DivNumber decimal(5,1);

SET @DivNumber = (.01 * 2541);

SELECT 
    CAST(ROUND(@DivNumber / Count(date_record_entered), 1) AS decimal(5,1))
  FROM dbo.tablename 
 WHERE date_record_entered IS NOT NULL 
   and date_record_entered >= 20131201 
   AND date_record_entered <= 20131231

SELECT SKU,
    case when p.SKU is null then 'notExists' else 'exists' end [exists?]
FROM (VALUES
   ('SKU1'),
   ('SKU2'),
   ('SKU3'),
   ('SKU4'),
   ......
   ......
   ......

   ('SKUN')
) SKU(SKU)
left outer join Products p on p.SKU = SKU.SKU

SELECT name, address, description
FROM names JOIN info USING(id)

create index your_table_x
    on your_table(your_column)
    indextype is ctxsys.context
    parameters ('sync (on commit)');

DECLARE @TBL TABLE(
    	C1 INT,
    	C2 INT
)

INSERT INTO @TBL (C1, C2) EXEC sptemp

SELECT *, 34 FROM @TBL

DECLARE @TestTable TABLE (ID INT IDENTITY(1,1), ColA INT, ColB INT)
INSERT INTO @TestTable (ColA, ColB) VALUES (5,2)
INSERT INTO @TestTable (ColA, ColB) VALUES (5,NULL)
INSERT INTO @TestTable (ColA, ColB) VALUES (NULL,2)


SELECT SUM(ColA) - SUM(ColB) FROM @TestTable 
SELECT SUM(ColA - ColB) FROM @TestTable

SELECT split_part('first:last', ':', 1) AS first_part

SELECT NAME, LISTAGG(CAR, ',') WITHIN GROUP (ORDER BY CAR) AS CARS
FROM   (SELECT NAME,CAR
FROM TABLE1, TABLE2
where TABLE1.IdN=TABLE2.IdC)
GROUP BY NAME;

INSERT INTO myTable (col1, col2, col3....)
SELECT 1, 2, mySP_or_mySDF(), 3, 4

CREATE TABLE Department
(
    ID INT,
    NAME VARCHAR(50),
    CONSTRAINT dept_pk PRIMARY KEY (ID),
    CONSTRAINT dept_uq UNIQUE(Name)
)

CREATE TABLE Employee
(
    ID INT,
    NAME VARCHAR(50),
    CONSTRAINT Emp_pk PRIMARY KEY (ID),
    CONSTRAINT Emp_uq UNIQUE(Name)
)

CREATE TABLE Employee_Department
(
    DepartmentID INT,
    EmployeeID INT,
    CONSTRAINT empdep_pk PRIMARY KEY (DepartmentID, EmployeeID),
    CONSTRAINT empdep_FK1 FOREIGN KEY (DepartmentID)
        REFERENCES Department(ID),
    CONSTRAINT empdep_FK2 FOREIGN KEY (EmployeeID)
        REFERENCES Employee(ID)
)

insert into table (funcs)
values('func1()'||
'func2()'||
'#func3()'||
'func4()'||
'#func5()');

SELECT a.id, a.col1, a.col2
  FROM tbl AS a
  JOIN tbl AS b ON 
      (     a.id=b.id
        AND (a.col1 =  b.col2 OR  a.col2 = b.col1)
        AND (a.col1 != b.col1 AND a.col2 != b.col2)
      )

DECLARE @countRatio decimal(6,3)     
SET @countRatio = (((2.0)/(4))*(6))/100.0
SELECT @countRatio 
==========================
0.030

SELECT pd.contentnodeid,
       pt.name,
       s.Value
FROM   vw_abc pd
       INNER JOIN propertytype pt
         ON pd.propertytypeid = pt.id
       INNER JOIN tab t
         ON t.id = pt.tabid
       INNER JOIN contenttype ct
         ON ct.nodeid = pt.contenttypeid
       INNER JOIN propertytype pt1
         ON pt1.name = pt.name
       INNER JOIN vw_abc pd1
         ON pd1.propertytypeid = pt1.id
       CROSS APPLY dbo.split(',', pd1.datanvarchar) as s
WHERE  t.TEXT LIKE 'ANC'
       AND pd1.datanvarchar <> 'NULL'
       AND pd1.datanvarchar <> ''
       AND pd.datanvarchar LIKE '%'
       AND pd1.datanvarchar LIKE '%'  

INSERT INTO t
(cod, name)
VALUES
('T1;T2;',
 'Pencil Box;Eraser;');

---------------------------
|COD   |NAME              |
|T1;T2;|Pencil Box;Eraser;|
---------------------------

INSERT t2
SELECT
  CAST('<r>'+REPLACE(cod,';','</r><r>')+'</r>' AS XML).query('/r[1]').value('.','varchar(256)') cod,
  CAST('<r>'+REPLACE(name,';','</r><r>')+'</r>' AS XML).query('/r[1]').value('.','varchar(256)') name
FROM t;

INSERT t2
SELECT
  CAST('<r>'+REPLACE(cod,';','</r><r>')+'</r>' AS XML).query('/r[2]').value('.','varchar(256)') cod,
  CAST('<r>'+REPLACE(name,';','</r><r>')+'</r>' AS XML).query('/r[2]').value('.','varchar(256)') name
FROM t;

----------------
|COD|NAME      |
|T1 |Pencil Box|
|T2 |Eraser    |
----------------

SELECT C.id_car, name, AVG(rating_value) AS average
FROM car C JOIN rating R 
      ON C.id_car = R.id_car
GROUP By C.id_car, name
ORDER BY average DESC

INSERT dbo.table VALUES(@p1, @p2, ...);

SELECT DATEDIFF(day, OrderDate, GETDATE())
FROM myTable

select DEPARTMENT_NAME, q1, q2, decode(q2, 0, null, q1 / q2) from
(select DEP.DEPARTMENT_NAME, 
count(distinct hsp.pat_id) q1, 
count(distinct case when meas.flo_meas_id in ('00', '7', '8', '9', '0') then hsp.pat_id else NULL end) q2
from pat_enc_hsp hsp 
left outer join clarity_adt adt on hsp.pat_enc_csn_id = adt.pat_enc_csn_id
left outer join clarity_dep dep on ADT.DEPARTMENT_ID = dep.DEPARTMENT_ID
inner join patient pat on hsp.PAT_ID = pat.PAT_ID
left outer join ip_flwsht_rec rec on rec.INPATIENT_DATA_ID = hsp.INPATIENT_DATA_ID
left outer join ip_flwsht_meas meas on rec.FSD_ID = meas.FSD_ID
left outer join ip_flo_gp_data on meas.FLO_MEAS_ID = ip_flo_gp_data.FLO_MEAS_ID
where adt.department_id IN (1,2,3,4,5) 
and (hsp.ed_disposition_c is null or hsp.ed_disposition_c not in ('5','6'))
and hsp.HOSP_ADMSN_TIME between TO_DATE ('08-10-2014 00:00:00', 'DD-MM-YYYY HH24:MI:SS') and TO_DATE ('08-10-2014 23:59:59', 'DD-MM-YYYY HH24:MI:SS')
GROUP BY DEP.DEPARTMENT_NAME);

with ordered as (
    select *, rn = row_number() over (partition by fk_id order by pk_id)
      from tbl
    )
update cur
   set value = cur.value - prior.value
  from ordered cur
  join ordered prior on prior.fk_id = cur.fk_id
                and prior.rn = cur.rn-1;

SELECT Users.id, Users.username, COUNT(*) AS classes 
  FROM Users 
LEFT OUTER JOIN Classes ON User.fk_class_id = Classes.id 
       GROUP BY Users.id, Users.username

SELECT T.* 
FROM
    (SELECT CAST('Hello' AS VARBINARY(MAX)) AS test_col1,
            CAST('World' AS VARBINARY(MAX)) AS test_col2) AS T
     WHERE CAST(test_col1 AS VARCHAR(MAX)) LIKE '%' + CAST(0x48 AS VARCHAR(MAX)) + '%'

select 
sum(case when Healthcare ='1' then 1 else 0 end)  as [Healthcare_never],
sum(case when Healthcare ='2' then 1 else 0 end)  as [Healthcare_not often],
sum(case when Healthcare ='3' then 1 else 0 end)  as [Healthcare_average],
sum(case when Healthcare ='4' then 1 else 0 end)  as [Healthcare_often],
sum(case when Healthcare ='5' then 1 else 0 end)  as [Healthcare_very often],
avg(Cast((case when Healthcare > 0 Then Healthcare Else Null end) as float)) as Healthcare_Average,
count(case when Healthcare > 0 Then Healthcare Else Null end) as N_Healthcare,

sum(case when Religious ='1' then 1 else 0 end)  as [Religious_never],
sum(case when Religious ='2' then 1 else 0 end)  as [Religious_not often],
sum(case when Religious ='3' then 1 else 0 end)  as [Religious_average],
sum(case when Religious ='4' then 1 else 0 end)  as [Religious_often],
sum(case when Religious ='5' then 1 else 0 end)  as [Religious_very often],
Avg(cast((case when Religious > 0 Then Religious Else Null end) as float)) as Religious_Average,
count(case when Religious > 0 Then Religious Else Null end) as N_Religious,

sum(case when Sport ='1' then 1 else 0 end)  as [Sport_never],
sum(case when Sport ='2' then 1 else 0 end)  as [Sport_not often],
sum(case when Sport ='3' then 1 else 0 end)  as [Sport_average],
sum(case when Sport ='4' then 1 else 0 end)  as [Sport_often],
sum(case when Sport ='5' then 1 else 0 end)  as [Sport_very often],
Avg(cast((case when Sport > 0 Then Sport Else Null end) as float)) as Sport_Average,
count(case when Sport > 0 Then Sport Else Null end) as N_Sport

from Member 

select *
from b
where type_id in (
  select type_id
  from a
  where status = true
)

var query = from date in dbdate.Dates 
            join article in dbarticle.Articles on date.ArticleBarcode
                                               equals article.Barcode
            let days = article.days 
                    ?? db.Groups.Where(g => g.Number == article.GroupNumber)
                                .Select(g => g.Days).FirstOrdefault()
                    ?? 0
            where DbFunctions.AddDays(date.RunDate, days * -1) > DateTime.Now
            select article;

psql -h 192.168.10.160 -p 5432 -f C:\Backup.sql db_name postgres 

SELECT t1.a, t2.d*t2.f AS m, SUM(t2.d*t2.f)
FROM table1 AS t1, table2 AS t2 
WHERE t1.a=t2.a GROUP BY t1.b

SELECT
  stuff
FROM 
  foo
INNER JOIN
  bar
    ON  (join predicates here)
WHERE
  (static filters here)

SELECT users.username, COUNT(mail.receiver) AS count_mail
FROM users 
LEFT JOIN mail ON mail.receiver = users.username 
LEFT JOIN block ON block.blocker = users.username
    AND mail.sender = block.blocked
WHERE block.blocked IS NULL
GROUP BY 1

declare
cursor c is
SELECT * FROM Measurement WHERE Value >= 1234567890 ORDER BY Value ASC;
l_rec c%rowtype;
begin
    open c;
    for i in 1 .. 2000
    loop
        fetch c into l_rec;
        exit when c%notfound;
    end loop;
    close c;
end;
/

SELECT Sheet1.[PROJECT_NAME], MAX(Sheet1.[MILESTONE_NAME])
FROM Sheet1
    INNER JOIN Sheet1 AS Sheet1_1 ON (Sheet1.[PROJECT_NAME] = Sheet1_1.[PROJECT_NAME])
        AND (Sheet1.[MILESTONE_NAME] = Sheet1_1.[MILESTONE_NAME])
GROUP BY Sheet1.[PROJECT_NAME]
ORDER BY Sheet1.[PROJECT_NAME]

SELECT  a."UserID",
        a."Name",
        b."Name" As AIDName
FROM    tableName a
        INNER JOIN tableName b
            ON a."AidID" = b."UserID"

DELETE FROM MyTableName;
DELETE FROM SQLITE_SEQUENCE WHERE NAME = 'MyTableName';

-- Syntax
-- DATEDIFF ( datepart , startdate , enddate )

-- Example usage
SELECT DATEDIFF(DAY, GETDATE(), GETDATE() + 1) AS DayDiff
SELECT DATEDIFF(MINUTE, GETDATE(), GETDATE() + 1) AS MinuteDiff
SELECT DATEDIFF(SECOND, GETDATE(), GETDATE() + 1) AS SecondDiff
SELECT DATEDIFF(WEEK, GETDATE(), GETDATE() + 1) AS WeekDiff
SELECT DATEDIFF(HOUR, GETDATE(), GETDATE() + 1) AS HourDiff
...

SELECT COALESCE(b.logo, dflt.logo) AS logo 
FROM mytable dflt
LEFT OUTER JOIN mytable b ON b.customerid=5
WHERE dflt.customerid=18

select *
from (
   select MATCH(test) AGAINST("str" IN BOOLEAN MODE) AS testRelevance,
          ....
   from ...
   where ... 
) as t
where testRelevance > 0

;with SkipHour(UserID, LoginAT, rn) as (
  select UserID, min(LoginAt), cast (1 as bigint)
    from LogTable
   group by UserID
  union all
  select SkipHour.UserID, LogTable.LoginAt,
         row_number() over (partition by SkipHour.UserID 
                            order by Logtable.LoginAt) rn
  from SkipHour
     inner join LogTable
        on LogTable.UserID = SkipHour.UserID
     where datediff(minute, SkipHour.LoginAt, LogTable.LoginAt) >= 60
     -- Only first rows from previous generation qualify to have children
        and rn = 1
)
select *
from SkipHour
where rn = 1
order by UserID, LoginAT

insert into user(name, subid)
    select n.name, coalesce(max(u.subid), 1)
    from (select 'bbb' as name union all select 'ccc') n left join
         user u
         on u.name = n.name
    group by u.name;

SELECT LPAD('columnname',11,'0')

Create  Proc TestProc (@LN Nvarchar(100), @FN Nvarchar(100), @DOB Nvarchar(100)) 
As
--      TestProc    '''Hello''', '''What'',''Hmmm''', Null

Declare @SQL Nvarchar(Max),
        @Columns Nvarchar(Max) = '',
        @OrCriteria Nvarchar(Max) = '';        

If      @LN Is Not Null
Begin
        Set     @Columns = @Columns + 'LN, ';
End;         

If      @FN Is Not Null
Begin
        Set     @Columns = @Columns + 'FN, ';
End;     

If      @DOB Is Not Null
Begin
        Set     @Columns = @Columns + 'DOB, ';
End;     

Select  @OrCriteria = Coalesce(@OrCriteria + ' Or ','') + varType + ' In (' + varVal + ')' 
From   (Select  'LN' As varType, @LN As varVal
        Union
        Select  'FN', @FN
        Union
        Select  'DOB', @DOB) As n

If      @Columns <> ''
Begin
        Set     @SQL = 'Select  ' + Left(RTrim(@Columns),Len(RTrim(@Columns))-1) + '
                        From    TestData 
                        Where   (' + @OrCriteria + ')';

        Select  @SQL
        --  Exec    sp_executeSQL @SQL;                     
End
Else
Begin
        Return;
End;

 SELECT OS_NAME FROM OS WHERE VERSION LIKE '*1*' 

SELECT f.Name, f.Friend
FROM FRIENDSHIP f INNER JOIN SCHOOL s1 ON f.Name = s1.Name
INNER JOIN SCHOOL s2 ON f.Friend = s2.Name
WHERE s1.School <> s2.School

SELECT set_config(
    'search_path',
    current_setting('search_path') || ',zzz',
    false
) WHERE current_setting('search_path') !~ '(^|,)zzz(,|$)';

select id, department_code, sub_department_code, class_code,
       (case when sub_department_code is null and class_code is null
             then desc_text
        end) as department_name,
       (case when department_code is not null and sub_department_code is not null and class_code is null
             then desc_text
        end) as sub_department_name,
       (case when class_code is not null then desc_text
        end) as class_name
from t

SELECT u.username, SUM(l.points) AS points
  FROM leaderboard l
        INNER JOIN yourUserTable u
                ON l.id = u.ColumnNameForTheUserId
 WHERE roundtime BETWEEN LOCALTIMESTAMP - INTERVAL '24 hours' 
                     AND LOCALTIMESTAMP
 GROUP BY u.username 
 ORDER BY points DESC 
 LIMIT 25

CREATE TRIGGER trDriver
   ON  DRIVER
   AFTER INSERT, UPDATE
AS 
BEGIN
    SET NOCOUNT ON;

    IF NOT EXISTS(Select * 
              from CompanyBranch cb
              Inner join inserted i on i.BranchPostedAt = cb.BranchId )
    BEGIN
        RAISERROR ('The BranchPostedAt is not in the CompanyBranch table.', 16, 1);
        ROLLBACK TRANSACTION;
        RETURN
    END

END
GO

;WITH t AS (
SELECT 1 AS iteration, p.Permission_ID AS PermissionID, p.Permission_ID, CAST(N'/' + p.Permission AS NVARCHAR(MAX)) AS Permission
FROM #TempPermissions AS p
UNION ALL
SELECT iteration + 1, t.PermissionID, p.Parent_ID, COALESCE(N'/' + (SELECT s.Permission FROM #TempPermissions AS s WHERE s.Permission_ID = p.Parent_ID), N'') +  t.Permission
FROM t INNER JOIN #TempAppPermissions AS p ON t.Permission_ID = p.Permission_ID
)
SELECT PermissionID, Permission FROM t
WHERE Permission_ID = -1
ORDER BY PermissionID, Iteration

update crates cr set cr.total_pieces = 
(
    select sum(bu.pieces) pieces from crates cr
    join boxes bo on bo.crate_id = cr.id
    join buckets bu on bu.box_id = box.id
    where crate.id = cr.id
    group by crate.id
);

SELECT 
    d.ItemID 
FROM 
    Documents d 
WHERE 
    d.ItemID NOT IN 
      (
         --this would be whatever your first query was
         SELECT TOP 250 ItemID 
         FROM Documents 
         WHERE CategoryID = d.CategoryID 
         ORDER BY d.ItemID DESC
      ) 

;with tcte(tid, tname, lvl) 
as
(
select st.object_id, st.name, 0 
from sys.tables st left join sys.foreign_keys sfk on sfk.parent_object_id = st.object_id 
where sfk.name is null

union all

select st.object_id, st.name, 1 
from sys.tables st left join sys.foreign_keys sfk on sfk.parent_object_id = st.object_id 
where sfk.parent_object_id = sfk.referenced_object_id

union all

select st.object_id as tid, st.name, tcte.lvl + 1 
from sys.tables st inner join sys.foreign_keys sfk on sfk.parent_object_id = st.object_id 
inner join tcte on tcte.tid = sfk.referenced_object_id
where tcte.tid <> sfk.parent_object_id
)

select tname, max(lvl) lvl from tcte group by tname order by lvl

select SUBSTR(COMMENTS, 1,INSTR(COMMENTS, '|',1,1)-1) dates,
       SUBSTR(COMMENTS, INSTR(COMMENTS, '|',1,1)+1,(INSTR(COMMENTS, '|',1,2)-INSTR(COMMENTS, '|',1,1)-1) ) EMPLOYEE_NAME,
       SUBSTR(COMMENTS, INSTR(COMMENTS, '|',1,2)+1,length(COMMENTS) ) COMMENTS 
  from MIG_BRM_ACCT_NOTE;

SELECT term_taxonomy_id
FROM wp_term_relationships
WHERE object_id = 8 AND 
      object_id NOT IN (SELECT term_taxonomy_id
                        FROM wp_term_relationships
                        WHERE object_id IN (1, 2, 3, 4, 5)
                       )

 INSERT into outter_table@outter_db
 SELECT * from inner_view

UPDATE 
  prc.user, 
  prc_test.user 
SET 
  prc_test.user.pwd_user = prc.user.pwd_user
WHERE 
  prc_test.user.name_user = prc.user.name_user

SELECT Files.ID, count(Payments.FileID) as numpays FROM
Files
LEFT OUTER JOIN
Payments
ON Files.id=Payments.FileID
GROUP BY files.ID
ORDER BY numpays desc

UPDATE SET table SET user_name= CAP_FIRST(CONCAT(SUBSTRING_INDEX(user_name, ' ',-1), ' ', SUBSTRING_INDEX(user_name, ' ',1)))

res = Item.scoped

res = res.where(["creator_id is ?", cr.id]) if cr
res = res.where(["title like ?", "%#{title}%"]) unless title.empty?
res = res.where(["description like ?", "%#{description}%"]) unless description.empty?

SELECT t1.Id, t1.Name, t2.Color 
from TableA t1 left outer join TableB t2 
on t1.Id_TableB = t2.Id;

SELECT 
       alias.name alias, team.name team, sid.steam_id steam_id,
       (SUM(IFNULL(ws1.kills,0)) + SUM(IFNULL(ws2.kills,0)) + SUM(IFNULL(spnr.kills,0))) kills_total
FROM pickup
            JOIN player ON player.pickup_id = pickup.id
            JOIN team ON player.team_id = team.id
            JOIN sid ON player.sid_id = sid.id
            JOIN alias ON player.alias_id = alias.id
            LEFT JOIN weapon_stats_1 ws1 ON ws1.pickup_id = pickup.id AND ws1.player_id = player.id
            LEFT JOIN weapon_stats_2 ws2 ON ws2.pickup_id = pickup.id AND ws2.player_id = player.id
            LEFT JOIN spanner_stats spnr ON spnr.pickup_id = pickup.id AND spnr.player_id = player.id
WHERE pickup.logfile_name = 'srv-20130725-2151-log' GROUP BY player.id ORDER BY kills_total DESC

string sqlQuery = "select e.RelatedID from tblA e "
                                + "join (select MAX(r.CreatedDate) as RecendDate, r.RelatedID "
                            + "from tblA r "
                            + "where r.RelatedTable = 'tblB' and r.Publishers in (2,3) "
                            + "group by r.RelatedID) x on e.RelatedID = x.RelatedID and e.CreatedDate = x.RecendDate "
                            + "where e.RelatedTable = 'tblB' and e.Publishers in (2,3) and e.RemoveFlag = 1 "
                            + "union "
                            + "select distinct(l.ListingID) from  tblA e "
                            + "inner join tblB l on e.RelatedID = l.ListingID "
                            + "inner join tblC os on l.StateID = os.StateID "
                            + "where os.StateCode = 'COMPLETE' ";

DECLARE @someval BIT = 'true'

SELECT @someval

SET @someval = 'false'

SELECT @someval

  select COUNT(*) from Employee emp  
  where 
  (@@SERVERNAME = 'Server1' AND emp.LocationID in (1,2,3))
    OR 
  (@@SERVERNAME = 'Server2' AND emp.LocationID in (4,5,6))
    OR 
  (@@SERVERNAME = 'Server3' AND emp.LocationID in (7,8,9))

SELECT SUM(CASE WHEN person.sex=1 THEN 1 ELSE 0 END) AS Female, 
       SUM(CASE WHEN person.sex=0 THEN 1 ELSE 0 END) AS Male,
       cast(DATEDIFF(CURRENT_DATE,person.birthday)/(365.256366) AS SIGNED) AS Age
FROM person
GROUP BY Age

SELECT * FROM Table1
WHERE (a is null or a != 2) and (b is null or b != 5)

select *
from (
    select product_id,
           product_no,
           product_registration_no, 
           lag(product_id) over (partition by product_no order by product_id) as prev_id,
           lead(product_id) over (partition by product_no order by product_id) as next_id
    from mytab
) 
where product_no='20120033' 
and product_registration_no='green' 

UPDATE table SET post_content = REPLACE(post_content, 'String: [css3_grid id=''gcse'']', '');

SELECT actorID, quotes.*
FROM ACTOR_QUOTES
CROSS JOIN TABLE(QUOTES) quotes
WHERE ACTORID = ('200');

WHERE NOT (
    FirstDate = '01 JAN 2015'
    AND
    Name IN ('Foo', 'Bar') )

WITH cte1 AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY DATE 
                               ORDER BY CASE WHEN Dogs IS NULL THEN 1 END) r1 
  FROM View1
), cte2 AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY DATE 
                               ORDER BY CASE WHEN Region IS NULL THEN 1 END) r2
  FROM View2
), cte3 AS (
  SELECT *, ROW_NUMBER() OVER (PARTITION BY DATE 
                               ORDER BY CASE WHEN Bed IS NULL THEN 1 END) r3
  FROM View3
)
SELECT COALESCE(cte1.Date, cte2.Date, cte3.Date) Date, 
                Dogs, D_Qty, Region, R_Qty, Bed, B_Qty
FROM cte1
FULL OUTER JOIN cte2
  ON cte1.Date = cte2.Date AND r1=r2
FULL OUTER JOIN cte3
  ON cte1.Date = cte3.Date AND r1=r3
  OR cte2.Date = cte3.Date AND r2=r3
ORDER BY Date, COALESCE(r1,r2,r3)

select * from table 
where find_in_set(4,receiver_id ) >0

String categoryID = new Integer(position).toString();

            final String SELECT_FROM = "SELECT description " + "FROM games "
                    + "WHERE _id = " + categoryID;
            Cursor cursor = database.query(SELECT_FROM);
            cursor.moveToFirst();

            Intent intent = new Intent();
            intent.setClass(SqliteDbActivity.this, ViewAction.class);

            Bundle b = new Bundle();
            b.putString("categoryID", cursor.getString(cursor.getColumnIndex("fieldname"));
            intent.putExtras(b);

            startActivity(intent);

On Error resume next
Dim RecordsAffected as long
Dim cmd
Set cmd = server.createobject("ADODB.Command")

cmd.ActiveConnection = GetConnectionString()
cmd.CommandText = "Select stuff here"
cmd.CommandType = adCmdText

cmd.Execute RecordsAffected, , adExecuteNoRecords
If err.number > 0 or RecordsAffected = 0 then
    Response.Write "No record affected or SQL error or something"
end if

INSERT INTO temptable (RoomID, isavailable)
SELECT t1.RoomId, 1 // static  value
FROM Room t1 
INNER JOIN 
(
    SELECT RoomID, SUM(quantity) AS QTY 
    FROM Room_Item 
    GROUP BY RoomID 
    HAVING SUM(Quantity) > 0
) t2 ON t1.RoomID = t2.RoomID 
ORDER BY RoomID

select  SiteName
    ,SUM(Case When DATEPART(mm,OrderDate) = DATEPART(mm,getdate())
                        and DATEPART(yyyy,OrderDate) = DATEPART(yyyy,getdate())
                        and DATEPART(dd,OrderDate) > DATEPART(dd,DATEADD(DAY, 1-DATEPART(WEEKDAY, getdate()), getdate()))
              Then 1
            Else 0 
            End) as Orders
from SiteOrder where SiteName in ('Site1','Site2','Site3','Site4')
GROUP BY SiteName
order by SiteName

ROUND(MONTHS_BETWEEN(CON.F_CON_END_DATE, TRUNC(SYSDATE)), 0) MONTHSTOEXPIRE

declare @string nvarchar(255)

select @string = coalesce(@string + ', ', '') + cast(prodid as nvarchar(5))
from products

update t
    set status = b.status
    from myTable t
        inner join lastBackup.dbo.myTable b
            on t.idField = b.idField

SELECT     V.CODE_OF_HOLIDAY, V.SITES_CODE, A.SITES_NAME, D.DESCRIPTION
FROM       ZZZ_SITES_VISITED V, ZZZ_SITES_AVAILABLE A, ZZZ_HOLIDAY_DETAILS H, ZZZ_DIFFICULTY_RATINGS D
WHERE      V.CODE_OF_HOLIDAY = H.CODE_OF_HOLIDAY
AND        A.SITES_CODE = V.SITES_CODE(+)
AND        H.DIFFICULTY_RATING = D.HOLIDAY_DIFICULTY
AND        H.CODE_OF_HOLIDAY = V.CODE_OF_HOLIDAY
AND        LENGTH(D.DESCRIPTION) > 6
ORDER BY   V.SITES_CODE

with t(date_col) as (
select '01/01/2014' from dual
union all
select '1/2/2014' from dual
union all
select '01/3/2014' from dual
union all
select '1/04/2014' from dual
union all
select '11/1/14' from dual)
select date_col,
       case
         when regexp_instr(date_col, '^\d/\d/\d{4}$') = 1 then
          'd/m/yyyy'
         when regexp_instr(date_col, '^\d{2}/\d/\d{4}$') = 1 then
          'dd/m/yyyy'
         when regexp_instr(date_col, '^\d/\d{2}/\d{4}$') = 1 then
          'd/mm/yyyy'
         when regexp_instr(date_col, '^\d{2}/\d{2}/\d{4}$') = 1 then
          'dd/mm/yyyy'
         else
          'Unknown format'
       end date_format
  from t;

DATE_COL   DATE_FORMAT
---------- --------------
01/01/2014 dd/mm/yyyy
1/2/2014   d/m/yyyy
01/3/2014  dd/m/yyyy
1/04/2014  d/mm/yyyy
11/1/14    Unknown format

SELECT @query:=CONCAT(
      'select count(*) from ('
    , GROUP_CONCAT( CONCAT( y.prefix, x.table_schema, y.postfix ) SEPARATOR ' UNION ALL ' )
    , ') as total_count' )
FROM (
    SELECT  DISTINCT table_schema
    FROM    information_schema.tables
    WHERE   table_schema LIKE '%dog%'
    ) AS x
JOIN (
    SELECT
          'select * from '        AS prefix
        , '.log where insane = 1' AS postfix 
    ) AS y
;

-- SELECT @query AS Query;

PREPARE STMT FROM @query;
EXECUTE STMT;
DEALLOCATE PREPARE STMT;

SELECT CLASS, COUNT (*)
FROM MYTABLE
GROUP BY CLASS

import os
db.myTable.image_thumbnail.default = os.path.join(request.folder, 'static', 'images', 'defaultUpload.png')

SELECT pr.ProdName, pr.ProdPrice
FROM Product pr
 INNER JOIN OrdLine ol ON pr.ProdNo=ol.ProdNo
 INNER JOIN OrderTbl ord ON ord.OrdNo = ol.OrdNo
 INNER JOIN Customer cu ON cu.CustNo=ord.CustNo 
WHERE cu.CustNo='C2388597'
AND ord.OrdDate BETWEEN '01-Jan-04' AND '31-Jan-04';

PaymentAccFactID        Int
PaymentNaturalKey       Int (the "natural identifier" of a transaction)
CustomerDim             Int
PaymentTypeDim          Int 
... additional dims as needed ...
NewStatusTS             Timestamp (ansi timestamp)
NewStatusHourDim        Int
NewStatusFlag           SmallInt
ProcessingStatusTS      Timestamp 
ProcessingStatusHourDim Int
ProcessingStatusFlag    SmallInt
SucceededStatusTS       Timestamp
SucceededStatusHourDim  Int
SucceededStatusFlag     SmallInt
FailedStatusTS          Timestamp
FailedStatusHourDim     Int
FailedStatusFlag        SmallInt

SELECT * 
FROM BlogPosts 
WHERE ID IN 
    (SELECT PostID FROM photos GROUP BY PostID HAVING count(*) >= 5)

UPDATE table SET file_path = SUBSTR(file_path, 1, LENGTH(file_path) - LOCATE('/', REVERSE(file_path))+1) WHERE 1;

SELECT l.id, l.name, l.email, lm.id, lm.name, lm.email, 
   MAX(CASE WHEN f.title = 'Firstname' THEN fd.val END) FirstName,
   MAX(CASE WHEN f.title = 'Lastname' THEN fd.val END) Lastname,
   MAX(CASE WHEN f.title = 'Country' THEN fd.val END) Country,
   MAX(CASE WHEN f.title = 'Town' THEN fd.val END) Town
FROM lists l
   JOIN listmembers lm ON l.id=lm.nl
   JOIN fieldsdata fd ON fd.eid = lm.id
   JOIN fields f ON f.id = fd.fid 
GROUP BY l.id, lm.id

select
p.product
, case when ld.visibility = 'private' then
   'PRIVATE'
  else
   u.name
  end as listed_by
, case when ld.visibility = 'private' then
   'PRIVATE'
  else
   ld.list_name
  end as listed_name
from products p

inner join users u on u.ser_id = p.user_id
inner join user_onto_list uol on uol.user_id = u.user_id
inner join list_detail ld on ld.list_id = uol.list_id

WITH CUSTS AS (SELECT 1000 AS CUST_NO, TO_DATE('01-JAN-2015', 'DD-MON-YYYY') AS START_DATE, TO_DATE('31-DEC-2015', 'DD-MON-YYYY') AS END_DATE FROM DUAL UNION ALL
               SELECT 1001 AS CUST_NO, TO_DATE('02-JAN-2015', 'DD-MON-YYYY') AS START_DATE, TO_DATE('31-DEC-2016', 'DD-MON-YYYY') AS END_DATE FROM DUAL UNION ALL
               SELECT 1002 AS CUST_NO, TO_DATE('02-JAN-2015', 'DD-MON-YYYY') AS START_DATE, TO_DATE('31-MAR-2015', 'DD-MON-YYYY') AS END_DATE FROM DUAL UNION ALL
               SELECT 1003 AS CUST_NO, TO_DATE('03-JAN-2015', 'DD-MON-YYYY') AS START_DATE, TO_DATE('31-AUG-2015', 'DD-MON-YYYY') AS END_DATE FROM DUAL ),
     DATES AS (SELECT DISTINCT TRUNC(TO_DATE('04-JAN-2015', 'DD-MON-YYYY') - DAYINCREMENT, 'DD') AS DT
                FROM (SELECT LEVEL-1 AS DAYINCREMENT
                        FROM DUAL
                        CONNECT BY LEVEL <= 30))
SELECT d.DT, COUNT(*)
  FROM CUSTS c
  CROSS JOIN DATES d
  WHERE d.DT BETWEEN c.START_DATE AND c.END_DATE
  GROUP BY d.DT
  ORDER BY DT DESC

sum(case when t.credit then t.amount else -t.amount end)

select *, case when id in (1,5,7) 
               then 'T'
               else 'W'
          end as status
from your_table

        select CASE 
                WHEN exists (select email from companies c where c.Id = u.ID and c.Email = u.Email) THEN 1 
                ELSE 2 END as SortMeFirst,   * 
    From Users u 
    where companyId = 1 
    order by SortMeFirst

UPDATE c SET NextCallTime = dbo.GetNextCallTime(CallID)
OUTPUT deleted.* --Which returns the copy of the row before the change is made
FROM 
(SELECT TOP 1 * FROM Calls ORDER BY NextCallTime) c
;

select field_a, field_b
  from (select field_a,
               field_b,
               max(field_b) over (partition by primary_key_id) as max_b
          from table_a)
 where primary_key_id=123
   and field_b = max_b;

EXEC sp_rename 'Sales.SalesTerritory', 'SalesTerr';

declare @find varchar(100) = 'cafe';

declare @phrase varchar(100) = 'I like the cafe at my office';

;with 
x(x)
as (    select cast('<w>'+replace(@phrase, ' ', '</w><w>')+'</w>' as xml)
    ),
words(pos, word)    
as  (   select  dense_rank() over (order by n),
                p.n.value('.', 'varchar(100)')
        from x
        cross
        apply x.nodes('/w')p(n) 
    )
select  d.* 
from    words w
cross
apply   (   select  * 
            from    words 
            where   pos in (w.pos-1, w.pos+1)
        )d(pos, word)
where   w.word=@find

Scanner teclado=new Scanner(System.in);

try{
    ObjectContainer db= Db4oEmbedded.openFile("DB4O.yap");
    System.out.print("Name of Wine: ");
    String nomVino = teclado.next();
    System.out.print("Name of Cellar: ");
    String nomBodega = teclado.next();
    System.out.print("D.O: ");
    String DO = teclado.next();

    System.out.print("Type of Wine: ");
    String tipoVino = teclado.next();
    System.out.print("Grad: ");
    float gradosAlch = teclado.nextFloat();
    System.out.print("Year of wine: ");
    int fecha = teclado.nextInt();

    teclado.close();

    ObjectSet<Bodega> foundBodegas = db.query(new Predicate<Bodega>() {
                                        @Override public  boolean match(Bodega candidate) {
                                             return candidate.getName().equals(nomeBodega);
                                        }});

    Bodega bodega = null;

    if (foundBodegas.size() == 1) {
        bodega = foundBodegas.next();
    }
    else {
        bodega = new Bodega(nomBodega, DO);
    }

    Vinos v = new Vinos(nomVino,  bodega  ,tipoVino,gradosAlch,fecha);

    db.store(v); //guardar objetos
    db.commit(); // valida los datos
    //odb.rollback(); // deshace los datos
    System.out.print("Vino Introducido\n");
    db.close(); //cerrar la bd  
}
catch(Exception e)
{
    System.out.println (e);
}

SELECT t1.id as id,
    t1.text as english,
    t2.text as translated
FROM translation t1
    LEFT JOIN translation t2 on t1.id = t2.id
        and t2.locale = :locale
WHERE t1.locale = 'en_US'
ORDER BY translated

SELECT item 
FROM dbo.customerTable
WHERE ISNULL(customerId,'') IN (SELECT Customer FROM @customers)

DECLARE @D AS DATE='15-jan-2011'
;WITH CTE 
as
(   SELECT * 
    FROM user_subscription 
    WHERE (@D BETWEEN subscription_start_date and subscription_end_date) OR subscription_end_date <= @D 
),
CTE1
AS
(
   SELECT ROW_NUMBER() OVER(PARTITION BY USER_ID ORDER BY subscription_end_date DESC) AS RN,*
   FROM CTE
)

SELECT * FROM CTE1 WHERE RN=1 

(DATEPART(hh, @yourValue) * 60 * 60) + (DATEPART(mi, @yourValue) * 60) + DATEPART(s, @yourValue)

SELECT "code",
    geo(38.73311, -9.138707, "geo_latitude", "geo_longitude") AS "distance"
    FROM "pt_postal" WHERE 1 = 1
        AND "geo_latitude" BETWEEN 38.7241268076 AND 38.7420931924
        AND "geo_longitude" BETWEEN -9.15022289523 AND -9.12719110477
        AND "distance" <= 1
    ORDER BY "distance" ASC
LIMIT 2048;

SELECT MAX(CONVERT(DateTime, MaybeDate))
FROM (
  SELECT MaybeDate
  FROM MyTable
  WHERE ISDATE(MaybeDate) = 1) T

select sum (w.Weight * f.Frequency) from WeightTable w
join FreqTable f  on f.Word = w.Word

update your_table
set B = A
where B is null

CONVERT(VARCHAR(5),tbltime.Time,108) AS [Time]

SELECT timing from class_Table group by timing

:setvar dbname testsnapshot

use master;

if db_id('$(dbname)') is not null
begin
    alter database [$(dbname)] set single_user with rollback immediate;
    drop database [$(dbname)];
end
go

create database [$(dbname)];
go

use [$(dbname)];
go


-- create a table before row versioning is enabled
--
create table t1 (i int not null);
go
insert into t1(i) values (1);
go

-- this check will show that the records do not contain a version number
--
select avg_record_size_in_bytes 
from sys.dm_db_index_physical_stats (db_id(), object_id('t1'), NULL, NULL, 'DETAILED')
-- record size: 11 (lacks version info that is at least 14 bytes)


-- enable row versioning and and create an identical table
--
alter database [$(dbname)] set allow_snapshot_isolation on;
go

create table t2 (i int not null);
go

set transaction isolation level read committed;
go

insert into t2(i) values (1);
go

-- This check shows that the rows in t2 have version number
--
select avg_record_size_in_bytes
     from sys.dm_db_index_physical_stats (db_id(), object_id('t2'), NULL, NULL, 'DETAILED')
-- record size: 25 (11+14)

-- this update will show that the version store has records
-- even though the isolation level is read commited
--
begin transaction;
update t1 
    set i += 1; 
select * from sys.dm_tran_version_store;
commit;
go

-- And if we check again the row size of t1, its rows now have a version number
select avg_record_size_in_bytes
from sys.dm_db_index_physical_stats (db_id(), object_id('t1'), NULL, NULL, 'DETAILED')
-- record size: 25

INSERT INTO productinventory (ProductID, VendorID, CustomerPrice, ProductOverrides) 
VALUES 
(123, 3, 100.00, 'CustomerPrice'), 
(124, 3, 100.00, 'CustomerPrice'), 
(125, 3, 100.00, 'CustomerPrice') 
ON DUPLICATE KEY UPDATE 
  CustomerPrice = VALUES(CustomerPrice), 
  ProductOverrides = IF(FIND_IN_SET(VALUES(ProductOverrides), ProductOverrides) > 0, 
                        ProductOverrides, 
                        CONCAT_WS(',', ProductOverrides, VALUES(ProductOverrides)));

SELECT 
    Country 
    SUM(widget.price * weight.weight) / SUM(weight.weight)
FROM
    Widget
        INNER JOIN
    Weight ON Widget.contract = Weight.contract
WHERE
    Weight.contract >= '2016-01-01'
    AND Weight.contract <= '2016-12-01'
GROUP BY Country

SELECT a.id FROM a LEFT JOIN b ON a.id = b.id WHERE b.id IS NULL
SELECT b.id FROM b LEFT JOIN a ON b.id = a.id WHERE a.id IS NULL

SELECT a.IdAppointment,GROUP_CONCAT(CAST(ca.IdClient AS CHAR) SEPARATOR ',')  FROM Appointments a
INNER JOIN ClientsAppointments ca ON ca.IdAppointment = a.IdAppointment
group by a.IdAppointment

select id, article + ' ' + city_name  + ' ' + zipcode  + ' ' + country
into summary
from cities

WITH cte AS (
 SELECT [Date] AS WorkingDay,
 ROW_NUMBER() OVER (ORDER BY [Date] ASC) AS RN
 FROM DimDate
 WHERE IsHolidayUSA = 0
 AND IsWeekday = 1
)
SELECT
 DateStarted,
 DateCompleted,
 c2.RN - c1.RN AS CycleTime
FROM MyTable t
INNER JOIN cte c1
 ON t.DateStarted=c1.WorkingDay
INNER JOIN cte c2
 ON t.DateCompleted=c2.WorkingDay

SELECT id, rtype FROM test
WHERE FIND_IN_SET('US', country) > 0

CREATE  TABLE IF NOT EXISTS `test`.`sample` (

  `id` INT NOT NULL AUTO_INCREMENT ,

  `domains` VARCHAR(100) NOT NULL ,

  PRIMARY KEY (`id`) ,

  UNIQUE INDEX `domains_UNIQUE` (`domains` ASC) );

select f.film, f.rental_rate
from film f 
where f.rental_rate > (select avg(f2.rental_rate) from film f2);

create procedure DeleteComment(
  @CommentID int
  )
  as 
 declare
  @CommentToDelete TABLE (id int);
  begin

  -- save comments for deletion
  insert into @CommentToDelete 
  select descendant from CommentTree  
  where  ancestor = @CommentID;

  -- delete relation from tree
with tree (commentTreeID, ancestor, descendant , path,  src) as 
(
select id,  ancestor,  descendant , cast ( '-'+ cast(id as varchar(2000)) +'-' as varchar(2000))   , 0from 
CommentTree ct
where ct.ancestor = @CommentID
union all
select CT.Id, CT.ancestor,  CT.descendant ,cast( t.path + '-' + cast(id as varchar(2000)) +'-' as varchar(2000)), 1
from tree t
join CommentTree CT 
 on CT.ancestor = t.descendant and
  CHARINDEX (cast( '-' + cast(id as varchar(2000)) +'-' as varchar(2000)), t.path) = 0 and
  t.src != 2
union all
 select CT.Id, CT.descendant,  CT.ancestor ,cast( t.path + '-' + cast(id as varchar(2000)) +'-' as varchar(2000)), 2
from tree t
join CommentTree CT 
 on CT.descendant = t.descendant and
 CHARINDEX(cast( '-' + cast(id as varchar(2000)) +'-' as varchar(2000)), t.path) =0  and
   t.src != 2
 ) 
 delete CT 
  from CommentTree CT 
  join tree t 
  on t.commentTreeID = CT.ID;

  -- now we can delete comments
  delete Comments
  where id in (select id from  @CommentToDelete);

end;

 SELECT * FROM activities
 WHERE  date(timestamp) between start_date
 and DATE_SUB(start_date,interval x day))

select group_concat(first_name), group_concat(last_name),
CONCAT(house_number, " ", street_name, " ", street_suffix, " ", unit_number, " ") AS Address,
group_concat(distinct party) as parties
from walksheet_1 
group by Address
having parties in ('DEM','REP');

SELECT 
    p.id 
FROM Photo p
JOIN PhotoConnect pc on pc.photo_id = p.id
JOIN PhotoConnect pc1 on pc1.photo_id = p.id
WHERE pc.outside_name = 'country' and pc.outside_key = 6 
  AND pc1.outside_name = 'region' and pc1.outside_key = 13
GROUP BY photo_id

update dhont
set    seats = coalesce(calculated.seats, 0)
from   dhont as parties
left join (
  select party, count(*) as seats
  from (
    select     party
    from       dhont
    cross join generate_series(1, :seat_count) as divisor
    order by   cast(votes as decimal) / divisor desc
    limit      :seat_count
  ) as seat_labels
  group by party
) as calculated on parties.party = calculated.party
where parties.party = dhont.party

 graphs = (graphid, dateofsnapshot or other things unique to the snapshot)

hibernate.jdbc.batch_size=50

DECLARE @t TABLE ([Drink] varchar(max), [Type] varchar(max), [Price] money )

INSERT @t
([Drink],[Type])
VALUES
('Coke','Vanilla'),
('Coke','Cherry'),
('Gatorade','Lime'),
('Gatorade','Grape'),
('Gatorade','Fruit Punch'),
('Pepsi','Vanilla'),
('Pepsi','Cherry')

;WITH t AS (
  SELECT
    [Drink],[Type],
    ROW_NUMBER() OVER(PARTITION BY [Drink] ORDER BY [Type] DESC) rn
  FROM @t
)
SELECT [Pepsi],[Coke],[Gatorade]
FROM t
PIVOT(MAX([Type]) FOR [Drink] IN ([Pepsi],[Coke],[Gatorade])) p

SELECT CASE
         WHEN caller < callee THEN callee
         ELSE caller
       END      AS caller1,
       CASE
         WHEN caller < callee THEN caller
         ELSE callee
       END      AS caller2,
       Count(*) AS [Count]
FROM   YourTable
GROUP  BY CASE
            WHEN caller < callee THEN callee
            ELSE caller
          END,
          CASE
            WHEN caller < callee THEN caller
            ELSE callee
          END 

create function dbo.GreatCircleDistance
    (
    @Latitude1  float,
    @Longitude1 float,
    @Latitude2  float,
    @Longitude2 float
    )
returns float
as
/*
FUNCTION: dbo.GreatCircleDistance

    Computes the Great Circle distance in kilometers
    between two points on the Earth using the
    Haversine formula distance calculation.

Input Parameters:
    @Longitude1 - Longitude in degrees of point 1
    @Latitude1  - Latitude  in degrees of point 1
    @Longitude2 - Longitude in degrees of point 2
    @Latitude2  - Latitude  in degrees of point 2

*/
begin
declare @radius float

declare @lon1  float
declare @lon2  float
declare @lat1  float
declare @lat2  float

declare @a float
declare @distance float

-- Sets average radius of Earth in Kilometers
set @radius = 6371.0E

-- Convert degrees to radians
set @lon1 = radians( @Longitude1 )
set @lon2 = radians( @Longitude2 )
set @lat1 = radians( @Latitude1 )
set @lat2 = radians( @Latitude2 )

set @a = sqrt(square(sin((@lat2-@lat1)/2.0E)) + 
    (cos(@lat1) * cos(@lat2) * square(sin((@lon2-@lon1)/2.0E))) )

set @distance =
    @radius * ( 2.0E *asin(case when 1.0E < @a then 1.0E else @a end ))

return @distance

end

SELECT CONCAT('DROP TABLE ', TABLE_NAME , ';')
FROM INFORMATION_SCHEMA.TABLES

WHERE TABLE_SCHEMA='YourDatabase'
AND TABLE_NAME NOT IN ('Table1', 'Table2');

DECLARE @Students TABLE (
    StudentId INT,
    StudentName VARCHAR(50));
INSERT INTO @Students VALUES (1, 'Tom');
INSERT INTO @Students VALUES (2, 'Dick');
INSERT INTO @Students VALUES (3, 'Harry');
DECLARE @StudentGrades TABLE (
    StudentId INT,
    GradeId INT);
INSERT INTO @StudentGrades VALUES (1, 1);
INSERT INTO @StudentGrades VALUES (1, 1);
INSERT INTO @StudentGrades VALUES (1, 2);
INSERT INTO @StudentGrades VALUES (1, 3);
INSERT INTO @StudentGrades VALUES (2, 1);
INSERT INTO @StudentGrades VALUES (2, 2);
INSERT INTO @StudentGrades VALUES (3, 1);
INSERT INTO @StudentGrades VALUES (3, 1);
INSERT INTO @StudentGrades VALUES (3, 3);
INSERT INTO @StudentGrades VALUES (3, 4);
INSERT INTO @StudentGrades VALUES (3, 4);
DECLARE @Grades TABLE (
    GradeId INT,
    GradeName VARCHAR(10));
INSERT INTO @Grades VALUES (1, 'A');
INSERT INTO @Grades VALUES (2, 'B');
INSERT INTO @Grades VALUES (3, 'C');
INSERT INTO @Grades VALUES (4, 'D');

--Student/ Grade Summary
SELECT
    s.StudentId,
    s.StudentName,
    g.GradeName,
    COUNT(sg.GradeId) AS GradeCount
FROM
    @Students s
    CROSS JOIN @Grades g
    LEFT JOIN @StudentGrades sg ON sg.StudentId = s.StudentId AND sg.GradeId = g.GradeId
GROUP BY
    s.StudentId,
    s.StudentName,
    g.GradeName;

--Find ten students with A and B but not C or D
SELECT TOP 10
    *
FROM
    @Students s

WHERE
    EXISTS (SELECT * FROM @StudentGrades sg WHERE sg.StudentId = s.StudentId AND sg.GradeId = 1) --Got an A
    AND EXISTS (SELECT * FROM @StudentGrades sg WHERE sg.StudentId = s.StudentId AND sg.GradeId = 2) --Got a B
    AND NOT EXISTS (SELECT * FROM @StudentGrades sg WHERE sg.StudentId = s.StudentId AND sg.GradeId IN (3, 4)); --Didn't get a C or D

SELECT 
    t1.*, 
    t2.tax    
FROM 
    product t1
LEFT JOIN (
    SELECT 
      tax_productid,
      CONCAT(GROUP_CONCAT(tax_code SEPARATOR " "), " ", sum(tax_iva), "%") AS tax
    FROM tb_tax 
    GROUP BY tax_productid 
) t2 ON t2.tax_productid = t1.id

SELECT i, 
CASE 
WHEN ((MONTH(CURRENT_DATE )) = SUBSTRING(yearmonth,6))THEN 
  CASE
      WHEN DAY(CURRENT_DATE) = 1 THEN `day1_value`
      WHEN DAY(CURRENT_DATE) = 2 THEN `day1_value`
  END 
END Y
FROM dp;

SELECT recipe_id
FROM ingredients
WHERE ingredients_name IN ('pork', 'pepper', 'tomato', 'salt')
GROUP BY recipe_id
HAVING COUNT(distinct ingredients_name) = 4

ON c.character_col + 0 = p.numeric_col

SELECT extract(month FROM date) month,
       count(*) purchases,
       SUM(price*quantity) income,
       sum(price*quantity) / count(distinct customerId)
FROM
    transactions
WHERE
    date BETWEEN i2 AND i3
GROUP BY extract(month FROM date);

set @field='70:30';
select substr(@field,1,LOCATE(':',@field)-1) as baselvl,
substr(@field,LOCATE(':',@field)+1,length(@field)-LOCATE(':',@field)) as oblvl

WITH first AS (
   SELECT extract(EPOCH FROM foo.t_date) AS the_date
        , foo_val AS the_value
   FROM bar
   JOIN foo ON foo.user_id = bar.x_id
           AND foo.user_name = 'xxxx'
   )
, x AS (
   SELECT MIN(the_date) AS min_epoch
        , MAX(the_date) AS max_epoch
   FROM  first
   )
, y AS (
   SELECT width_bucket(f.the_date, x.min_epoch, x.max_epoch, 4) AS bin, *
   FROM   first f, x
   )
, z AS (
   SELECT row_number() OVER (PARTITION BY bin ORDER BY the_value) AS rn, *
   FROM   y
   )
SELECT bin, round(sum(bin_sum) OVER w / sum(bin_ct) OVER w, 2) AS running_avg
FROM  (
   SELECT bin
        , sum(the_value) AS bin_sum
        , count(*)       AS bin_ct
   FROM   z
   WHERE  rn < 21   -- max 20 lowest values
   GROUP  BY 1
   ) sub
WINDOW w AS (ORDER BY bin)
ORDER  BY 1;

    DELETE FROM MYTABLE WHERE _id NOT IN 
   (SELECT _id from MYTABLE ORDER BY timestamp DESC LIMIT 25)

SELECT a.* FROM 
tbl a 
inner join 
tbl b
ON a.variant_id =b.variant_id AND a.attr_id = b.attr_id
WHERE a.id <> b.id;

with cte(monno , monname ) as(
select 1, 'Jan' union all 
select 2, 'Feb' union all 
select 3, 'Mar' union all 
select 4, 'Apr' union all 
select 5, 'May' union all 
select 6, 'Jun' union all 
select 7, 'Jul' union all 
select 8, 'Aug' union all 
select 9, 'Sep' union all 
select 10, 'Oct' union all 
select 11, 'Nov' union all 
select 12, 'Dec' 
)
select monname,
monno,
coalesce(cnt,0) as cnt
from cte c
outer apply (
select count(*) as cnt
from Contributors_tbl 
where CreatedOn >= DATEADD(mm,c.monno - 1,'20140101')
And CreatedOn < DATEADD(mm,c.monno,'20140101')
)t
order by monno

[CPU_PER_SESSION           n|UNLIMITED|DEFAULT]     
[CPU_PER_CALL              n|UNLIMITED|DEFAULT]            
[CONNECT_TIME              n|UNLIMITED|DEFAULT]
[IDLE_TIME                 n|UNLIMITED|DEFAULT]
[LOGICAL_READS_PER_SESSION n|UNLIMITED|DEFAULT]  
[LOGICAL_READS_PER_CALL    n|UNLIMITED|DEFAULT]
[COMPOSITE_LIMIT           n|UNLIMITED|DEFAULT]
[PRIVATE_SGA               n [K|M]|UNLIMITED|DEFAULT]

SELECT DISTINCT t1.* 
FROM Table AS t1 
    INNER JOIN Table AS t2
    ON t1.firstname = t2.firstname 
       AND t1.lastname = t2.lastname
       AND t1.id <> t2.id

update `users_individual_cards` ...
delete `users_individual_cards` where ... (same condition) and own + want + trade = 0

SELECT m.date, FROM_UNIXTIME(i.time, '%Y-%m-%d'),`time`,`protocal`,(`octet`/1024) as `octet10243`,`percent`,`div`,FROM_UNIXTIME(`time`, '%Y-%m-%d') as `newtime3` 
    FROM makeupdate m
        LEFT JOIN ipport i
            on m.date = FROM_UNIXTIME(ipport.time, '%Y-%m-%d')
                AND (`protocal` = 'Echo' ) 
                AND `div` = 'XDIV'
    WHERE m.date >= '2011-01-05' AND m.date <= '2011-01-08'

set @max_orig_id = coalesce((select max(id) from output_table),0);
insert into output_table (code) select code from input_table;
update input_table join output_table on input_table.code=output_table.code and output_table.id > @max_orig_id set input_table.new_id=output_table.id;

package My::Schema::Result::Artist;

 __PACKAGE__->table('artist');
 __PACKAGE__->add_columns(id => { ... }, name => { ... })

 sub sqlt_deploy_hook {
   my ($self, $sqlt_table) = @_;

   $sqlt_table->add_index(name => 'idx_name', fields => ['name']);
 }

 1;

SELECT two.*
  FROM two
 WHERE (SELECT COUNT(*) FROM one) =
       (CASE WHEN col1 IN (SELECT * FROM one) THEN 1 ELSE 0 END +
        CASE WHEN col2 IN (SELECT * FROM one) THEN 1 ELSE 0 END +
        CASE WHEN col3 IN (SELECT * FROM one) THEN 1 ELSE 0 END +
        CASE WHEN col4 IN (SELECT * FROM one) THEN 1 ELSE 0 END
       )

SELECT calendar_year_nbr, week, min(actual_date),max(actual_date)
FROM D_date
GROUP BY calendar_year_nbr, week

select ai.name, sum(ai.pay)
from actedin ai
group by ai.name
having sum(case when ai.year = 2010 then 1 else 0 end) > 0;

begin    
  insert into table1 values(seq.nextval, 'test') ;
  insert into table2 values(seq.currval, 'test3');
  commit;
end;

select f2.Filename,f1.DWGNO,f1.Project
from File1 f2 left join File1 f1 on
f2.Filename like f1.Filename+'%'
where f1.DWGNO != '' 

SELECT UserID, UserName
FROM Visit
WHERE VisitDate BETWEEN '04/01/2016' AND '04/03/2016'
GROUP BY UserID, UserName
HAVING COUNT(*) >= 2

CREATE TRIGGER trigger_name
   ON Table1
   AFTER UPDATE
AS 
BEGIN
      SET NOCOUNT ON;
      IF UPDATE(CustomerProductID) BEGIN
        Update t1
            SET DateMod = GETDATE() 
            FROM Table1 t1 join
                 Inserted i
                 ON Table1.PrimaryKeyColumn = i.PrimaryKeyColumn
      END
END

declare @s varchar(max) = 'select '

select @s=@s+name+',' from sys.columns
where object_id=object_id('schematemplate.scanner')
  and name not in ('asset_category','asset_classification')
order by column_id

set @s=substring(@s,1,len(@s)-1)+' from schematemplate.scanner'

exec(@s)

db.Culture.find({"owner_id" : {"$in":[set_of_entityids]" }});

(select * from your_table where Y = 1 order by rand() limit 1)
union
(select * from your_table where Y = 2 order by rand() limit 2)
union
(select * from your_table where Y in (4,5,6) order by rand() limit 2)

WITH
  foo      AS  select foo from table1
SELECT
    col1, col2 - foo.foo
FROM
    table2, foo
WHERE
   col2 > foo.foo

SELECT MAX(EmployeeID)
FROM tableName
WHERE EmployeeID LIKE CONCAT(SUBSTRING(EmployeeID, 1, 4),'%')

SELECT SUM(dtl_erc_upd.quantity) AS project_count 
FROM dtl_erc_upd 
INNER JOIN project 
ON project.project_name = dtl_erc_upd.project_name 

select tax, amount, 
    case when tax is not null and amount is not null 
          and replace(translate( tax,    '123456789', '000000000' ), '0', '') is null
          and replace(translate( amount, '123456789', '000000000' ), '0', '') is null
        then to_number(tax)+to_number(amount) 
        else 0
    end summed 
  from teststr 

Select vc.[_Case Master ID],
 vc.[_Caseload Assignment Current],
 vc.[_Participant Name],
 vc.[Case Status],
 vc.[Reporting Structure Level 4],
 vc.[Reporting Structure Level 5],
 vc.[Application Date],
 vc.[Eligibility Date],
 vc.[Eligibility Determination Extension Date],
 vc.[Eligibility Extended To Date], 
 vc.[Days in Application],
 cn.[Case_Note_Date], 
 cn.[Case_Note_Category_Desc],
 cn.[Case_Note_Summary_Narr]
From  biVR_Cases vc
LEFT outer JOIN 
   (SELECT Case_Master_ID, Case_Note_Date, Case_Note_Category_Desc, Case_Note_Summar_Narr, 
           ROW_NUMBER() OVER (PARTITION BY Case_Master_ID ORDER BY Case_Note_Date DESC) as RowNum FROM buCase_Note) cn 
   ON cn.Case_Master_ID = vc.[_Case Master ID] AND cn.RowNum=1

from somewhere import Patch

class FilteredPatchManager(models.Manager):
    def get_query_set(self, *args, **kwargs):
        return super(FilteredPatchManager, self).get_query_set().exclude(author__contains='@example.com')


class FilteredPatch(Patch)
    objects = FilteredPatchManager()

    class Meta:
        proxy = True

select id, createdAt, data_type
from ((select id, createdAt, 'Article' as data_type
       from Article)
      union
      (select id, createdAt, 'Project' as data_type
       from Project)) MyTable
order by createdAt desc
limit 0, 7

WITH Sections AS (
   SELECT 1 Section, 1 StartUnit, 5 EndUnit FROM DUAL
   UNION ALL SELECT 2, 0, 2 FROM DUAL
   UNION ALL SELECT 3, 1, 1 FROM DUAL
), 
Numbers AS (
   SELECT ROWNUM-1 n
   FROM   DUAL
   CONNECT BY LEVEL < 1000
)
select section, n
from sections, numbers
where n between startunit and endunit
order by section, n;

top_scores = (myModel.objects
                     .order_by('-score')
                     .values_list('score', flat=True)
                     .distinct())
top_records = (myModel.objects
                      .order_by('-score')
                      .filter(score__in=top_scores[:10]))

SELECT *
FROM test t
WHERE NOT EXISTS (
        SELECT 1
        FROM test
        WHERE NAME = t.NAME
            AND number <> t.number);

INSERT INTO dbo.TmpFeesToRules1 (name, LookupId)
SELECT DISTINCT name, 0 FROM Fee

INSERT INTO Lookup (LookupType, LookupDesc)
SELECT 'FEE', name FROM dbo.TmpFeesToRules1

UPDATE TFTR
SET
    LookupID = LU.id
FROM
    Lookup LU
INNER JOIN dbo.TmpFeesToRules1 TFTR ON
    TFTR.name = LU.LookupDesc
WHERE
    LU.LookupType = 'FEE'

SELECT st.[code], SUM(whst.WHQtyOnHand)
FROM dbo.[StkItem] st
INNER JOIN dbo.WhseStk whst 
    ON whst.WHStockLink = st.StockLink
WHERE whst.WHWhseID IN (3,4)
    AND st.Code = 'BNV203N'
GROUP BY st.[Code]

 Document doc=XMLfunctions.XMLfromString(this.getResources().openRawResource(name of the xml));       
        int numResults = XMLfunctions.numResults(doc);


        NodeList nodes = doc.getElementsByTagName("head tag");


            Element e = (Element)nodes.item(inx);

            btn[0].setText( XMLfunctions.getValue(e, "option1"));
            btn[1].setText( XMLfunctions.getValue(e, "option2"));
            btn[2].setText( XMLfunctions.getValue(e, "option3"));
            btn[3].setText( XMLfunctions.getValue(e, "option4"));
            tv.setText( XMLfunctions.getValue(e, "name"));
            tv1.setText( XMLfunctions.getValue(e, "answer"));

            tv.startAnimation(animation);

UPDATE Contacts
    SET company = ''
    WHERE company IN (
        SELECT TOP 100 company
             FROM Contacts                 
             GROUP BY company
             HAVING count(company) > 20
             ORDER BY count(company) DESC
    );

SELECT * 
FROM (  SELECT  CASE WHEN pet NOT IN ('dog','cat') THEN 'others' ELSE pet END pet, 
                age
        FROM Pet.Info) AS B
PIVOT (AVG(age) FOR pet IN ([dog],[cat],[others])) AS C

MERGE workingtable AS target
using (select all column from temptable )) as source
on target.id=source.id
WHEN NOT MATCHED then
INSERT (col1,col2,col3......... ) --workingtable
      VALUES (mention those column from source ) 

with sample_data as (select 1 id, 'row 1' label from dual union all
                     select 2 id, 'row 2' label from dual union all
                     select 3 id, 'row 3' label from dual),
           dummy as (select level lvl
                     from   dual
                     connect by level <= p_num)
select *
from   (select sd.*
        from   sample_data sd,
               dummy d
        order by dbms_random.value)
where  rownum <= p_num;

--#SET TERMINATOR ;
select * from sysibm.sysdummy1;

--#SET TERMINATOR /
create or replace trigger t1 ...
begin
 ...
end
/

SELECT c.Case_Code,COALESCE(c.case1, c.case2) AS case_def,aspm.UserId
FROM Cases AS c
LEFT JOIN aspnet_Membership AS aspm
ON COALESCE(c.case1, c.case2) = aspm.userId

 update temp set 
        flg1 = 
            case when flag1 is null then 'Y' else flg1 end,
        flg2 = 
           case when flag1 is not null and flag2 is null then 'Y' else flg2 end,
        flg3 = 
            case when flag1 is not null and flag2 is not null and flag3 is null then 'Y' else flg3 end
where id = 132

select combo1.gene, combo2.gene, count (gene2.goterm)
from (select distinct gene from gene) combo1
cross join (select distinct gene from gene) combo2
join gene gene1 on combo1.gene = gene1.gene
left join gene gene2 on combo2.gene = gene2.gene
    and gene1.goterm = gene2.goterm and gene1.auto < gene2.auto
group by combo1.gene, combo2.gene
order by combo1.gene, combo2.gene

SELECT NAME, Id1, Id2, Effdate
  FROM Table_Name t_1
 WHERE Effdate =
       (SELECT (t_2.Effdate) 
        FROM Table_Name t_2 
        WHERE t_2.NAME = t_1.NAME
        and t_2.id1 = t_1.id1
        and t_2.id2 = t_1.id2
        GROUP BY t_2.name,t_2.id1,t_2.id2)
   AND Your_Year_Variable_Value BETWEEN t_1.Yearfrom AND t_1.Yearto

SELECT PERSON
FROM SPEAKS
WHERE LANG IN( 'French', 'Russian', 'Italian')
GROUP BY PERSON
HAVING COUNT(DISTINCT LANG) = 3

SELECT [type] = QUOTENAME(s.name) + '.' + QUOTENAME(tp.name), 
  dp.[permission_name], 
  [principal] = p.name
FROM sys.types AS tp
INNER JOIN sys.schemas AS s
ON tp.[schema_id] = s.[schema_id]
INNER JOIN sys.database_permissions AS dp
ON tp.user_type_id = dp.major_id
AND dp.class_desc = N'TYPE'
INNER JOIN sys.database_principals AS p
ON p.principal_id = dp.grantee_principal_id
WHERE tp.is_user_defined = 1;

SELECT t2.id FROM MyTable t1
JOIN MyTable t2 ON (t1.City = t2.City AND t1.id <> t2.id)
WHERE t1.id = @input

select * 
from RBOTRANSACTIONSALESTRANS main 
where main.DATAAREAID = 'DAT'
 and exists 
  (
    select 1 
    from RBOTRANSACTIONSALESTRANS sub 
    where sub.QTY < 0 
      and sub.DATAAREAID = main.DATAAREAID
      and sub.STORE = main.STORE 
      and sub.TERMINALID = main.TERMINALID
      and sub.TRANSACTIONID = main.TRANSACTIONID
  )
order by main.TRANSACTIONID

SELECT id,name,loan,payment
FROM (
SELECT p.id    id,
       p.name  name,
       0       type,
       b.id    detail_id,
       b.loan  loan,
       0       payment
  FROM person p
  JOIN b ON p.id = b.personId
 UNION ALL 
SELECT p.id      id,
       p.name    name,
       1         type,
       c.id      detail_id,
       0         loan,
       c.payment payment
  FROM person p
  JOIN c ON p.id = c.personId

) q
ORDER BY id, detail_id, type

insert into permission( userid, login, permission )
select UserId, login, 0 from users

SELECT * 
FROM EMPLOYEE 
WHERE ROLE = MANAGER 
      AND DEPARTMENT IN (SELECT DEPARTMENT 
                         FROM EMPLOYEE 
                         WHERE NAME IS LIKE "JOHN*") 

SELECT *
FROM(SELECT first_name, salary
     FROM Employees
     ORDER BY salary
) WHERE ROWNUM = 1

select 
  cast(tableA.id as varchar) + '-' + 
  cast(tableB.id as varchar)  + '-' + 
  cast(tableC.id as varchar)  as compositeKey, 
  tableA.foo //etc...

res.render('index', {
  title: 'Home',
  rows: rows
});

CREATE OR REPLACE PROCEDURE call_myproc_n_times( p_n IN NUMBER )
AS
  p_status         NUMBER;
  p_ora_error_code VARCHAR2(1000);
  p_ora_error_msg  VARCHAR2(1000);
BEGIN
  FOR i IN 1 .. p_n 
  LOOP
    myproc( 'test', 
            p_status, 
            p_ora_error_code, 
            p_ora_error_msg );
  END LOOP;
END;

DECLARE
  l_num_sessions     number := 10;
  l_exec_per_session number := 100;
  l_jobno            pls_integer;
BEGIN
  FOR i IN 1 .. l_num_sessions
  LOOP
    dbms_job.submit( 
      l_jobno,
      'BEGIN ' ||
      '  call_myproc_n_times( ' || l_exec_per_session || ' ); ' ||
      'END;',
      sysdate + interval '1' minute );
  END LOOP;
  commit;
END;

Isues     Issue Magament

ID    |    IDM  ID
 A    |     X    A  
 B    |     Y    B  
 C    |     Z    A

DBMS_OUTPUT.ENABLE();

CREATE VIEW [dbo].[ViewHolidayAllocation]
AS

SELECT 
    ROW_NUMBER() OVER(ORDER BY Id) AS RowNum, 
    * 
FROM
(
    SELECT Id, startDate, endDate FROM Holidays
    UNION
    SELECT Id, startDate, endDate FROM Allocations
) AS result

public class Main {
    public static void main(String[] args) throws SQLException {
        DriverManager.registerDriver(new TimesTenDriver());
        Connection c = ...;
        DatabaseMetaData md = c.getMetaData();

        final ResultSet rawTables = md.getTables(null, "<your schema>", "%", null);

        List<Table> tables = new ArrayList<Table>();

        while (rawTables.next()) {
            final String tableName = rawTables.getString("TABLE_NAME");
            Table table = new Table(tableName);

            ResultSet rawKeys = md.getImportedKeys(null, "<your schema>", tableName);

            while (rawKeys.next()) {
                table.refs.add(rawKeys.getString("PKTABLE_NAME"));
            }

            rawKeys.close();

            tables.add(table);
        }

        rawTables.close();
        c.close();

        LinkedList<List<Table>> layers = new LinkedList<List<Table>>();

        while (tables.size() > 0) {
            List<Table> indep = new ArrayList<Table>();
            for (Table o : tables) {
                indep.add(o);
                for (Table i : tables) {
                    if (i.refs.contains(o.name)) {
                        indep.remove(o);
                        break;
                    }
                }
            }

            layers.add(indep);

            for (Iterator<Table> it = tables.iterator(); it.hasNext(); ) {
                Table t = it.next();
                if (indep.contains(t)) {
                    it.remove();
                }
            }
        }

        for (ListIterator<List<Table>> it = layers.listIterator(layers.size()); it.hasPrevious(); ) {
            final List<Table> layer = it.previous();

            for (Table table : layer) {
                System.out.println("ttbulkcp -i <your DSN> <your schema>." + table + " " + table);
            }
        }
    }

    private static class Table {
        public final String name;
        public final Set<String> refs;

        public Table(String name) {
            this.name = name;
            this.refs = new HashSet<String>();
        }
    }
}

    clin_sig     REGEXP '^[[:<:]](4|5)[[:>:]]$'
AND clin_sig NOT REGEXP '^[[:<:]](2|3)[[:>:]]$'

select 
d1.movie_id
, d1.rating as user1Rating
, d2.rating as user2Rating
, abs(d1.rating - d2.rating)
from
details d1
inner join details d2 on d1.movie_id = d2.movie_id
where d1.user_id = 1
and d2.user_id = 2 

DECLARE @currentYear int
SELECT @currentYear = DATEPART(year, GETDATE())

SELECT SUM(CASE WHEN DATEPART(year,[date]) = @currentYear 
    THEN Expenses ELSE 0 END) AS 'Actual YTD',
SUM(Expenses) / COUNT( DISTINCT DATEPART(year,[date])) AS 'Average YTD',
SUM(CASE WHEN DATEPART(year,[date]) = @currentYear -1 
    THEN Expenses ELSE 0 END) AS 'Last Year YTD'

FROM Table1

with par as (
  select date '2015-08-07' enddate, 4 LookBackDays, 3600 inteval, 'Bob' Name, 
         '09:00' open, '14:00' close from dual),
t1 as (
  select to_char(enddate-level+1, 'yyyy-mm-dd') dt, name, open, close from par
    connect by level <= LookBackDays + 1 ),
t2 as (
  select to_char(to_date(open, 'hh24:mi') + (level) * inteval / (24*60*60), 'hh24:mi') tm
    from par
    connect by to_date(open, 'hh24:mi') + level * inteval / (24*60*60) 
               <= to_date(close, 'hh24:mi') )
select to_date(dt, 'yyyy-mm-dd') dt, 
       lag(to_date(dt||' '||tm, 'yyyy-mm-dd hh24:mi'), 1,to_date(dt||' '||open, 'yyyy-mm-dd hh24:mi'))over(partition by to_date(dt||' '||open, 'yyyy-mm-dd hh24:mi') order by tm) open,  
       to_date(dt||' '||close, 'yyyy-mm-dd hh24:mi') close, name, 
       to_date(dt||' '||tm, 'yyyy-mm-dd hh24:mi') IntervalEnd
from t1 cross join t2 order by dt, tm

  UPDATE tableB
     SET col1 = 
         CASE WHEN (0, 0) = (SELECT col1, col2 
                               FROM tableA 
                              WHERE <tableA constraints>
                            )
              THEN "this value"
              ELSE "that value"
         END
   WHERE <tableB constraints>;

SELECT
  ID,
  SUM(case when productid in (1,2,3)       then qty * hrs
           when productid in (100,200,300) then qty
      end) result1
FROM
  Prod
GROUP BY
  ID

update answer set user = 'Usr2' where id = 3;

DO
$$
BEGIN
EXECUTE format('CREATE TABLE %I AS SELECT * FROM backup', 'backup_' || to_char(CURRENT_DATE,'yyyy-mm-dd'));
END;
$$ LANGUAGE plpgsql;

SELECT id, store_id, date_submitted, code, user_name 
FROM quotes q
INNER JOIN stores s
    ON q.store_id = s.store_number
INNER JOIN leads l 
    ON s.code=l.code 
WHERE date_submitted > "2013-01-01 00:00:00" 
AND date_submitted < "2013-01-31 23:59:59" 
GROUP BY q.id

select pid from `patient_list` t1, patient_info t2 
where replace(pid, "*", "") + 0 > 2000 and t2.id = t1.id 
order by replace(pid, "*", "") + 0
limit 1

SELECT country, count (*) FROM <TABLE_NAME> WHERE url_id = 3404 GROUP BY Country

myDataTable.Columns.Add("Sorter", typeof(System.Int32), "Convert(TextColumn, 'System.Int32')");

select 
  cc.id idchild, 
  ccparent.id idparent,
  ccgrandparent.id idgrandparent
from con_categoria cc
  left join con_categoria ccparent on cc.fk_cat = ccparent.id
  left join con_categoria ccgrandparent on ccparent.fk_cat = ccgrandparent.id
where cc.fk_cat = 378

   WITH pvt AS (
           SELECT p.product, o.quantity, o.date
           FROM   Orders o
           JOIN Products p on o.pid=p.pid
           )
   SELECT *
   FROM   pvt
   PIVOT (
          quantity                    
          FOR date
          IN  ('2015-02-16','2015-02-17','2015-02-18', '2015-02-19','2015-02-20')   
         );

SELECT
     a.ID
from
     Table1 a
         left join
     Table2 b
         on
            a.tid = b.tid
where
    b.tid is null

select sum(length(column_name)) + count(*) as total_bytes from table_name;

SELECT SUM(TotalVisitedTime)
FROM (    
    -- AS PER @Alex Aza,  @Andriy M     
        SELECT 1234 AS TotalVisitedTime
     ) AS OuterTable

to_char(nvl(INVOICE_NET,0) + nvl(INVOICE_TAX,0), '9,999,999.99') AS GROSS_PRICE 

SELECT users.id, IF(COUNT(others.id) = 0, '', COUNT(others.id)) as c
FROM users JOIN other ON users.id=others.user_id 
GROUP BY users.id

SELECT FirstName, LastName, Email
FROM CONSULTANTS, SKILLS
WHERE SKILLS.ExpertiseID = '3' AND 
( CONSULTANTS.STATE = 'NJ' OR CONSULTANTS.STATE = 'NY' );
GROUP BY FirstName, LastName, Email

Dim sql as string
Dim dbs as DAO.Database
set dbs = CurrentDb()

sql = "INSERT INTO table(field1) VALUES(1)"
dbs.Execute sql, dbFailOnError

dbs.close
set dbs = nothing

SELECT Rating, COUNT(column_name)
FROM   TABLE
GROUP BY
       Rating

select
    t.MbrID,
    t.TransactionDate,
    t.Charge,
    t.AuthorizationID
from YourTable t
    left join YourTable r
        on r.ReversalID = t.AuthorizationID
where t.ReversalID is null
    and r.ReversalID is null

select name,
       max(case when DateInit < CONVERT(DATE,GETDATE()) then DateInit end) as LastVisit,
       min(case when DateInit > CONVERT(DATE,GETDATE()) then DateInit end) as NextVisit
from Appointments
group by name

ALTER TABLE atable ADD COLUMN mycolumn VARCHAR(255);

update atable a join
       something s
       on s.id = a.some_id
    set a.mycolumn = s.acolumn;

select top(200) IDA from Categories
order by case when [order] is null then 1 else 0 end, [order]

INSERT INTO userexternalid (userid, facebookid, externalid) 
    SELECT id AS userid, facebookid, externalid FROM user;

UPDATE PARENT 
  SET RENEW_DATE = TO_DATE('08/31/' || EXTRACT(YEAR FROM JOINED), 'MM/dd/yyyy') 
WHERE STATUS_IND = 'Active'

select 
t.id,t.parent,coalesce(x.cnt,0) as cnt
from t left join
(select parent,count(*) as cnt
 from t
 group by parent) x
on x.parent = t.id

select 
    FirstName, LastName, Count(Department) 
from 
    Employee
where 
    FirstName = '<FirstName>' -- Add  condition here
    and LastName = '<LastName>'
group by 
    FirstName, LastName
having 
    Count(Department) > 1

SELECT POSITION, 
       DENSE_RANK() OVER (PARTITION BY MYVAL ORDER BY POSITION ASC) AS NO_OCCURENCE, 
       MYVAL
FROM Table

With YourData as (
 SELECT 35 as ID, 100 as Code, '1/1/2014 14:50' as yDatetime,
   'a' as yUser, 'IN' AS status  UNION ALL
 SELECT 35,100, '1/1/2014 15:45', 'a', 'OUT' UNION ALL
 SELECT 35,100, '1/1/2014 18:20', 'a', 'IN'  UNION ALL
 SELECT 35,100, '1/1/2014 19:10', 'a', 'OUT'
)
SELECT
  ID,
  Code,
  yDatetime AS When_IN,
  (SELECT Min(yDatetime) FROM YourData yd2
   WHERE (yd2.yDatetime>YourData.yDatetime)
     AND Status='OUT'
     -- extra matching needed here
     -- for ID, CODE, User fields in use
  ) AS When_OUT,
  yUser as _User
FROM YourData WHERE Status='IN'

SELECT id,crse_date,
    CASE 
        WHEN RIGHT(crse_date,2) = 01 THEN CONCAT(crse_date,31)
        WHEN RIGHT(crse_date,2) = 02 THEN CONCAT(crse_date,28)
        WHEN RIGHT(crse_date,2) = 03 THEN CONCAT(crse_date,31)   
        WHEN RIGHT(crse_date,2) = 04 THEN CONCAT(crse_date,30)       
    END AS newdate
 FROM yourtable


After you alter your table. Here is new query for your problem
Takenote : your field name is not advisable

SELECT new_TarikhSebenarTamatPengajian, 
    CASE
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 01 THEN CONCAT(new_TarikhSebenarTamatPengajian,31)
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 02 THEN CONCAT(new_TarikhSebenarTamatPengajian,28) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 03 THEN CONCAT(new_TarikhSebenarTamatPengajian,31)
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 04 THEN CONCAT(new_TarikhSebenarTamatPengajian,30) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 05 THEN CONCAT(new_TarikhSebenarTamatPengajian,31) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 06 THEN CONCAT(new_TarikhSebenarTamatPengajian,30) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 07 THEN CONCAT(new_TarikhSebenarTamatPengajian,31) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 08 THEN CONCAT(new_TarikhSebenarTamatPengajian,31) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 09 THEN CONCAT(new_TarikhSebenarTamatPengajian,30) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 10 THEN CONCAT(new_TarikhSebenarTamatPengajian,31) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 11 THEN CONCAT(new_TarikhSebenarTamatPengajian,30) 
    WHEN RIGHT(new_TarikhSebenarTamatPengajian,2) = 12 THEN CONCAT(new_TarikhSebenarTamatPengajian,31)
    END AS newdate 
FROM TEMP_AKAUN_MARA

select *
from <table>
where id in (null)

class MyDomain {
    Long parentId
    String titleAgg

    static mapping = {
        titleAgg formula: '(SELECT LISTAGG(e.title) FROM Entity e WHERE e.parrent = parent_id)'
    }

}

tblUnit
UnitID, UnitName
1, Unit1
2, Unit2
3, Unit3
4, Unit4
5, Unit5

tblPiece
PieceID,PieceName
1, Molded
2, Bolted
3, Painted
4, Packed

tblUnitPiece
UnitPieceID, UnitID, PieceID
1, 1, 1
2, 1, 2
3, 1, 3
4, 1, 4
5, 2, 1
6, 2, 2
7, 2, 3
8, 3, 1
9, 3, 3
10, 4, 1
11, 4, 2
12, 5, 1

SELECT id
FROM DEVICE d LEFT OUTER JOIN
     USER_DEVICE ud
     ON d.id = ud.device_id and
        ud.user_id = 1
WHERE ud.device_id IS null;

SELECT d.*,
COUNT(distinct d2.id) AS department_count,
COUNT(distinct e.id) AS employee_count
FROM department AS d
LEFT JOIN department AS d2 ON (d.id = d2.parent_id)
LEFT JOIN employees AS e ON (e.department_id = d.id)
GROUP BY d.id
ORDER BY d.id

String hql = "select sum(doc._masskg), "+
"    case when (month(doc._date) = month(%1$s)) then 'NOW' else 'BEFORE' "+
"from Document doc "+
"    where month(doc._date) <= month(%1$s) "+
"group by "+
"    case when (month(doc._date) = month(%1$s)) then 'NOW' else 'BEFORE' end";

Iterator i = session.createQuery(String.format(HQL, "to_date('09.10.2011', 'DD.MM.YYYY')"))
                .iterate();  

;WITH cteCombined as
(
    SELECT 
          rowType = 0 --orders
        , [date] = convert(date, o.dateadded) 
        , o.c1
        , o.c2
        , o.c3
        , o.requestedshipping
    FROM [db1].[dbo].[order] o 
    UNION ALL
    SELECT 
          rowType = 1 --shipments
        , [date] = convert(date, s.dateshipped)
        , s.c1, s.c2
        , c3 = null
        , requestedshipping = s.[service]
    FROM [db2].[dbo].[ship] s
)
SELECT c.[date]
    , tot_order = sum(case when c.rowtype = 0 then 1 else 0 end)
    , tot_shipped = sum(case when c.rowtype = 1 then 1 else 0 end)
    --EDIT: based on expected results then tot_express appears to be only based on orders (with assumption that you will have an order prior to a shipment)
    , tot_express = sum(case when c.rowType = 0 AND c.requestedshipping = 'EXPRESS' then 1 else 0 end)
    , tot_order_c3 =  sum(case when c.rowtype = 0 then c.c3 else 0 end)
    , tot_ship_c1 =  sum(case when c.rowtype = 1 then c.c1 else 0 end)
    , tot_ship_c2 =  sum(case when c.rowtype = 1 then c.c2 else 0 end)
    /*etc...*/
FROM cteCombined c
GROUP BY c.[date]
;

update WebCatalog.Published.DemoTracking
set Purchased = 1
where Purchased = 0 and RCompanyLink in (select Link as RCompanyLink from WebCatalog.Published.RCompany where RC.Expiration >= GETDATE() and RC.DemoLicense = 0)

select a.itemID, b.itemID, COUNT(*) countForCombination
from grocery_store a
inner join grocery_store b
on a.customer_id = b.customer_id
and a.itemID < b.itemID
group by a.itemID, b.itemID
order by countForCombination desc

create table #datelist (ValidDateCheck date, ValidResults int)

declare @startdate date = '1/1/2015'
declare @enddate date = '2/1/2015'
declare @interval int = 1 --Use 1 if you want every day between your dates, use 2 if you want every other day, etc.

declare @datecounter date = @startdate
declare @count int

while @datecounter <= @enddate
begin
set @count = 
    (select count(*) 
    from Table 
    where CrtDt <= @datecounter and ExpDt > @datecounter)
insert into #datelist values (@datecounter, @count)
set @datecounter = dateadd(dd, @interval, @datecounter)
end

select * from #datelist order by 1

SELECT idproperty,
       property_unit,
       tenant,
       expiry_date,
       idcontract
FROM  (SELECT Row_number() OVER (partition BY idproperty, property_unit
                  ORDER BY expiry_date DESC) Rn,
              *
       FROM   tablename) a
WHERE  a.rn = 1 

update #test
set value=  replace(','+value+',',',A,',',')

update #test
set value= case when len(value)=0 then '' else STUFF(value, 1, 1, '')  end 

update #test
set value=  case when len(value)=0 then '' else  STUFF(value, len(value),1, '') end  

CREATE Table #Foo 
   (fooID INT NOT NULL Identity (1,1), 
    field1 varchar(20), 
    field2 varchar(20), 
    field3 varchar(20), 
    field4 varchar(20), 
    field5 varchar(20))

SELECT u.*, 
        CASE WHEN s.user_id IS NULL THEN 'false' ELSE 'true' END as IsSubscriber 
FROM users u 
   LEFT JOIN subscribers s ON u.id = s.user_id

PREPARE clear_temp FROM "DELETE FROM w_projection_temp WHERE user_id = ?"
EXECUTE clear_temp USING uid;
DEALLOCATE PREPARE clear_temp;

SQL> SET serveroutput ON
SQL> DECLARE
  2    val_name VARCHAR2(10);
  3    ta_tab   VARCHAR2(10);
  4    v_str    VARCHAR2(100);
  5    A        VARCHAR2(10);
  6    b        VARCHAR2(10);
  7    c        VARCHAR2(10);
  8    d        NUMBER;
  9  BEGIN
 10    val_name := 'LALIT';
 11    ta_tab   := 'TEST';
 12    v_str    :='SELECT '''||val_name||''', ename,'''||ta_tab||''', sal from emp where empno = 7788';
 13    EXECUTE IMMEDIATE v_str INTO A,b,c,d;
 14    dbms_output.put_line(a||'-'||b||'-'||c||'-'||d);
 15  END;
 16  /
LALIT-SCOTT-TEST-3000

PL/SQL procedure successfully completed.

SELECT
  COUNTRY.name AS name
FROM
  NEIGHBOUR
  INNER JOIN COUNTRY ON
    NEIGHBOUR.id_country1=COUNTRY.id
    OR NEIGHBOUR.id_country2=COUNTRY.id 
WHERE
    (NEIGHBOUR.id_country1=<your requested id>
    OR NEIGHBOUR.id_country2=<your requested id>)
    AND COUNTRY.id<><your requested id>

select datepart(day, '31DEC2013')
select datepart(month, '31DEC2013')
select datepart(year, '31DEC2013')

update t, (
select 1 as v, id from temp1
union all
select 2, id from temp2
...
) as q set val=q.v where t.id=q.id
  UPDATE listtable t1 
  SET t1.column3 = ';'
  WHERE t1.column2 < ( SELECT MAX(t2.column2) 
                       FROM listtable t2 
                       WHERE t1.column1 = t2.column1 )

DECLARE @start_time DATETIME, @end_time DATETIME
SET @start_time = CURRENT_TIMESTAMP

 -- query goes here

SET @end_time = CURRENT_TIMESTAMP
SELECT DATEDIFF(ms, @start_time, @end_time)

SELECT 
 indxs.*,
 ((indx_val2 - indx_val2_avg) * (indx_val1 - indx_val1_avg)) / total_rows AS cv
FROM (
    SELECT 
      dt,
      MAX(CASE WHEN indx_nm = 'ABQI' THEN indx_nm ELSE NULL END) AS indx_nm1,
      MAX(CASE WHEN indx_nm = 'ABQI' THEN indx_val ELSE NULL END) AS indx_val1,
      MAX(CASE WHEN indx_nm = 'ACNACTR' THEN indx_nm ELSE NULL END) AS indx_nm2,
      MAX(CASE WHEN indx_nm = 'ACNACTR' THEN indx_val ELSE NULL END) AS indx_val2
    FROM table1 a
    GROUP BY dt
  ) indxs 
  INNER JOIN (
    /* Join against a query returning the AVG() and COUNT() across all rows */
    SELECT
      'ABQI' AS indx_nm1_aname,
      AVG(CASE WHEN indx_nm = 'ABQI' THEN indx_val ELSE NULL END) AS indx_val1_avg,
      'ACNACTR' AS indx_nm2_aname,
      AVG(CASE WHEN indx_nm = 'ACNACTR' THEN indx_val ELSE NULL END) AS indx_val2_avg,
      COUNT(*) AS total_rows
    FROM table1 b
    WHERE indx_nm IN ('ABQI','ACNACTR')
    /* And it is a cartesian product */
  ) aggs ON 1=1
WHERE
  indx_nm1 IS NOT NULL
  AND indx_nm2 IS NOT NULL
ORDER BY dt

SELECT ISNULL(MAX(item_code) + 1) FROM item
WHERE user_id = 2

declare @sql varchar(8000) -- varchar(max) in SQL 2005+

SELECT 
        @sql = t1.Routine_Definition
FROM
        INFORMATION_SCHEMA.Routines t1 

print @sql

select     
  a.*,  
  COUNT(a.ID) SUMFILL
from 
  quizz a
  left join quizz_result countt
    on countt.QUIZZ_ID = a.ID 
group by 
   a.ID

 select
 ..
 Agent,
 case when coalesce(MiddleName, '') = '' then FirstName + ' ' + LastName 
      else FirstName + ' ' + MiddleName + ' ' + LastName 
 end as Name,
 ...
 from tbSystemUser 

SELECT id, skeys(hstore(users)) AS column, svals(hstore(users)) AS value FROM users;

select
  pkid,
  fkself,
  otherData
from
  (select
    pkid,
    fkself,
    otherData,
    dense_rank() over (partition by least(pkid, fkself), greatest(pkid, fkself) order by pkid) as rank
  from
    YourTable t)
where
  rank = 1

select 
  case when exists(
    select username, count(*)
    from person
    group by username
    having count(*) > 1 )
    then 1
    else 0
  end

with x as 
(select row_number() over(partition by FirstName order by Investment_DT desc) as rn, *
from [dbSuppHousing].[dbo].[tblABC])
select Login_Name
      ,r.Role_Name
      ,Investment_DT
      ,FirstName     
      ,LastName
      ,Login_Name
      ,Investment_DT
      ,Investment_ID
into #temptable
from x join tblUsers t 
on t.UserName = x.Login_Name
join tblUser_Roles ur on t.User_Id=ur.USER_ID
join tblRoles r on r.Role_Id=ur.Role_ID
where x.rn = 1
-- order by x.FirstName 

SELECT XMLQuery('
    for $customer in ora:view("customer")/ROW
       return $customer/LAST_NAME
' RETURNING CONTENT) FROM DUAL;


    Dim conString As String = "data source=ServerName;" & _
                                "initial catalog=DBName;" & _
                                "integrated security=SSPI;" & _
                                "persist security info=false;"

    Dim conSQL As New SqlConnection(conString)

    conSQL.Open()

    Dim cmdSQL As New SqlCommand()
    cmdSQL.CommandType = Data.CommandType.Text
    cmdSQL.CommandText = "SELECT FieldName1, FieldName2 FROM MyTable"

    Dim adptSQL As New SqlClient.SqlDataAdapter(cmdSQL)
    Dim myDataSet As New DataSet()
    adptSQL.Fill(myDataSet)

    conSQL.Close()

    With myDataSet.Tables(0)
        For rowNumber As Integer = 0 To .Rows.Count - 1
            With .Rows(rowNumber)
                Console.WriteLine(String.Format("Field1: {0}, Field2: {1}", _
                                                .Item(0).Value.ToString, _
                                                .Item(1).Value.ToString))
            End With
        Next
    End With

;With i As
(
   SELECT vendor_id, sum(invoice_total-payment_total) as totalbalance
   FROM invoices
   WHERE payment_total is not null
   GROUP BY vendor_id
)
SELECT Vendors.vendor_name, i.totalbalance
From Vendors LEFT JOIN i ON Vendors.vendor_id = i.vendor_id

CREATE TABLE `TableKeys` (
  `table_name` VARCHAR(8) NOT NULL,
  `last_key` VARCHAR(6) NOT NULL,
  PRIMARY KEY (`table_name`)
);

SELECT * FROM `TableKeys`;

table_name | last_key
-----------+---------
users      | U00003A2
articles   | A000166D
products   | P000009G

CREATE TABLE mixers (
    mixer_id INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,
    mixer_name VARCHAR(255) NOT NULL,
)

CREATE TABLE ingredients (
    ingredient_id INT(11) NOT NULL PRIMARY KEY AUTO_INCREMENT,
    ingredient_name VARCHAR(255) NOT NULL,
)

CREATE TABLE mixer_ingredients
    mixer_id INT(11) NOT NULL,
    ingredient_id  INT(11) NOT NULL,
    PRIMARY KEY (mixer_id, ingredient_id),
    FOREIGN KEY (mixer_id) REFERENCES mixers(mixer_id),
    FOREIGN KEY (ingredient_id) REFERENCES ingredients(ingredient_id),
)

SELECT ce.id, ce.file, ce.date_init, ce.content_type, ce.created_by_id, ce.status, ce.date_decide, u.username,S.details
                         FROM content_edits AS ce
                         INNER JOIN users AS u
                         ON ce.created_by_id=u.id
                         INNER JOIN (
                           /*add details required columns*/
                           select 0 as entity_type,a.id as entity_id,a.art_details as details
                            from m_articles AS a
                            union all 
                           select 1 as entity_type,g.id as entity_id,g.grp_details as details
                            from groups AS g
                           union all 
                           select 3 as entity_type,n.id as entity_id,n.n_details as details
                            from e_news AS n
                           )S
                                  ON ce.entity_id=S.entity_id
                                  AND ce.entity_type = S.entity_type
                         LIMIT 10;

`select X , Y from mytable where LOWER(Y) = LOWER(@toSearch)`

select t.NDC_10, p.NDC_8
FROM test t
INNER JOIN product p ON (LOCATE(p.NDC_8,t.NDC_10) <> 0)

SELECT  *,  
        (weight > 10) overweight
FROM    Cat

WHERE entered_by='2254'
AND ENTERED_DATE BETWEEN trunc (sysdate, 'mm')/*current month*/ AND SYSDATE

SELECT T1.id, ROUND(COALESCE(SUM(T2.amount), 0), 2) AS spent_amount 
FROM T1 
LEFT JOIN T2 
    ON T2.t1_id = T1.id 
    AND T2.date <= '2014-01-01' 
    AND T2.flag2 = 't' 
WHERE T1.flag1 = 't'

select ID, MerchantID, NAME
from PricePlan pp
inner join (
    select MerchantID, max(VALIDFROM) as VALIDFROM
    from PricePlan
    where VALIDFROM <= '7-sep-09'
    	and VALIDUPTO >= '9-sep-09'
    group by MerchantID
) pp2 on pp.MerchantID = pp2.MerchantID
    and pp.VALIDFROM = pp2.VALIDFROM

SELECT P.personID, P.Name, IFNULL(O.Name, 'None') OrgName
FROM PEOPLE P 
LEFT OUTER JOIN ORGs O ON P.orgID = O.OrgID 

SELECT COUNT(case when tank_list.level='6' then garage_list.account_id end) as num1,
       COUNT(case when tank_list.level='8' then garage_list.account_id end) as num2,
       COUNT(case when tank_list.level='10' then garage_list.account_id end) as num3, 
        garage_list.account_id, 
        garage_list.tank_id,
        player_list.clan,
        player_list.nickname,
        tank_list.level
    FROM garage_list 
        RIGHT JOIN player_list ON garage_list.account_id = player_list.account_id 
        RIGHT JOIN tank_list ON garage_list.tank_id = tank_list.tank_id


      where tank_list.level in ('6','8','10')

      and player_list.clan = 'bad-1'

      GROUP BY account_id 

SELECT t1.`subscriber_email`, t2.`firstname`, t2.`lastname`, t2.`telephone` from `newsletter_subscriber` t1 JOIN `sales_flat_order_address` t2 on
t1.`subscriber_email` = t2.`email`

select array_agg(x."id")  as "id" from public."jp_OnlyIds" as x

USE Northwind
GO


CREATE TABLE #MyTemp
   (  RowID    int  IDENTITY,
      LastName varchar(20)
   )

DECLARE @SQL nvarchar(250)
SET @SQL = 'INSERT INTO #MyTemp SELECT LastName FROM Employees;'
EXECUTE sp_executesql @SQL

SELECT n.nationality,
       sum(branda), sum(brandb), sum(branda * brandb)
FROM (SELECT t.txn_id, n.nationality,
             MAX(CASE brand WHEN 'branda' THEN 1 ELSE 0 END) AS branda,
             MAX(CASE brand WHEN 'brandb' THEN 1 ELSE 0 END) AS brandb
      FROM transaction_data t INNER JOIN
           products p
           USING (sku) INNER JOIN
           nationalities n
           USING (nationality_id)
      GROUP BY t.txn_id, n.nationality
     ) tn
GROUP BY n.nationality
ORDER BY max(txn_id) DESC
LIMIT 20;

SELECT * FROM easylens WHERE `index` = 1.6000000238418578;
+----+------+--------+------+-------+-------+-------+---------+----------+
| id | type | design | name | brand | index | color | coating | material |
+----+------+--------+------+-------+-------+-------+---------+----------+
|  4 | sv   | dase   | gel  | hoya  |   1.6 |   293 | ar      | plastic  |
|  5 | sv   | fase   | rel  | essi  |   1.6 |   293 | ar      | plastic  |
|  6 | sv   | gase   | mel  | hoya  |   1.6 |   292 | ar      | plastic  |
+----+------+--------+------+-------+-------+-------+---------+----------+

SELECT CODE, SUM (CASE Sign WHEN '-' THEN -Amount ELSE Amount END) as Total
FROM myTable
GROUP BY Code

SELECT 'object_id', 'name'

UNION ALL

SELECT object_id, name
FROM sys.tables

DECLARE @tmp TABLE
(
    Name    varchar(30),
    GUID    uniqueidentifier
)

INSERT @tmp
    SELECT  x.Name, NEWID()
    FROM    (SELECT DISTINCT Name FROM MyTable) x

UPDATE MyTable
    SET GUID = tmp.GUID
    FROM MyTable t
    INNER JOIN @tmp tmp ON t.Name = tmp.Name

SELECT DATE(NOW()+duration * INTERVAL '1day') FROM tbl;

  SELECT 
  Students.StudentName,
  Students.StudentNumber,
  Schools.SchoolAddress 
FROM
  XSchools 
  INNER JOIN YStudents 
    ON Schools.schoolName = Students.schoolName 
WHERE Schools.schoolName = 'London School' 

{'fields': {'county': {'type': 'string'},
            'distance': {'type': 'number'},
            'population': {'type': 'number'},
            'row_id_2': {'type': 'number'},
            'running_total': {'type': 'number'}},
 'rows': [{'county': 'Rensselaer',
           'distance': 1.4299124873995,
           'population': 1700,
           'row_id_2': 34,
           'running_total': 1700},
          {'county': 'Columbia',
           'distance': 1.51173290729954,
           'population': 2200,
           'row_id_2': 44,
           'running_total': 3900}],
 'time': 0.002,
 'total_rows': 2}

SELECT * 
FROM users 
WHERE freetrial=1 
AND FROM_UNIXTIME(date_created,'%Y-%m-%d') + INTERVAL 20 DAY = CURRENT_DATE()

things.equals(t_things)

SELECT COUNT(DISTINCT employee_id) AS "Total",
SUM( CASE WHEN hire_date BETWEEN '2005-01-01' AND '2005-12-31' THEN 1 else 0 end) as   
'2005', 
SUM( CASE WHEN hire_date BETWEEN '2006-01-01' AND '2006-12-31' THEN 1 else 0 end) as 
'2006',
SUM( CASE WHEN hire_date BETWEEN '2007-01-01' AND '2007-12-31' THEN 1 else 0 end) as 
'2007',
SUM( CASE WHEN hire_date BETWEEN '2008-01-01' AND '2008-12-31' THEN 1 else 0 end) as 
'2008',
SUM( CASE WHEN hire_date < '2005-01-01' OR  hire_date > '31-12-2008' 
THEN 1 else 0 end) as 
"Out of Range"
FROM   employees

SELECT 
YEAR(t.voucher_date) as period,
COUNT(t.id) as total_count, 
(SELECT COUNT(t2.id) FROM booking_global as t2 where t2.booking_status = 'CONFIRMED' and YEAR(t2.voucher_date) = YEAR(t.voucher_date)) as confirmed,
(SELECT COUNT(t3.id) FROM booking_global as t3 where t3.booking_status = 'PENDING'  and YEAR(t3.voucher_date) = YEAR(t.voucher_date)) as pending
FROM booking_global t 
GROUP BY YEAR(t.voucher_date)

 SELECT * 
FROM   peopleaffiliation pa 
       LEFT OUTER JOIN addresses addr 
                    ON pa.addressid = addr.addressid 
       LEFT OUTER JOIN addresstypes addtyp 
                    ON addtyp.addresstypeid = addr.addresstypeid 
WHERE  (addr.preferredaddress = 1 )
        OR( COALESCE(addr.preferredaddress, 0) = 0 
           AND addtyp.addresstypeconst = 'Work' )

SELECT * FROM
(SELECT color_id, parent_id, language_id, name, 1 as order_rank
 FROM some_table
 WHERE parent_id = %parent_id% AND language_id = %language_id%
 UNION
 SELECT NULL, %parent_id%, %language_id%, NULL, 2 as order_rank
)
ORDER BY order_rank
LIMIT 1

with    cte(customer,children,crates,i) as 
        (
        Select customer,children, children/80 + case when children%80 = 0 then 0 else 1 end crates, 0 from test
        union all
        select  customer,children,crates
        ,       i + 1
        from    cte
        where   cte.i < cte.crates -1
        )
select  customer,children,crates
from    cte
order by customer

Sum(tblReceived.ReceivedQTY) AS SumOfReceivedQTY, IIf(IsNull([SumofReceivedQTY]),0,[SumofReceivedQTY]) AS RECQTY

declare @id int = 1

;with cte
as
(
    select PARENTCUSTOMERID, 0 as level 
    from CUSTOMER_PROFILE where CUSTOMERID = @id

    union all

    select t.PARENTCUSTOMERID, cte.level  + 1 as level
    from CUSTOMER_PROFILE t
    inner join cte on t.CUSTOMERID = cte.PARENTCUSTOMERID 

)

select top 1 PARENTCUSTOMERID from cte
order by level desc

select t.name, t.region, t.date
from (select t.*,
             (select t2.region
              from new_table t2
              where t2.name = t.name and
                    t2.date = t.date and -- not sure if this condition is really necessary
                    t2.id < t.id
              order by t2.id desc
              limit 1
             ) as prev_region
      from new_table t
     ) t
where prev_region is null or prev_region <> region;

<someXML>
    <record ID="1">
        <blah>
            <moreBlah/>
        </blah>
    </record>
    <record ID="2">
        <blah>
            <moreBlah/>
        </blah>
    </record>
</someXML>

WHERE GroupId IN (@group) OR GroupId = @group

EDIT for additional question
drop schema test1

SELECT
    ProdID,
    [Date],    -- A poor name for a column, since it's not only a reserved word, but also not at all descriptive
    ROW_NUMBER() OVER (PARTITION BY ProdID ORDER BY [Date]) AS counter
FROM
    My_Table

INSERT INTO table1 (Product,ProductOption, ServiceId)
SELECT DISTINCT 2,1, serviceId FROM Table1 t1
WHERE NOT EXISTS
  (SELECT 1 FROM table1
   WHERE product = 2
   AND ProductOption = 1
   AND ServiceId = t1.ServiceId)

Database.forDataSource(dataSource).withDynSession {
  sqlu"""INSERT INTO `users`(`email`) VALUES ("theEmailAdress@test.de")
  """.firstOption match {
    case Some(num) if num == 1 => sql"SELECT LAST_INSERT_ID()".as[Long].firstOption()
    case None => None
  }
}

select
    product,
    tree_level,
    count(1) over (partition by product,tree_level_category) 
        * case when product like '%FACE%'
               then case tree_level_category
                        when '0-5' then 3
                        when '-1' then 2
                    end
               when product like '%MOBIL%'
               then case tree_level_category
                        when '0-5' then 3
                    end
               when product like '%FAST%'
               then case tree_level_category
                   when '0-5' then 2
                   when '-1' then 2
              end
        end 
from (
    select
        product,
        tree_level,
        case when tree_level in (0,1,2,3,4,5)
             then '0-5'
             when tree_level = '-1'
             then '-1'
             else null 
        end tree_level_category
    from
       product
) as t

select  case    when [date] < @currentweek  then 'R' 
                else null   
                end as [current week],
        case    when [date] > @currentweek 
                    and [date] < @1stweek   then 'R' 
                else null   
                end as [first week]

DECLARE @tmp TABLE (date smalldatetime, rownum int IDENTITY);
DECLARE @weekends TABLE (date smalldatetime);
DECLARE @minDate smalldatetime, @maxDate smalldatetime, @date smalldatetime;
/* #1 */
SELECT @minDate = MIN(date), @maxDate = MAX(date)
FROM testDates;
SET @date = @minDate - DATEPART(dw, @minDate) + 7;
WHILE @date < @maxDate BEGIN
  INSERT INTO @weekends
  SELECT @date UNION ALL
  SELECT @date + 1;
  SET @date = @date + 7;
END;
/* #2 */
INSERT INTO @tmp
SELECT date FROM testDates
UNION
SELECT date FROM @weekends
ORDER BY date;
/* #3 & #4 */
SELECT *
FROM (
  SELECT
    MIN(date + CASE DATEPART(dw, date) WHEN 1 THEN 1 WHEN 7 THEN 2 ELSE 0 END)
      AS dateRangeStart,
    MAX(date - CASE DATEPART(dw, date) WHEN 1 THEN 2 WHEN 7 THEN 1 ELSE 0 END)
      AS dateRangeEnd,
    COUNT(CASE WHEN DATEPART(dw, date) NOT IN (1, 7) THEN date END) AS dates,
    DATEADD(d, -rownum, date) AS GroupID
  FROM @tmp
  GROUP BY DATEADD(d, -rownum, date)
) s
WHERE dates > 0;

select t1.group1,
  t2.group2
from
(
  select name group1,
    row_number() over(order by id) rn
  from yourtable
  where accountid = 6
) t1
full outer join
(
  select name group2,
    row_number() over(order by id) rn
  from yourtable
  where accountid = 8
) t2
  on t1.rn = t2.rn;

SELECT Distinct Jurisdiction, JurisdictionX, LicenceNumber, DateIssued, ExpirationDate, Resident
FROM #TEMP
WHERE LicenseNumber IS NOT NULL AND 
      DateIssued IS NOT NULL AND 
      ExpirationDate IS NOT NULL
UNION
SELECT Distinct Jurisdiction, JurisdictionX, LicenceNumber, DateIssued, ExpirationDate, Resident
FROM #TEMP
WHERE JurisdictionX NOT IN ( SELECT JurisdictionX from #TEMP
      WHERE LicenseNumber IS NOT NULL AND 
            DateIssued IS NOT NULL AND 
            ExpirationDate IS NOT NULL);

WITH cteOrderedUpdates As
(
   SELECT
      TankNumber,
      Gallons,
      TimeUpdated,
      FuelType,
      ROW_NUMBER() OVER 
      (
         PARTITION BY 
            TankNumber 
         ORDER BY 
            TimeUpdated DESC
      ) As RowNumber
   FROM
      someTable
)
SELECT
   x.TankNumber,
   x.Gallons,
   x.TimeUpdated,
   x.FuelType,
   x.Gallons - IsNull(y.Gallons, 0) As GallonsUsed
FROM
   cteOrderedUpdates As x
   LEFT JOIN cteOrderedUpdates As y
   ON x.TankNumber = y.TankNumber
   And x.RowNumber = y.RowNumber - 1
WHERE
   x.RowNumber = 1
ORDER BY
   x.TankNumber
;

DECLARE @start DATETIME, @end DATETIME
SET @start = '2013-05-25 12:45:00.000'
SET @end = '2013-05-25 17:45:00.000'
       (SELECT COUNT(*) AS [Moves]
    FROM 
        (
        SELECT moves AS too
        FROM moveevent
        FULL OUTER JOIN job AS too ON moves = too.jobid
        WHERE  (moveevent.time >= @start and moveevent.time <= @end)
    UNION ALL
        SELECT moves AS frm
        FROM moveevent
        FULL OUTER JOIN job AS frm ON moves = frm.jobid
        WHERE  (moveevent.time >= @start and moveevent.time <= @end)
        )   
        AS m

select  *
from    (
        select  row_number() over (
                    partition by Sub 
                    order by LastUpdated desc) as rn
        ,       *
        from    YourTable
        ) as SubQueryAlias
where   rn = 1

ROUND((SYSDATE-TRUNC(SYSDATE))*24)

MERGE INTO ItemLog it USING
(SELECT ItemID, MessageTime, 
    CASE WHEN A.Voltage<B.Voltage and A.Voltage<C.Avg_Voltage and C.SD_Voltage<5 THEN 'Good' ELSE 'Bad' END Calculated_Status1, 
    CASE WHEN A.Temperature<B.Temperature and A.Temperature>C.Temperature and C.SD_Temperature>10 THEN 'Good' ELSE 'Bad' END Calculated_Status2 
FROM ItemLog A,
   (SELECT F.ItemID,
        F.MessageTime Key_MessageTime,
        S.Voltage,
        S.Temperature
    FROM ItemLog F,
        ItemLog S
    WHERE F.ItemID=S.ItemID 
        and S.MessageTime=
            SELECT MAX(MessageTime)
            FROM ItemLog
            WHERE ItemID=F.ItemID
               and MessageTime<F.MessageTime
               and Voltage<12
               and Temperature<125
    ) B,  -- Returns the Voltage and Temperature from the prior time it was <12 and <125
   (SELECT K.ItemID, K.MessageTime,
        AVG(L.Temp) Avg_Temperature, STDDEV(L.Temperature) SD_Temp, 
        AVG(L.Voltage) Avg_Voltage, STDDEV(L.Voltage) SD_Voltage 
    FROM ItemLog K,
        ItemLog L
    WHERE K.ItemID=L.ItemID 
        and L.MessageTime=
            SELECT MAX(MessageTime)
            FROM ItemLog
            WHERE ItemID=K.ItemID
               and MessageTime<K.MessageTime
    GROUP BY K.ItemID, K.MessageTime
     ) C  -- Returns the Voltage and Temperature stats from all prior messages
   (SELECT ItemID 
    FROM ItemLog
    WHERE Voltage>40
     ) D  -- Returns all ItemID where Voltage was ever >40, to exclude them
WHERE A.ItemID=B.ItemID and A.MessageTime=B.MessageTime
  and A.ItemID=C.ItemID and A.MessageTime=C.MessageTime
  and A.ItemID=D.ItemID(+) and D.ItemID IS NULL)z
ON
(it.ItemID = z.ItemID AND it.MessageTime = z.MessageTime)
WHEN MATCHED THEN
UPDATE SET it.STATUS1 = z.Calculated_Status1,
       it.STATUS2 = z.Calculated_Status2;

INSERT INTO MYTABLE (col1, col2, col3) 
SELECT col1, col2, col3
FROM @table1 
WHERE ...

CREATE PROCEDURE [dbo].[viewSimilarRecords]
 @recordType varchar(25),
 @recordSource varchar(25)

 AS 
SELECT * FROM myTableName 
WHERE
(recordtype  =@recordType   OR @recordType IS NULL) AND --<<change to OR??
(recordsource=@recordSource OR @recordSource IS NULL)
                          --^^^^^^^^^^^^^^^^^^^^^^^^
 GO

DELETE FROM orderdetail 
WHERE orderdetail.order_sequence_number IN 
(
    SELECT id 
    FROM orders 
    WHERE date_ordered BETWEEN X AND Y
)

// Java API
String condition = "tab.ENQ_TIME = (select min(AQ_TABLE1.ENQ_TIME) from AQ_TABLE1 self where tab.CORRID=AQ_TABLE1.CORRID)";
dequeueOption.setCondition(condition);

CREATE DATABASE ORA10;

UPDATE t1
SET t1.ColC = t2.ColC
FROM dbo.test1 t1 JOIN dbo.test2 t2 ON t1.pkey = t2.pkey

create unique index UX_InvoiceDetails_InvoiceId on InvoiceDetails(InvoiceID) 
  where EndEffectiveTime is null

SELECT Name, 
    CASE WHEN Count(*) > 2 THEN CONCAT(COUNT(*), ' Have too many fruits')  
         ELSE CAST(COUNT(*) As CHAR) 
    END AS 'Fruits Number'
FROM 
    MyTable Group By Name

SELECT
      [Week]
    , CAST(SUM(MaxScoreP) AS float) AS [SP]
    , CAST(AVG(MaxScoreP) AS float) AS [AP]
    , CAST(SUM(MaxScoreR) AS float) AS [SR]
    , CAST(AVG(MaxScoreR) AS float) AS [AR]
FROM (
            SELECT
                  [date]                                                     AS DATE_
                , [machineID]
                , tbl_tablename.[Week]
                , MAX(CASE
                        WHEN [Type] = 'PILOT' THEN CAST(JL AS float) END)    AS [MaxScoreP]
                , MAX(CASE
                        WHEN [Type] = 'ROLL-OUT' THEN CAST(JL AS float) END) AS [MaxScoreR]
            FROM tbl_tablename
                  INNER JOIN (
                              SELECT TOP 7
                                    [Week]
                              FROM tbl_tablename
                              GROUP BY
                                    [Week]
                              ORDER BY
                                    [Week] DESC
                        ) AS w7
                              ON tbl_tablename.[Week] = w7.[Week]
            GROUP BY
                  tbl_tablename.[Week]
                , [date]
                , [machineID]
      ) AS m
GROUP BY
      [Week]
ORDER BY
      [Week] ASC 

select 
   instance_name,
   to_char(startup_time,'mm/dd/yyyy hh24:mi:ss') as startup_time ,
   systimestamp - startup as uptime
from gv$instance;

SELECT * from T where T.A = @a and T.B = @b


IF (@@ROWCOUNT = 0)
BEGIN
    SELECT * from T where T.A = @a and T.B IS NULL
END

SELECT bill.billnumber_id, billdetail.billclass, SUM(billdetail.amount) AS Amount,
       (case when SUM(billdetail.amount) > 10 then 'BigOne'
             else 'Little'
        end)
GROUP BY bill.billnumber_id, billdetail.billclass

UPDATE [yourTableName]
SET Rent = 0
WHERE Rent IS NULL

select array_agg(attr => val) from t1;

UPDATE table2
SET table2.PageID = 
    (SELECT t1.PageID
    FROM table1 t1
   WHERE t1.id = table2.SCRID)
WHERE EXISTS(
    SELECT 'TABLE1PAGE'
    FROM table1 t1
    WHERE t1.id = table2.SCRID)

foreach part in array string_to_array('one,two,three', ',')
loop
    -- do something with part
end loop;

SELECT c.original_SKU, c.bought_with, count(*) as times_bought_together
FROM (
  SELECT a.sku as original_SKU, b.sku as bought_with
  FROM items a
  INNER join items b
  ON a.order_id = b.order_id AND a.sku != b.sku) c
GROUP BY c.original_SKU, c.bought_with

where  exists
       (
       select  *
       from    other_table
       where   value like ?
               and id in (subcategory, subcategory2)
       )

select q.totalmarks from
(
SELECT *,@curRow := @curRow + 1 AS row_number
FROM student as std JOIN    (SELECT @curRow := 0) r
WHERE std.status=1
ORDER BY (std.datetime) ASC
) q
where row_number>( 
          SELECT us.startnum 
            FROM user AS us 
           WHERE us.username='abc'
          )
limit 10

CREATE TABLE `ProductInfo` (
  `ProductID` BIGINT UNSIGNED NOT NULL,
  `AttributeKey` VARCHAR(20) NOT NULL,
  `AttributeVal` VARCHAR(20),
  PRIMARY KEY (`ProductID`, `AttributeKey`),
  FOREIGN KEY (`ProductID`) REFERENCES `Products` (`id`)
);

INSERT INTO ProductInfo
  (`ProductID`, `AttributeKey`              , `AttributeVal`)
VALUES
  (         1 , 'adjustment'                ,         '0.13'),
  (         1 , 'weight'                    ,        '14.60'),
  (         1 , 'have_some_individual_label',        'value')
;

SELECT a.col1
FROM tblname a
JOIN tblname b
  ON b.col1 = CONCAT(a.col1, 's')

UPDATE
  table2
SET
  avgin=ifnull(
    (
      SELECT
        Specified
      FROM
        table1
      WHERE
        table1.Device=table2.Device
        AND substring(table1.Interface,1,3)=substring(table2.Interface,1,3)
      LIMIT 1
    ),
    'default value'
  )

select *  
from
  4e_magic_items mi
 ,4e_magic_item_levels mil
 ,4e_monster_sources ms
where mi.id = mil.itemid
  and mi.source = ms.id
  and itemlevel between 1 and 30
  and source not in(16,2,5,13,15,3,4,12,7,14,11,10,8,1,6,9)  
  and type not in(
                  'Arms' ,'Feet' ,'Hands' ,'Head' ,'Neck' ,'Orb' ,
                  'Potion' ,'Ring' ,'Rod' ,'Staff' ,'Symbol' ,'Waist' ,
                  'Wand' ,'Wondrous Item' ,'Alchemical Item' ,'Elixir' ,
                  'Reagent' ,'Whetstone' ,'Other Consumable' ,'Companion' ,
                  'Mount'
                 )
  and ((type != 'Armor') or (false))
  and ((type != 'Weapon') or (false))
order by
  type asc
 ,itemlevel asc
 ,name asc

/*
Some thoughts:
==============
0 - Formatting really matters, in SQL even more than most languages.
1 - consider selecting only the columns you need, not "*"
2 - use of table aliases makes it short & clear ("MI", "MIL" in my example)
3 - joins in the WHERE clause will un-clutter your FROM clause
4 - use NOT IN for long lists
5 - logically, the last two lines can be added to the "type not in" section.
    I'm not sure why you have the "or false", but I'll assume some good reason
    and leave them here.
*/

location_id IN ('2', '3', '4', '5')

SELECT *
FROM `tasks`
LEFT JOIN `tags_tasks` ON ( `tags_tasks`.`task_id` = `tasks`.`id` )
LEFT JOIN `tags` ON ( `tags`.`id` = `tags_tasks`.`tag_id` )
WHERE `tags`.`name` = 'Problem'

select *
from table t left outer join
     (select id
      from table t
      group by t
      having sum(case when comment = 'apple' then 1 else 0 end) > 0 and
             sum(case when comment = 'orange' then 1 else 0 end) > 0
     ) toexclude
     on t.id = toexclude.id
where toexclude.id is null;

SELECT table1.*, table2.z
FROM table1
INNER JOIN table2
  ON table2.name LIKE CONCAT('%', table1.name, '%') 
 AND table1.year = table2.year

update B set spent = s.spent
from
    (
        select distinct on (provider_id)
            be.id, aggregation.spent
        from
            (
                select provider_id, sum(spent) spent
                from A
                group by provider_id
            ) aggregation
            inner join
            B be using (provider_id)
    ) s    
where B.id = s.id

($v('P_ITEM').length >= 14 && $v('P_ITEM').substring(0,1) == '1') ||
($v('P_ITEM').length >= 11 && $v('P_ITEM').substring(0,1) == '2')

CASE
    WHEN str LIKE ',%,' THEN SUBSTRING(str, 2, LEN(str)-2)
    WHEN str LIKE ',%'  THEN RIGHT(str, LEN(str)-1)
    WHEN str LIKE '%,'  THEN LEFT(str, LEN(str)-1)
    ELSE str
END

select a.id, a.column1, b.column2 
from table1 a 
left join table2 b on a.id = b.otherid;

alter table big_table add new_column tinyint;

update  big_table bt
join    smaller_table st
on      bt.key1 = st.key1
        and bt.key2 = st.key2
set     bt.new_column = st.my_column;

alter table big_table modify new_column tinyint not null;

declare
  xml_str clob := q'[<?xml version="1.0" encoding="UTF-8"?>
<CATALOG>
 <CD>
  <TITLE>Empire Burlesque</TITLE>
  <ARTIST>Bob Dylan</ARTIST>
  <COUNTRY>USA</COUNTRY>
  <COMPANY>Columbia</COMPANY>
  <PRICE>10.90</PRICE>
  <YEAR>1985</YEAR>
 </CD>
 <CD>
  <TITLE>Hide your heart</TITLE>
  <ARTIST>Bonnie Tyler</ARTIST>
  <COUNTRY>UK</COUNTRY>
  <COMPANY>CBS Records</COMPANY>
  <PRICE>9.90</PRICE>
  <YEAR>1988</YEAR>
 </CD>
</CATALOG>]';

v_doc  dbms_xmldom.domdocument;
node   dbms_xmldom.domnode;
txt    varchar2(4000);
type   t_list is table of number index by varchar2(4000);
v_list t_list;
  procedure enum_nodes(n dbms_xmldom.domnode, tag_name varchar2) is
    chn  dbms_xmldom.domnode;
    nl   dbms_xmldom.domnodelist;
  begin
    nl := dbms_xmldom.getchildnodes(n);
    for i in 0..dbms_xmldom.getlength(nl) loop
      chn := dbms_xmldom.item(nl, i);

      if dbms_xmldom.getnodetype(chn) = 1 then
         enum_nodes(chn, tag_name || dbms_xmldom.getnodeName(chn) || '/');
      elsif dbms_xmldom.getnodetype(chn) = 3 then
         v_list(tag_name || dbms_xmldom.getnodevalue(chn)) := 1;
      end if;
    end loop;
  end;
begin
  v_doc := dbms_xmldom.newdomdocument(xml_str);
  node := dbms_xmldom.makenode(v_doc);

  enum_nodes(node, '/');

  txt := v_list.first;
  while txt is not null loop
     dbms_output.put_line(txt);
     txt := v_list.next(txt);
  end loop;
end;
/

CREATE TRIGGER increment_value_on_insert 
    AFTER INSERT ON `users saved`
    REFERENCING
        NEW ROW as new_row
    FOR EACH ROW BEGIN
    UPDATE total
    SET value = value+1
    WHERE
     topicid = new_row.topicid
    END

update folder as f
   set owner_id = o.owner_id
  from owner as o
 where o.ident_string = left(f.folder_name,length(o.ident_string));

USERS-FEEDS TABLE
+---+----------+---------+
|id | user_id  |feed_id  |
+---+----------+---------+
|1  | 1        |1        |
+---+----------+---------+
|2  | 1        |2        |
+---+----------+---------+
|3  | 1        |3        |
+---+----------+---------+
|4  | 2        |2        |
+---+----------+---------+
|5  | 2        |3        |
+---+----------+---------+
|6  | 3        |1        |
+---+----------+---------+
|7  | 3        |2        |
+---+----------+---------+

SELECT *
FROM   sourcebans.sb_bans  
WHERE  removetype IS NULL
       AND removedon IS NULL
       AND reason NOT LIKE '%[FragSleuth] Duplicate account%'
       AND (ip IN(SELECT ip
                 FROM   fragsleuth.history
                 WHERE  trackingid = "ad000c3803b48190aabf382e01b957c9")
       OR authid IN(SELECT steamid
                    FROM   fragsleuth.history
                    WHERE  trackingid = "ad000c3803b48190aabf382e01b957c9"))

ALTER TABLE emails MODIFY COLUMN name `name_data_type` after email;

var lastCode = (
    from c in sedc.Codes
    where SqlMethods.Like(c.Code, "ABCD[0-9][0-9][0-9][0-9][0-9][0-9][0-9]")
    orderby c.Code descending
    select c)
    .FirstOrDefault();

YEAR(BirthDate)/1000

SELECT a.`name`, b.`compname`, c.`result`
FROM `compresults` c
INNER JOIN `competitions` b ON b.cid = c.cid
INNER JOIN `athletes` a ON c.`athlete` = a.`athlete`
WHERE b.`compdate` = (
                                    SELECT co.`compdate` 
                                    FROM `competitions` co INNER JOIN `compresults` cr ON cr.`cid` = co.`cid` 
                                    WHERE cr.`athlete` = a.`athlete`
                                    ORDER BY co.`compdate` DESC LIMIT 1
                    )

Select  'DXB' || Next As NextTransactionId
From
(
  Select    Max(Cast(Replace(Transaction_Id, 'DXB', '') As Int)) + 1 As Next
  FROM      transaction_master
  WHERE     (transaction_id LIKE 'DXB%')
)

select alls.letter
      ,alls.number
      ,ints.letter||ints.number as result
  from competition.lag alls
      ,(select letter
              ,number
              ,difference
              ,result 
          from (select letter
                      ,number
                      ,difference
                      ,case when difference>30 then 1 else 2 end as result
                  from competition.lag
               ) temp
         where result = 1
       ) ints
 where ints.letter=alls.letter
   and alls.number>=ints.number
   and alls.number-30<=ints.number

-- Setup a temp table with "bigstring" as your text and "lastpos" as the location of LAST "de"
 DECLARE @tmp1 TABLE (bigstring varchar(1000), lastpos int)
 INSERT INTO @tmp1 (bigstring) VALUES ('Número Total de Líquidos que se Consumen en el Hogar a la Semana')
 INSERT INTO @tmp1 (bigstring) VALUES ('Número Total de Líquidos que se Consumen en el Hogar a la Semana de')
 INSERT INTO @tmp1 (bigstring) VALUES ('Leave this de one alone')

  -- Ensure we don't have any trailing spaces
  UPDATE @tmp1 SET bigstring = RTRIM(bigstring)

  -- If the string ENDS in ' de' then record the starting position of that word
  UPDATE @tmp1 SET lastpos = LEN(bigstring)-2 WHERE RIGHT(bigstring,3) = ' de'

  -- Here is how our table looks now
  SELECT * from @tmp1

  -- Now, if LASTPOS is not null, we want everything to the LEFT of that + 'marca'
  UPDATE @tmp1 SET bigstring = SUBSTRING(bigstring, 1, lastpos) + 'marca' WHERE lastpos IS NOT NULL

  -- Done!
  SELECT * from @tmp1

SELECT NAME, MIN(DISTANCE) FROM
(
SELECT NAME, 
((19.171150  - COORDINATES.LAT) * (19.171184 - COORDINATES.LAT) + 
 (-96.173990 - COORDINATES.LON) * (-96.173990 - COORDINATES.LON)) AS DISTANCE  
FROM COORDINATES
INNER JOIN INFORMATION
ON COORDINATES.INFORMATION_ID=INFORMATION.ID 
WHERE DISTANCE < 0.000023544
) 
GROUP BY NAME

SELECT f.name
FROM files as f
INNER JOIN (SELECT file_id
            FROM files_tags_associations
            WHERE tag_id IN (3,5)
            GROUP BY file_id
            HAVING COUNT(*) = 2) as ft
    ON f.file_id = ft.file_id

select (
         select T2.SupplierID as SUPNO,
                T2.ProdCode as PRODCODE
         from YourTable as T2
         where T1.SupplierID = T2.SupplierID  
         for xml path('SUPPLIER_LINES'), type
       )
from YourTable as T1
group by SupplierID
for xml path('SUPPLIER')

SELECT p.productname, c.customername, od.orderid, od.quantity
FROM orders o
INNER JOIN customers c ON o.customerid = c.id
INNER JOIN orderdetail od ON o.id = od.orderid
INNER JOIN products p ON odproductid = p.id

with rcte(a,b, i, is_wd) as (
select from_dt , to_dt , id, case when (to_char(from_dt, 'DY') in ('SAT','SUN')) then 0 else 1 end from t
  union all
  select decode(a, null, a,a+1), b, i, case when (to_char(a, 'DY') in ('SAT','SUN')) then 0 else 1 end 
  from rcte
  where a+1 <= b
)
select i id, sum(is_wd) 
from rcte
group by i

SELECT   Project.ProfileID
FROM     Project
    JOIN Projects_Specialities USING (ProjectID)
    JOIN Projects_Industries   USING (ProjectID)
WHERE    Projects_Specialities.SpecialityID = ?
     AND Projects_Industries.IndustryID     = ?
GROUP BY Project.ProfileID
HAVING   SUM(Projects_Specialities.SpecialityID = ?)
     AND SUM(Projects_Industries.IndustryID     = ?)

DECLARE @program_guid uniqueidentifier, @program_binary binary(16)
--
SELECT @program_guid = '327EBEA7-3D4E-473A-8D72-7CB68AB51F73'
SELECT @program_binary = CAST(@program_guid AS binary(16)) 

#load SQL file contents in an array
$SQL = Get-Content "U:\Test\FileToSplit.sql"
$OutputPath = "U:\TestOutput"

#find first section name and count number of sections
$sectioncounter = 0
$checkcounter = 0
$filenames = @()

$SQL | % {
    #Add file name to array if new section was found on the previous line
    If ($checkcounter -lt $sectioncounter) 
    {
        $filenames += $_
        $checkcounter = $sectioncounter
    }
    Else
    {
        If ($_.StartsWith("/*")) 
        {
            $sectioncounter += 1
        }
    }
}

#return if too many sections were found
If ($sectioncounter > 50) { return "Too many sections found"}

$sectioncounter = 0
$endcommentcounter = 0

#for each line of the SQL file (Ref: sodawillow)
$SQL | % {

    #if new comment block is found point to next section name, unless its the start of the first section
    If ($_.StartsWith("/*") -And ($endcommentcounter -gt 0))
    {
        $sectioncounter += 1
    }

    If ($_.EndsWith("*/"))
    {
        $endcommentcounter += 1
    }

    #build output path
    $tempfilename = $filenames[$sectioncounter]
    $outFile = "$OutputPath\$tempfilename.sql"

    #push line to the current output file (appending to existing contents)
    $_ | Out-File $outFile -Append
}

SELECT e1.empno, e2.mgr
FROM emp AS e1 INNER JOIN emp AS e2
WHERE e1.mgr = e2.empno

SELECT SUM(New_Zealand)
FROM Slaughter_Data
WHERE Animal = 'Bovine'
    AND WeekEndingDate BETWEEN '2010-01-04' AND '2015-01-03'
    AND New_Zealand IS NOT NULL
GROUP BY WeekEndingDate

SELECT 
    DefaultConstraintName = df.name,
    df.definition
FROM 
    sys.default_constraints df
INNER JOIN 
    sys.tables t ON df.parent_object_id = t.object_id
INNER JOIN 
    sys.columns c ON c.object_id = df.parent_object_id AND df.parent_column_id = c.column_id
WHERE 
    t.Name = N'YourTableNameHere'
    AND c.Name = N'YourColumnNameHere'

--Total DLs--
select sum(DLs_ReferredBy_Null) as DLs_ReferredBy_Null_Total, sum(DLs_ReferredBy_NotNull) as DLs_DLs_ReferredBy_NotNull_Total
From
 (
Select
Count(CASE WHEN P.ReferredBy IS NULL THEN T.Create_Dtime END) As DLs_ReferredBy_Null,
Count(CASE WHEN P.ReferredBy IS NOT NULL THEN T.Create_Dtime END) As DLs_ReferredBy_NotNull
From Player_Tapjoy T 
Inner Join Player P On T.Player_Id=P.Player_Id
Union All
Select
Count(CASE WHEN P.ReferredBy IS NULL THEN Pt.Create_Dtime END) As DLs_ReferredBy_Null,
Count(CASE WHEN P.ReferredBy IS NOT NULL THEN Pt.Create_Dtime END) As DLs_ReferredBy_NotNull
From Player_Aux_Pt Pt
Inner Join Player P On Pt.Player_Id=P.Player_Id
Where
Pt.Site = 'AppCircle'
)

EXEC sp_addextendedproperty 
@name = N'Description', @value = 'Hey, here is my description!',
@level0type = N'Schema', @level0name = yourschema,
@level1type = N'Table',  @level1name = YourTable,
@level2type = N'Column', @level2name = yourColumn;
GO

ALTER TABLE YourTable MODIFY
   YourColumn VARCHAR(4)
   CHARACTER SET latin1
   COLLATE latin1_bin;

SELECT Patient_Name, Disease_status, Date_of_birth, Vital Status,
case when [Activity Status] in ('Active main hospital', 'Active regional hospital', 'Active consult' Then 'Alive'
else 'Dead' end [Vital Status]
  FROM Patient_Info_table
  WHERE Disease_status =  "diabetes"

SELECT 
    Data.Value('(Products/Product/ExternalId/text()[1]) AS ExternalId,
    x.Data.value('
        sum(
            for $quantity in /Products[1]/Product/Quantity
            return round($quantity)
        )
    ', 'float') Trn_Quantity
FROM x

select name
from table1
where name regexp binary '^CU[0-9]'

begin transaction;

   declare @deletedIds table ( id int );

   delete t1
   output deleted.id into @deletedIds
   from table1 t1
    join table2 t2
      on t2.id = t1.id
    join table3 t3
      on t3.id = t2.id;

   delete t2
   from table2 t2
    join @deletedIds d
      on d.id = t2.id;

   delete t3
   from table3 t3 ...

commit transaction;

SELECT id 
FROM Table1
UNION
SELECT id
FROM Table2
UNION
SELECT id
FROM Table3

UPDATE termine SET alarm_goes_off = (to_date('12/30/1899', 'MM/DD/YYYY') + (termin_start - alarmvorlauf));

With commandSQL
    .Connection = connection
    .CommandText = "spAddCSVDataLine"  'Stored procedure here
    .CommandType = CommandType.StoredProcedure
    .Parameters.AddWithValue("Name", If(IsDBNull(ds.Tables("dataExcel").Rows(j)("Name")), "", Trim(ds.Tables("dataExcel").Rows(j)("Name"))))
End With

select Sum(VisitingCount)as VisitingCount, [Time]
from (
  select Sum(VisitingCount)as VisitingCount, [Time]
    from #Temp group by [Time]
  Union All
    select count(page) as VisitingCount, 
    (datepart(hour,Date)*60+datepart(minute,Date))/30 as [Time]
    from scr_SecuristLog
    where Date between '2009-05-04 10:30' and '2009-05-04 12:30'
    GROUP BY (datepart(hour,Date)*60+datepart(minute,Date))/30--scr
  ) X
group by [Time]
order by 2 asc

SELECT * FROM my_table AS t1
INNER JOIN my_table AS t2
ON (
    t1.RecordID < t2.recordID
    AND
    DATEDIFF(second, t1.DateField1, t2.DateField1) <= 30
    AND
    t1.TextField1 = t2.TextField1
    AND
    t2.TextField2 = t1.TextField2
);

DECLARE @dbname nvarchar(128)
SET @dbname = N'Senna'

IF (EXISTS (SELECT name 
FROM master.dbo.sysdatabases 
WHERE ('[' + name + ']' = @dbname 
OR name = @dbname)))

-- code mine :)
PRINT 'db exists'

SELECT Department, NAME, EMAIL, ID, DATE1, DATE2
FROM (
SELECT ROW_NUMBER() OVER (PARTITION BY Department ORDER BY DATE1 DESC, DATE2 DESC, ID DESC) AS RowNumber, 
       Department, NAME, EMAIL, ID, DATE1, DATE2
FROM MyTable ) t
WHERE RowNumber = 1

SELECT u.*,p.*,f.*
FROM USER u
LEFT JOIN picture p ON p.user_id = id
INNER JOIN friends f ON f.friends_of = u.id
WHERE f.friends_id = 1

SELECT TASK, DAY, COUNT(*) FROM TABLE GROUP BY TASK, DAY

select * from table1
union
select * from table2
where not exists(select 1 from table1 
                 where table2.parent = table1.parent 
                 and table2.type = table1.type)

select * from 
(
    SELECT 
        t1.name as level1, t2.name as level2 
    FROM 
        People as t1 
    JOIN 
        People as t2 ON t2.parent_id = t1.id
    UNION
    select t1.Name as level1, '' as level2 
        from People t1 
        where Parent_id=0 
        and not exists(select 1 from People where Parent_id=t1.Id)

) People 

ORDER BY 
    level1, level2

 INSERT INTO the_table
 SELECT a, upper(a) FROM
 ( SELECT 'qwerty' a )

IF EXISTS(SELECT * FROM Names nm WHERE nm.Username = '%a%')
BEGIN
        -- It should return 0 rows if the query above has rows
        SELECT * FROM Names nm WHERE 1=2;

END

select lastLogin 
  from user.nodes 
 where lastLogin >= trunc(sysdate) - 30

SELECT l.AnimeID, 
       l.Name, 
       l.AnimeImage, 
       l.Synopsis, 
       l.Type, 
       l.Episodes, 
       l.Genres, 
       (SELECT ISNULL(AVG(Rating), 0) Rating
          FROM Anime_Reviews 
         WHERE AnimeID = l.AnimeID)
  FROM Anime_List l

[
  {
    venue: 'Some Nightclub',
    categories: ['bar', 'nightclub']
  },
  {
    venue: 'Some Cafe',
    categories: ['cafe', 'disco']
  }
]

select slug, name, 1 as mt 
  from tablea 
union 
select slug, name, 0 as mt 
  from tableb 
 order 
    by name;

SELECT 
SUM(if (CONCAT(@year, '-01') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Jan,
SUM(if (CONCAT(@year, '-02') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Feb,
SUM(if (CONCAT(@year, '-03') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Mar,
SUM(if (CONCAT(@year, '-04') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Apr,
SUM(if (CONCAT(@year, '-05') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) May,
SUM(if (CONCAT(@year, '-06') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Jun,
SUM(if (CONCAT(@year, '-07') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Jul,
SUM(if (CONCAT(@year, '-08') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Aug,
SUM(if (CONCAT(@year, '-09') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Sep,
SUM(if (CONCAT(@year, '-10') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Oct,
SUM(if (CONCAT(@year, '-11') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) Nov,
SUM(if (CONCAT(@year, '-12') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance * IF (type_money = 2, @euro, 1), 0)) `Dec`

FROM insurances  i
INNER JOIN policies p ON p.id = i.policy_id 
WHERE (i.initial_date >= p.date_ini
AND i.final_date   <= p.date_expired) 
;

DECLARE @value AS BIT
IF EXISTS(
   SELECT NULL
   FROM dbo.mytable
   WHERE (@A = C OR @A = D) OR (@B = C OR @B = D)
) 
   SET @value = CAST(1 As bit)
ELSE 
   SET @value = CAST(0 As bit)

RETURN @value

merge into t t 
     using (select p_id from p where p_id = 1) d 
        ON (t.p_id = d.p_id) 
      when matched then update set c = 'iii';

SELECT *
FROM sites s JOIN site_articles sa ON s.site_id = sa.site_id
WHERE ....

file_id     line_id     line_data
---------------------------------
1           1           this
1           2           is
1           3           where
1           4           your
1           5           data
1           6           lives

STUFF ( character_expression , start , length , replaceWith_expression )
SELECT STUFF('Name - Location - 0005', 5, 0, ' (West)');

<?php
$query2 = db_select('wp_votes','wpv');
$query2->join('node','n','wpv.nid = n.nid');
$query2->fields('wpv',array('nid','vote'));
$query2->fields('n',array('title'));
$alias = $query2->addExpression('AVG(vote)', 'average');
$query2->groupBy('wpv.nid');
$query2->sortBy($alias, 'DESC');
$rez = $query2->execute()->fetchAll();

SET @Message =
    CASE  
        WHEN @DataBaseName LIKE 'DBa' /*As Yves points out in the comments
                                        should this be 
        WHEN @DataBaseName LIKE 'DBa%' COLLATE SQL_Latin1_General_CP1_CS_AS  */
        THEN 'Valid name'
    ELSE 'INVALID name'
    END

ALTER Procedure [dbo].[SP_myProcedure]
AS
IF EXISTS (SELECT name FROM master.sys.databases WHERE name = 'tempDB') BEGIN
 EXEC SP_UpdatetempDB - copy data from another data base
END
ELSE BEGIN
  print 'database does not exists'
  EXEC SP_CreatetempDB -- create my database SP
  EXEC SP_CreatetempDBTables - create table SP
  EXEC SP_UpdateTEmpDBData - copy data from another database
END

create or replace view user_authorize as
WITH queryResult_1 as 
(            select u.id as userId, dpt.hierarchy as hierarchy
              from app_user u
              join app_user_department udp
                on u.id = udp.userId
              join core_department dpt
                on udp.departmentId = dpt.id
    ),
queryResult_2 as
(            select u.id as userId, dpt.hierarchy as hierarchy
              from app_user u
              join app_user_excluded_department udp
                on u.id = udp.userId
              join core_department dpt
                on udp.departmentId = dpt.id
    )
    select dp.id, queryResult_1.userId
    from core_department dp
    join queryResult_1 
    on dp.hierarchy like queryResult_1.hierarchy || '%'

    minus

    select dp.id, queryResult_2.userId
    from core_department dp
    join queryResult_2
    on dp.hierarchy like queryResult_2.hierarchy || '%'


select *
from user_authorize ua
where ua.userId = 1

INSERT INTO new_network (user_id,network_id,network_url)
 SELECT u.user_id, u.network_id, 
   CASE WHEN u.network_url LIKE s.network_prefix+'%' 
        THEN u.network_url
        ELSE s.network_prefix + '/' + u.network_url END
 FROM url_table u
 JOIN network_table s
 ON u.network_id=s.network_id;

;WITH Parents as (
    select ID,Type,parent_id from tblProjectItem where ID = @ID
    union all
    select pi.ID,pi.Type,pi.parent_id
    from
        Parents p
            inner join
        tblProjectItem pi
            on
                p.parent_id = pi.ID
)
select @parentId = ID from Parents where Type = 32

where b.RevenueDate >= dateadd(month, datediff(month, 0, a.ExpenseDate), 0) and
      b.RevenueDate < dateadd(month, 1+datediff(month, 0, a.ExpenseDate), 0)

SELECT *
FROM table_1
WHERE (@Color IS NULL OR Color = @Color)
AND (@Finish IS NULL OR Finish = @Finish)
AND (@Height IS NULL OR Height = @Height)
AND (@Type IS NULL OR Type = @Type)
AND (@Trim IS NULL OR Trim = @Trim)
AND (@Width IS NULL OR Width = @Width)

SELECT
    case WHEN REGEXP_Instr(c1, '[[:digit:]]')=0 THEN c1 end result1
    ,c1
FROM
(
    select 'asdf' c1 from dual union all
    select '1234' c1 from dual union all
    select 'as1234df' c1 from dual
) test_data;

systimestamp AT TIME ZONE 'IST'

UPDATE t1
SET t1.SortOrder = t2.SortOrder 
FROM @t t1
INNER JOIN
(SELECT Item1ID, Item2ID, ROW_NUMBER() OVER
    (PARTITION BY Item1ID ORDER BY Item1ID, Item2ID) AS SortOrder
from @t) t2
ON t1.Item1ID = t2.Item1ID 
AND t1.Item2ID = t2.Item2ID

SELECT DISTINCT id
FROM table
WHERE local_id = 1 OR user_id IS NULL

DELETE FROM excelformats
 WHERE rowid not in 
            (SELECT MIN(rowid) 
               FROM excelformats
              GROUP BY key, value, computed); 

select *
from A
where Id not in (
  select A.Id
  from A
  inner join E on A.Date between E.Start_date and E.End_date
)

select general_power
from t_power
where
    date_trunc('week', p_date_time) = date_trunc('week', current_timestamp) 
    and
    p_date_time::time between '05:00:00' and '22:00:00'

select      
    g.gloss as meaning,
    wrd.ss_type as word_Type,
    wrd.word as word,
    wrdopp.word as opposite
FROM wn_synset as wrd 
JOIN  wn_gloss as g
  ON wrd.synset_id = g.synset_id 
JOIN wn_antony as a
  ON a.synset_id_2 = wrd.synset_id
  and wrd.w_num= a.w_num_2 -- Not sure if this is needed
JOIN wn_synset as wrdopp
  ON a.synset_id_1 = wrdopp.synset_id
  and wrdopp.w_num= a.w_num_1 -- Not sure if this is needed
where wrd.word= 'good'  
order by wrd.ss_type

select 
    CONVERT(varchar(10), 
    cast(StartDate as date),101) +' - ' + CONVERT(varchar(10), 
    cast(EndDate as date),101) Duration 
from 
    dbo.Calendar 
order by StartDate desc, EndDate;

update table set
    columnx = (case when condition then 25 else columnx end),
    columny = (case when condition then columny else 25 end)

SELECT Userid, User, Max(UserUpdate) AS MaxDate
FROM myTable
GROUP BY Userid, User

with member [x] as sum( 
    [Date Dim].[CY Hierarchy].[Calendar Year].members(0) : [Date Dim].[CY Hierarchy].currentMember,
    [Measures].[Commitment Count] 
)

select [x] on 0, [Date Dim].[CY Hierarchy].[Calendar Year] on 1 from [Cube]

DECLARE @d1 datetime, @d2 datetime 

SELECT @d1 = '2008-06-09 10:18:00.000', @d2 = '2008-06-10 11:20:00.000'

SELECT
    CAST(DATEDIFF(hour, @d1, @d2) AS varchar(30)) + ' hours, ' +
    CAST(DATEDIFF(minute, @d1, @d2) % 60 AS varchar(30))  + ' minutes, ' +
    CAST(DATEDIFF(second, @d1, @d2) % 3600 % 60 AS varchar(30))  + ' seconds'

WITH cte AS
(
    SELECT person_id, COUNT(DISTINCT student_id) AS r
    FROM #PERSON
    GROUP BY person_id
)
SELECT student_id, CASE WHEN r = 1 THEN 0 ELSE 1 END
FROM #PERSON p
JOIN cte c
  ON p.person_id = c.person_id
-- ORDER BY student_id

SELECT ColumnA,
       ColumnB,
       ColumnC
FROM   ( 
  SELECT ROWNUM rn,
         COUNT(*) OVER ( ORDER BY NULL ) mx,
         q.ColumnA,
         q.ColumnB,
         q.ColumnC
  FROM   (
    SELECT ColumnA,
           ColumnB,
           ColumnC
    FROM   your_table
    ORDER BY ColumnA
  ) q
)
WHERE  MOD( rn, 10 ) = 0
OR     ( mx = rn AND mx < 10 );

select email as "Email Address"
from subscribers
where event_id='123' 
      and email not in(
          select email as "Email Address"
          from subscribers
          where event_id<>'123')
group by email

Select
  Qty,
  Weight
From (
  Select
    Qty,
    Weight,
    Sum(Qty) Over(Order By Weight Desc Rows Between Unbounded Preceding And Current Row) As RunningQty
  From
    Test
  Where
    Product = 'PEN'
  ) a
Where
   RunningQty <= 200

select t.date,b.title,a.name from book b  
innerjoin transaction t on t.bookid = b.id 
innerjoin author a on b.authorid = a.id

select
    Achievement,
    sum(case when RankNum = 1 then 1 else 0 end) as HighRank1,
    sum(case when RankNum = 2 then 1 else 0 end) as HighRank2,
    ...
from (
    select
        PersonId,
        Achievement,
        row_number() over(
            partition by PersonId order by Rank) as RankNum
    from sourcetable
) as t
group by Achievement

  SELECT tag_id, 
         COUNT(article_id) AS article_count 
    FROM article_tags 
GROUP BY tag_id

select co.CompanyID, AllIndustries = 
       (select (cast(industry as varchar(200))+',') as [text()]
       FROM company c, 
       company_industry_map m 
       WHERE c.company_id = m.company_id and c.company_id = co.company_id 
       order by industry_id for XML PATH(''))
from Companies co

SELECT
s.IDsong, s.name,
a1.name AS artists_name,
a2.name AS author_name,
a3.name AS composer_name,
a4.name AS producer_name,
sg.name AS genres_name
FROM songs AS s
  JOIN artists AS a1 ON s.IDartist = a1.IDartist
  JOIN artists AS a2 ON s.IDauthor = a2.IDartist
  JOIN artists AS a3 ON s.IDcomposer = a3.IDartist
  JOIN artists AS a4 ON s.IDmusicProducer = a4.IDartist
  JOIN songs_genres AS sg ON s.IDgenre = sg.IDgenre

SELECT 
  mytable.*
FROM mytable
INNER JOIN lookup ON mytable.col1=lookup.col1 AND mytable.col2=lookup.col2

select name, min(datetime), max(datetime)
from (select t.*,
             sum(case when name <> prevname then 1 else 0 end) over (order by datetime) as cnt
      from (select t.*, lag(name) over (order by datetime) as prevname
            from table t
           ) t
     ) t
group by name, cnt;

select t2.seqnum, t2.b_date, coalesce(t1.c_id, t3.max_id) as c_id
  from table2 t2
  left outer join table1 t1
    on t2.b_date between t1.min_date and t1.max_date
  cross join (select max(c_id) as max_id from table1) t3
  order by t1.c_id, t2.b_date

SELECT SUBSTRING(master.dbo.fn_varbintohexstr(HashBytes('MD5', 'HelloWorld')), 3, 32)

create procedure sprocGetRandomBattle
@n int -- number of loops
as
declare @num int = 1;
declare @result table
    (
     -- input your column list
    )
while @num <=@n
begin   
insert into @result 
select * -- replace '*' with column list
from Nomination where NominationId in 
    (select top 2 NominationId from Nomination where IsActive = 1 and CategoryId in 
        (select CategoryId from Category where CategoryId in 
            (select top 1 CategoryId from Category where Active = 1 and CategoryId in 
                (select CategoryId from Nomination group by CategoryId having count(*) > 1)
            order by newid()) and OwnerId in 
        (select UserId from [User] where IsPrivate = 0))
    order by newid())
set @num = @num+1
end
select * from @result
go

SELECT min(ID) as ID
  ,sum(Value1) as Value1
  ,sum(Value2) as Value2
FROM
  db..table
GROUP BY
  Text1
  ,Text2

-- Move data to temp storage
SELECT ID,
   VAL
  INTO #temp_table
  FROM dbo.test_table

-- Remove data from original table
DELETE
  FROM dbo.test_table

-- Drop and Create ID column
ALTER TABLE dbo.test_table
DROP COLUMN ID

ALTER TABLE dbo.test_table
ADD ID int IDENTITY(1,1)

-- Move data back to original table
SET IDENTITY_INSERT dbo.test_table ON

INSERT INTO dbo.test_table (ID, VAL)
SELECT ID, VAL
FROM #temp_table

DECLARE @MaxID int
SELECT @MaxID = MAX(ID) + 1
FROM dbo.test_table

SET IDENTITY_INSERT dbo.test_table OFF

-- Reseed IDENTITY property
DBCC CHECKIDENT ('dbo.test_table', RESEED, @MaxID)

 INSERT INTO table_name(name,qty,code) VALUES 
 ( 
    SELECT i.name,i.qty,i.code FROM table2 i
    WHERE (i.code = 'abcd' AND i.name = 'def') OR i.code != 'abcd'
 )

SELECT 
    date,
    name,
    salary
    CASE
      WHEN lag(name, 1) OVER (ORDER BY date ASC) = name THEN 'same' 
      ELSE 'start' 
    END AS calc_col
FROM your_table
ORDER BY date ASC

SELECT exmpl, qstn
   FROM Foo\BarBundle\Entity\Examples exmpl
   LEFT JOIN exmpl.question qstn
   LEFT JOIN qstn.users u
   WHERE :user MEMBER OF qstn.users

SELECT p.name
FROM   Product p
       JOIN (SELECT pro_id,
                    Max(value) AS value
             FROM   Product_details
             GROUP  BY pro_id) pd
         ON p.pro_id = pd.pro_id
ORDER  BY pd.value 

SELECT  *
FROM    A
FULL JOIN
        B
ON      a.IP = b.IP
WHERE   a.IP IS NULL OR b.IP IS NULL

SELECT ID, Login, Guid FROM Users WHERE ID IN (
    SELECT RequestSender FROM Contacts WHERE RequestRecipient=(
        SELECT ID FROM Users WHERE Guid=?1
    ) UNION SELECT RequestRecipient FROM Contacts WHERE RequestSender=(
        SELECT ID FROM Users WHERE Guid=?1
    )
)

SELECT GameId, TeamId
FROM yourTable
WHERE GameId IN (SELECT GameId FROM yourTable WHERE TeamId = 40);

UPDATE Table1
    JOIN Table2
        ON Table1.Col1 = Table2.Col2
SET Table1.Col2 = Table1.Col2/Table2.Col2

SELECT a.id,a.Name,a.Total_Members,c.Total_Amount
FROM committee_Group a
INNER JOIN (SELECT Name,sum(Contribution) as 'Sum_Con'
            FROM Group_Member
            GROUP BY Name)b on a.Id=b.Id
INNER JOIN comitees c on c.Total_Amount=b.Sum_Con
                     and b.Name=c.Name

SELECT 
'COM001', 
'John', 
case 
when cast('01-Jan-4501 00:00:00' as date) > cast('01-Jan-2100 00:00:00' as date)
then cast(getdate() as varchar(30))
else '01-Jan-4501 00:00:00'
end 

replace(replace(replace(varchar2, 'x', '1'), 'y', '2'), 'z', '3')

select concat(name, repeat('$', ceil(length(name) * 0.4))

CREATE INDEX betlog_mult_idx ON betlog ("marketId", "runnerId");

package require sqlite3
set stmt [format {UPDATE uploads SET %s=:data WHERE rowid=:id} $col]
fileRepo eval $stmt

select *
from dictionary;

DROP TABLE dbo.calendario 
GO

CREATE TABLE dbo.calendario (
    datacal DATETIME NOT NULL PRIMARY KEY,
    horautil BIT NOT NULL DEFAULT 1
);

-- DELETE FROM dbo.calendario;

DECLARE @dtmin DATETIME, @dtmax DATETIME, @intervals int

SELECT @dtmin = '2014-03-11 00:00:00'
     , @dtmax = '2030-12-31 23:50:00'


SELECT @intervals = DateDiff(minute, @dtmin, @dtmax) / 10

;WITH 
  L0   AS(SELECT 1 AS c UNION ALL SELECT 1),
  L1   AS(SELECT 1 AS c FROM L0 AS A, L0 AS B),
  L2   AS(SELECT 1 AS c FROM L1 AS A, L1 AS B),
  L3   AS(SELECT 1 AS c FROM L2 AS A, L2 AS B),
  L4   AS(SELECT 1 AS c FROM L3 AS A, L3 AS B),
  L5   AS(SELECT 1 AS c FROM L4 AS A, L4 AS B),
  L6   AS(SELECT 1 AS c FROM L5 AS A, L5 AS B),
  Nums AS(SELECT ROW_NUMBER() OVER(ORDER BY c) AS n FROM L6)

INSERT INTO dbo.calendario(datacal)
SELECT DateAdd(minute, 10 * (n - 1), @dtmin)
  FROM Nums
 WHERE n BETWEEN 1 AND @intervals + 1

-- SELECT * FROM dbo.calendario ORDER BY datacal

select pr.PersonId
from PersonRole pr
group by pr.PersonId
having sum(case when pr.RoleId = 2 then 1 else 0 end) > 0 and
       sum(case when pr.RoleId = 3 then 1 else 0 end) > 0;

select myfunction(arg1,arg2,arg3)
  from (
    select arg1, arg2, arg3
      from data_table
      where something='something-other'
  ) as _;

[...]
born int REFERENCES place(place_no),
lives int REFERENCES place(place_no),
[...]

    SELECT * 
      FROM users
     ORDER BY RAND()
     HAVING RAND() * 1000 < 10

...
.process(new XmlToSqlProcessor())
.split().body()
.recipientList(simple("sql:${in.body}?dataSource=dataSource"))

DECLARE @cols NVARCHAR(max)='UPDATE dbo.stage_a set '

SELECT @cols += COLUMN_NAME + '=case when ' + COLUMN_NAME
                + ' = '""' then null else '+COLUMN_NAME+' end,'
FROM   INFORMATION_SCHEMA.COLUMNS
WHERE  TABLE_NAME = 'stage_a'
       AND TABLE_SCHEMA = 'dbo'

SELECT @cols = LEFT(@cols, Len(@cols) - 1)

PRINT @cols

EXEC Sp_executesql @cols 

^(\S+\s+){5}151

group_concat(DISTINCT concat_ws (' ',`a`.`last_name`,`a`.`first_name`,`a`.`middle_name`)) as author,

SELECT * 
FROM `users` 
WHERE user = 'king'
OR alias = 'king'
OR FIND_IN_SET ('king', aliases)>0;

SELECT fruit_attribute,
       SUM(CASE WHEN t1.fruit = 'Orange' THEN t1.submissions ELSE 0 END) AS Orange,
       SUM(CASE WHEN t1.fruit = 'Lemon' THEN t1.submissions ELSE 0 END) AS Lemon
FROM fruits t1
GROUP BY fruit_attribute;

DECLARE @Group VARCHAR(50)
SET @Group = 'Karnataka Customers'

;WITH CTE AS
(
  SELECT *
  FROM [dbo].[LedgerGroups]
  WHERE GroupParent = @Group
  UNION ALL
  SELECT B.*
  FROM CTE A
  INNER JOIN [dbo].[LedgerGroups] B
  ON A.GroupName = B.GroupPArent
)
SELECT *
FROM CTE
OPTION(MAXRECURSION 0);

SELECT DISTINCT
P.Household_key,
P.Person_id,
A.Account_id
FROM
Person P
INNER JOIN Account A ON P.Person_id = A.Person_id
ORDER BY 
P.Household_key,
P.Person_id,
A.Account_id

select it.id, it.qty - lc.qty as difference
from items it
  left join log_count lc on it.id = lc.id 
where it.qty - lc.qty > 0;

SELECT 
* 
, CASE WHEN EXISTS 
    (SELECT * FROM dbo.Member m WHERE m.TeamID = t.TeamID AND m.Age > 35) 
   THEN 1 ELSE 0 END AS IsAbove35 
, CASE WHEN (SELECT SUM(Earned) FROM Job j WHERE j.TeamID = t.TeamID) > 0
   THEN 1 ELSE 0 END AS HasEarnings
, CASE WHEN EXISTS
    (SELECT * FROM Job j WHERE j.TeamID = t.TeamID AND Status = 'Complete')
    AND NOT EXISTS 
    (SELECT * FROM Job j WHERE j.TeamID = t.TeamID AND Status <> 'Complete')
   THEN 1 ELSE 0 END AS AllJobsComplete
FROM dbo.Team t

 WITH FemalesQuery AS
(
    SELECT Id_pk
      FROM Users
     WHERE Gender = 'F'
), MalesQuery AS
(
    SELECT Id_pk
      FROM Users
     WHERE Gender = 'M'
)

SELECT Id2_pk
  FROM Friends
 WHERE Id1_pk IN (SELECT Id_pk FROM FemalesQuery)
   AND Id2_pk IN (SELECT Id_pk FROM MalesQuery)
 UNION
 SELECT Id1_pk
  FROM Friends
 WHERE Id2_pk IN (SELECT Id_pk FROM FemalesQuery)
   AND Id1_pk IN (SELECT Id_pk FROM MalesQuery)

select t1.vItem, t2.VItem from
    ( select *, ROW_NUMBER() over (order by vItem) r from US ) t1
        inner join
    ( select *, ROW_NUMBER() over  (order by vItem desc) -1 r from SE ) t2
        on t2.r = t1.r % (select COUNT(*) from SE)
order by t1.vItem

UPDATE USER SET USER.title = (CASE USER.oldId
                              WHEN 'adab01' THEN 1
                              WHEN 'agok01' THEN 2
                              WHEN 'alla01' THEN 1
                              WHEN 'allm01' THEN 2 
                              ELSE USER.oldID end)
WHERE USER.oldId in
(
    'adab01',
    'agok01',
    'alla01',
    'allm01'
)

WITH CTE AS (
    SELECT 1 N
    UNION ALL
    SELECT N + 1 FROM CTE WHERE N < 5
)
UPDATE MyTable
SET MyNumber = (
    SELECT TOP 1 N FROM CTE
    WHERE NOT EXISTS (SELECT * FROM MyTable WHERE MyNumber = N)
)
WHERE PrimaryKey = 2

select field1, field2, field3, field4
  from table1
 except 
select field1, field2, field3, field4
  from table2

INSERT INTO UserRoles (UserId, RoleId)
SELECT @UserId, Id FROM Roles WHERE Name = @Name;

SELECT g.naam,g.gebruikerID ,g2.naam,g2.gebruikerID
FROM gebruiker g , gebruiker g2, vriend v
WHERE g.gebruikerID = v.gebruikerID_Jezelf 
OR g2.gebruikerID = v.gebruikerID_Persoon
AND g.gebruikerID IN(SELECT gebruikerID_Jezelf FROM vriend) 
OR g2.gebruikerID IN(SELECT gebruikerID_Persoon FROM vriend);

   UPDATE t
    SET handsetId = r.handset_type_id
    FROM #_tmp_fav_table t
    INNER JOIN registration r ON r.favorite_id=t.favorite_id
    INNER JOIN buddies b ON b.reg_id=@regID 
    INNER JOIN @favDT f ON  b.favorite_id=f.favorite_id
    where r.reg_id=f.favorite_id

select distinct p1, tmp.hop, p2, count from (
    select if(p1 < p2, p1, p2) as p1, hop, if(p1 < p2, p2, p1) as p2 from (
        select r1.obj_1 as p1, r1.obj_2 as hop, r2.obj_2 as p2
        from t_relations r1 inner join t_relations r2 on r1.obj_2 = r2.obj_1
            union
        select r1.obj_2 as p1, r1.obj_1 as hop, r2.obj_2 as p2
        from t_relations r1 inner join t_relations r2 on r1.obj_1 = r2.obj_1
            union 
        select r1.obj_1 as p1, r1.obj_2 as hop, r2.obj_1 as p2
        from t_relations r1 inner join t_relations r2 on r1.obj_2 = r2.obj_2
            union
        select r1.obj_2 as p1, r1.obj_1 as hop, r2.obj_1 as p2
        from t_relations r1 inner join t_relations r2 on r1.obj_1 = r2.obj_2
    ) tmp where p1 <> p2
) tmp inner join (
    select hop, count(*) as count from (
        select distinct p1, hop, p2 from (
            select if(p1 < p2, p1, p2) as p1, hop, if(p1 < p2, p2, p1) as p2 from (
                select r1.obj_1 as p1, r1.obj_2 as hop, r2.obj_2 as p2
                from t_relations r1 inner join t_relations r2 on r1.obj_2 = r2.obj_1
                    union
                select r1.obj_2 as p1, r1.obj_1 as hop, r2.obj_2 as p2
                from t_relations r1 inner join t_relations r2 on r1.obj_1 = r2.obj_1
                    union 
                select r1.obj_1 as p1, r1.obj_2 as hop, r2.obj_1 as p2
                from t_relations r1 inner join t_relations r2 on r1.obj_2 = r2.obj_2
                    union
                select r1.obj_2 as p1, r1.obj_1 as hop, r2.obj_1 as p2
                from t_relations r1 inner join t_relations r2 on r1.obj_1 = r2.obj_2
            ) tmp where p1 <> p2
        ) tmp
    ) tmp group by hop
) tmp2 on tmp.hop = tmp2.hop;

UPDATE TT 
    SET CODE = (SELECT TOP 1 CODE
                FROM #TSPV_TEMP T2 with(nolock)
                WHERE T2.KEY < tt.KEY AND
                      CODE IS NOT NULL
                ORDER BY KEY DESC
               )
    FROM #TSPV_TEMP TT with (nolock)
    where tt.CODE IS NULL;

/* Drop all non-system stored procs */
DECLARE @name VARCHAR(128)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'P' AND category = 0 ORDER BY [name])

WHILE @name is not null
BEGIN
    SELECT @SQL = 'DROP PROCEDURE [dbo].[' + RTRIM(@name) +']'
    EXEC (@SQL)
    PRINT 'Dropped Procedure: ' + @name
    SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'P' AND category = 0 AND [name] > @name ORDER BY [name])
END
GO

/* Drop all views */
DECLARE @name VARCHAR(128)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'V' AND category = 0 ORDER BY [name])

WHILE @name IS NOT NULL
BEGIN
    SELECT @SQL = 'DROP VIEW [dbo].[' + RTRIM(@name) +']'
    EXEC (@SQL)
    PRINT 'Dropped View: ' + @name
    SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'V' AND category = 0 AND [name] > @name ORDER BY [name])
END
GO

/* Drop all functions */
DECLARE @name VARCHAR(128)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] IN (N'FN', N'IF', N'TF', N'FS', N'FT') AND category = 0 ORDER BY [name])

WHILE @name IS NOT NULL
BEGIN
    SELECT @SQL = 'DROP FUNCTION [dbo].[' + RTRIM(@name) +']'
    EXEC (@SQL)
    PRINT 'Dropped Function: ' + @name
    SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] IN (N'FN', N'IF', N'TF', N'FS', N'FT') AND category = 0 AND [name] > @name ORDER BY [name])
END
GO

/* Drop all Foreign Key constraints */
DECLARE @name VARCHAR(128)
DECLARE @constraint VARCHAR(254)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'FOREIGN KEY' ORDER BY TABLE_NAME)

WHILE @name is not null
BEGIN
    SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'FOREIGN KEY' AND TABLE_NAME = @name ORDER BY CONSTRAINT_NAME)
    WHILE @constraint IS NOT NULL
    BEGIN
        SELECT @SQL = 'ALTER TABLE [dbo].[' + RTRIM(@name) +'] DROP CONSTRAINT [' + RTRIM(@constraint) +']'
        EXEC (@SQL)
        PRINT 'Dropped FK Constraint: ' + @constraint + ' on ' + @name
        SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'FOREIGN KEY' AND CONSTRAINT_NAME <> @constraint AND TABLE_NAME = @name ORDER BY CONSTRAINT_NAME)
    END
SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'FOREIGN KEY' ORDER BY TABLE_NAME)
END
GO

/* Drop all Primary Key constraints */
DECLARE @name VARCHAR(128)
DECLARE @constraint VARCHAR(254)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'PRIMARY KEY' ORDER BY TABLE_NAME)

WHILE @name IS NOT NULL
BEGIN
    SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'PRIMARY KEY' AND TABLE_NAME = @name ORDER BY CONSTRAINT_NAME)
    WHILE @constraint is not null
    BEGIN
        SELECT @SQL = 'ALTER TABLE [dbo].[' + RTRIM(@name) +'] DROP CONSTRAINT [' + RTRIM(@constraint)+']'
        EXEC (@SQL)
        PRINT 'Dropped PK Constraint: ' + @constraint + ' on ' + @name
        SELECT @constraint = (SELECT TOP 1 CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'PRIMARY KEY' AND CONSTRAINT_NAME <> @constraint AND TABLE_NAME = @name ORDER BY CONSTRAINT_NAME)
    END
SELECT @name = (SELECT TOP 1 TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE constraint_catalog=DB_NAME() AND CONSTRAINT_TYPE = 'PRIMARY KEY' ORDER BY TABLE_NAME)
END
GO

/* Drop all tables */
DECLARE @name VARCHAR(128)
DECLARE @SQL VARCHAR(254)

SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'U' AND category = 0 ORDER BY [name])

WHILE @name IS NOT NULL
BEGIN
    SELECT @SQL = 'DROP TABLE [dbo].[' + RTRIM(@name) +']'
    EXEC (@SQL)
    PRINT 'Dropped Table: ' + @name
    SELECT @name = (SELECT TOP 1 [name] FROM sysobjects WHERE [type] = 'U' AND category = 0 AND [name] > @name ORDER BY [name])
END
GO

SELECT
shelves._id AS _id,
shelves.shelf_name AS shelf_name,
COUNT(products._id) AS total_num_products_in_shelf,
sum(case when products.priority > 0 Then 1 else 0 end) 
as num_products_in_shelf_with_priority
FROM shelves INNER JOIN products
ON shelves._id = products.shelf_id
GROUP BY shelves._id, shelves.shelf_name
HAVING COUNT(products._id) > 0
ORDER BY shelf_name ASC

select order_number, customer_number, creation_date, estimated_ship_date,
  max(estimated_ship_date) over (partition by customer_number order by creation_date
    range between 15/1440 preceding and 15/1440 following) as estimated_ship_date
from cust_orders;

SomeInt64Value := (qryMyQuery.FieldByName('blahblah') as TLargeIntField).AsLargeInt;

select d.*
from deals d
join deals_bookings b on d.id = b.deal_id
where b.date > curdate()
  and b.deal_id not in (
    select deal_id
    from deals_bookings
    where date <= curdate()
)
order by b.date desc

SELECT A.id_offer, t.tags
from 
  (Select * from offer o
    Where o.id_offer IN (600, 629)
    AND o.State=0
    ORDER BY ? DESC
    Limit ?,?) A
INNER JOIN offer_has_tags B
    ON A.id_offer = B.offer_id_offer
INNER JOIN tags t
    ON b.tags_id_tags = t.id_tags

USE [master]
GO
SELECT * FROM [mydatabase].[dbo].[calibration]



USE [mydatabase]
GO
SELECT * FROM [calibration]

CREATE FUNCTION `test`.`decimalToMilli` (bigTime decimal)
RETURNS INTEGER
BEGIN
  return ((bigTime * 1000) MOD 100000  -- seconds and milliseconds
         + (floor(bigTime / 100) MOD 100) * 60000 --minutes
         + (floor(bigTime / 10000)) * 3600000 -- hours
         );
END

SELECT CAST(SUM(Quantity * UnitPrice * (Discount/100)) AS DECIMAL(4,2)) 
FROM Stock_Purchase_Details

"$set": { "state": doc.state.toUpperCase() } }

select nhi ,sum(case when length='dna' then 1 else 0 end) dna_count 
from table 
group by nhi  
having sum(case when length='dna' then 1 else 0 end)>3;

SELECT ID, EMAIL, LOWER(EMAIL), HOW_MANY
FROM (
  SELECT ID, EMAIL, COUNT(*) OVER (PARTITION BY LOWER(EMAIL)) AS HOW_MANY
  FROM USERS
)
WHERE HOW_MANY >= 3
ORDER BY ID;

        ID EMAIL                          LOWER(EMAIL)                     HOW_MANY
---------- ------------------------------ ------------------------------ ----------
         1 bob@example.com                bob@example.com                         3 
         2 Bob@example.com                bob@example.com                         3 
         3 BOB@example.com                bob@example.com                         3 
         4 john.smith@example.com         john.smith@example.com                  3 
         5 John.smith@example.com         john.smith@example.com                  3 
         6 JOHN.smith@example.com         john.smith@example.com                  3 
         7 blah@example.com               blah@example.com                        4 
         8 BLAH@example.com               blah@example.com                        4 
         9 blAH@example.com               blah@example.com                        4 
        10 BLah@example.com               blah@example.com                        4 
        11 james.smith@example.com        james.smith@example.com                 3 
        12 James.smith@example.com        james.smith@example.com                 3 
        13 JAMES.smith@example.com        james.smith@example.com                 3 

WITH T1 AS
(
SELECT *,
       LAG(RowNumber) OVER (ORDER BY ID) AS PrevRowNumber
FROM YourTable
), T2 AS
(
SELECT *,
       IIF(PrevRowNumber IS NULL OR PrevRowNumber > RowNumber, 1, 0) AS NewGroup
FROM T1
)
SELECT ID,
        RowNumber,
        Data,
        SUM(NewGroup) OVER (ORDER BY ID 
                            ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS  Grp
FROM T2

UPDATE r
    SET r.[FirstSeen] = GetDate()
FROM [dbo].[Results] r
INNER JOIN [dbo].[WebPages] p ON p.[Id] = r.[WebPages_Id]
WHERE p.[WebSites_Id]=@SiteId

declare @NoOfDaysForDelayApproval decimal(9,2)

ALTER TABLE my_table
    ADD CONSTRAINT MY_TABLE_PASSWORD_CK CHECK (LENGTHB(password) >= 4)

SELECT R1.SomeColumn, R2.SomeColumn
FROM Master_table M 
         INNER JOIN Refrenced_Table R1  --<-- Alias R1
ON M.Column1 = R1.Pk                   -- JOIN Condition with Alias R1
       INNER JOIN Refrenced_Table R2      --<-- Alias R2
ON M.Column2 = R2.Pk                  -- JOin condition with Alias R2

SELECT users.NAME
    ,users.phone
    ,user_groups.activity
FROM users
INNER JOIN group_membership ON group_membership.userID = users.userID
INNER JOIN user_groups ON user_groups.groupID = group_membership.groupID
WHERE user_groups.activity = 'Knitting'

UNION

SELECT users.NAME
    ,users.phone
    ,independent_activity.activity
FROM users
INNER JOIN independent_activity ON independent_activity.userID = users.userID
WHERE independent_activity.activity = 'Knitting';

WITH 
mockup_data as (
SELECT   
'a' customer_Number,           1 acct,         100 start_balance,        to_date('01-01-15','MM-DD-YY') open_date,       'b-1' prev_account from dual union all      
SELECT 'b'            ,1,          80,         to_date('03-04-14','MM-DD-YY'), null       from dual union all 
SELECT 'c'            ,2,         200,         to_date('04-11-14','MM-DD-YY'),       'c-1' from dual union all 
SELECT 'c'            ,1,         150,         to_date('06-12-15','MM-DD-YY'),        null from dual union all 
SELECT 'd'            ,1,         600,         to_date('08-16-15','MM-DD-YY'),        null from dual union all 
SELECT 'e'            ,3,         400,         to_date('12-19-15','MM-DD-YY'),       'e-2' from dual union all 
SELECT 'e'            ,2,         150,         to_date('10-21-14','MM-DD-YY'),     'e-1' from dual union all 
SELECT 'e'            ,1,         100,         to_date('01-18-13','MM-DD-YY'),     null  from dual ),
data_with_roots AS
       (SELECT d.*,
               CASE
                 WHEN (SELECT COUNT (*)
                       FROM   mockup_data d2
                       WHERE  d2.prev_account = d.customer_number || '-' || d.acct) = 0 THEN
                   'Y'
                 ELSE
                   'N'
               END
                 is_root
        FROM   mockup_data d),
     hierarchy AS
       (SELECT CONNECT_BY_ROOT (customer_number) customer_number,
               CONNECT_BY_ROOT (acct) acct,
               CONNECT_BY_ROOT (start_balance) start_balance,
               CONNECT_BY_ROOT (open_date) open_date,
               start_balance prev_start_balance,
               open_date prev_open_date,
               LEVEL - 1 lvl
        FROM   data_with_roots d
        CONNECT BY customer_number || '-' || acct = PRIOR prev_account
        START WITH is_root = 'Y'),
     previous_only AS
       (SELECT *
        FROM   hierarchy
        WHERE  lvl >= 1)
SELECT *
FROM   previous_only PIVOT (MAX (prev_start_balance) AS prev_start, MAX (prev_open_date) AS prev_open
                     FOR lvl
                     IN (1 AS "01", 2 AS "02", 3 AS "03", 4 AS "04", 5 AS "05" -- etc... as many levels as you need to support
                                                                              ));

SELECT LEN(REPLACE(myColumn, 'N', '')) FROM ...

update u
set active = 0
From UserInfo u
where (SELECT count(*)
FROM UserRecords recs
where recs.UserId= u.UserId) = 0
and     u.active = 1
and     exists (Select 1
                From UserInfo u2
                Where u2.lastname = u.lastname
                and     u2.firstname = u.firstname
                and     u2.userid <> u.userid
                and     u2.active = 1)

select distinct(survey_id) as identifier, 
       (select max(survey_id) from survey) as "current" 
  from survey_main;

SELECT `variabletype `,
       COUNT(`variabletype `) AS `value_occurrence` 
FROM   `my_table`
GROUP BY `value`
ORDER BY `value_occurrence` DESC
LIMIT    1;

CREATE VIEW SomeFancyName
AS
    SELECT s.profile_pic AS sender_pic
           ,r.profile_pic AS receiver_pic
        FROM Chats c
        JOIN users s
            ON c.sender_id = s.user_id
        JOIN users r
            ON c.receiver_id = s.user_id

select CONTACTNAME, SUBSTRING (EMAIL,CHARINDEX('@',EMAIL,0)+1,LEN(EMAIL)) as Email
from CONTACTS result

DECLARE @cols NVARCHAR (MAX)
DECLARE @query NVARCHAR (MAX)
SELECT @cols = COALESCE (@cols + ',[' + CONVERT(VARCHAR(7), join_date, 120) + ']', 
          '[' + CONVERT(VARCHAR(7), join_date, 120) + ']')
           FROM    (SELECT DISTINCT CONVERT(VARCHAR(7), join_date, 120) as join_date FROM Mdata) PV  
           ORDER BY join_date

SELECT @query = 'SELECT *
FROM
(
   SELECT Mtype, CONVERT(VARCHAR(7), join_date, 120) as join_date FROM Mdata
) AS t
PIVOT 
(
  COUNT(join_date) 
  FOR join_date IN( ' + @cols + ' )' +
') AS p ;'

EXEC SP_EXECUTESQL @query

(AVG(q1) + AVG(q2) ... + AVG(qn))/(n*1.0)

Select * From 
Customers c JOIN 
    (SELECT Address1, PostCode FROM Customer GROUP BY Address1, PostCode HAVING Count(1) > 1) c2 
        ON c.Address1 = c2.Address1 AND c.PostCode = c2.PostCode

declare @theName char(25)
select @theName = 'dave'

SELECT p.id, p.name 
FROM parent p
LEFT OUTER JOIN child c   -- OUTER in case there's no children
    ON p.id = c.parentid
INNER JOIN grandchild g   -- INNER because you say there's always children
    ON c.id = g.parentid
WHERE p.name = @theName
    OR c.name = @theName
    OR g.name = @thename
GROUP BY p.id, p.name     -- GROUP BY to combine multiple hits

 select  Distinct  DT.Station  , DT.Slot , DT.SubSlot, DT.CompID , CL.CompName
            from  DeTrace DT    
            Left outer join CList as CL  
                  on  DT.CompID = CL.CompID 
                  where CL.CompName = '9234220'
                    and DT.DeviceID = '1151579773'
                  order by CompName 

select idMain,IdSub,quantity,
  coalesce((SELECT SUM(quantity) 
            from A a2 
            where a2.idSub=a.idSub) - quantity,0) as new column
from A
where idMain=49;

SELECT *
FROM a, b

SELECT *
FROM a CROSS JOIN b

SELECT COUNT(INCIDENT_ID),
DATE_FORMAT(CREATE_DATE,'%m-%Y') AS formatted_date
from incident_view
where (create_year = YEAR(CURDATE()) or create_year = YEAR(CURDATE())-1) 
AND DATE_FORMAT(CREATE_DATE ,'%Y%m') <> DATE_FORMAT(now() ,'%Y%m')
AND CUSTOMER_COMPANY_NAME = "Company"

GROUP BY formatted_date

ORDER BY 
YEAR(CREATE_DATE), MONTH(CREATE_DATE)

select 
 t1.name,
 case when t1.groupid is null then '' else 
 (select q.text from
   (select rownum as counter,name,text from TableName where groupid=1)q 
 where 
  q.counter = (select max(rownum) from TableName t2 where groupid=1 and
  t2.name<=t1.name))end as Text,
 t1.groupid 
from 
 TableName t1 
where 
 (t1.groupid<>1 or t1.groupid is null);

SELECT name, dateIn
FROM   dates
WHERE  NOT EXISTS(
         SELECT *
         FROM   cards
         WHERE  cards.personID = dates.personID
            AND cards.cardDate = dates.dateIn
            AND cards.cardColor = 'red'
       )

update Products
set attribute_id = (
    select min(attribute_id)
    from Attributes a
    where a.attribute_name=(select attribute_name from Attributes a2 where a2.attribute_id=Products.attribute_id)
);


DELETE
FROM Attributes
WHERE attribute_id NOT IN
(
    SELECT MIN(attribute_id)
    FROM Attributes
    GROUP BY attribute_name
);

UPDATE "Table A" AS A1
SET Col2 = 
(
    SELECT 'Same as ' + MIN(A2.Col1) 
    FROM "Table A" AS A2 
    WHERE A2.Col2 = A1.Col2 
    AND A2.Col1 < A1.Col1
)
WHERE EXISTS
(
    SELECT 1
    FROM "Table A" AS A2 
    WHERE A2.Col2 = A1.Col2 
    AND A2.Col1 < A1.Col1
)

SELECT 
      gocm.CustomerID
    , o.TotalOfOrders 
FROM (
    SELECT DISTINCT gocm.CustomerID, invitePath
    FROM dbo.GroupOrder_Customer_Mapping gocm
    WHERE gocm.grouporderid = 8254
) gocm 
LEFT JOIN (
    SELECT 
          o.CreatedForCustomerID
        , TotalOfOrders = SUM(DISTINCT o.OrderTotal) 
    FROM dbo.[Order] o
    WHERE o.grouporderid = 8254
    GROUP BY o.CreatedForCustomerID
) o ON o.CreatedForCustomerID = gocm.customerid 
ORDER BY invitepath 

SELECT v1.vendor_id, v2.vendor_id v2id FROM Vendor v1, Vendor v2 WHERE v1.vendor_id <> v2.vendor_id;

+-----------+-----------+
| vendor_id | v2id      |
+-----------+-----------+
|         2 |         1 |
|         3 |         1 |
|         1 |         2 |
|         3 |         2 |
|         1 |         3 |
|         2 |         3 |
+-----------+-----------+

SELECT owner_id, count(partner_id),
       sum(case when level = 'gold' then 1 else 0 end) as gold,
       sum(case when level = 'silver' then 1 else 0 end) as silver,
       sum(case when level = 'bronze' then 1 else 0 end) as bronze
FROM owner_partner
GROUP BY owner_id;

select Person_Ref from Images where Effect_Ref = 2 and Person_Ref IN 
( your first query which gives 2 4 5 6)

select col1, NULL as col2, col3 from Table1
union all
select col1, col2, Null as col3 from Table2

create table ContainerComponents (
  ContainerID int FK references Container(ID),
  ComponentID int FK references Component(ID),
  Name string,
  -- optional - to give the relationship a meaning
  Type int FK references RelationshipType(ID)
)

update table
set [year] = year([Date])

select ar.*
from (select ar.*,
             LAG(DEST_TIME, 1) OVER (order by FEP_ID) HIT 
      from dsyy.archiv ar 
     ) ar
where ARR_TIME < HIT;

<?php
$sql = "SELECT foo FROM bar WHERE 1";
$params = array();

foreach ($_POST['filters'] as $filter_key => $filter_value) {
$sql .= " AND $filter_key = ? ";
$params[] = $filter_value;
}

$query = $dbh->prepare($sql);
if ($query->execute($params)) {
$results = $query->fetchAll(PDO::FETCH_OBJ);
var_dump($results);
}
else {
echo $query->errorInfo();
}

check_constraint_definition
    : CHECK '(' boolean_value_expression ')'
    ;
boolean_value_expression
    : (~')')+
    | '(' boolean_value_expression ')'
    ;

CAST(int AS DECIMAL(5,3))

SELECT c.userid, u.name, 
       MAX(CASE WHEN fieldid = 1 THEN value END) AS piva,
       MAX(CASE WHEN fieldid = 3 THEN value END) AS code
FROM customfields AS c
INNER JOIN users AS u ON c.userid = u.userid
GROUP BY c.userid, u.name

;with cte as (
   select location, type, [date], 
          row_number() over (partition by location order by [date] desc) rn
   from yourTable
)
select location, type, [date]
from cte
where rn = 1 --<<-- rn = 1 gets the max date for each location.

If @Var = 'DefaultValue' then
BEGIN
     SELECT * FROM table 
END
ELSE
BEGIN
     SELECT * FROM table
     WHERE Exists(select * from atable)
END

SELECT dateadd(minute, datediff(minute, 0, rundate), 0) , 
       count( distinct dateadd(minute, datediff(minute, 0, JobDateStamp), 0))
FROM tbl_tasks
GROUP by dateadd(minute, datediff(minute, 0, rundate), 0) 

select
  matches.name,
  matches.limit

from (
    select
      c.name,
      c.customerId,
      l.limit,
      l.limitId,
      count(*) over(partition by cc.customerId, lc.limitId) as matchCount
    from tblCustomer c
    join tblCustomerCategory cc on c.customerId = cc.customerId
    join tblLimitCategory lc on cc.categoryId = lc.categoryId
    join tblLimit l on lc.limitId = l.limitId
) as matches

join (
    select
       cc.customerId,
       count(*) as categoryCount
     from tblCustomerCategory cc
     group by cc.customerId
) as customerCategories
on matches.customerId = customerCategories.customerId

join (
    select
      lc.limitId,
      count(*) as categoryCount
    from tblLimitCategory lc
    group by lc.limitId
) as limitCategories
on matches.limitId = limitCategories.limitId

where matches.matchCount = customerCategories.categoryCount
and matches.matchCount = limitCategories.categoryCount

$obj = PDO::prepare("SELECT x,y,z FROM table1 WHERE x=:param1 AND y=:param2");
for ($x=0; $x<100; $x++) {
    $obj->execute(array('param1'=>$param1, 'param2'=>$param2));
}

WITH Outpatients AS (
    SELECT DISTINCT MainEmail
    FROM SurveyPicList
    WHERE MainHospital = @MainHospital
          AND chkOutpatient = 'on'
)
,OutpatientsRawCsv AS (
    SELECT (
       SELECT ',' + MainEmail
       FROM Outpatients
       FOR XML PATH('')
    ) AS Csv
)
,PartBs AS (
    SELECT DISTINCT MainEmail
    FROM SurveyPicList
    WHERE MainHospital = @MainHospital
          AND chkPartB = 'on'
)
,PartBRawCsv AS (
    SELECT (
       SELECT ',' + MainEmail
       FROM PartBs
       FOR XML PATH('')
    ) AS Csv
)
SELECT STUFF(OutpatientsRawCsv.Csv, 1, 1, '') AS OutpatientsCsv
      ,STUFF(PartBRawCsv.Csv, 1, 1, '') AS PartBCsv
FROM OutpatientsRawCsv
     CROSS JOIN PartBRawCsv

SELECT count(*) FROM segment
WHERE name NOT IN
(
    SELECT segment_name FROM segment_segment_assoc
    UNION
    SELECT child_name FROM segment_segment_assoc
)

alter table Orders add orderDate Datetime DEFAULT (GETDATE())


CREATE TABLE Orders
(

orderDate Datetime DEFAULT GETDATE()
)

[NSPredicate predicateWithFormat:@"(first_user_id = %@ OR second_user_id) AND status = %@",@(u_id),@(u_id),@"CONF"];

SELECT 
  p.project_id,
  m.members,
  i.issues
FROM projects AS p
LEFT JOIN 
  (
      SELECT project_id, COUNT(user_id) AS members 
      FROM project_members 
      GROUP BY project_id
  ) AS m
ON p.project_id = m.project_id
LEFT JOIN 
  (
      SELECT project_id, COUNT(issue_id) AS issues 
      FROM project_issues
      GROUP BY project_id
  ) AS i
ON p.project_id = i.project_id
WHERE members > 10 AND issues > 10
ORDER BY members, issues;

create proc spInsertRole
(
    @roleName varchar(50)
    --really shouldn't be 50, but that's
    --how I originally wrote my code
)
as
begin
    set nocount on
    begin try
        begin tran
        -- length check moved here.  Raise error when > 15.
        -- Severity (argument 2) needs to be higher than 10
        -- to stop execution and trigger the catch block.
        -- State (argument 3) is an arbitrary value between 0 and 255.
        if len(@roleName) > 15 
            raiserror('Role name is too long.', 11, 5)
        insert into dbo.webpages_Roles(RoleName)
        values (@roleName)
        commit transaction
    end try
    begin catch
        select ERROR_MESSAGE() as ErrorMessage
        -- length check was here. program will always roll back now.
        rollback transaction
    end catch
end

;WITH cte (A, highest_c)
AS
(
   SELECT
      A,
      highest = MAX(C)
   FROM ALinQ1
   GROUP BY A
)
UPDATE tab
SET C = c.highest_c
FROM ALinQ1 tab
INNER JOIN cte c
  ON tab.a = c.a
WHERE tab.C IS NULL
    AND tab.B <> 0;

SELECT TOP 1 * FROM mytable ORDER BY newid()

SELECT
    cn.country_name,
    COUNT(DISTINCT c.c_id) AS count_of_cities
FROM
    COUNTRY cn LEFT JOIN
    CITY c ON c.id = cn.id
GROUP BY cn.country_name

SELECT SUM(case when switch=0 AND detail=1 then 1 else 0 end) as zeroone
    , SUM(case when switch=0 AND detail=2 then 1 else 0 end) as zerotwo
    , SUM(case when switch=1 AND detail=1 then 1 else 0 end) as oneone
    , SUM(case when switch=1 AND detail=2 then 1 else 0 end) as onetw
FROM tablename

SELECT  
 DISTINCT tabData.idData
 FROM    tabData 
 WHERE   EXISTS (SELECT *
                  FROM tabDataDetail
                 WHERE tabData.idData = tabDataDetail.fiData
                   AND tabDataDetail.fiSparePart = 8837)
   AND   EXISTS (SELECT *
                  FROM tabDataDetail
                 WHERE tabData.idData = tabDataDetail.fiData
                   AND tabDataDetail.fiSparePart = 8969)
 ORDER BY tabData.idData

UPDATE TheTable
SET Ville = REPLACE(Ville, 'Saint ', 'St ')
WHERE Ville LIKE 'Saint %'

CREATE TABLE recipe (
    recipe_id NUMERIC PRIMARY KEY
    recipe_name VARCHAR (100)
    -- etc...
);

CREATE TABLE ingredient (
    ingredient_id NUMERIC PRIMARY KEY
    ingredient_name VARCHAR (10),
    -- etc...
);

CREATE TABLE recipe_ingredient (
    recipe_id NUMERIC REFERENCES recipe (recipe_id),
    ingredient_id NUMERIC REFERENCES ingredient (ingredient_id),
    PRIMARY KEY (recipe_id, ingredient_id)
);

SELECT ptnt_vst_csno 
FROM   table_name 
ORDER  BY Substring(ptnt_vst_csno, 1, Charindex('P', ptnt_vst_csno)), 
          CONVERT(INT, Substring(Substring(ptnt_vst_csno, 
                                 Charindex('P', ptnt_vst_csno), 
                                 Len( 
                                              ptnt_vst_csno)), 2, Len( 
                       ptnt_vst_csno))) 

set @a = round(24900*0.3333333333, 4, 1)

SELECT * FROM Table
WHERE
    Place != 'I'
    AND (
        (Country = 'CN' AND Code != 'R')
        OR
        (Country = 'JP' AND Reason != 'Z')
    )

 SELECT * 
FROM Books
WHERE (
   ((Author LIKE '%' + @p_author + '%' OR @p_author = '') OR 
   (Country LIKE '%' + @p_country + '%' OR @p_country = ''))
   AND (@p_author <> '' OR @p_country <> '')
) AND 
(Domain LIKE '%' + @p_domain + '%' OR '%' @p_domain = '')

select * from customers where fname like 'Bob%' or lname like 'Bob%';

SELECT r.date AS raceDate, 
  count(s.userId) AS numSignups,
  case when u.id is null then 0 else 1 end as Enrolled
FROM signup AS s
  INNER JOIN race AS r ON r.id = s.raceId
  LEFT JOIN user u on s.userid = u.id and u.name = 'Barack Obama'
GROUP BY s.raceId

WITH static_list AS (
  SELECT 'A' AS v FROM dual UNION ALL
  SELECT 'B' AS v FROM dual UNION ALL
  SELECT 'C' AS v FROM dual
)
SELECT v FROM static_list 
 MINUS (SELECT column 
          FROM table);

select t.aId, t.bId, t.cId, tsum.cnt
from t join
     (select aId, bId, cId, count(*) as cnt
      from t
      where createTime <= CURREENT_TIMESTAMP
      group by aId, bId, cId
     ) tsum
     on t.aId = tsum.aId and t.bId = tsum.bId and t.cid = tsum.cId;

DECLARE @MAXNUM2 numeric(20)

-- First make an auto increment table starting at 1
DEFINE @tmp 
( 
   aNum int identity(1,1),
   pInsNum varchar(10)
)

INSERT INTO @tmp (pInsNum)
  SELECT num1 FROM INSERTED;

-- Now find offset
SELECT @MAXNUM2 = MAX(num2) FROM TEST

IF @MAXNUM2 is null
BEGIN
 SET @MAXNUM2  = 0
END

-- Do update
UPDATE TEST
SET num2 = @MAXNUM2 + aNum
FROM TEST 
   INNER JOIN @tmp  ON @tmp.pInsNum = TEST.num1

select (n/c)*100 pct
from ( select count(*) c from przedmioty ) 
, ( select count(*) n from przedmioty 
    where id_prz NOT IN (select id_prz from transakcje));

CREATE UNIQUE NONCLUSTERED INDEX ix ON T1(Name) WHERE (Flag = 1)

SELECT A.*, B.MaxOfSubDate, B.MaxOfOurRev, B.MaxOfClientRev
FROM A
LEFT OUTER JOIN B On A.[0/DocID] = B.DocID

select min(date), max(date), count(*) as ReportsAccessed
from (select t.*, max(date) over () as maxd
      from table t
     ) t
group by (datediff(day, date, maxd) / 3)
order by min(date);

SELECT MIN(acct) as acct, na1, na2, na3, na4, MIN(na5) as na5, MIN(na6) as na6, MIN(na7) as na7, MIN(na8) as na8, MIN(zip) as zip, MIN(DOMICILE) as DOMICILE, sum(shares) as total_shares
FROM table_name
GROUP BY na1, na2, na3, na4
ORDER BY na1

-- If field is varchar
WHERE CAST(Code AS INT) % 3 = 0

-- If field is TEXT
WHERE CAST(CAST(Code AS VARCHAR(10)) AS INT) % 3 = 0

@comp_name nvarchar (50),
@City nvarchar (50),
@State nvarchar (10),
@Address ntext,
@Zip_Code nvarchar (50),
@Country nvarchar (50),
@cust_name nvarchar (50),
@CompanyID int
AS
INSERT INTO Company_Listing
(comp_name, City, State, Address, Zip_Code, Country)
VALUES (@comp_name, @City, @State, @Address, @Zip_Code, @Country)

INSERT INTO Customer_Listing
(cust_name, City, State, Address, Zip_Code, Country, CompanyId)
VALUES (@comp_name,@City,@State,@Address,@Zip_Code,@Country,SCOPE_IDENTITY())

CREATE PROCEDURE updateMessages(IN dateFrom DATETIME)   
BEGIN      
  UPDATE EsbMessage SET body = '' where dateTime <= dateFrom -(86400*7); //86400 = 1 day
  #if message is over one year old:
  DELETE FROM EsbMessage where dateTime <= dateFrom -(86400*365);
END

DROP PROCEDURE IF EXISTS myupdate;
DELIMITER //
CREATE PROCEDURE myupdate ()
BEGIN 
DECLARE found VARCHAR(64);
SET found = (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = Database() AND TABLE_NAME = 'A');
IF found = 'types' THEN
   INSERT INTO B SELECT * FROM A;
   SELECT 'A into B';
ELSE 
   SELECT 'A not found';
END IF;
END;//
DELIMITER ;
CALL myupdate();
DROP PROCEDURE myupdate;

-------------Sample Table

create table [log] (Id int,[status] varchar(10))
create table Email ([Status] varchar(10),id int)

go

------------ Trigger Creation

  create trigger tri_log on log
for insert 
as

insert into email(id,[status])
select a.[id],a.[status] 
from inserted a where a.[status] = 'false'

go

------------------Sample Check

select * from [log]
select * from [email]

-----------insert records for test

insert into [log] values (1,'True')
insert into [log] values (2,'False')

----------verify result
select * from [log]
select * from [email]

UPDATE mytable
   SET mycolumn = mycolumn * 0.6;

DELETE FROM PRJHIST a
 WHERE EXISTS (SELECT 'X' 
                 FROM PRJ b
                WHERE a.PRJ_NAME = b.PRJ_NAME
                  AND a.PRJ_VERSION = b.PRJ_VERSION);

SELECT table_owner, table_name, db_link
  FROM dba_synonyms 
 WHERE owner        = 'PUBLIC'
   AND synonym_name = <<synonym name>>

SELECT DISTINCT   
  date, user_id, SUM(count) OVER (PARTITION BY user_id ORDER BY date) AS count 
  FROM actions
WHERE
  action IN ('Call', 'Email');

declare @temptbl table (rowid int primary key identity, tag nvarchar(1), loc int, time1 datetime)

declare @tag as nvarchar(1), @loc as int, @time1 as datetime

declare tempcur cursor for 
select tag, loc, time1
from YourTable
-- order here by time or whatever columns you want to

open tempcur

fetch next from tempcur
into @tag, @loc, @time1

while (@@fetch_status = 0)
begin
    if not exists (select top 1 * from @temptbl where tag = @tag and loc = @loc and rowid = (select max(rowid) from @temptbl))
    begin
        print 'insert'
        print @tag
        print @loc
        print @time1
        insert into @temptbl (tag, loc, time1) values (@tag, @loc, @time1)
    end
    else
    begin
        print 'update'
        print @tag
        print @loc
        print @time1
        update @temptbl
        set tag = @tag,
            loc = @loc,
            time1 = @time1
         where tag = @tag and loc = @loc and rowid = (select max(rowid) from @temptbl)
    end


    fetch next from tempcur
    into @tag, @loc, @time1
end

deallocate tempcur

select * from @temptbl

COALESCE(
IF (
positive.reason IS NOT NULL,
positive.reason,
deduction.reason
),'CUSTOM')
 AS reason,

SELECT title
 FROM movie m
 WHERE m.mid NOT IN (SELECT mid
                       FROM rating)

;WITH cte AS
(
   SELECT (t1.Amount / t1.Tax * t1.Extra) AS [CalculatedValue],
          t1.Option1,
          t1.Option2,
          t1.Option3
   FROM t1
)
SELECT cte.[CalculatedValue] + Option1 AS [Value1],
       cte.[CalculatedValue] + Option2 AS [Value2],
       cte.[CalculatedValue] + Option3 AS [Value3],

DBCC CHECKIDENT ( table_name, RESEED, new_reseed_value )

ALTER PROCEDURE dbo.AddPassword
  @ID int,
  @Password varchar(50)
WITH ENCRYPTION
AS
BEGIN
  SET NOCOUNT ON;

  OPEN SYMMETRIC KEY Password_Key
   DECRYPTION BY CERTIFICATE PasswordCertificate;

  -- for debugging 101:    
  SELECT EncryptByKey(Key_GUID('Password_Key')
    , @Password, 1, HashBytes('SHA1', CONVERT(varbinary(128),@ID)));

  INSERT INTO dbo.EncryptionTest(ID,Password,Password_Encrypted)
  VALUES (@ID,@Password,EncryptByKey(Key_GUID('Password_Key')
    , @Password, 1, HashBytes('SHA1', CONVERT(varbinary(128),@ID))));
END
GO

VAR cur1 REFCURSOR

DECLARE
        MY_TBL1 NUMBER := 1;
        MY_TBL2 NUMBER := 1;

BEGIN
        IF(MY_TBL1 > 0) THEN
        BEGIN
                OPEN :cur1
                FOR
                SELECT  *
                FROM    MY_TBL1
                ORDER BY
                        MY_TBL1_ID DESC;
        END;
        ELSIF (MY_TBL2 > 0) THEN
        BEGIN
                OPEN :cur1
                FOR
                SELECT  *
                FROM    MY_TBL2
                ORDER   BY
                        MY_TBL2_ID DESC;
        END;
        END IF;
END;
/

PRINT cur

INSERT INTO tblSoftware (SoftwareName, SoftwareType)
SELECT
       SoftwareName
     , CASE WHEN Type = 'PC' 
          THEN 1 
          ELSE '2'
       END AS Type
FROM tbl2
WHERE domainRole > 1

mysql -u root -p db_name < file.sql

create table tmp as
--your query

select patterns, count(*) n_mentions
from tmp
group by patterns
order by count(*) desc
limit 10;

SELECT 
[User],
[Add] = SUM(CASE [Operation] WHEN 'Add' THEN 1 ELSE 0 END),
[Modify] = SUM(CASE [Operation] WHEN 'Modify' THEN 1 ELSE 0 END),
[Update] = SUM(CASE [Operation] WHEN 'Update' THEN 1 ELSE 0 END),
[Delete] = SUM(CASE [Operation] WHEN 'Delete' THEN 1 ELSE 0 END) 
FROM [tablename]
GROUP BY [User]
ORDER BY [User] ASC

SET @cols = STUFF((SELECT distinct ',' + QUOTENAME(QT.QUESTION_DESC)
                 FROM #QUES_TEMP QT
                 GROUP BY QT.QUESTION_DESC
                 FOR XML PATH(''), TYPE
                 ).value('.', 'NVARCHAR(MAX)')
                 ,1,1,'')

set @query = 'SELECT EVAL_ID, AuditType, ' + @cols + ' from
        (
            select     QT.EVAL_ID,
                       QT.AuditType,
                       QT.SCORE,
                       QT.QUESTION_DESC
            into ##tmp
            from #QUES_TEMP QT
         ) x

        pivot
        (
             max(SCORE)
             for QUESTION_DESC in (' + @cols + ')
        ) p '

execute(@query);

SELECT * FROM ##tmp

SELECT * 
FROM db.user u 
(LEFT) JOIN db.product p
ON u.user_id = p.user_id

DECLARE @my_int INT 
SET @my_int = 0

SELECT N.id_name
    ,IFNULL(N.name, N.nickname) AS [username]
    ,CASE
      WHEN N.name IS NOT NULL THEN 'name'
      ELSE 'nickname'
    END AS [username_source]
FROM NAMES N
INNER JOIN companies_to_names C ON C.id_name = N.id_name
                                 AND C.id = 1

SELECT COUNT(docs.doc_id) document_count, docs.org_id, docs.org_name
FROM (
  SELECT documents.id doc_id, organizations.id org_id, organizations.company_name org_name
  FROM documents
  INNER JOIN jobs ON documents.job_id = jobs.id
  INNER JOIN organizations ON jobs.client_id = organizations.id
  UNION
  SELECT documents.id doc_id, organizations.id org_id, organizations.company_name org_name
  FROM documents
  INNER JOIN jobs ON documents.job_id = jobs.id
  INNER JOIN organizations ON jobs.server_id = organizations.id
  UNION
  SELECT documents.id doc_id, organizations.id org_id, organizations.company_name org_name
  FROM documents
  INNER JOIN jobs on documents.job_id = jobs.id
  INNER JOIN users ON jobs.creator_id = users.id
  INNER JOIN organizations ON users.organization_id = organizations.id
) docs
GROUP BY org_id, org_name
ORDER BY document_count DESC

SELECT...
, SUM("Particles") OVER(ORDER BY TimeStamp_Field) as SUM_Particles
...

SELECT v
FROM (
 (SELECT v, TIMEDIFF(T, `timestamp`) AS tdiff
   FROM table_name
   WHERE `timestamp` <= T AND v IS NOT NULL
   ORDER BY `timestamp` DESC
   LIMIT 1)
UNION ALL
 (SELECT v, TIMEDIFF(`timestamp`, T) AS tdiff
   FROM table_name
   WHERE `timestamp` > T AND v IS NOT NULL
   ORDER BY `timestamp` ASC
   LIMIT 1)
) u
ORDER BY tdiff
LIMIT 1

SELECT pol_nm, SUM(days)
FROM
 (
   SELECT pol_nm, next_date-MIN(ST_DATE) AS days
   FROM
    (
      SELECT pol_nm, ST_CD, ST_DATE,
        MIN(CASE WHEN ST_CD NOT IN (5,6) THEN ST_DATE END) 
        OVER (PARTITION BY pol_nm 
              ORDER BY ST_DATE
              ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS next_date
      FROM tab
      QUALIFY ST_DATE <> next_date 
    ) AS dt
   GROUP BY pol_nm, next_date
 ) AS dt
GROUP BY pol_nm

CREATE OR REPLACE PROCEDURE DELETE_DUPLICATE AS

BEGIN

  FOR I IN (SELECT TAB.A, TAB.B, MIN(ROWID) RID
              FROM DUPLICATE_TABLE TAB
             GROUP BY TAB.A, TAB.B
            HAVING COUNT(*) > 1) LOOP

    DELETE FROM DUPLICATE_TABLE TAB
     WHERE I.RID <> TAB.ROWID
       AND TAB.A = I.A
       AND TAB.B = I.B;

    COMMIT;

  END LOOP;

END;

CREATE SEQUENCE LD_USER_ROLE_SEQ;

INSERT INTO LD_USER_ROLE
   (USER_ROLE_ID,INS_USER,INS_DATE, USERNAME) 
VALUES 
   (ld_user_role_seq.nextval, 'sp22',to_date('2003/05/03 21:02:44','yyyy/mm/dd hh24:mi:ss'),'JOHN BARRY', )

select *
    from Programs
    where ClientId = 5
        and DATEADD(Day, 0-DATEDIFF(Day, 0, GetDate()), GetDate()) between ProgramStart and ProgramEnd

CREATE TABLE CocoJambo (
    Id  CHAR(12) NOT NULL,
    Value INT NULL,
    CHECK( Id LIKE '[0-9][0-9][0-9][0-9][A-Z][0-9][0-9][0-9][0-9][0-9][0-9][0-9]' )
);
GO

CREATE UNIQUE INDEX IUN_CocoJambo_Id
ON CocoJambo (Id);
GO

INSERT  CocoJambo (Id, Value)
          SELECT '1001P0010001', 100
UNION ALL SELECT '1001P0010002', 200
UNION ALL SELECT '1001P0010003', 300
UNION ALL SELECT '1001P0010004', 400
UNION ALL SELECT '1001P0020001', 100
UNION ALL SELECT '1001P0020002', 200
UNION ALL SELECT '1001P0020003', 300
UNION ALL SELECT '1001P0020004', 400;
GO

-- Test 1: generating a single Id
DECLARE @Prefix CHAR(5),
        @Sufix CHAR(4);
SELECT  @Prefix = '1001P',
        @Sufix = '0001';

BEGIN TRAN

DECLARE @LastGeneratedMiddleValue  INT,
        @LastValue INT;

SELECT  @LastGeneratedMiddleValue = y.MiddleValue,
        @LastValue = y.Value
FROM 
    (
    SELECT  x.MiddleValue, x.Value,
            ROW_NUMBER() OVER(ORDER BY x.MiddleValue DESC) AS RowNum
    FROM 
        (
        SELECT  CONVERT(INT,SUBSTRING(a.Id,6,3)) AS MiddleValue, a.Value
        FROM    CocoJambo a WITH(UPDLOCK) -- It will lock the rows (U lock) during transaction
        WHERE   a.Id LIKE @Prefix+'%'+@Sufix
        ) x
    ) y
WHERE   y.RowNum=1;

SELECT  @LastGeneratedMiddleValue  = ISNULL(@LastGeneratedMiddleValue ,0)
SELECT  @Prefix
        +RIGHT('00'+CONVERT(VARCHAR(3),@LastGeneratedMiddleValue +1),3)
        +@Sufix AS MyNewId,
        @LastValue AS Value

COMMIT TRAN;
GO

-- Test 2: generating many Id's
BEGIN TRAN

DECLARE @Results TABLE (
    Prefix CHAR(5) NOT NULL,
    Sufix CHAR(4) NOT NULL,
    LastGeneratedMiddleValue  INT NOT NULL,
    LastValue INT NULL
);
INSERT  @Results (Prefix, Sufix, LastGeneratedMiddleValue, LastValue)
SELECT  y.Prefix, y.Sufix, y.MiddleValue, y.Value
FROM 
    (
    SELECT  x.Prefix, x.MiddleValue, x.Sufix, x.Value,
            ROW_NUMBER() OVER(PARTITION BY x.Prefix, x.Sufix ORDER BY x.MiddleValue DESC) AS RowNum
    FROM 
        (
        SELECT  SUBSTRING(a.Id,1,5) AS Prefix,
                CONVERT(INT,SUBSTRING(a.Id,6,3)) AS MiddleValue,
                SUBSTRING(a.Id,9,4) AS Sufix,
                a.Value
        FROM    CocoJambo a WITH(UPDLOCK) -- It will lock the rows (U lock) during transaction
        ) x
    ) y
WHERE   y.RowNum=1;

SELECT  r.*, 
        r.Prefix
        +RIGHT('00'+CONVERT(VARCHAR(3),r.LastGeneratedMiddleValue +1),3)
        +r.Sufix AS MyNewId,
        r.LastValue AS Value
FROM    @Results r;

COMMIT TRAN;
GO

SELECT DISTINCT Customers.CustomerName
                , SampleDetails.OrderID
                , SampleDetails.SampleNumber
                , Orders.DefaultReceiveDate
                , SampleDetails.Matrix
                , SampleDetails.Test
                , SampleDetails.Method
                , SampleDetails.CustomerTestPrice
                , Results.ResultStatus
  FROM Results
       INNER JOIN (((SampleDetails
                     LEFT JOIN Invoices
                            ON SampleDetails.OrderID = Invoices.OrderID)
                    INNER JOIN Orders
                            ON SampleDetails.OrderID = Orders.OrderID)
                   INNER JOIN Customers
                           ON Orders.CustomerID = Customers.CustomerID)
               ON Results.OrderID = SampleDetails.OrderID
 GROUP BY Customers.CustomerName
          , SampleDetails.OrderID
          , SampleDetails.SampleNumber
          , Orders.DefaultReceiveDate
          , SampleDetails.Matrix
          , SampleDetails.Test
          , SampleDetails.Method
          , Results.ResultStatus
          , SampleDetails.CustomerTestPrice
          , Invoices.InvoiceID
          , Results.ApprovedDate
          , Orders.CustomerID
          , SampleDetails.Cancelled
HAVING ( ( ( Orders.DefaultReceiveDate ) > [Enter the start date:] )
         AND ( ( Invoices.InvoiceID ) IS NULL )
         AND ( ( Results.ApprovedDate ) IS NOT NULL )
         AND ( ( Orders.CustomerID ) IS NOT NULL
               AND ( Orders.CustomerID ) NOT LIKE "AFL*" )
         AND ( ( SampleDetails.Cancelled ) = False )
         AND ( SUM(IIF([ResultStatus] = 3, 0, 1)) ) = 0 )
 ORDER BY Customers.CustomerName; 

SELECT BS.[ID],BS.[WarehouseNo],BS.[Customer],BS.[Site],BS.[VendorNo],BS.[Description],
BS.[ActualQty],BS.[BaseQty], (BS.[BaseQty] - BS.[ActualQty]) AS PlaceOrderQty
FROM [dbo].[StockControlBaseStock] AS BS
LEFT JOIN [dbo].[StockControlStockOrder] AS SO
ON BS.ID = SO.BaseStockRef
WHERE (BS.[ActualQty] + Iif(SO.OrderQTY IS NULL, 0, SO.OrderQTY)) <> BS.[BaseQty]
AND BS.[ActualQty] IS NOT NULL
AND BS.[BaseQty] IS NOT NULL

select object_id, name, image_path
from
  (SELECT images.image_path AS image_path, objects.id AS object_id, objects.name
  FROM objects LEFT JOIN images ON images.object_id = objects.id
  ORDER BY RAND()) as z
group by z.object_id, z.name

CREATE TABLE Cars (VIN INTEGER NOT NULL UNIQUE);

CREATE TABLE Drivers (driver_licence_number INTEGER NOT NULL UNIQUE);

CREATE TABLE CarDrivers 
(
 VIN INTEGER NOT NULL REFERENCES Cars (VIN), 
 driver_licence_number INTEGER NOT NULL 
    REFERENCES Drivers (driver_licence_number)
);

INSERT INTO Cars VALUES (1), (2), (3);
INSERT INTO Drivers VALUES (22), (55), (99);

INSERT INTO CarDrivers VALUES (1, 22), (1, 55);

CREATE TABLE CarDrivers_staging
(
 VIN INTEGER NOT NULL REFERENCES Cars (VIN), 
 driver_licence_number INTEGER NOT NULL 
    REFERENCES Drivers (driver_licence_number)
);

INSERT INTO CarDrivers_staging 
   VALUES (1, 55), -- remains
          (1, 99); -- insert
                   -- DELETE (1, 22)

MERGE INTO CarDrivers
   USING CarDrivers_staging S 
      ON S.VIN = CarDrivers.VIN
         AND S.driver_licence_number = CarDrivers.driver_licence_number 
WHEN NOT MATCHED THEN
   INSERT (VIN, driver_licence_number)
      VALUES (VIN, driver_licence_number)
WHEN NOT MATCHED BY SOURCE THEN
   DELETE;

db.item.finsSomething({"request.item":{$in:[number]}})

SELECT id,
       name,
       (SELECT group_concat(value, ', ')
        FROM Table2
        WHERE id = Table1.id
          AND type = 'clothing'
       ) AS clothing,
       (SELECT group_concat(value, ', ')
        FROM Table2
        WHERE id = Table1.id
          AND type = 'toys'
       ) AS toys
FROM Table1

SELECT
    D.[OS Name]
,   SUM(D.[Computer Count]) AS [Computer Count]
,   D. ...
FROM
(
SELECT [OS Name],
(SELECT COUNT (DISTINCT statement for total computers including a few joins and where))
(SELECT COUNT (DISTINCT statement for installed including a few joins and where))
(SELECT COUNT (DISTINCT statement for exempt including a few joins and where))
(SELECT COUNT (DISTINCT statement for missing including a few joins and where and a subquery))
FROM table

UNION ALL
SELECT [OS Name],
(SELECT COUNT (DISTINCT statement for total computers including a few joins and where))
(SELECT COUNT (DISTINCT statement for installed including a few joins and where))
(SELECT COUNT (DISTINCT statement for exempt including a few joins and where))
(SELECT COUNT (DISTINCT statement for missing including a few joins and where and a subquery))
FROM table2
) D
GROUP BY
    D.[OS Name]

String sql = "select MY_SEQ_ID.nextval from dual";
        SQLQuery query = session.getCurrentSession().createSQLQuery(sql);
        List idList=query.list();
        BigDecimal number=(BigDecimal) idList.get(0);
        System.out.println(number);

SELECT*
FROM    (
    SELECT list.*, @counter := @counter +1 AS counter
    FROM (select @counter:=0) AS initvar, list
    ORDER BY value DESC   
) AS X
where counter <= (10/100 * @counter);
ORDER BY value DESC

CREATE PROCEDURE CreatePerson(IN newID int)
BEGIN
   insert into person (person_id) values (newID);
   insert into patient (patient_id) values (newID);
   --as many statements as you need. perhaps wrap in a TRANSACTION.
END;

SELECT M.TYPE, COUNT(DISTINCT F.CD) AS TOTAL,
       COUNT(DISTINCT CASE WHEN F.GENDER = 0 THEN F.CD END) AS NUM_MALE,
       COUNT(DISTINCT CASE WHEN F.GENDER = 1 THEN F.CD END) AS NUM_FEMALE
FROM MARC M LEFT JOIN
     FUNCION F
     ON M.CD_FUNCION = F.CD
GROUP BY M.TYPE;

$env:PSModulePath += ";c:\some\path\to\sql"

SELECT
  SUM(IF(active=0,1,0)) as nonActiveCount,
  SUM(IF(active=1,1,0)) as activeCount,
  SUM(IF(featured=0,1,0)) as nonfeaturedCount,
  SUM(IF(featured=1,1,0)) as featuredCount
FROM myTable

(SELECT f.delta      AS field_data_field_session_start_date_delta
     , f.entity_id  AS date_id_date_filter
     , f.delta      AS date_delta_date_filter
     , n.title      AS node_title
     , n.nid        AS nid
     , n.language   AS node_language
     , f.field_session_start_date_value AS field_data_field_session_start_date_field_session_start_date
     , f.field_session_start_date_value2 AS field_data_field_session_start_date_field_session_start_date2
     , 'node'       AS field_data_field_session_start_date_node_entity_type
  FROM `node` n
  JOIN `field_data_field_session_start_date` f
    ON f.entity_id = n.nid
   AND f.entity_type = 'node'
   AND f.deleted = '0'
   AND f.field_session_start_date_value >= NOW()
WHERE n.status = '1'
ORDER
    BY f.field_session_start_date_value ASC
LIMIT 3 OFFSET 0)
UNION
(SELECT f.delta      AS field_data_field_session_start_date_delta
     , f.entity_id  AS date_id_date_filter
     , f.delta      AS date_delta_date_filter
     , n.title      AS node_title
     , n.nid        AS nid
     , n.language   AS node_language
     , f.field_session_start_date_value AS field_data_field_session_start_date_field_session_start_date
     , f.field_session_start_date_value2 AS field_data_field_session_start_date_field_session_start_date2
     , 'node'       AS field_data_field_session_start_date_node_entity_type
  FROM `node` n
  JOIN `field_data_field_session_start_date` f
    ON f.entity_id = n.nid
   AND f.entity_type = 'node'
   AND f.deleted = '0'
   AND f.field_session_start_date_value <= NOW()
   AND f.field_session_start_date_value2 > NOW()
WHERE n.status = '1'
ORDER
    BY f.field_session_start_date_value ASC
LIMIT 3 OFFSET 0)

SELECT  equip.*
FROM    equip e
WHERE   equipid IN
        (
        SELECT  equipid
        FROM    equip_equipcat ec
        JOIN    equipcat c
        ON      c.equipcatid = ee.equipcatid
        WHERE   equipcat LIKE '%rake%' 
                OR
                equipcatkeywords LIKE '%rake%'
        )
        AND
        (
        equipdesc LIKE '%rake%'
        OR
        keywords LIKE '%rake%'
        )
        AND hideyn  = 0
ORDER BY
        equipdesc 

select field1 , field2, field3 
from table1
join (select distinct field4 from table2) x
  on field1 like '%'+field4+'%'

SELECT 
    a.Location, 
    a.Invoice_date, 
    a.service, 
    a.QTY, 
    b.[user]
FROM Invoice_detail AS a 
INNER JOIN Invoice_tb AS b 
    ON a.invoice_number = b.invoice_number 
    AND a.location = b.location
WHERE 
    invoice_date BETWEEN @startdate AND @enddate
    AND NOT(a.service = 1 AND a.Location = 1)
ORDER BY a.location

select * from Table1 as t1
left outer join Table2 as t2
    on t1.RepID = t2.RepID
where t1.Date = @Date
order by t1.Date desc

SELECT T1.Name,
( SELECT MIN( T2.Dates) FROM Table2 T2 WHERE T1.ID = T2 = ID) AS Dates
FROM Table1 T1 
WHERE T1.Name = 'John'

message = "You picked %s"
value = "07May90"
puts sprintf(message, value)

CREATE TYPE MY_OBJECT AS OBJECT
(
    a_date date,
    a_char varchar2(1)
);

CREATE TYPE MY_COLUMN AS VARRAY(100) of MY_OBJECT;

create table my_table
(
    col1 number,
    my_columns my_column
);

INSERT INTO my_table 
VALUES(1, my_column(my_object(sysdate, 'X')));

exec dbms_scheduler.create_job(
job_name=>'JOB_RUN_MY_PROGRAM',
program_name=>'PROG_RUN_MY_PROCEDURE',
schedule_name=>'INTERVAL_EVERY_DAY',
enabled=>true,
auto_drop=>false,
comments=>'This will run my scheduler program');

  SELECT n.* 
    FROM NAME n
ORDER BY CASE 
           WHEN displayName LIKE '%@%' THEN 1 
           ELSE 2 
         END, n.displayname COLLATE NOCASE

SELECT t1.`parent_entry_id` AS event_data_id,
       t1.`child_entry_id` AS user_id,
       t2.`child_entry_id` AS event_id
FROM `exp_playa_relationships` AS t1
INNER JOIN `exp_playa_relationships` AS t2
        ON t2.`parent_entry_id` = t1.`parent_entry_id`
           AND t2.`parent_field_id` = 4
WHERE  t1.`parent_field_id` = 5

     string dateof = DateTime.Today.ToString("MM/dd/yyyy");

            connection.Open();
            using (var command = new SqlCommand(@"SELECT [Id],[AssignedToUser], [Status], [RequestID] FROM [dbo].[Notifications] WHERE  '" + dateof + "' = convert(varchar(25), TimeStatusChange, 101) ORDER BY TimeStatusChange DESC", connection))

select a.c.value('(../../../../../@id)[1]', 'int') as project
      ,a.c.value('(../../../../@id)[1]', 'int') as entity
      ,a.c.value('(../../../@id)[1]', 'int') as subproject
      ,a.c.value('(../../@id)[1]', 'int') as jobplan
      ,a.c.value('(../@id)[1]', 'int') as activity
      ,a.c.value('(@id)[1]', 'int') as task
from @xml.nodes('/project/..')t(c)   
cross apply t.c.nodes('project/entity/subproject/jobplan/activity/task') as a(c) 

UNION

select a.c.value('(../../../../@id)[1]', 'int') as project
      ,a.c.value('(../../../@id)[1]', 'int') as entity
      ,NULL as subproject
      ,a.c.value('(../../@id)[1]', 'int') as jobplan
      ,a.c.value('(../@id)[1]', 'int') as activity
      ,a.c.value('(@id)[1]', 'int') as task
from @xml.nodes('/project/..')t(c)   
cross apply t.c.nodes('project/entity/jobplan/activity/task') as a(c) 

UNION

select a.c.value('(../../../../@id)[1]', 'int') as project
      ,NULL as entity
      ,a.c.value('(../../../@id)[1]', 'int') as subproject
      ,a.c.value('(../../@id)[1]', 'int') as jobplan
      ,a.c.value('(../@id)[1]', 'int') as activity
      ,a.c.value('(@id)[1]', 'int') as task
from @xml.nodes('/project/..')t(c)   
cross apply t.c.nodes('project/subproject/jobplan/activity/task') as a(c) 

UNION  

select a.c.value('(../../../@id)[1]', 'int') as project
      ,NULL as entity
      ,NULL as subproject
      ,a.c.value('(../../@id)[1]', 'int') as jobplan
      ,a.c.value('(../@id)[1]', 'int') as activity
      ,a.c.value('(@id)[1]', 'int') as task
from @xml.nodes('/project/..')t(c)   
cross apply t.c.nodes('project/jobplan/activity/task') as a(c) 

SELECT
  SUM(category == 'both') AS both_count,
  SUM(category == 'A') AS a_count,
  SUM(category == 'B') AS b_count
FROM (
  SELECT
    name,
    CASE WHEN SOME(tag == 'A') AND SOME(tag == 'B') THEN 'both' 
         WHEN EVERY(tag == 'A') THEN 'A' 
         WHEN EVERY(tag == 'B') THEN 'B'
         ELSE 'none' END AS category
  FROM 
    (SELECT 'bob' as name, 'A' as tag),
    (SELECT 'bob' as name, 'A' as tag),
    (SELECT 'bob' as name, 'B' as tag),
    (SELECT 'tom' as name, 'A' as tag),
    (SELECT 'tom' as name, 'A' as tag),
    (SELECT 'amy' as name, 'B' as tag),
    (SELECT 'amy' as name, 'B' as tag),
    (SELECT 'jen' as name, 'A' as tag),
    (SELECT 'jen' as name, 'A' as tag)
  GROUP BY name)

(1)  Run the subquery
(2)  Check each row in table1 against the result set from the subquery.

select * from information_schema.columns

SELECT
    problems.problem_id,
    creator_member_id,
    problem_title,
    problem_description,
    sum(vote) as totalVotes,
    problem_date
FROM problems
LEFT JOIN problem_votes
    ON problems.problem_id = problem_votes.problem_id
GROUP BY problems.problem_id

select trim(COLUMN_NAME) from .......
;

SELECT A.ITEM_TYPE,A,ITEM_NAME,A.avgA,B.avgB
FROM
(
    SELECT [ITEM_TYPE]
          ,[ITEM_NAME]
          ,AVG([ACT_VOL]) as avgA     
    FROM [MyDb].[dbo].[VT_TOTALS]
    WHERE ITEM_TYPE = 'A'
      AND PROD_VOL != '0'
      AND PROD_VOL IS NOT NULL
      AND START_DATETIME >=DATEADD(day,-1, '20120420')
    group by [ITEM_TYPE],[ITEM_NAME]
) A FULL JOIN
(
    SELECT [ITEM_TYPE]
          ,[ITEM_NAME] 
         ,AVG([ACT_VOL]) as avgB     
    FROM [MyDb].[dbo].[VT_TOTALS]
    WHERE ITEM_TYPE = 'A'
      AND PROD_VOL != '0'
      AND PROD_VOL IS NOT NULL
      AND START_DATETIME >=DATEADD(day,-7, '20120420')
      AND START_DATETIME <='20120420'
    group by [ITEM_TYPE],[ITEM_NAME]
) B on A.ITEM_TYPE=B.ITEM_TYPE and A.ITEM_NAME=B.ITEM_NAME

SELECT G.*, T1.NAME as T1_NAME, T2.NAME AS T2_NAME
FROM GAMES G
INNER JOIN TEAM T1 ON T1.T_ID=G.HO_T_ID
INNER JOIN TEAM T2 ON T2.T_ID=G.V_T_ID

SELECT [Last], [another field ?]
FROM Roster
WHERE Position Like "Ops*";

select (column_name + ' ' + data_type +
        (case when character_maximum_length is not null
              then '('+character_maximum_length+')'
              else ''
         end) + ','
       ) as ColumnDef
from Information_Schema.columns
order by ordinal_position

SELECT p.classyear, 
       p.lastname, 
       p.firstname, 
       p.studentid, 
       pvt.math, 
       pvt.biology 
FROM   (SELECT sr.grade, 
               si.classyear, 
               si.studentid, 
               si.firstname, 
               silastname 
        FROM   student_info si 
               INNER JOIN student_records sr 
                 ON si.studentid = sr.studentid 
               INNER JOIN course_records cr 
                 ON sr.courseid = cr.courseid) p PIVOT ( AVG (grade) FOR 
       coursedec IN ( 
       [Math], [Biology]) ) AS pvt 
ORDER  BY pvt.classyear; 

SELECT r.Reading_ID, rr.Reading_Type_ID, r.Reading, r.Reading_Date,
       LAG(r.Reading, 1, 0) OVER (PARTITION BY rr.Reading_Type_ID ORDER BY r.Reading_Date
                                 ) as Yesterday_Reading
FROM Calendar c CROSS JOIN
     (SELECT DISTINCT r.Reading_Type_ID FROM Readings r) rr LEFT JOIN
     Readings r
     ON c.Date = r.Reading_Date AND r.Reading_Type_ID = rr.Reading_Type_ID;

SELECT drinker
FROM frequents
GROUP BY drinker
HAVING COUNT(drinker) = (SELECT COUNT(DISTINCT name) FROM bars);

concat(concat(INITCAP(lastname), INITCAP (firstname)), '~~~~~')

SELECT
  City, State, County,
  GROUP_CONCAT(Zipcode SEPARATOR ',') AS Zipcodes
FROM
  MyTable
WHERE
  <Whatever you have>
GROUP BY
  City, State

select * from 
( 
   select StaffId, max(AssignedFromDate) as adate
   from StaffDepartmentAssgnment 
   group by staffid
) x
inner join StaffDepartmentAssgnment y
      on y.staffid = x.staffid and adate = y.AssignedFromDate
where DepartmentId = 'dept2'

where (case when @onlyMM = 1 then man_zrdtyp else -1 end) not in (1616,2001)

create table pages (
  id serial primary key, 
  page_type char(1) not null
    check (page_type in ('s', 't')),
  title varchar(50) not null unique,
  unique (id, page_type)
);

create table stats (
  id integer primary key,
  page_type char(1) not null default 's'
    check(page_type = 's'),
  show_average boolean,
  foreign key (id, page_type) references pages (id, page_type)
);

create table tags (
  id integer primary key,
  page_type char(1) not null default 't'
    check(page_type = 't'),
  color varchar(50) not null
);

create table stat_tags (
  stat_id int not null,
  tag_id int not null,
  primary key (stat_id, tag_id),
  foreign key (stat_id) references stats(id),
  foreign key (tag_id) references tags(id)
);

DECLARE
    i INTEGER;
BEGIN
    SELECT COUNT(*) INTO i FROM user_indexes WHERE index_name = 'MYINDEX';
    IF i = 0 THEN
        EXECUTE IMMEDIATE 'CREATE INDEX myIndex ...';
    END IF;
END;
/

<cfquery name="GET_SALES_TOTAL" datasource="#dsn#">
SELECT SUM(COALESCE(NETTOTAL,0)) NETTOTAL,
       SC.CITY_ID,
       SC.CITY_NAME,
       M.INVOICE_MONTH
FROM SETUP_CITY SC 
    LEFT OUTER JOIN COMPANY C 
        ON SC.CITY_ID = C.CITY 
    CROSS JOIN  
    (   SELECT DISTINCT DATEPART(MM,INVOICE_DATE) INVOICE_MONTH 
        FROM #DSN2_ALIAS#.INVOICE
    ) M
            LEFT OUTER JOIN #DSN2_ALIAS#.INVOICE I 
                ON C.COMPANY_ID = I.COMPANY_ID
               AND DATEPART(MM,I.INVOICE_DATE) = M.INVOICE_MONTH 
WHERE PURCHASE_SALES = 1 
AND SC.COUNTRY_ID=1
GROUP BY M.INVOICE_MONTH,
         SC.CITY_ID,
         SC.CITY_NAME
ORDER BY M.INVOICE_MONTH,
         SC.CITY_ID,
         SC.CITY_NAME
</cfquery>

select col2
from A A1
where not exists (
  select 1
  from A A2
  where A1.col2 = A2.col1
)

select o.name "Name", 
   (select count(*) from table_name i where i.name = o.name) "Count"
from table_name o;
with C as
(
  select *
  from TestingTable1 A
    inner join TestingTable2 B
      on A.BUYER_ID = B.USER_ID and
         B.LAST_TIME = A.Created_TIME and
         B.PRODUCT_ID <> A.ITEM_ID
  union all
  select * 
  from TestingTable1 A
    inner join TestingTable2 B 
      on A.BUYER_ID = B.USER_ID and 
         B.PRODUCT_ID = A.ITEM_ID and
         B.LAST_TIME <> A.CREATED_TIME
)
select *
from C
union all
select *
from TestingTable1 A
  inner join TestingTable2 B
    on A.BUYER_ID = B.USER_ID and
       A.CREATED_TIME <> B.LAST_TIME and
       A.ITEM_ID <> B.PRODUCT_ID
where not exists (select *
                  from C
                  where A.BUYER_ID = C.BUYER_ID and
                        A.ITEM_ID = C.ITEM_ID and
                        A.CREATED_TIME = C.CREATED_TIME) and
      not exists (select *
                  from C
                  where B.USER_ID = C.USER_ID and
                        B.PRODUCT_ID = C.PRODUCT_ID and
                        B.LAST_TIME = C.LAST_TIME);

ORDER BY coalesce(updated_at, created_at) DESC, id DESC

SELECT t1.* , t2.ItemName , t3.Price
FROM Table1 t1 
INNER JOIN Table2 t2  ON t1.Item = t2.Item
INNER JOIN Table3 t3  ON t1.Transact = t3.Transact

SELECT address, min(timestamp), max(timestamp)
FROM ((SELECT address_from as address, timestamp 
       FROM transactions 
      )
      UNION ALL
      (SELECT address_to as address, timestamp
       FROM transactions
      )
     ) a
GROUP BY address;

select *
from
(
    select entityid, [name], stringvalue as stringvalue
    from mytable
) as d
pivot
(
    min(stringvalue)
    for [name] in ([ShortDescription],[LongDescription])
)
as p

class Thread(models.Model):
    subscribers = models.ManyToManyField(User)
    other attributes...

FROM Neptune_FN_Analysis 
INNER JOIN Neptune_prem ON Neptune_FN_Analysis.PremID = CInt(Neptune_prem.premice_id)

SELECT DISTINCT HighEnd AS CombinedSets FROM Chipset
UNION
SELECT DISTINCT LowEnd AS CombinedSets FROM VideoCard

;with cte as
(select a,b,c,d, row_number() over (partition by d order by c,b) rn
 from your_derived_resultset)
select a,b,c,d 
from cte
where rn = 1 

CREATE TABLE base2(id int, name String)
PARTITIONED BY (state string);

INSERT OVERWRITE TABLE base2 PARTITION (state)
SELECT id, name, substring(state,0,1)

Select
    A.*
From [Table] A
Join (Select Name, MAX(C2) From [Table] Group By [Name]) B
    On A.Name = B.Name And A.C2 = B.C2

select name,
       sum(n = 1) as Column1Cnt,
       sum(n = 2) as Column1Cnt,
       sum(n = 3) as Column1Cnt
from (select (case when n.n = 1 then column1
                   when n.n = 2 then column2
                   when n.n = 3 then column3
              end) as name,
             n.n
      from t cross join
           (select 1 as n union all select 2 union all select 3) n
     ) t

Select id,discount
from customer 
where discount=(select MAX(discount) from customer) OR discount=(select MIN(discount) from customer);

Select * from 
  (
    Select
      dateadd(
        second, -1 * datepart(second, datetime)
        , dateadd(minute, mod(datepart(minute, datetime),15) * -1, datetime)
      )
      , feederid, vr, vy, vb
      , rank() over (
        partition by dateadd(
          second
          , -1 * datepart(second, datetime)
          , dateadd(minute, mod(datepart(minute, datetime),15) * -1, datetime)
        ) order by datetime desc
      ) rnk
   ) where rnk = 1

SELECT
    *
FROM
    ContentMaster
WHERE
    ContentAddedByUserID='%@'
AND
    HiveletCode='%@'
ORDER BY
    rowid DESC
LIMIT 10

  var query = "SELECT id, " +
              "concat('./directory/',picture) AS  picture "
              "FROM people";

SELECT t1.* 
FROM tbl t1
JOIN ( SELECT SubjectID
            , MAX(lastUpdatedDate) AS lastUpdatedDate
       FROM tbl 
       GROUP BY SubjectID ) t2 ON t1.SubjectID =  t2.SubjectID
                              AND t1.lastUpdatedDate =  t2.lastUpdatedDate

    public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);

ProgressDialog pd=ProgressDialog.show(this,"","Please Wait...");
Handler handler =new Handler()
{
 public void handleMessage(Message msg)
{
 if(msg.what==0)
{
 pd.dismiss();
 setContentView(R.layout.main);
}
}
};   
            Thread thread = new Thread()
            {
                @Override
                public void run() {
                  loadData();
                   setUpDB();
                  handler.sendEmptyMEssage(0);
                }
            };
            thread.start();
        }

 SELECT m.message_id m_id
      , m.sender_id s_id
      , m.thread_id t_id
      , m.subject
      , m.message
      , m.date_sent
      , s.firstname sender
      , r.firstname recipient
   FROM message m
   JOIN message_recipient n
     ON n.message_id = m.message_id
   JOIN user_public_info s
     ON s.user_public_info_id = m.sender_id
   JOIN user_public_info r
     ON r.user_public_info_id = n.recipient_id
   JOIN (SELECT thread_id, MAX(max_message_id) max_message_id FROM message GROUP BY thread_id)x
     ON x.thread_id = m.thread_id AND x.max_message_id = m.message_id;

SELECT s.[Id],
       s.[Name],
       CASE WHEN EXISTS (SELECT 1 FROM [dbo].[SourceUser] su WHERE su.SourceId = s.[Id] AND su.UserId = 1)
            THEN CAST(1 AS BIT)
            ELSE CAST(0 AS BIT)
       END AS Access
 FROM [dbo].[Source] s
 INNER JOIN [dbo].[SourceAccount] sa ON sa.SourceId = s.Id
 WHERE sa.AccountId = 1 AND s.SiteId = 1

update myTable
set code = cast(code as int) * 10000
where curr_qtr = 'q1_2014'

public Cursor findNameInTable(int myVariable1, int myVariable2, ..., int myVariableN) 
{
    String inInterval = "(?,?,?,...,?)"; // N question mark altogether.
    String where = COL_CAT1 + " IN " + inInterval 
                   + " OR " + COL_CAT2 + " IN " + inInterval
                   + ...........
                   + " OR " + COL_CATM + " IN " + inInterval;
int numberOfColumn = M; // The number of columns you have.
String[] whereArgs = new String[M * N];
for (int i = 0; i < M; i++)
{
     whereArgs[i * N + 0] = Integer.toString(myVariable1);
     whereArgs[i * N + 1] = Integer.toString(myVariable2);
     whereArgs[i * N + 2] = Integer.toString(myVariable3);
        ........................
     whereArgs[i * N + N - 1] = Integer.toString(myVariableN);
}  
Cursor c = myDatabase
        .query(DATABASE_TABLE, new String[] { KEY_ROWID, COL_NAME , COL_COMMENTS }, 
                where,
                whereArgs, null,
                null, null);
    return c;
}

SELECT loginid
  FROM customer
 WHERE code IN ('TEST1', ... , 'TEST20')
 GROUP BY loginid
HAVING COUNT(DISTINCT code) = 20;

ORDER BY
Action, 
CASE WHEN Control_ID = DataValue THEN 1 ELSE 0 END

UPDATE yourTable SET signupType = IF(Town IS NULL, 1, 0);

sys.default_constraints for default constraints on columns
sys.check_constraints for check constraints on columns
sys.key_constraints for key constraints (e.g. primary keys)
sys.foreign_keys for foreign key relations

create table t2 (i int,v text default 'Vao');
create table t3 (v text);
insert into t3 select 'Vao';
insert into t3 select 'Vao1';
td=# with n as (
    select column_default from 
        information_schema.columns 
    where 
        table_name  = 't2' and 
        column_name = 'v'
) select * from t3 join n on n.column_default = $$'$$||t3.v||$$'::text$$;
  v  | column_default
-----+----------------
 Vao | 'Vao'::text
(1 row)

SqlDataReader myReader = getEmp.ExecuteReader(CommandBehavior.SequentialAccess);

while (myReader.Read())
{
   int startIndex = 0;

   // Read the bytes into outbyte[] and retain the number of bytes returned.
   retval = myReader.GetBytes(1, startIndex, outbyte, 0, bufferSize);

   // Continue reading and writing while there are bytes beyond the size of the buffer.
   while (retval == bufferSize)
   {
      // write the buffer to the output, e.g. a file
      ....

      // Reposition the start index to the end of the last buffer and fill the buffer.
      startIndex += bufferSize;
      retval = myReader.GetBytes(1, startIndex, outbyte, 0, bufferSize);
   }

   // write the last buffer to the output, e.g. a file
   ....
}

// Close the reader and the connection.
myReader.Close();

No Action
Cascade
SET NULL
SET Default

select activities.type, sum(activity_fees.amount) 
...
Union
SELECT 'dummy', avg(activities.rating) 
....

SELECT
  ug.user_id,
  COUNT(DISTINCT goal_id) as matches
FROM
  user_goal ug
  INNER JOIN user u ON ug.user_id = u.id
  INNER JOIN profile p ON u.profile_id = p.id
  LEFT JOIN user_block ub ON u.id = ub.blocked_id
  LEFT JOIN user_block ub2 ON u.id = ub2.blocker_id
  LEFT JOIN user_user uu ON u.id = uu.user_id
  LEFT JOIN friend_request fr ON u.id = fr.user_id
  LEFT JOIN (
    SELECT iug.goal_id FROM user_goal
  ) iug ON iug.user_id = u.id
WHERE
  /* I looked at your WHERE clause for a while and couldn't get my head
     around what you're trying to do so I'll leave this to you */

select u.*
from dbo.Users u
join dbo.Form f on u.? = f.formId
join dbo.FormEmployment fe on fe.formId = f.formId
join dbo.Grade g on g.gradeId =  fe.gradeId
join dbo.ShiftGrade shg on shg.gradeId =g.gradeId
join dbo.Shift sh on sh.shiftId = shg.shiftId
where
    sh.shiftId = -- recently added shift id
and g.gradeId == -- recently added grade id

select
 regexp_replace('select userid,username from tablename where user_id=[REQ.UID] and username=[REQD.VP.UNAME]'
,'.*(\[.*?\]).*(\[.*?\]).*','\1\2')
from dual
;

SELECT cll.cl_id, cc.cc_id, cc_rego, cc_model, cll.cl_dateIn, cll.cl_dateOut
FROM courtesycar cc, courtesyloan cll
WHERE cl_dateIn = ( 
  SELECT  MAX( cl.cl_dateIn )
  FROM courtesyloan cl
  WHERE cl.cc_id = cc.cc_id )
AND cc.cc_id = cll.cc_id

SELECT ti.*, 
       nvl(i.id, n.id) itemid, 
       nvl(i.description, n.description) description, 
       nvl(i.col_sumthing, n.col_sumthing) col_sumthing 
  FROM ticketitems ti
  LEFT JOIN itemdetails i ON ti.itemid = i.id
  LEFT JOIN newsitems n ON ti.itemid = n.id
 WHERE ti.ticket = '100'

UPDATE TBL
SET PATTERN = TRIM('"' from PATTERN)

select object_name, created, last_ddl_time
from user_objects
where object_type = 'TRIGGER'

class People {
    Person person
}

Class Person{

    static hasOne = [people:People]

}

SELECT p1.id_area, p1.name, COALESCE(p2.name, '')
FROM perarea p1
     LEFT JOIN perarea p2 ON (p1.id_areapadre = p2.id_area)

SELECT
(SELECT COUNT(*) FROM tbl WHERE  col1 = 4 )+
(SELECT COUNT(*) from tbl WHERE  col2 = 4)
AS SumCount

WITH  cl AS
(select o.LINEID, o.BILL, o.[Total Amount], 
(select SUM([Total Amount]) from bills t where o.BILL = t.BILL and o.LINEID >= t.LINEID) as 'sum_total_ammount'
from bills o inner join payment p on o.BILL = p.BILL)

select o.LINEID, o.BILL, o.[Total Amount], 
case when p.[Paid Amount] >= sum_total_ammount then o.[Total Amount] 
else (o.[Total Amount] - sum_total_ammount + p.[Paid Amount]) end as 'Allocated Amount'
from cl o inner join payment p on o.BILL = p.BILL
and (o.[Total Amount] - sum_total_ammount + p.[Paid Amount]) > 0

select accoutn_name
from test.dbo.accounts
order by left(account_name,charindex('-',account_name,1)-1)
                        ,replace(right(left(account_name,CHARINDEX('-',account_name,1)+2),2),'-', '')
                        ,REPLACE(right(account_name,2),'-','')

insert into table2(t1col) 
    select id
    from table1 t1
    where not exists (select 1 from table2 t2 where t2.t1col = t1.id);

select r.*
from (select token, average, ntile(100) over (order by average) as percentile 
      from responses
     ) r
where token = <whatever>;

-- List of objects .. store in a table somewhere with
-- a db column set to an empty string
create table tempdb.dbo._mylist ( name nvarchar(500), db nvarchar(500) )
insert tempdb.dbo._mylist values ('obj 1', '')
insert tempdb.dbo._mylist values ('obj 2', '')

-- Setup cursor for databases
DECLARE db_cursor CURSOR FOR
   SELECT name from sys.databases WHERE [state] != 6 -- OFFLINE

-- Loop through cursor
OPEN db_cursor;
DECLARE @dbname sysname;
FETCH NEXT FROM db_cursor INTO @dbname;
WHILE (@@FETCH_STATUS <> -1)
BEGIN;
    -- added dbname to object list if found (joined using common collation)
   EXECUTE ('use ' + @dbname + '; update l set db = db + '';' + @dbname + ''' from tempdb.dbo._mylist l join sysobjects o on o.name = l.name COLLATE SQL_Latin1_General_CP1_CI_AS;');
   FETCH NEXT FROM db_cursor INTO @dbname;
END;
CLOSE db_cursor;
DEALLOCATE db_cursor;
GO

-- Select results
select name, db = isnull(stuff(db,1,1,''), '') from tempdb.dbo._mylist

-- Cleanup
drop table  tempdb.dbo._mylist

-- variables
declare @vb1 binary(16), @vb2 binary(16), @lo binary(8), @hi binary(8)

-- 2 guids to compare
declare @guid1 uniqueidentifier set @guid1 = '96B4316D-1EA7-4CA3-8D50-FEE8047C1329'
declare @guid2 uniqueidentifier set @guid2 = 'FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF'

-- split every 8 bytes into a binary(8), which is a bigint, the largest size usable with XOR
select @vb1 = @guid1, @vb2 = @guid2

-- xor the high and low parts separately
select @hi = convert(binary(8), substring(@vb1,1,8)) ^ convert(bigint, substring(@vb2,1,8))
select @lo = convert(binary(8), substring(@vb1,9,8)) ^ convert(bigint, substring(@vb2,9,8))

-- the final result, concatenating the bytes using char(8) - binary -> uniqueidentifier
select 'A', @guid1 union all
select 'B', @guid2 union all
select 'A XOR B = ', convert(uniqueidentifier, convert(binary(16),convert(char(8),@hi) + convert(char(8),@lo)))

DECLARE @LookupTable TABLE (
  userid     INT,
  mobileid   INT,
  startedate DATETIME,
  enddate    DATETIME,
  owner      CHAR(3))

INSERT INTO @LookupTable
SELECT 1, 1, '20001212 00:00:00.000', '20010101 00:00:00.000', N'asd' UNION ALL
SELECT 2, 2, '20001212 00:00:00.000', '20010101 00:00:00.000', N'dgs' UNION ALL
SELECT 3, 3, '20010102 00:00:00.000', '20020101 00:00:00.000', N'sdg' UNION ALL
SELECT 4, 4, '20001212 00:00:00.000', '20010101 00:00:00.000', N'sdg'


DECLARE @UserInfoTable TABLE (
  userid    INT,
  firstname VARCHAR(10),
  lastname  VARCHAR(10),
  address   VARCHAR(10))

INSERT INTO @UserInfoTable
SELECT 1, N'tom', N'do', N'test' UNION ALL
SELECT 2, N'sam', N'smith', N'asds' UNION ALL
SELECT 3, N'john', N'saw', N'asdasda' UNION ALL
SELECT 4, N'peter', N'winston', N'near by'

DECLARE @Mobile TABLE (
  mobileid   INT,
  name       VARCHAR(10),
  number     INT,
  imeinumber INT )

INSERT INTO @Mobile
SELECT 1, N'apple', 123, 1111111 UNION ALL
SELECT 2, N'nokia', 456, 2222222 UNION ALL
SELECT 3, N'vodafone', 789, 3333333

DECLARE @CallLogs TABLE (
  id            INT,
  mobileid      INT,
  callednumbers VARCHAR(50),
  [date]        DATETIME,
  totalduration INT )

INSERT INTO @CallLogs
SELECT 1, 1, N'123,123,321', '20001213 00:00:00.000', 30 UNION ALL
SELECT 2, 1, N'123,123,321', '20001214 00:00:00.000', 30 UNION ALL
SELECT 3, 2, N'123,123,321', '20001213 00:00:00.000', 30 UNION ALL
SELECT 4, 2, N'123,123,321', '20001214 00:00:00.000', 30 UNION ALL
SELECT 5, 3, N'123,123,321', '20001213 00:00:00.000', 30 UNION ALL
SELECT 6, 3, N'123,123,321', '20001214 00:00:00.000', 30 UNION ALL
SELECT 7, 1, N'123,123,321', '20020113 00:00:00.000', 30 UNION ALL
SELECT 8, 1, N'123,123,321', '20020114 00:00:00.000', 30

SELECT DISTINCT firstname,
                lastname,
                device1.name AS mobilename,
                stuff((select ',' + callednumbers 
                       from @CallLogs log1 
                       where lt.mobileid = log1.mobileid 
                       for xml path('')), 1, 1, '') AS callednumbers 
FROM   (@LookupTable lt
        INNER JOIN @UserInfoTable user1
          ON lt.userid = user1.userid)
       INNER JOIN @Mobile device1
         ON lt.mobileid = device1.mobileid
WHERE  lt.startedate > '20000101' AND  startedate < '20010101'
ORDER  BY firstname  

SELECT DISTINCT ...
  FROM A
  JOIN B ON ...

SELECT d1.id, d1.match1, d1.match2, d1.match3, d1.data, count(*) matchid
FROM idcountdata d1
JOIN idcountdata d2 on d1.match1 = d2.match1 
  and d1.match2 = d2.match2 
  and d1.match3 = d2.match3
  and d1.id >= d2.id
GROUP BY d1.id, d1.match1, d1.match2, d1.match3, d1.data

With CTE as (
--Insert Existing query without rollup here
)

Select * From CTE

Union All

Select 'Grand Total' as County
    , null as Year
    , SUM(Total) as Total
    , SUM(Q1) as Q1
    , SUM(Q2) as Q2
    , SUM(Q3) as Q3
    , SUM(Q4) as Q4

From CTE

CREATE FUNCTION CheckDuplicateValues(@value1 INT, @value2 INT) RETURNS INT AS 
BEGIN 
    RETURN (
        SELECT COUNT(*) FROM Table1 WITH (READCOMMITTEDLOCK)
        WHERE Value1 = @value1 
          AND Value2 = @value2
    );
END; 
GO

String[] args=new String[] {"2", "3", "4"};
Cursor cursor=database.query(myTable, 
         myTableColumns,
         "_columnValue in (?, ?, ?)",
         args,
         null, null, null);

SELECT * FROM yourTable
WHERE `status` = "Pass"
LIMIT 3;

with logs as
       (select l.*
          from audit_log l join audit_item i on l.ai_id = i.ai_id
         where l.packaging_id = 100 and i.ai_name = 'AAA')
select u.email
  from users u join logs l on u.userid = l.userid
 where l.insert_date = (select max(insert_date) from logs);

        CC01 = 20
        AND
        YR01 >= RIGHT(YEAR(CURRENT DATE - 220 DAYS),2)
        AND NOT
            (
            YR01 = RIGHT(YEAR(CURRENT DATE - 220 DAYS),2)
            AND
            MO01 = MONTH(CURRENT DATE - 220 DAYS)
            AND
            DY01 < DAY(CURRENT DATE - 220 DAYS)
            )
        AND NOT
            (
            YR01 = RIGHT(YEAR(CURRENT DATE - 220 DAYS),2)
            AND
            MO01 < MONTH(CURRENT DATE - 220 DAYS)
            )

SELECT ERRONEOUS.PERSON_ADDRESS_ID
FROM PERSON_ADDRESS ERRONEOUS LEFT OUTER JOIN
     PERSON_ADDRESS VALID
     ON LEFT(ERRONEOUS.PERSON_ADDRESS_ID, 8) = LEFT(VALID.PERSON_ADDRESS_ID, 8) and
        ERRONEOUS.PERSON_ADDRESS_ID <> VALID.PERSON_ADDRESS_ID
WHERE valid.Person_Address_Id is null and
     LEN(ERRONEOUS.PERSON_ADDRESS_ID) = 8

;with cte as
(
    select id, d,  datediff(s, d, lead(d) over(order by d)) as diff from Test
)
select * from cte where diff > 5

Select YR, 
  sum(case when ListeningProfRating = 1 then 1 else 0 end) As Begining,
  sum(case when ListeningProfRating = 2 then 1 else 0 end) As Inter,
  sum(case when ListeningProfRating = 3 then 1 else 0 end) As Advanced,
  sum(case when ListeningProfRating = 4 then 1 else 0 end) As AdvHigh
  Campus 
from mytable
Where YR = '2014' 
  AND ListeningScoreCode IN('S', 'B')
group by yr, campus

SELECT colfkey, COALESCE( col1, col2, col3, col4 ) AS value
FROM   table_name
WHERE  ROWNUM = 1
AND    COALESCE( col1, col2, col3, col4 ) IS NOT NULL;

(select t.*
 from tablename t
 where colname = '1'
 limit 1)
union all
(select t.*
 from tablename t
 where colname = '2'
 limit 1)

SELECT * FROM USER_UPDATABLE_COLUMNS
WHERE table_name = 'MY_DATAVIEW';

OWNER                          TABLE_NAME                     COLUMN_NAME                    UPDATABLE INSERTABLE DELETABLE
------------------------------ ------------------------------ ------------------------------ --------- ---------- ---------
TEST                           MY_DATAVIEW                    KEY1                           YES       YES        YES       
TEST                           MY_DATAVIEW                    KEY2                           YES       YES        YES       
TEST                           MY_DATAVIEW                    COLUMN_FROM_TABLE1             YES       YES        YES       
TEST                           MY_DATAVIEW                    COLUMN_FROM_TABLE2             NO        NO         NO   

WHERE STR_TO_DATE(my_field,'myformat') > DATE_SUB( NOW(), INTERVAL 24 HOUR)

SELECT       cols.table_name
             , cols.column_name
             , cols.position
             , cons.status
             , cons.owner
FROM         all_constraints cons
             , all_cons_columns cols
WHERE        cols.table_name = 'TABLE_NAME'
AND          cons.constraint_type = 'P'
AND          cons.constraint_name = cols.constraint_name
AND          cons.owner = cols.owner
ORDER BY     cols.table_name, cols.position;

SELECT  a.*
FROM    alerts a
        LEFT JOIN alerts_viewed b
            ON a.alert_id = b.alert_id
WHERE   b.alert_id IS NULL

select p.projectID,
    p.projectName,
    year(bt.createdOn) as Year,
    month(bt.createdOn) as Month,
    sum(bt.actualTotalTime) as TotalTime
from Projects_tasks pt
inner join Projects p on pt.projectID = p.projectID
inner join Tasks t on p.taskID = t.taskID
inner join billingsTimes bt on t.taskID = bt.taskID
group by p.projectID,
    p.projectName,
    year(bt.createdOn),
    month(bt.createdOn),

CREATE TABLE `company`
(
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(50),
    PRIMARY KEY (`id`)
) ENGINE=InnoDB;

CREATE TABLE `post_code`
(
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `postal_code` VARCHAR(10),
) ENGINE=InnoDB;

CREATE TABLE `distance`
(

    `comnpany_id` INTEGER NOT NULL,
    `post_code_id` INTEGER NOT NULL,
    `distance` FLOAT NOT NULL,
    PRIMARY KEY (`company_id`,`post_code_id`),
    CONSTRAINT `distance_FK_1`
        FOREIGN KEY (`company_id`)
        REFERENCES `company` (`id`)
        ON DELETE CASCADE,
    CONSTRAINT `distance_FK_2`
        FOREIGN KEY (`post_code_id`)
        REFERENCES `post_code` (`id`)
        ON DELETE CASCADE
) ENGINE=InnoDB;

> df = data.frame(a=1:3,b=4:6)
> df
  a b
1 1 4
2 2 5
3 3 6
> DF = data.frame(A=I(list(df,df)),B=I(list(df,df)))
> DF
         A        B
1 1:3, 4:6 1:3, 4:6
2 1:3, 4:6 1:3, 4:6
> sapply(DF,class)
     A      B 
"AsIs" "AsIs" 
> sapply(DF$A,class)
[1] "data.frame" "data.frame"
> sapply(DF$B,class)
[1] "data.frame" "data.frame"
> DF[2,1]
[[1]]
  a b
1 1 4
2 2 5
3 3 6

SELECT game_id,gtype_imagefolder,game_isactive,game_title,game_description,game_image,game_imagealt,game_content,game_alias,game_software,game_flashlink,game_metatitle,game_metakeywords,game_metadescription,game_h1title,game_h1content,game_h2title,game_h2content,aff_affiliatelink,aff_description,aff_bonus,aff_id,aff_title,aff_image,aff_imagealt,aff_banner,aff_banneralt  
FROM games g 
LEFT JOIN (SELECT asoft_affiliateid,asoft_softwareid 
      FROM affiliates_software 
      ORDER BY RAND() ) aff_soft 
ON g.game_software=aff_soft.asoft_softwareid 
INNER JOIN (SELECT aff_id,aff_affiliatelink,aff_description,aff_bonus,aff_title,aff_image,aff_imagealt,aff_banner,aff_banneralt 
            FROM affiliates 
            WHERE aff_isactive=1) aff 
ON aff_id=asoft_affiliateid 
LEFT JOIN (SELECT gtype_imagefolder,gtype_id FROM games_type) gt ON game_type=gtype_id 
WHERE game_type=1 

GROUP BY game_id ORDER BY game_releasedate DESC

Select * 
from
   users u left outer join
   objects o on u.[id] = o.user_id
where
   o.user_id is null

SELECT SUM(overtime)
  FROM
  (
    SELECT employee_id,
           IF(HOUR(SEC_TO_TIME(SUM(TIMEDIFF(time_out,time_in))))>40,
              HOUR(SEC_TO_TIME(SUM(TIMEDIFF(time_out,time_in))))-40,
              0) AS overtime 
      FROM events 
     GROUP BY employee_id
  )TOTAL

    DECLARE @customerID varchar(max) = Null ;

  SET @customerID= '1,2,3,4,5'


     DECLARE @tempTble Table (
            customerID varchar(25) NULL);


while len(@customerID ) > 0
begin
  insert into @tempTble (customerID ) values(left(@customerID , charindex(',', @customerID +',')-1))
  set @customerID = stuff(@customerID , 1, charindex(',', @customerID +','), '')
end

select * from @tempTble

SELECT
    c.id,
    c.CategoryName,
    c.Description,
    (SELECT count(t.id)
     FROM topic t
     WHERE t.categoryId = c.id
    ) AS NumberOfTopics,
    (SELECT count(p.id)
     FROM post p
     JOIN topic t ON p.topicId = t.id
     WHERE t.categoryId = c.id
    ) AS NumberOfPosts,
    (SELECT max(p.createdOn) FROM post p
     JOIN topic t ON p.topicId = t.id
     WHERE t.categoryId = c.id
    ) AS LastPostDate
FROM category c;

select * 
from 
    customer  
    INNER JOIN  
    dblink('host=192.168.3.9 dbname=db2 user=postgres password=postgres', '
        SELECT
            status,
            last_churn_1,
            attempts,
            last_dialed,
            lead_id,
            date_added
        FROM campaign_customer
        where lead_id='3434'
        ') AS table2 (
            status char(50),
            last_churn_1 char(50),
            attempts int,
            last_dialed char(250),
            lead_id char(8),
            date_added char(50)
        ) ON customer.phone1 = table2.last_dialed
where customer.leadid = '3434'

    <columnName> LIKE '?_____=' + REPLICATE('[0-9A-Fa-f]',16)
AND <columnName> NOT LIKE '?_____=' + REPLICATE('[0-9]',16)

select *
from A
join B on A.id = B.aId
where A.created is not null

SELECT KeyWordID FROM <YOUR_TABLE> WHERE KeyWord= 'Blue'
INTERSECT
SELECT KeyWordID FROM <YOUR_TABLE> WHERE KeyWord= 'Yellow'

select ID1,Sales from table1 where ID1 in(select ID1 from table2 where ID3 in (select ID3 from table where ID2=0))

select s.countdate, s.countvalue
from (select s.*, lag(countvalue) over (order by countdate) as prevvalue
      from (<subquery>) s
     ) s
where prevvalue is null or prevvalue <> countvalue;

SELECT id_no
FROM   revenue_table
WHERE  revenue_type IN ( 'Tape', 'Shipping', 'Reproduction' )
GROUP  BY id_no
HAVING COUNT(DISTINCT revenue_type) = 3  

MERGE INTO quickbooks_companies dest
  USING( SELECT 'My Company' company_name,
                '11223344' access_token,
                '99887766' access_token_secret
           FROM dual ) src
     ON( dest.company_name = src.company_name )
  WHEN MATCHED THEN UPDATE
     SET dest.access_token = src.access_token,
         desc.access_token_secret = src.access_token_secret
  WHEN NOT MATCHED THEN INSERT( company_name, access_token, access_token_secret )
     VALUES( src.company_name, src.access_token, src.access_token_secret )

CAST(CD AS DATE)

select distinct cui  
from foo where CUI not in (select distinct CUI from foo 
                     where  SAB = 'SNOMEDCT_US')

CREATE TRIGGER TR_Regions ON Regions 
FOR INSERT
AS
INSERT INTO Availability 
        (region, technic, count)
    SELECT
        i.id, t.id, 0
        FROM INSERTED            i
            CROSS JOIN Technics  t

GO

SELECT  id ,
        CASE WHEN amount >= 0 THEN amount
             ELSE NULL
        END AS debit ,
        CASE WHEN amount < 0 THEN amount
             ELSE NULL
        END AS credit
FROM    Test.dbo.Accounts

IF id doesn't exist in table, then:

INSERT INTO DYNAMIC_PIVOT_TABLE (id, $name) 
   SELECT id, value as "$name" where name = "$name";

ELSE 

UPDATE DYNAMIC_PIVOT_TABLE  ... etc

SELECT MONTH(qc.CreateDate) as MON, COUNT(NCR) as NCR, COUNT(RMA) as RMA
FROM QualityControl qc
WHERE CreateDate >= '2015-01-01' AND CreateDate < '2016-01-01' 
GROUP BY MONTH(qc.CreateDate)
ORDER BY MON;

CREATE TABLE #a(a_id int, is_active bit)
CREATE TABLE #b(b_id int, a_id int)

INSERT INTO #a(a_id,is_active)
VALUES(1,1),(2,0),(3,1),(4,0),(5,0)

INSERT INTO #b(b_id,a_id)
VALUES(1,1),(2,1),(3,4),(4,4),(5,4),(6,4)

SELECT * 
FROM #a as a
LEFT JOIN #b as b
        ON a.a_id = b.a_id
        AND a.is_active = 0

DROP TABLE #a
DROP TABLE #b

select 
  outer_t.id
 ,outer_t.f1
 ,outer_t.f2
 ,inline_view.groupfoo
 from t as outer_t 
 left join (
  select 
      f1
     ,group_concat(f2) as groupfoo 
    from t 
    group by f1
 ) inline_view on inline_view.f1 = outer_t.f1
;

ALTER SEQUENCE foo_seq
  INCREMENT BY -4;

SELECT foo_seq.nextval
  FROM dual;

ALTER SEQUENCE foo_seq
  INCREMENT BY 1;

SELECT field1, field2, field3
FROM   table1
WHERE  field4 = 1 AND field5 = 'bob'

=sumproduct($A2:$A5,C2:C5)

SELECT DISTINCT trimmed
FROM (
    SELECT RTRIM(LTRIM(MyID)) as trimmed
    FROM dbo.SourceTbl
) A

select u.*, b.numbuyer, s.numseller
from users u left join
     (select buyer, count(*) as numbuyer
      from transactions
      group by buyer
     ) b
     on  b.buyer = u.user_id left join
     (select seller, count(*) as numseller
      from transactions
      group by seller
     ) s
     on s.buyer = u.user_id;

SELECT
  g.[Name],
  n.[Name] as 'Neighborhood',
  m.[Position]
FROM 
  [Gang] g INNER JOIN [GangMember] m ON m.[GangID]=g.[ID]
  LEFT OUTER JOIN [Neighborhood] n ON g.[NeighborhoodID] = n.[ID]

select e.*
from Employee e 
where not exists
(
    select 1 from Department d
    where e.DeptId = d.ID
)

SELECT coalesce(t1.x, t2.x) x, t1.y, t2.z
FROM (select count(y), x from a group by x) t1 
full join (select count(z), x from b group by x) t2 on (t1.x = t2.x)

SELECT id, GREATEST(score1, score3, score3, score4) AS col_value,
       CASE GREATEST(score1, score3, score3, score4) 
         WHEN score1 THEN 'score1'
         WHEN score2 THEN 'score2'
         WHEN score3 THEN 'score3'
         WHEN score4 THEN 'score4'
       END AS col_name
FROM test_scores

Please let me know if there is a better solution.

CREATE TABLE SCHEMA_PROPERTY (
   REAL_NAME  nvarchar2(64) not null,
   NAME       generated always as (lower(real_name)) primary key,
   VALUE nvarchar2(1024)
);

select DATEDIFF(Year,DOB,CURRENT_TIMESTAMP) age,Count(ID) users from dbo.student  where DatePart(year,registration_date)>=2010
GROUP BY  DATEDIFF(Year,DOB,CURRENT_TIMESTAMP)

SELECT 
   dt.dt,
   CASE 
      WHEN tcr.CreatedCount IS NULL 
        THEN 0 
        ELSE tcr.CreatedCount 
   END AS 'CreatedCount',
   CASE 
      WHEN tcl.ClosedCount IS NULL 
        THEN 0 
        ELSE tcl.ClosedCount 
   END AS 'ClosedCount',
   c.cname
FROM
    (SELECT DISTINCT company_recid, company_name AS cname
    FROM v_rpt_service) c 
LEFT JOIN 
   (SELECT 
       dt = cast(DATEADD(DAY, (- 1 * n), getdate()) AS date)
    FROM
       (SELECT TOP (30) 
           n = ROW_NUMBER() OVER (ORDER BY m1.number) - 1
        FROM 
           [master].dbo.spt_values AS m1
        CROSS JOIN 
           [master].dbo.spt_values AS m2) X
    ) dt ON 
        1=1
LEFT JOIN
    (SELECT 
        COUNT(a.TicketNbr) AS CreatedCount,
        CAST(a.date_entered AS date) AS 'DayCreated',
        a.company_name cname,
        a.company_recid cid
     FROM 
        v_rpt_Service a
     LEFT JOIN 
        Company ON a.company_name = Company.Company_Name
     WHERE 
        (a.Board_Name = 'SOC - Incident'
         OR a.Board_Name = 'SOC - Service' 
         OR a.Board_Name = 'SOC - Escalation')
     GROUP BY 
         CAST(a.date_entered AS date), a.company_name, a.company_recid) tcr ON dt.dt = tcr.DayCreated AND c.Company_recID = tcr.cid 
LEFT JOIN
   (SELECT 
       COUNT(a.TicketNbr) AS ClosedCount,
       CAST(a.date_closed AS date) AS 'DayClosed',
       a.company_recid
    FROM 
       v_rpt_Service a
    LEFT JOIN 
       Company ON a.company_name = Company.Company_Name
    WHERE 
       (a.Board_Name = 'SOC - Incident' OR
        a.Board_Name = 'SOC - Service' OR
        a.Board_Name = 'SOC - Escalation')
    GROUP BY 
       CAST(a.date_closed AS date), a.company_recid) tcl ON dt.dt = tcl.DayClosed AND c.Company_recID = tcl.company_recid 
ORDER BY 
    cname, dt

UPDATE [MyTable]
SET DueDate = DATEADD(dd, 1, DueDate) -- add one day (set to midnight)
WHERE DATEPART(hh, DueDate) = 0 -- do this for dates where hour is zero (midnight)

SELECT A.Name, A.LastCount, (((A.FirstCount-A.LastCount)/A.FirstCount)*100) Trend
FROM (SELECT A.Name, MAX(IF(A.Interval = 'Last', A.Count, 0)) LastCount, 
             MAX(IF(A.Interval = 'First', A.Count, 0)) FirstCount
      FROM tableA A
      GROUP BY A.Name
     ) AS A

select customer_id , start_date , end_date
from table_name t_1 
where not exists(
  select 1 from table_name t_2 
  where t_2.customer_id = t_1.customer_id
  and t_2.start_date = t_1.start_date
  and t_2.end_date > t_1.end_date) 
and not exists (
  select 1 from table_name t_3 
  where t_3.customer_id = t_1.customer_id
  and t_3.end_date = t_1.end_date
  and t_3.start_date<t_1.start_date)

SELECT     CASE WHEN ROW_NUMBER() OVER (PARTITION BY t1.c1 ORDER BY t2.c1,t3.c1) = 1 THEN t1.c1 END, 
           t2.c1, t3.c1
FROM       t1
CROSS JOIN t2
INNER JOIN t3
ON         t3.c1 = t2.c1
ORDER BY   t1.c1

SELECT object_name, owner, created
FROM all_objects
WHERE object_type = 'TABLE' 
AND created >= TO_DATE('20120901', 'YYYYMMDD')

select 
    ItemSizeNm 
from 
    MstItemSize 
where SizeTypeNm ='Ring' 
and ItemSizeNm  in (select ringSize from @tblRingSize)

select Client_number , 'Recon'
FROM yrtableName 
GROUP BY Client_number
HAVING SUM(balance) = 0

select t.*, tmax.date as highpricedate, tmax.price as highprice
from tblstock t outer apply
     (select top 1 t2.*
      from tblstock t2
      where t2.symbol = t.symbol
      order by t2.price desc
     ) tmax;

DELETE FROM Main WHERE [Record ID] = 14341665;

ORACLE uses: INSTR
SQL SERVER uses: PATINDEX, CHARINDEX

ORACLE uses: SUBSTR
SQL SERVER uses: SUBSTRING

SELECT CASE
        WHEN "HT" IS NULL THEN 'Null'
        WHEN "HT" <= 4  THEN '0-4'
        WHEN "HT" <= 8  THEN '4-8'
        WHEN "HT" <= 12 THEN '8-12'
        WHEN "HT" <= 16 THEN '12-16'
        WHEN "HT" <= 20 THEN '16-20'
        WHEN "HT" <= 24 THEN '29-24'
        WHEN "HT" <= 28 THEN '24-28'
        WHEN "HT" <= 32 THEN '28-32'
        WHEN "HT" <= 36 THEN '32-36'
        WHEN "HT" <= 40 THEN '36-40'
        WHEN "HT" <= 44 THEN '40-44'
        WHEN "HT" <= 48 THEN '44-48'
        WHEN "HT" <= 52 THEN '48-52'
        WHEN "HT" <= 56 THEN '52-56'
        WHEN "HT" <= 60 THEN '56-60'
        WHEN "HT" <= 64 THEN '60-64'
        WHEN "HT" <= 68 THEN '64-68'
        WHEN "HT" <= 72 THEN '68-72'
        WHEN "HT" <= 76 THEN '72-76'
        WHEN "HT" <= 80 THEN '76-80'
        WHEN "HT" <= 84 THEN '80-84'
        WHEN "HT" <= 88 THEN '84-88'
        ELSE                 '>88'    
    END AS "Height Range",            
    count(*) AS "Count"  -- DISTINCT not needed any more
FROM (
   SELECT DISTINCT ON ("PATID")  -- get greatest "HT" per patient
          "PATID", "HT"
   FROM   dbo."VITAL"
   ORDER  BY "PATID", "HT" DESC NULLS LAST
   ) sub
GROUP BY 1;

ALTER TRIGGER [LabourAPI].[trg_IOIU_Employee]

   ON [LabourAPI].[Employee]
   INSTEAD OF INSERT, UPDATE

AS BEGIN

    SET NOCOUNT ON;
    SET XACT_ABORT ON;

    DECLARE
          @EmployeeID INT
        , @PersonID INT
        , @TabelNumber VARCHAR(6)
        , @DepartmentUID UNIQUEIDENTIFIER
        , @PositionID INT
        , @DateIn DATETIME
        , @DateOut DATETIME
        , @IsMainWorkPlace BIT
        , @DatePension DATETIME
        , @IsLabourUnionMember BIT
        , @FiringReasonID INT

    DECLARE cur CURSOR LOCAL READ_ONLY FAST_FORWARD FOR
    SELECT
          EmployeeID
        , PersonID
        , TabelNumber
        , DepartmentUID
        , PositionID
        , DateIn
        , DateOut
        , IsMainWorkPlace
        , DatePension
        , IsLabourUnionMember
        , FiringReasonID
    FROM INSERTED

    OPEN cur

    FETCH NEXT FROM cur INTO
          @EmployeeID
        , @PersonID
        , @TabelNumber
        , @DepartmentUID
        , @PositionID
        , @DateIn
        , @DateOut
        , @IsMainWorkPlace
        , @DatePension
        , @IsLabourUnionMember
        , @FiringReasonID

    WHILE @@FETCH_STATUS = 0 BEGIN

        SELECT
              @PersonID 
            , @TabelNumber 
            , @DepartmentUID 
            , @PositionID 
            , @DateIn 
            , @DateOut 
            , @IsMainWorkPlace 
            , @DatePension 
            , @IsLabourUnionMember 
            , @FiringReasonID

        FETCH NEXT FROM employee INTO
              @EmployeeID
            , @PersonID
            , @TabelNumber
            , @DepartmentUID
            , @PositionID
            , @DateIn
            , @DateOut
            , @IsMainWorkPlace
            , @DatePension
            , @IsLabourUnionMember
            , @FiringReasonID

    END

    CLOSE cur
    DEALLOCATE cur

END

select top 100 * from tbl_test 

update tableA set colA = colE;

select 2.0 / 14

select * 
from my table 
where EventsAttended like ('77,%') 
   or EventsAttended like ('%,77,%') 
   or EventsAttended like (',77%') ;

Declare @V1 VarChar(Max), @V2 VarChar(Max), @V3 VarChar(Max)

Select @V1 = ...

Set @V2 = (Select ...)

Select @V3 = ...

Select @V1+@V2+@V3

CREATE TABLE dbo.IncludedCompanies (CompanyName varchar(1000)

INSERT INTO dbo.IncludedCompanies
VALUES
('Archer Daniels Midland'),
('PTG, LLC')
...

SELECT *
FROM Company C
JOIN IncludedCompanies IC
ON C.CompanyName = IC.CompanyName

select tradenumber
from t
group by tradenumber
having min(spread) <> max(spread)

declare @timein datetime ='2014-10-29 07:40:14.000'
,@breakout datetime = '2014-10-29 12:05:11.000'
,@breakin datetime ='2014-10-29 15:06:14.000'
,@timeout datetime ='2014-10-29 19:05:09.000'
,@totAM int, @totPM int, @totHrs int, @totMins int, @totSecs int, @totAMPM int , @totWorkHrs datetime

set @totAM = DATEDIFF ( second , @timein , @breakout )

set @totPM = DATEDIFF ( second , @breakin , @timeout )

SET @totAMPM = (@totPM+ @totAM)

SET @totHrs = @totAMPM/3600
SET @totMins = (@totAMPM % 3600) / 60
SET @totSecs = @totAMPM % 60


Select @totHrs as Hours, @totMins as minutes,  @totSecs  as Seconds

ALTER TABLE section ADD KEY(last_member, id);

SELECT osuser 
FROM   v$session 
WHERE  schemaname = 'abc';

SELECT a.*
FROM A as a
LEFT JOIN B AS b ON b.column = a.column
WHERE B.column IS NULL

SELECT 
    ISNULL(Class, 'Grand Total') as Score, 
    sum(Maths) as Maths, 
    sum(English) as English,
    sum(Maths) + sum(English) as Total
FROM 
    table 
GROUP BY 
    ISNULL(Class, 'Grand Total')
WITH ROLLUP

SELECT Map 
FROM 
    Table 
GROUP BY  
    Map
HAVING 
    MAX(Elev) - MIN(Elev) > 2000
ORDER BY
    MAX(Elev) - MIN(Elev) 

SELECT department_name as 'deptName',
       COUNT(users.department_id) as 'userCount'
  FROM departments
  LEFT OUTER JOIN users
    ON departments.id = users.department_id
 GROUP BY `deptName`

     update Table1 set col1= col1 + 1;

SELECT provider_food_joints.*, 
       menu_item.* 
FROM   provider_food_joints 
       INNER JOIN menu_item 
               ON menu_item.foodjoint_id = provider_food_joints.foodjoint_id 
WHERE  provider_food_joints.foodjoint_name = '".$foodjoint_name."' 

select avg(paymentdays)
from (select sp.sales_id, (datediff(max(sp.payment_date), min(sp.payment_date)) + 1) as paymentdays
      from sales_payment sp
      group by sp.sales_id
     ) sp;

SELECT FACILITY.fac_name
     , SUM(FEE_LOG.fee_amount) AS TOTAL_FEES 
FROM FACILITY
JOIN BOOK_DETAIL ON FACILITY.fac_id = BOOK_DETAIL.fac_id 
JOIN TRANS_LOG ON BOOK_DETAIL.bkdt_id = TRANS_LOG.bkdt_id 
LEFT JOIN FEE_LOG ON TRANS_LOG.trans_id = FEE_LOG.trans_id 
JOIN TRANS_TYPE  TRANS_LOG.trans_type_id = TRANS_TYPE.trans_type_id 
WHERE TRANS_TYPE.trans_type_desc IN ('LOST', 'CHECKIN')
GROUP BY FACILITY.fac_name;

--this creates a refcursor to allow us to simply print the results
var refc refcursor
/

declare --here we declare our variables
    product_name_1 varchar2(15) ;
    offer_valid_date_1 date ;
    trade_count_1 number ;
    product_name_2 varchar2(15) ;
    offer_valid_date_2 date ;
    trade_count_2 number ;    
begin
    begin --this creates a block so we may handle any exceptions just to this
          select PRODUCT_NAME,    MAX(EXPIRY_DATE),    COUNT(DEAL_NUMBER)
            into product_name_1 , offer_valid_date_1 , trade_count_1
            --in oracle you select INTO, not var=COL
        from (
                --Data extractions with several joins goes here....
                select 
                    123 PRODUCT_NAME,    
                    sysdate EXPIRY_DATE,    
                    5 DEAL_NUMBER
                from dual --this is a 'fake' table to generate some data for testing

        )  TempTable1 --drop the "as"
        GROUP BY PRODUCT_NAME ;
    exception --if not data is found, then this error is thrown
              --if multiple values are thrown an error will also be thrown (not caught here)
    when no_data_found then
        product_name_1 := null ; --note, to do a var = , we use "var := value;"
        offer_valid_date_1 := null;
        trade_count_1 := null;
    end ;
    begin
          select PRODUCT_NAME,    MAX(EXPIRY_DATE),    COUNT(DEAL_NUMBER)
            into product_name_2 , offer_valid_date_2 , trade_count_2
            --in oracle you select INTO, not var=COL
        from (
                --Data extractions with several joins goes here....
                select 555 PRODUCT_NAME,    sysdate EXPIRY_DATE,    6 DEAL_NUMBER
                from dual

        )  TempTable2 -- drop the "as"
        GROUP BY PRODUCT_NAME ;
    exception --if not data is found, then this error is thrown
              --if multiple values are thrown an error will also be thrown (not caught here)
    when no_data_found then
        product_name_2 := null ;
        offer_valid_date_2 := null;
        trade_count_2 := null;
    end ;

    open :refc for  --you cannot just have a select statement, you must "open" a cursor for it    
    --oracle IsNull is NVL (or NVL2 or you can do a case or decode...)
    SELECT nvl(PRODUCT_NAME_1,'Product 1') AS PRODUCT_NAME
          , OFFER_VALID_DATE_1 AS MAX_MATURITY
          , nvl(TRADE_COUNT_1,0)
      FROM DUAL --you also must have a table, DUAL is an oracle table for this tasks
        UNION
   SELECT nvl(PRODUCT_NAME_2,'Product 2') AS PRODUCT_NAME
          , OFFER_VALID_DATE_2 AS MAX_MATURITY
          , nvl(TRADE_COUNT_2,0)
    FROM DUAL;

end ;
/

--now print the results, if you did this in a proc you would simple have this as an output
print refc;

-------------
PRODUCT_NAME MAX_MATURITY              NVL(:B1,0)             
-------------------------------------- ---------------------- 
123          18.FEB.2011 08:43         1                      
555          18.FEB.2011 08:43         1                      

SELECT am.amount / (r2.multiplier * r2.value) AS calculated_amount
FROM amount AS am
JOIN (SELECT YEAR(rate_date) AS year, MAX(rate_date) AS maxdate
      FROM rate
      GROUP BY year) AS r1 ON YEAR(am.rate_date) = r1.year
JOIN rate AS r2 ON r1.maxdate = r2.rate_date

SELECT c.name
FROM (SELECT c.name, IF(@lastLetter=@lastLetter:=LEFT(c.name, 1), @cnt:=@cnt+1, @cnt:=0) letterCnt
      FROM customers c, (SELECT @lastLetter:='', @cnt:=0) A 
      ORDER BY c.name ASC
    ) AS c
WHERE c.letterCnt < 5

DELIMITER $$

DROP PROCEDURE IF EXISTS InsertMetaValues$$
CREATE PROCEDURE InsertMetaValues()
       BEGIN
               DECLARE x  INT;
               SET x = 1;
               WHILE x  <= 554 DO
                   INSERT INTO profile_meta(profile_id,meta_key,meta_value) VALUES(x,'userclass','Command');
                   SET  x = x + 1;
               END WHILE;
       END$$
   DELIMITER ;
   CALL InsertMetaValues();
   # IF you want to delete it after it finishes:
   # DROP PROCEDURE IF EXISTS InsertMetaValues;

SELECT A.ICAO, A.IATA, A.AIRPORT_NAME, A.CITY, A.COUNTRY, A.REVISED_DATE
FROM AIRPORT_CHECKLIST A LEFT JOIN AIRPORT_CHECKLIST_SELECTED B 
ON A.ICAO = B.ICAO
WHERE A.COMPANY = 'TOM' AND B.ICAO IS NULL;

SELECT a.phone, b.phone
      ,CASE WHEN a.phone = b.phone THEN 1 ELSE 0 END AS match
  FROM a, b
  WHERE a.id = b.id

SELECT db.table.faxnum, db.table.idnum, 
  c.userid, c.comments, 
  d.editid, d.edits
FROM db.table
LEFT JOIN 
( 
  select db.comments.grpnum, db.comments.userid, count(*) as comments
  FROM db.comments
  WHERE db.comments.date_submit >= '2016-02-26'
    AND db.comments.date_submit <= '2016-02-28'
    AND db.comments.grpnum='1234' 
  group by db.comments.grpnum, db.comments.userid
) as c
  ON db.table.idnum = c.grpnum
LEFT JOIN 
( 
  select db.edits.grpnum, db.edits.editid, count(*) as edits
  FROM db.edits
  WHERE db.edits.date_submit >= '2016-02-26'
    AND db.edits.date_submit <= '2016-02-28'
    AND db.edits.grpnum='1234' 
  group by db.edits.grpnum, db.edits.editid
) as d
  ON db.table.idnum = d.grpnum
  AND c.userid = d.editid
WHERE db.table.idnum = '1234';

var query = from l in context.info_log
            from a in context.application_info
            where l.app_id == a.app_id
            where l.level_nm == "ERROR" || l.level_nm == "FATAL"
            group l by new { a.app_id, a.app_nm } into lg
            select new
            {
              Id = lg.Key.app_id,
              Name = lg.Key.app_nm,
              Error = lg.Where(x => x.level_nm == "ERROR").Count(),
              Fatal = lg.Where(x => x.level_nm == "FATAL").Count(),
            };

update patient set security_level = '2' 
where security_level = '1';

Private Function GetData(ODBC As DBConnection, ByVal QuerySQL As String, Optional Parameters As Collection) As ADODB.Recordset
    Dim DB As ADODB.Connection
    Dim Query As ADODB.Command
    Dim Parameter As ADODB.Parameter
    Dim Output As ADODB.Recordset

    Set DB = New ADODB.Connection

    If dbOpen(DB, ODBC) Then
        Set Query = New ADODB.Command
        Query.ActiveConnection = DB
        Query.CommandText = QuerySQL

        If Not Parameters Is Nothing Then
            For Each param In Parameters
                Set Parameter = Query.CreateParameter(, adVarChar, adParamInput, Len(param), param)
                Query.Parameters.Append Parameter
            Next
            Set Parameter = Nothing
        End If

        Set Output = New ADODB.Recordset
        Output.CursorType = adOpenStatic
        Output.CursorLocation = adUseClient
        Output.Open Query
    Else
        MsgBox "Cannot connect to the database.", vbExclamation
        Set Output = Nothing
    End If

    Set GetData = Output
End Function

WITH cte AS (
    SELECT * FROM table1 WHERE id = 7
    UNION ALL
    SELECT table1.* FROM table1 JOIN cte ON table1.id = cte.parentId
)
SELECT * FROM cte

create temporary table foo_log_ins (like foo);

create rule log_foo_ins as
on insert to foo
do also
insert into foo_log select new.*;

create temporary table foo_log_del (like foo);

create rule log_foo_del as
on delete to foo
do also
insert into foo_log_del select old.*;

select p.name, p.partnum, p.sku,
       max( case when s.name='WEIGHT' then s.value else null end ) weight,
       max( case when s.name='HEIGHT' then s.value else null end ) height,
       max( case when s.name='COLOR'  then s.value else null end ) color
from product p join product_spec s on p.id = s.p_id
where sku <= 1003
group by p.name, p.partnum, p.sku

with test(ID1, ID2, SomeNotImportantComun) as
(
select 1 ,2, 'A' from dual union all
select 2 ,1, 'A' from dual union all
select 3 ,4, 'C' from dual
)
select id1, id2, SomeNotImportantComun
from (
        select id1, id2, SomeNotImportantComun,
               row_number() over ( partition by least(id1, id2), greatest(id1, id2) order by id1 desc, id2 desc) as rank
        from test
     )
where rank = 1

select * from [Car]
where Make = @Make or 
      City = @City or 
      MinPrice >= @MinPrice or 
      MaxPrice <= @MaxPrice
order by 
      case when Make = @Make then 3 else 0 end + 
      case when City = @City  then 2 else 0 end + 
      case when MinPrice >= @MinPrice then 1 else 0 end + 
      case when MaxPrice <= @MaxPrice then 1 else 0 end
      desc

If rst.EOF = True Then '----> here
  MsgBox ("SEARCH FAILED")
Else
  MsgBox ("QUANTITY ORDERED  " & rst!QuantityOrdered & vbCrLf & "   My Load Number is   " &  rst!LoadNumber)
End If

SELECT MAX(o2.dailytotal) AS DailyTotal,
       DATE_FORMAT(o2.datetime2, '%W') AS DayOfTheWeek,
       SUBSTRING_INDEX(GROUP_CONCAT(o2.datetime2 ORDER BY o2.dailytotal DESC), ',', 1) AS ActualDate
FROM (SELECT DATE(s1.datetime) AS datetime2,
             SUM(s1.ordertotal) AS dailytotal      
      FROM `order` o1
      GROUP BY DATE(o1.datetime)
     ) o2
GROUP BY DATE_FORMAT(o2.datetime2, '%W')
ORDER BY DailyTotal DESC;

SELECT t2a.name AS one_name, t2b.name AS two_name, ...
FROM table1 AS t1 JOIN table2 AS t2a (ON t2a.id = t1.one_id)
                  JOIN table2 AS t2b (ON t2b.id = t1.two_id)

SELECT account, MIN(dt_effective) FROM your_table
GROUP BY account

UPDATE
    `my_table`
SET
    `my_column_1` = 0
WHERE 
    `my_column_2` = 35
    AND `my_column_3` = 3
    AND `id` != 136

update
  Track
set
  the_geom = GEOMETRY::STGeomFromText(Track.STAsText(),4326)

select 
  DATEADD(MILLISECOND, 
          cast(dateModified as bigint) % 1000, 
          DATEADD(SECOND, cast(dateModified as bigint) / 1000, '19700101'))
from sometable

SELECT
    T1.Page, 
    T1.UserId, 
    T1.Date, 
    MIN(T2.Date) AS Date2, 
    DATEDIFF(minute, T1.Date, MIN(T2.Date)) AS DaysDiff,
    COUNT(*) RequestCount
FROM
    [STO24541450] T1 LEFT JOIN [STO24541450] T2
    ON T1.UserId = T2.UserId AND T2.Date > T1.Date
GROUP BY
    T1.Page, T1.UserId, T1.Date
HAVING 
    DATEDIFF(minute, T1.Date, MIN(T2.Date)) >= 5 AND COUNT(*) >= 5;

;WITH cte (dt) AS (
SELECT DATEADD(MONTH, v.number, '20140101') 
FROM master..spt_values v 
WHERE
   v.number >= 0 AND
   v.number < 12 AND
   v.type = 'p'
)

SELECT 
    Ventas, 
    prd_descripcion,
    COALESCE(crt_fecinivige, DATENAME(MM, dt) + ' ' + CAST(YEAR(dt) AS VARCHAR(4))),
    prd_producto_id, 
    pnc_cantidad    
FROM cte c

LEFT JOIN (
    SELECT 
      COUNT(crt_numinterno_id) * 100.00 / pnc_cantidad AS Ventas,
      prd_descripcion, 
      DATENAME(MM, crt_fecinivige) + ' ' + CAST(YEAR(crt_fecinivige) AS VARCHAR(4)) AS crt_fecinivige, 
      C.prd_producto_id,
      pnc_cantidad 
    FROM Certificados C 
    INNER JOIN Penetracion P 
      ON C.ges_gestor_id = P.ges_gestor_id 
      AND C.spo_sponsor_id = P.spo_sponsor_id 
      AND C.prd_producto_id = P.prd_producto_id 
    LEFT JOIN Productos R 
      ON C.ges_gestor_id = R.ges_gestor_id 
      AND C.spo_sponsor_id = R.spo_sponsor_id 
      AND C.prd_producto_id = R.prd_producto_id 
    WHERE C.ges_gestor_id = @codGestor 
      AND C.spo_sponsor_id = @codSponsor 
      AND (@codProducto = '' OR @codProducto = C.prd_producto_id) 
      AND crt_fechabaja IS NULL 
      AND crt_fecinivige BETWEEN @fechaInicio AND @fechaFin 
    GROUP BY 
      pnc_cantidad,
      prd_descripcion,
      DATENAME(MM, crt_fecinivige),
      YEAR(crt_fecinivige), 
      DATEPART(yyyy,crt_fecinivige),
      C.prd_producto_id,
      DATEPART(m,crt_fecinivige) 
) a ON c.dt = a.crt_fecinivige
ORDER BY 
    DATEPART(yyyy,crt_fecinivige) DESC,
    DATEPART(m,crt_fecinivige) DESC

UPDATE products
  SET date = new_value_1,
      hour = new_value_2,
      ...
      ...
WHERE (where_clause)

SELECT * FROM MyTable WHERE name COLLATE BINARY = 'Nick'

SELECT a.*, b.*
FROM 
(
    SELECT 'A' AS grp, 1 AS ad UNION ALL
    SELECT 'A', 2 UNION ALL
    SELECT 'A', 3
) a 
CROSS JOIN
(
    SELECT DISTINCT date
    FROM tbl
    WHERE date >= CURDATE() - INTERVAL 1 WEEK
) b
LEFT JOIN tbl c ON a.grp = c.grp
               AND a.ad = c.ad
               AND b.date = c.date
INNER JOIN
(
    SELECT a.date
    FROM 
    (
        SELECT 'A' AS grp, 1 AS ad UNION ALL
        SELECT 'A', 2 UNION ALL
        SELECT 'A', 3
    ) a 
    CROSS JOIN
    (
        SELECT DISTINCT date
        FROM tbl
        WHERE date >= CURDATE() - INTERVAL 1 WEEK
    ) b
    LEFT JOIN tbl c ON a.grp = c.grp
                   AND a.ad = c.ad
                   AND b.date = c.date
    GROUP BY a.date
    HAVING COUNT(1) = COUNT(c.grp)
) d ON b.date = d.date

SELECT u.*
,      (SELECT COUNT(*) FROM notes WHERE notes.user_id=u.id) as amountnotes
FROM users u
ORDER BY amountnotes DESC

LIKE "C*"  

SELECT * FROM MyTable WHERE MyColumn ~ 'July.{0,40}July';

string query = "select * from crm_visible_v where ownerid in (select sicilno from personel.pkim_kutlama@netdb_1.europe.nortel.com where cikis_tarihi is null start with sicilno ='"+SicilNumvber+"' connect by prior sicilno = amir)";    

SELECT c.name,
       count(cj.joborder_id)
FROM company c,
     joborder jo,
     candidate_joborder cj
WHERE c.company_id=jo.company_id
  AND jo.joborder_id=cj.joborder_id
  AND jo.status = 'Active'
  AND cj.status=700
GROUP BY c.name;

SELECT t1.* 
FROM TABLE1 t1
LEFT JOIN TABLE2 t2
    ON t1.QuestionID = t2.QuestionID
    AND T2.Username = 'TESTING'
WHERE t2.QuestionId is null

SELECT pf.timestamp, tf.timestamp, date
FROM stnrain s join
     puyforecast pf
     on date(pf.timestamp) = s.date and
        hour(pf.timestamp) = 18 join
     tacforecast tf
     on date(tf.timestamp) = s.date and
        hour(tf.timestamp) = 18

...
v_t := to_timestamp(trunc(systimestamp));
...

SELECT ID, balance, TYPE FROM saving
UNION ALL
SELECT ID, balance, TYPE FROM time
UNION ALL
SELECT ID, balance, TYPE FROM fore;

select
    AVG( Price ) Avg_Price
from
(
    (
        select
            pc.Price
        from
            PC pc
            join Produt prod
             on pc.Model = prod.Model
        where
            prod.Maker = 'A'
    )
    union all
    (
        select
            pc.Price
        from
            Laptop l
            join Produt prod
             on l.Model = prod.Model
        where
            prod.Maker = 'A'
    )
) q

select * from (
  select * from mytable 
  where 
    repeatable = false
    and 
    EFF_DT <= '2007-06-20' < XPIR_DT
  union all
  select * from mytable
  where
    repeatable = true
    and EFF_DT <= str_to_date(concat("2007", "-", month(EFF_DT), "-", day(EFF_DT)), "%Y-%m-%d") < XPIR_DT
)
order by EFF_DT desc limit 1

select case when p.date_of_birth < current_date - interval '12 year'
       then '< 12'
       else '12+'
       end age_bracket,
       count (*)
from   person p
where  exists (
         select null
         from   person_status_history psh
         where  psh.person_id   = p.person_id and
                psh.reason_code = 85          and
                exists (
                  select null
                  from   person_visit pv
                  where  pv.person_id          = psh.person_id and
                         pv.reasses_appoint_no is not null     and
                         pv.visit_date         > psh.suspend_to_date)
group by case when p.date_of_birth < current_date - interval '12 year'
         then '< 12'
         else '12+'
         end

with dt as (select '2014-03-31'::date dt_created, '2014-02-28'::date now)

select
case when extract(day from (date_trunc('MONTH', now) + INTERVAL '1 MONTH - 1 day')) = extract(day from now)
then extract(day from dt_created) >= extract(day from now)
else extract(day from dt_created) = extract(day from now)
end matches
from dt

select B.Name,
       (
         select ', '+BP.Title
         from BlogPosts as BP
         where B.BlogId = BP.BlogId
         for xml path(''), type
       ).value('substring((./text())[1], 3)', 'varchar(max)') as BlogPosts
from Blog as B

INSERT INTO wp_postmeta (meta_key, meta_value,post_id)
SELECT 'sidebar','chicago', object_id 
  FROM wp_term_relationships 
 WHERE term_taxonomy_id = 
       (
          SELECT term_id 
            FROM wp_terms 
           WHERE name = 'Chicago'
       ) 
   AND object_id > 5911

;with pay AS (SELECT EmplID,SUM(PAY) AS Pay
              FROM PAY_TABLE
              GROUP BY EmplID
             )
     ,ded AS (SELECT EmplID,SUM(DEDUCTION) AS Ded
              FROM DEDUCTION_TABLE
              GROUP BY EmplID
              )
SELECT *
FROM pay
LEFT JOIN ded
  ON pay.EmplID = ded.EmplID

objMyConn.ConnectionString =  "Provider=sqloledb; Data Source=" & range("B2").value & "; Initial Catalog=" & range("B3").value &"; Integrated Security=SSPI;"

SELECT s1.PK_ProgramStatee, s1.FK_Program, s1.State
FROM ProgramStates s1
inner join
(
  SELECT max(PK_ProgramState) as mstate, FK_Program
  FROM ProgramStates
  group by FK_Program
) s2 on s2.mstate = s1.PK_ProgramState and s2.FK_Program = s1.FK_Program

SELECT country_id, age_category_id, count(*)
FROM tourist_age_category
  JOIN tourist_country ON tourist_country.tourist_id = tourist_age_category.tourist_id
GROUP BY country_id, age_category_id

SELECT X.*, X2.DayCnt 
FROM AccountTable X
INNER JOIN 
(
    SELECT a.accountnumber,a.StartDate, b.EndDate, Count(b.Date) DayCnt 
    FROM AccountTable a
    LEFT OUTER JOIN workdays w 
        ON a.StartDate >= w.date and 
        a.EndDate <= w.date and 
        IsWorkday = 'Y'
    GROUP BY a.accountnumber,a.StartDate, b.EndDate
) X2 
ON X.accountnumber = X2.accountnumber and
X.StartDate = X2.StartDate and X.EndDate = X2.EndDate

SELECT topic_id,
       vote_type,
       SUM(vote_value) vote_frequency,
       MAX(CASE
             WHEN voter_id = 5 THEN 1
             ELSE 0
           END)        AS this_voter_has_voted
FROM   votes
GROUP  BY topic_id,
          vote_type;  

create table batch (
  id        number primary key,
  created   date   default sysdate not null,
  uploaded  date,
  processed date,
  archived  date,

  check (uploaded  is null or uploaded >= created),
  check (processed is null or (uploaded is not null and processed >= uploaded)),
  check (archived  is null or (processed is not null and archived >= processed))
);

SELECT cust,
       date,
       store,
       COUNT(*) AS n_items,
       SUM(item_type = 1) AS item1,
       SUM(item_type = 2) AS item2,
       SUM(item_type = 3) AS item3,
       SUM(item_type = 4) AS item4
FROM t
GROUP BY cust,
         date,
         store

SELECT Date,
       (SELECT MAX(Kms) FROM invoices i2 WHERE i2.Kms < i1.Kms) AS StartKm,
        Kms AS FinishKm
FROM invoices i1
ORDER BY Kms

select 'grant all on ' + name + ' to <user_name>' from sysobjects where type = 'U' or type = 'P'
go

SELECT 
business_period,
SUM(transaction.transaction_value) AS total_transaction_value,
SUM(transaction.loss_value) AS total_loss_value,
(SUM(transaction.transaction_value) - SUM(transaction.loss_value)) AS net_value
FROM transaction
GROUP BY business_period

SELECT long_case_expression, COUNT(1)
  FROM
(
SELECT
    CASE 
        WHEN ...
        WHEN ...
        ...
    END as long_case_expression
FROM table
) a
GROUP BY long_case_expression

CREATE TRIGGER `records_integrity` BEFORE UPDATE
ON `records`
FOR EACH ROW
    SET NEW.epc=IFNULL(new.earnings/new.clicks, 0);

        SELECT CriteriaId FROM CRITERIA JBCRV1, (
            SELECT DISTINCT JBCRV2.CriteriaId AS CRITERIAID 
            FROM WIPCRITERIA JWBCRV1 
            INNER JOIN CRITERIA JBCRV2
                ON    JWBCRV1.CriteriaVal= JBCRV2.CriteriaVal
                AND   JWBCRV1.CriteriaText = JBCRV2.CriteriaText
            WHERE  JWBCRV1.CriteriaId = #{CriteriaId}
            GROUP BY JBCRV2.CriteriaId HAVING COUNT(1) = 
                (SELECT COUNT(1) 
                 FROM WIPCRITERIA 
                 WHERE CriteriaId = #{CriteriaId} ) 
        ) RESULT_TABLE
        WHERE JBCRV1.CriteriaId = RESULT_TABLE.CRITERIAID
        GROUP BY JBCRV1.BEN_CRTR_ID HAVING COUNT(1) = 
                (SELECT COUNT(1) 
                 FROM WIPCRITERIA 
                 WHERE CriteriaId = #{CriteriaId} )

select ID, T.teimestamp, 1 from TRACKS T
UNION ALL 
select ID, S.teimestamp, 2 from STATUS S
UNION ALL 
select ID, G.teimestamp, 3 from GIGS G

var sb = new StringBuilder();
sb.Append("select {0} from {1}");
sb.Append(" where {3} in (");
sb.Append("select top {4} sub.{3}");
sb.Append("    from (");
sb.Append("          select top {5} tab.{3}");
sb.Append("          from {1} tab");
sb.Append("          where {2}");
sb.Append("          order by tab.{3}");
sb.Append("    ) sub");
sb.Append("    order by sub.{3} desc");
sb.Append(")");
sb.Append("order by {3}");

sql = string.Format(sb.ToString(), this.ColumnsToSelect, this.TableName, 
    this.WhereClause, this.OrderBy, this.PageSize, this.PageNum * this.PageSize);

SELECT tbl1.users_id, COUNT(tbl2.date)
FROM (SELECT users_id, date, @Counter:=IF(users_id = @PrevId, @Counter + 1, 1) AS SequenceCtr, @PrevId:=users_id
FROM atable
CROSS JOIN (SELECT @Counter:=0, @PrevId:=0) Sub1
ORDER BY users_id, date) AS tbl1
LEFT OUTER JOIN (SELECT users_id, date, @Counter:=IF(users_id = @PrevId, @Counter + 1, 1) AS SequenceCtr, @PrevId:=users_id
FROM atable
CROSS JOIN (SELECT @Counter:=0, @PrevId:=0) Sub1
ORDER BY users_id, date) AS tbl2
ON tbl1.users_id = tbl2.users_id
AND tbl1.SequenceCtr + 1 = tbl2.SequenceCtr
AND tbl2.date > DATE_ADD(tbl1.date, INTERVAL 5 DAY)
GROUP BY tbl1.users_id;

SELECT REPLACE('052-12525', '-', ''), FORMAT(12332.1,0)

CREATE OR REPLACE PROCEDURE PR_SHOWVALUES 
(
  PRMROWMIN IN NUMBER  
, PRMROWMAX IN NUMBER  
, PRMORDERCOL IN VARCHAR2  
, PRMORDERDIR IN VARCHAR2  
, CURSORRESULT OUT SYS_REFCURSOR
) AS 
BEGIN

  open CURSORRESULT for
    select * from (
      select rownum r, v.* from 
          (
            select * from
            (
              select * from table1 tbl
              order by decode
              (
                UPPER(PRMORDERCOL),
                'COLUMNA', LOWER(tbl.COLUMNA),
                'COLUMNB', LOWER(tbl.COLUMNB),
                LOWER(tbl.TABLE1_ID)
              )
            )
            ORDER BY
              CASE
                WHEN UPPER(PRMORDERDIR) = 'DESC' THEN
                  ROWNUM * -1
                ELSE
                  ROWNUM
              END    
          ) v
    )
    where r >= PRMROWMIN and r <= PRMROWMAX;

END PR_SHOWVALUES;

CASE 
WHEN (ci.aDate - pa.Date) < 0 THEN  ci.LimitUS
WHEN (ci.lim - pa.Payment) < 0 THEN 'a'
ELSE 'b'

SELECT Name, MIN(Date) AS StartDate, MAX(Date) AS EndDate, SUM(Points)
FROM people
WHERE Date between to_date ('2003/01/01', 'yyyy/mm/dd')
AND to_date ('2003/12/31', 'yyyy/mm/dd') 
GROUP BY name
ORDER BY Points;

SELECT CASE WHEN cli.rownum = 1 THEN cli.lastName END AS lastName
,CASE WHEN cli.rownum = 1 THEN cli.firstName END AS firstName
,CONVERT(varchar(10),cli.apptDate,101) AS 'apptDate'
,cli.myStartTime
,cli.myEndTime

FROM 

(SELECT c.ID
    ,c.lastName
    ,c.firstName
    ,r.apptDate
    ,r.myStartTime
    ,r.myEndTime
    ,ROW_NUMBER() OVER (PARTITION BY c.ID ORDER BY c.ID, r.apptDate, r.myStartTime) as rownum

    FROM clients c
    LEFT OUTER JOIN tblReservation r
    ON c.clientID = r.clientID
    LEFT OUTER JOIN tblVisitTypes vt
    ON vt.TypeID = r.VisitType) 
cli

ORDER BY cli.ID, cli.rownum

declare @dateto as datetime
set @dateto='8/1/11'

SELECT 
    CASE WHEN Ordercount >= 360 THEN '360 or More'
         WHEN Ordercount = 1 THEN '1 trans'
         ELSE CAST (30 * FLOOR(Ordercount / 30) AS VARCHAR) + '-' + CAST (30 * CEILING (Ordercount / 30) AS VARCHAR)
    END grp,
    COUNT(*) userkeycount,
    SUM(SumOfOrders) SumOfOrders
FROM (
    SELECT ti.userkey,
        SUM(l.Price * l.OrderQty) AS SumOfOrders,
        count (distinct ti.orderid) AS Ordercount
    FROM         SOLine AS l WITH (nolock) LEFT OUTER JOIN
                 SOImported AS ti ON ti.OrderId = l.OrderId LEFT OUTER JOIN
                 Sale AS o ON o.SaleId = ti.Inventory_Id
     Where ti.createddate < @DateTo
     GROUP BY ti.userkey
) rs
GROUP BY CASE WHEN Ordercount >= 360 THEN '360 or More'
         WHEN Ordercount = 1 THEN '1 trans'
         ELSE CAST (30 * FLOOR(Ordercount / 30) AS VARCHAR) + '-' + CAST (30 * CEILING (Ordercount / 30) AS VARCHAR)
    END

GROUP BY  user_messages.messageid,
          user_messages.message,
          user_messages.sentby,
          user_messages.visibility

SELECT *
FROM YourTable A
WHERE NOT EXISTS(SELECT 1 FROM YourTable
                 WHERE InspectionID = A.InspectionID  
                 AND ComponentID = A.ComponentID
                 AND RatingTypeID = 6)

select t1.*,
       (case when cumecap <= t2.item_amount 
             then t1.capacity
             when cumecap - t1.capacity <= t2.item_amount
             then t2.item_amount - (cumecap - t1.capacity)
             else 0
        end) as allocated_capacity
from (select t1.*,
             sum(t1.capacity) over (partition by bag_type order by bag_id) as cumecap
      from t1
     ) t1 join
     t2
     on t1.bag_type = t2.item_type;

select count(1) from mysql.PRSSTATE where (BLOCKER  is NULL or BLOCKER = "");

SELECT name, modify_date
FROM sys.objects
where col = value and datecol >= datevalue and
      col not in ('Value1', 'Value2', 'Value3')
order by xxxx;

select * from ABC WHERE MY_ID between 3 and 8

WITH q AS (
    SELECT name, ts::date AS day
          ,avg(x) AS avg_x, sum(y) AS sum_y
          ,row_number() OVER (PARTITION BY name ORDER BY ts::date) AS rn
    FROM   data
    GROUP  BY 1,2
   )
SELECT q1.name, q1.day, q1.avg_x, q1.sum_y
      ,q2.day AS day2, q2.avg_x AS avg_x2, q2.sum_y AS sum_y2
FROM   q      q1
LEFT   JOIN q q2 ON q1.name = q2.name 
                AND q1.rn   = q2.rn + 1
ORDER  BY 1,2;

SELECT
  cc.[Customer_ID]
    ,[Account_Number]
    ,[First_Name]
    ,[Middle_Name]
    ,[Last_Name]
    ,[Password]
 ,ce.[Email]
 ,cph.Phone_Number
 ,ca.Address_1
 ,ca.Address_2
 ,ca.City
 ,ca.State
 ,ca.Zip
 ,tp.Type_Desc
 ,te.Type_Group + '-' + te.Type_Value as [EmailType]
 ,ta.Type_Group + '-' + ta.Type_Value as [AddressType]
 ,tph.Type_Group + '-' + tph.Type_Value as [PhoneType]

 FROM [CustomerPortal].[dbo].[Customer] cc WITH (NOLOCK) 

left join [CustomerPortal].[dbo].Customer_Email ce WITH (NOLOCK) on cc.Customer_ID =    ce.Customer_ID
left join [CustomerPortal].[dbo].Customer_Address ca WITH (NOLOCK) on cc.Customer_ID =cp.Customer_ID
left join [CustomerPortal].[dbo].Customer_Phone cph WITH (NOLOCK) on cc.Customer_ID =cph.Customer_ID
left join [dbo].Type_Table te on te.ID = ce.Type
left join [dbo].Type_Table ta on ta.ID = ca.Type
left join [dbo].Type_Table tph on tph.ID = cph.Type

SELECT MerchantName
FROM   Merchant
WHERE  NOT EXISTS (SELECT 1
                   FROM   Member
                   WHERE  Member.MemberId = Merchant.MemberId AND 
                          ReportId = 111) 

$query = "SELECT a.ID, a.ProductName, b.ID, b.Product, b.Partnerm, case when b.id is null then 0 else 1 end
FROM table_1 a
LEFT JOIN table_2 b
ON a.ID = b.ID and b.Partner = 21"

DELETE FROM myTable WHERE myColumn IS NULL OR trim(myColumn) = '';

select calcdate from
(
select startDate, endDate,
       decode (:pValue,1,
               select sysdate from dual,
               select activation_date from account where AcNo = 1234) as calcdate
)
where calcdate between startDate and endDate;

use Symfony\Component\Serializer\Serializer;
use Symfony\Component\Serializer\Encoder\XmlEncoder;
use Symfony\Component\Serializer\Encoder\JsonEncoder;
use Symfony\Component\Serializer\Normalizer\GetSetMethodNormalizer;

$encoders = array(new XmlEncoder(), new JsonEncoder());
$normalizers = array(new GetSetMethodNormalizer());

$serializer = new Serializer($normalizers, $encoders);

$person = new Acme\Person();
$person->setName('foo');
$person->setAge(99);

$jsonContent = $serializer->serialize($person, 'json');

// $jsonContent contains {"name":"foo","age":99}

select a.refnumber,
       c.firstname,
       c.lastname,
       c.company,
       a.registrationtype,
       b.yesnoentry
from reg a, reg b, regperson c
  where a.refnumber=b.refnumber
  and a.regpersonid=c.regpersonid
  and a.registrationtype !=''
  and b.yesnotoggle=1
  and b.yesnoentry=1;

ALTER FUNCTION FN_EMPCHECK
(
    @EmailAddress VARCHAR(150),
    @methodID INT
)
RETURNS INT
AS
BEGIN
    DECLARE @IsResult INT

    IF(@methodID = 101)
    BEGIN
        SELECT @IsResult = ID FROM table1 WHERE EmailAddress = @EmailAddress
    END
    ELSE IF(@methodID IN (102, 104, 105, 107, 108, 109, 110, 111, 114))
    BEGIN
        SELECT @IsResult = ID FROM table2 WHERE EmailAddress = @EmailAddress
    END
    ELSE IF(@methodID IN (103 ,106, 112, 113))
    BEGIN
        SELECT @IsResult = ID FROM table3 WHERE EmailAddress = @EmailAddress
    END

    RETURN @IsResult
END

SELECT t2.value1, t2.value2
FROM Table1 t1
    INNER JOIN Table3 t3 ON t1.key_id = t3.table1_id
    INNER JOIN Table2 t2 ON t3.table2_id = t2.key_id
WHERE t1.key_id = [your value]

set @path='F:\'+@dbName +'-'+convert(varchar(50),getdate(),112)+'.bak'

@pre_data=MgMultiSelect.where(:mg_details_id=>params[:id])

@selected_data=params[:team_id_new]
if params[:team_id_new].present?

  params[:team_id_new].each do |id|
   obj = @pre_data.where(:team_id_new => id).first
   if obj.present?
    obj.update_attributes(:mg_details_id => @task_data.id,:is_deleted => 0 )
   end
  end
end

select InitialTime, 
       max(case when seqnum_forward = 1 then EventType end),
       max(case when seqnum_backward = 1 then EventType end)
from (select t.*,
             row_number() over (partition by InitialTime order by EventTime desc) as seqnum_backward,
             row_number() over (partition by InitialTime order by EventTime asc) as seqnum_forward
      from table t
     ) t
group by InitialTime;

is not null

ALTER TABLE SillyTable ADD FirstInitial char(1), LastName varchar(50);

INSERT INTO SillyTable(FirstInitial, LastName) 
SELECT SUBSTRING(NameColumn, 1, 1), SUBSTRING(NameColumn, 3, LEN(NameColumn) - 2)
FROM SillyTable;

SELECT LastName + ' ' + FirstInitial AS WhatMyBossWantsToday FROM SillyTable;

Dim cnn As Object
Dim lngRow As Long
Dim lngID As Long, LR As Long, Upd As Long
Dim strID As String

LR = ThisWorkbook.Worksheets("Sheet2").Range("B" & Rows.Count).End(xlUp).Row
Upd = LR - 1
lngRow = 2

Set cnn = CreateObject("ADODB.Connection")
cnn.Open "Provider=Microsoft.ACE.OLEDB.12.0;" & _
    "Data Source=\Work\Sites\HLAA\NEW\test\HLAA 2015 NEW.mdb;" & _
    "Persist Security Info=False;"

Do While lngRow <= LR
    strID = ThisWorkbook.Worksheets("Sheet2").Cells(lngRow, 2).Value

    cnn.Execute "UPDATE Tbl_Primary SET MonitorCapacity = '" & _
        ThisWorkbook.Worksheets("Sheet2").Cells(lngRow, 74).Value2 & _
        "' WHERE RTP_ID2 = '" & strID & "'"

    lngRow = lngRow + 1

Loop
MsgBox "You just updated " & Upd & " records"

waveFile='Chick_eco.wav';

[y, fs, nbits]=wavread(waveFile);

subplot(2,2,1); plot(y); legend('Original signal');

startIndex=15000;
WindowSize=100;
endIndex=startIndex+WindowSize-1;
frame = y(startIndex:endIndex);

nframe=length(frame)

%find the peaks 

peaks = zeros(nframe,1);

k=3;

while(k <= nframe - 1)
    y1 = frame(k - 1);
    y2 = frame(k);
    y3 = frame(k + 1);
    if (y2 > 0)
    if (y2 > y1 && y2 >= y3)
        peaks(k)=frame(k);
    end
    end
    k=k+1;
end



peaks2=peaks;
peaks2(peaks2<=0)=nan;


subplot(2,2,2); plot(frame); legend('Get Window Length = 100');


subplot(2,2,3); plot(peaks); legend('Where are the PEAKS');



subplot(2,2,4); plot(frame); legend('Peaks in the Window');
hold on; plot(peaks2, '*');


for j = 1 : nframe
if (peaks(j) > 0)
     fprintf('Local=%i\n', j);
     fprintf('Value=%i\n', peaks(j));   

end
end


%Where the Local Maxima occur
[maxivalue, maxi]=max(peaks)

SELECT Object.ID, (SELECT name FROM Gloss G WHERE G.object_id = X.object_id AND G.order = X.ord) AS [GlossName],
    X.order, Title.name 
FROM Object
LEFT OUTER JOIN
    (SELECT object_id, MIN(order) ord FROM Gloss GROUP BY object_id) X
ON X.object_id = Object.ID
LEFT OUTER JOIN Title on Title.object_id = Object.ID

SELECT ownerid, zip, vin, make, model 
FROM 
(
SELECT ownerid, zip, vin, make, model, count(*) over (partition by ownerid, make, model) cnt FROM listing 
WHERE (ownerid, upper(make)) 
IN (SELECT dealership, attribute FROM ownerproduct WHERE productid = 'FRONT_LISTING')
AND new = 'Y'
)
WHERE cnt > 3
ORDER BY DBMS_RANDOM.RANDOM );

DECLARE @cono INT
DECLARE @repno NVARCHAR(10)
DECLARE @date DATETIME
DECLARE @count INT
DECLARE @closedOn DATETIME

DECLARE cur CURSOR FOR 

SELECT  '1' AS PPCONO,
        b.new_SalesrepId AS PPREP1,
        MAX(CONVERT(VARCHAR(8), (d.ScheduledStart - c.TimeZoneBias / CAST(24 * 60 AS FLOAT)), 112)) AS PPDATE,
        COUNT(b.new_SalesrepId) AS PPCOUNT,
        MAX(CONVERT(VARCHAR(8), (a.ActualEnd - c.TimeZoneBias / CAST(24 * 60 AS FLOAT)), 112)) AS ClosedOn
        FROM ActivityPointerBase AS a
            join SystemUserExtensionBase AS b ON b.SystemUserId = a.OwnerId
            join UserSettingsBase AS c ON c.SystemUserId = b.SystemUserId
            join ActivityPartyBase AS d ON d.ActivityId = a.ActivityId
                WHERE   b.new_SalesrepId <> '99999999'
                        and a.ActivityTypeCode = '4201'
                        and b.new_SalesrepId is not NULL
                        and a.StateCode = '1'
                        and d.ParticipationTypeMask = '9'
                        and CONVERT(varchar(8), a.ActualEnd - c.TimeZoneBias / cast(24 * 60 as float), 112) >= dateadd(day,datediff(day,1,CONVERT(varchar(8), GetDate(), 112)),0) 
                        and CONVERT(varchar(8), a.ActualEnd - c.TimeZoneBias / cast(24 * 60 as float), 112) < dateadd(day,datediff(day,0,CONVERT(varchar(8), GetDate(), 112)),0)
                        /* and CONVERT(VARCHAR(8), a.ActualEnd - c.TimeZoneBias / CAST(24 * 60 AS FLOAT), 112) < CONVERT(VARCHAR(8), GETDATE(), 112) */
                            group by    b.new_SalesrepId, 
                                        CONVERT(varchar(8), (d.ScheduledStart - c.TimeZoneBias / cast(24 * 60 as float)), 112)
                                            order by    b.new_SalesrepId ASC;

OPEN cur;

FETCH NEXT FROM cur INTO @cono, @repno, @date, @count, @closedOn

WHILE (@@FETCH_STATUS=0)
BEGIN

    IF EXISTS (SELECT 1 FROM [AS400].S062f7ar.APLUS83MDS.PEPAPPTS01 WHERE PPCONO = @cono and PPREP1 = @repno and PPDATE = @date)
    BEGIN
        UPDATE  [AS400].S062f7ar.APLUS83MDS.PEPAPPTS01
        SET     PPCOUNT = PPCOUNT + @count
        WHERE   PPCONO = @cono
            and PPREP1 = @repno
            and PPDATE = @date
    END
    ELSE
    BEGIN
        INSERT INTO [AS400].S062f7ar.APLUS83MDS.PEPAPPTS01
        (PPCOUNT, PPCONO, PPREP1, PPDATE) 
        VALUES
        (@count, @cono, @repno, @date)  
    END

    FETCH NEXT FROM cur INTO @cono, @repno, @date, @count    

END    

CLOSE cur
DEALLOCATE cur

if you don't have a specific reason to use GUIDs, use INTs.

Set oQuery = WorkBooks("Book 1").Sheets("Sheet 1").ListObjects(1).QueryTables(1)

insert into B (UPDATE_FILE, RUN_DATE, CREATED_DATE) 
SELECT UPDATE_FILE, RUN_DATE,now() from A 

public Cursor graphQuery(String exercise, String workout) {
     Cursor cursor = mDb.query(DATABASE_TABLE, new String [] {KEY_DATE, KEY_REPS,       
         KEY_REPS_FEEL, KEY_WEIGHT, KEY_WEIGHT_FEEL}, "KEY_WORKOUT = ? AND KEY_EXERCISE = ?",
         new String[] { workout, exercise },
         null,
         null,
         KEY_DATE); 

     return cursor;
}

WITH T1 AS (
    SELECT DATEPART(WEEKDAY,start_date) AS weekday
    FROM attend
    WHERE empl_no = 12345
)
SELECT
    (SELECT COUNT(*) FROM T1) AS total,
    (SELECT COUNT(*) FROM T1 WHERE weekday = 2 OR weekday = 6) AS subset

SELECT      t.A,
            t.B
FROM        my_table t
LEFT JOIN   my_table t2
        ON  t.A = t2.B
        AND t.B = t2.A
        AND t.A < t.B
WHERE       t2.A IS NULL

select id, sum(value) from (
    select id, value from table1
    union all select id, value from table2
    union all select id, value from table3
) t group by id

SELECT t.ename, t.deptno, mx.sal as sal, mx.avg_sal as avg_sal
FROM tbl t, 
  (SELECT MAX(sal) AS sal, AVG(sal) AS avg_sal, deptno
   FROM tbl
   GROUP BY deptno) mx
WHERE t.deptno = mx.deptno AND t.sal = mx.sal

SELECT dim1                AS Costc,
       period              AS Period,
       sum(actual)         AS Beds,
       isnull(SUM(CASE
                    WHEN measure LIKE 'beds%' THEN actual
                  END), 0) AS BEDS,
       isnull(SUM(CASE
                    WHEN measure LIKE 'occu%' THEN actual
                  END), 0) AS OCCU
FROM   statistics
WHERE  measure IN (SELECT measure
                   FROM   cukstats
                   WHERE  measure LIKE 'beds%'
                           OR measure LIKE 'occu%')
       AND dim1 = 'ABC'
       AND period = '201301'
GROUP  BY period,
          dim1 

SELECT a.customer, count(a.sale), max_sale
FROM sales a
INNER JOIN (SELECT customer, sale max_sale 
            from sales x where dates = (select max(dates) 
                                        from sales y 
                                        where x.customer = y.customer
                                        and y.sale > 0
                                       )

           )b
ON a.customer = b.customer
GROUP BY a.customer, max_sale;

select o.callId , o.timestamp , o.duration ,o.callNote ,
o.state,o.contactId,
  j.firstName , j.lastName ,j.company Id as company,
  j.email, j.contactNote,

r.number

from calls o 
left outer join contacts j 
  on o.contactId =j.contactId  
left outer join numbers r 
  on j.contactId=r.contactId;

select g_id, s_id, g_name, g_no, l_name
from g
left outer join s on s.g_id = g.g_id
left outer join l on l.l_id = s.l_id
where s_id is null or (s_id is not null and l_name = 'test')

SELECT
  rea.id,
  MAX(CASE WHEN rej.rejection_rowId = '1' THEN rej.rejection_code END) AS rejection1,
  MAX(CASE WHEN rej.rejection_rowId = '2' THEN rej.rejection_code END) AS rejection2,
  MAX(CASE WHEN rej.rejection_rowId = '3' THEN rej.rejection_code END) AS rejection3,
FROM
  reason rea
  INNER JOIN rejection rej ON rea.rowId = rej.rowId
WHERE
  rea.id = '12345'
GROUP BY rea.id

select
      gtl3.*
   from
      SELECT
            gtl2.username,
            min( gtl2.id ) as FirstGameTimeIDWithCommonHighPoint
         from
            ( select
                    gtl.username,
                    MAX( gtl.point ) as highestPointPerUser
                 from
                    game_toplist gtl
                 group by
                    gtl.username
                 order by 
                  MAX( gtl.point ) DESC
                 limit 100 ) as Top100
              JOIN game_toplist gtl2
                 ON Top100.username = gtl2.username
                 AND Top100.highestPointPerUser = gtl2.point ) as SinglePerUser
         join game_toplist gtl3
            on SinglePerUser.username = gtl3.username
           AND SinglePerUser.FirstGameTimeIDWithCommonHighPoint = gtl3.ID
   order by
      gtl3.point DESC

ALTER PROCEDURE [dbo].[isp_CompetitionSummary_GenerateByMatches]
@CompetitionId varchar(4),
@Matches int
AS
BEGIN
SELECT
@CompetitionId AS CompetitionId,
Sum(HomeGoals) AS HomeGoals,
Sum(AwayGoals) AS AwayGoals,
Sum(HalfTimeHomeGoals) AS HalfTimeHomeGoals,
Sum(HalfTimeAwayGoals) AS HalfTimeAwayGoals,
Sum(HomeTeamCorners) AS HomeCorners,
Sum(AwayTeamCorners) AS AwayCorners,
Sum(HomeTeamFouls) AS HomeFouls,
Sum(AwayTeamFouls) AS AwayFouls,
Sum(HomeTeamYellows) AS HomeYellows,
Sum(AwayTeamYellows) AS AwayYellows,
Sum(HomeTeamReds) AS HomeReds,
Sum(AwayTeamReds) AS AwayReds,
AVG(CAST(HomeGoals AS FLOAT)) AS AvgHomeGoals,
AVG(CAST(AwayGoals AS FLOAT)) AS AvgAwayGoals,
AVG(CAST(HalfTimeHomeGoals AS FLOAT)) AS AvgHalfTimeHomeGoals,
AVG(CAST(HalfTimeAwayGoals AS FLOAT)) AS AvgHalfTimeAwayGoals,
AVG(CAST(HomeTeamCorners AS FLOAT)) AS AvgHomeCorners,
AVG(CAST(AwayTeamCorners AS FLOAT)) AS AvgAwayCorners,
AVG(CAST(HomeTeamFouls AS FLOAT)) AS AvgHomeFouls,
AVG(CAST(AwayTeamFouls AS FLOAT)) AS AvgAwayFouls,
AVG(CAST(HomeTeamYellows AS FLOAT)) AS AvgHomeYellows,
AVG(CAST(AwayTeamYellows AS FLOAT)) AS AvgAwayYellows,
AVG(CAST(HomeTeamReds AS FLOAT)) AS AvgHomeReds,
AVG(CAST(AwayTeamReds AS FLOAT)) AS AvgAwayReds
FROM (
  SELECT TOP (@Matches) *
  FROM dbo.Match
  INNER JOIN dbo.MatchDetail ON dbo.Match.Id = dbo.MatchDetail.MatchId
  WHERE Div = @CompetitionId
  ORDER BY [Date] DESC
) x

constraint CCNumber_no_CCType check((CCNumber is null) or (CCType is not null))

SELECT SUM(homescore > awayscore) AS won,
   SUM(homescore < awayscore) AS lost,
   SUM(homescore = awayscore) AS tie
FROM ...

SELECT  
    (
        CAST(DATEPART(HOUR, m.Ocr_DataHora) AS NVARCHAR) +
        ':' +
        CAST((DATEPART(MINUTE, m.Ocr_DataHora) % 6) AS NVARCHAR) +
        '0'         
    )                                                  AS Hora,
    COUNT(*)                                           AS Movimentações,
    COUNT(CASE WHEN s.Veiculo_Modelo <> '' THEN 1 END) AS Sucesso
FROM
    Integracao m
WHERE
        m.Ocr_DataHora      >=  '2012-09-17 00:00:00.000'
    AND m.Ocr_DataHora      <   '2012-09-18 00:00:00.000'
GROUP BY        
    DATEPART(HOUR, m.Ocr_DataHora),
    (DATEPART(MINUTE, m.Ocr_DataHora) % 6)
ORDER BY    
    DATEPART(HOUR, m.Ocr_DataHora),
    (DATEPART(MINUTE, m.Ocr_DataHora) % 6)

select DISTINCT ON (tweet.id) tweet.id, tweet.content, tweet.username, tweet.geometry
from tweet
where
    tweet.topic_indicator > 0.15::double precision
    and (
        select count(distinct word)
        from
            unnest(
                array['test', 'god', 'safe', 'name', 'hello', 'pray', 'stay', 'word', 'peopl', 'rain', 'lord', 'make', 'life', 'hope', 'whatever', 'makes', 'strong', 'stop', 'give', 'television']::text[]
            ) s(word)
            inner join
            regexp_split_to_table(lower(tweet.content), ' ') v (word) using (word)
    ) >= 2

select id, status, user_id, created_at from
 (select id, status, user_id, created_at,
         (case when @user_id != user_id then 'true' else 'false' end) as user_changed,
         (case when @status  != status then 'true' else 'false' end) as status_changed,
         (case when @user_id != user_id then @user_id := user_id end) as new_user_id,
         (case when @status  != status then @status := status end) as new_status
  from (select * from logs order by user_id asc, created_at desc) l
   join (select @user_id := 0) u
   join (select @status := 0) s) q
where user_changed = 'true' or status_changed = 'true'
order by id
;

SELECT *
FROM `line` 
ORDER BY xi*xi + yi*yi
Limit 100

SELECT *
FROM database.sys.all_objects
WHERE upper(name) like upper('my prefix%')  --use UPPER for case-INsensitivity

SELECT * FROM table_name 
WHERE column_name like '%value%' and column_name like '%second_value%'

SELECT [group_ID]
FROM Table1 T
WHERE [tax_Id] in (2,3,4)
And not exists
( select 1 from Table1 E
Where T.group_id = E.group_id
And tax_id not in (2,3,4)
)
Group by group_id
Having count(distinct tax_id) =3

<xsl:template match="/">
  <xsl:apply-templates/>
</xsl:template>

<!-- match book explicitly ... -->
<xsl:template match="book">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>

    <!-- and add one "row" to the books content -->
    <one-more-row>value</one-more-row>
  </xsl:copy>
</xsl:template>

<!-- Just copy all the other elements/attributes (including book contents) -->
<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>

declare @ID int = 100001
declare @IsProcessed int

declare
  crsMy cursor fast_forward for
select
  distinct IsProcessed
from
  tTest
order by
  IsProcessed desc

open crsMy

fetch next from crsMy into @IsProcessed

while @@fetch_status = 0
begin
  select
    UNIQUEKEY
    ,ID
    ,Clicks
    ,IsProcessed
    ,INSERTDATE
  from
    tTest
  where
    (ID=@ID)
    and
    (IsProcessed=@IsProcessed)
  order by
    INSERTDATE desc



  fetch next from crsMy into @IsProcessed
end

close crsMy
deallocate crsMy

CREATE TABLE source (
       type CHAR(1) NOT NULL CHECK (type IN ('J', 'B')),
       id INT NOT NULL,
       PRIMARY KEY (type, id)
);

CREATE TABLE book (
       type CHAR(1) NOT NULL CHECK(type = 'B'), id INT NOT NULL,
       PRIMARY KEY (id),
       FOREIGN KEY (type, id) REFERENCES source (type, id) ON DELETE CASCADE
);

CREATE TABLE journal (
       type CHAR(1) NOT NULL CHECK(type = 'J'), id INT NOT NULL,
       PRIMARY KEY (id),
       FOREIGN KEY (type, id) REFERENCES source (type, id) ON DELETE CASCADE
);

CREATE TABLE scan (id INT NOT NULL, sourcetype CHAR(1) NOT NULL, sourceid INT NOT NULL,
       PRIMARY KEY (id),
       FOREIGN KEY (sourcetype, sourceid) REFERENCES source (type, id)
);

SELECT   Orders.orderNumber,
         Orders.customerId,
         Orders.orderDate,
         Orders.beenSupplied,
         Orders.purchaseDate,
         SUM(OrderItems.itemQuantity * Items.itemPrice) AS orderValue,
         SUM(OrderItems.itemQuantity)                   AS orderItemQuantity
FROM     Orders
    JOIN OrderItems USING (orderNumber)
    JOIN Items      USING (itemID)
WHERE    Orders.customerId   = 1
     AND Orders.beenSupplied = 1
GROUP BY Orders.orderNumber

INSERT INTO tablename (column names)
OUTPUT --this is where you put your select statement to get returned IDs etc.
VALUES (values in here, or you can use a select statememt as per usual)

    SELECT  t1.user1, t1.user2, 0 AS calling_calling, 0 AS calling_called, 0 AS called_calling, 0 AS called_called, COUNT(*) AS both_directions
 FROM   (SELECT monthly_connections_test.calling_party AS user1, monthly_connections_test_1.calling_party AS user2, monthly_connections_test.called_party AS calledUser
FROM         monthly_connections_test INNER JOIN
                      monthly_connections_test AS monthly_connections_test_1 ON 
                      monthly_connections_test.called_party = monthly_connections_test_1.called_party AND 
                      monthly_connections_test.calling_party < monthly_connections_test_1.calling_party) t1 
                      INNER JOIN monthly_connections_test AS monthly_connections_test_2 ON
                      monthly_connections_test_2.called_party = t1.user1
                      AND monthly_connections_test_2.calling_party = t1.calledUser

insert into mytable (col1, col2)
  values (1, 2),
         (3, 4),
         (5, 6)

SELECT user_id
     , SUM(points_won) - 1000 * COUNT(*) AS net_points
  FROM race_weeks
 WHERE recordable_type = 'User'
   AND (races_won > 0 OR races_lost > 0 OR races_tied > 0)
 GROUP BY user_id
 ORDER BY net_points DESC

select *
from dual
where (1 = 1)
      and (sysdate + 1 > sysdate)
      and case
            when i_value = 'S'
              then
                case
                  when (25 < 35)
                    then 1
                    else 0
                end
            when i_value = 'T'
              then
                case
                  when (30 > 40)
                    then 1
                    else 0
                end
          end = 1;

SELECT your_column, other_col
FROM your_table
WHERE your_column = ?

select e.*
from example e
where e.date >= (select max(e2.date) from example e2 where e2.date <= @v_from) and
      e.date <= @v_to;

SELECT t1.tag as tag, t2.tag as tag2, count(*)
FROM tags t1 join
     tags t2
     on t1.text_id = t2.text_id and t1.tag < t2.tag
GROUP BY t1.tag, t2.tag
ORDER BY count(*) desc;

(my_date - to_date('01/01/1970','DD/MM/YYYY')) * 86400

$first = $this->model->from('locations as one')
                     ->where('one.parent_id', '=', 0)
                     ->select('one.name'
                           , 'one.id'
                           , 'one.name AS sortkey1'
                           , DB::raw('CAST(NULL AS UNISIGNED) AS sortkey2')
                           , DB::raw('CAST(NULL AS UNISIGNED) AS sortkey3'));

INSERT INTO process (user_id,ads_id,medialist_id,`status`) SELECT 'your_uid','your_ads_id',id,'your_status' FROM medialist WHERE id NOT IN (SELECT medialist_id FROM process) ORDER BY RAND() LIMIT 1

select
    c.id,
    c.date,
    v.year,
    v.author
from
   cars c
   inner join versions v on
       c.id = v.id_car
   inner join (
        select 
            id_car, 
            max(year) as latestYear 
        from 
            versions 
        group by 
            id_car
    ) vmax on
       c.id = vmax.id_car
       and v.year = vmax.latestYear
where
   v.author = 'Carl'
   and c.date = '2012-01-04'

UPDATE TableA 
SELECT TableA.Col1 = t2.Col1, TableA.Col2 = TableB.Col
FROM TableA t2
INNER JOIN TableB ON ...

SELECT logid, transactionid, partid, qty, refid
FROM (
  SELECT logid, transactionid, partid, qty, refid,
         LAG(partid) OVER (ORDER BY logid) AS prev_partid,
         LAG(refid) OVER (ORDER BY logid) AS prev_refid,  
         LEAD(partid) OVER (ORDER BY logid) AS next_partid,
         LEAD(refid) OVER (ORDER BY logid) AS next_refid
  FROM mytable
  WHERE transactionid = 3) AS t
WHERE (partid = next_partid AND refid <> 0 AND next_refid = 0) OR
      (partid = prev_partid AND refid = 0 AND prev_refid <> 0)

SELECT emailaddress
      ,MAX(CASE WHEN cast(siteid AS varchar(max))= '1' THEN 1 ELSE 0 END) AS site1
      ,MAX(CASE WHEN cast(siteid AS varchar(max))= '2' THEN 1 ELSE 0 END) AS site2
FROM Users u
JOIN Users_Sites us
   ON u.user_id = us.user_id  --No idea what your actual join criteria should be.
GROUP BY emailaddress

DECLARE @counter INT=0
DECLARE @Text NVARCHAR(MAX)
SET @Text = '<tag><![CDATA[' + 'Test' + CHAR(28) + CHAR(55) + CHAR(29) + '<' + ']]></tag>' -- CHAR(28) --CHAR(8) -- CHAR(29) -- CHAR(63) 
WHILE @counter<32
BEGIN
SET @text= REPLACE(@text,CHAR(@counter),'?')
SET @counter=@counter+1
END
SELECT CAST(@Text AS XML)

with s as (
    select
        id,
        unnest(taglist) as tag,
        array_length(taglist, 1) as l
    from  tags
)
select a.tag as tag1, b.tag as tag2, count(*)
from
    s a
    inner join
    s b on
        a.id = b.id
        and
        (
            a.tag < b.tag
            or
            (
                a.tag = b.tag
                and
                1 = all(array[a.l, b.l])
            )
        )
group by a.tag, b.tag
order by a.tag, b.tag
;
 tag1 | tag2 | count 
------+------+-------
 A    | A    |     1
 A    | B    |     1
 A    | C    |     2
 A    | D    |     3
 B    | C    |     1
 B    | D    |     2
 C    | D    |     2
 D    | D    |     2

SELECT dateadd(mi, (datediff(mi, 0, StartDT) / 30) * 30, 0) as HalfHour
       , sum(DATEDIFF ( s , [StartDT] , [EndDT] )) as SumTotal
FROM Radio.dbo.Sheet1
GROUP BY dateadd(mi, (datediff(mi, 0, StartDT) / 30) * 30, 0) 
ORDER BY 1

CREATE VIEW myView AS 
SELECT add_date,
    t1.somecolumn col1,
    NULL col2,
    NULL col3
FROM t1
UNION ALL
SELECT
    add_date,
    NULL col1,
    t2.anothercolumn col2,
    NULL col3
FROM t2
UNION ALL
SELECT
    add_date,
    NULL col1,
    NULL col2,
    t3.yetanothercolum col3
FROM t3

SELECT table.column FROM table WHERE INSTR(table.column, "String", 0) > 0

$sql = $this->db->insert_string('YourTable', $data) . ' ON DUPLICATE KEY UPDATE duplicate=duplicate+1';
$this->db->query($sql);
$id = $this->db->insert_id();

SET NOCOUNT ON;

DECLARE 
      @x INT
    , @count INT

SELECT 
      @count = COUNT(1)
    , @x = 1 
FROM dbo.tbl_SystemStatisticsOverhaul

IF EXISTS(
    SELECT 1
    FROM tempdb.dbo.sysobjects
    WHERE ID = OBJECT_ID('tempdb..#import')
) DROP TABLE #import;

SELECT [column], RowNumber = ROW_NUMBER() OVER (ORDER BY id)
INTO #import
FROM dbo.tbl_SystemStatisticsOverhaul

WHILE @x < @count BEGIN

    INSERT INTO dbo.tbl_SystemStatistics ([column])  
    SELECT [column]
    FROM #import 
    WHERE RowNumber BETWEEN @x AND @x + 9

    SELECT @x = @x + 10

END

AND (state != 'PENDING' OR state IS NULL)

declare @Table SYSNAME;
declare @cols nvarchar(max);
declare @sql nvarchar(max); 

 SET @Table = N'TableName';

select @cols = stuff(
    (select ',' + quotename(name)   
     from sys.columns 
     where object_id=object_id(@Table) 
     and name like 'Subsequent%'
     for xml path(''), type)
    .value('.', 'nvarchar(max)'),1,1,'') 

set @sql = N'select ' + @cols + N' from '+ QUOTENAME(@Table)
exec sp_executesql @sql

SELECT qCP.*
FROM (SELECT RollNum, CGPA, Status, Name, FinalGrade
      FROM db
      WHERE Name = 'Computer Programming' 
      AND FinalGrade = 'A') qCP
INNER JOIN 
    (SELECT RollNum 
     FROM db 
     WHERE Name = 'Introduction to Computer Science' 
     AND FinalGrade = 'A') qIntro
ON qCP.RollNum = qIntro.RollNum

String[] selection = new String[]{ getUri().toString() };
Cursor meta = mContext.getContentResolver().query(Meta.Data.CONTENT_URI, null, Meta.Data.URI + "=?", selection, null);

SELECT PERSONID FROM T_PERSON WHERE 
    CCODE = (
        CASE WHEN @CCODE = 'ALL'  THEN CCODE
        ELSE @CCODE END
        )
    AND
    EMPCODE = (
        CASE WHEN @EMPCODE = 'ALL'  THEN EMPCODE
        ELSE @EMPCODE
        END
        )

select distinct r.ruleid,
                r.name,
                r.age,
                h.col2 
from hash h
join rule r on r.ruleId = h.ruleId
where not exists
( 
select 1 
from rule rr 
where rr.ruleId = h.ruleId
  and rr.state <>  h.state
)

select t1.Name as AccessPolicyName,
    t2.Name as DocumentName,
    ap.TermID as AccessPolicyTermID,
    d.TermID as DocumentTermID,
    d.UserName,
    ap.ValidFrom
from AccessPolicy ap
join Term t1 on t1.ID = ap.TermID
join Document d on d.someColumn = ap.someColumn -- don't know how policy and document are related?
join Term t2 on t2.ID = d.TermID

select case month(timestamp_iso(DATE))
        when 1 then 'January'
        when 2 then 'February'
        when 3 then 'March'
        when 4 then 'April'
        when 5 then 'May'
        when 6 then 'Jun'
        when 7 then 'July'
        when 8 then 'August'
        when 9 then 'September' 
        when 10 then 'October'
        when 11 then 'November'
        when 12 then 'December'
    end as Month,
    count (case when defect = 'TV' then 1 end) TV,
    count (case when defect = 'ADSL' then 1 end) ADSL,
    count (case when defect = 'IP' then 1 end) IP
from TABLE
where  STATUS='CLOSED'
group by month(timestamp_iso(DATE))
order by month(timestamp_iso(DATE))

CREATE TABLE #answers (UserTestID INT, QuestionID1 INT, AnswerID1 INT, QuestionID2 INT, AnswerID2 INT);

MERGE Table2
USING 
(  
    SELECT UserID
           ,TestID
           ,StartTime
           ,EndTime
           ,QuestionID1
           ,AnswerToQuestion1
           ,QuestionID2
           ,AnswerToQuestion2
    FROM Table1
) src ON (1=0)
WHEN NOT MATCHED THEN INSERT (UserID, TestID, StartTime, EndTime)
 VALUES (src.UserID, src.TestID, src.StartTime, src.EndTime
OUTPUT Inserted.UserTestID, src.QuestionID1, src.AnswerID1, src.QuestionID2, src.AnswerID2
INTO #answers(UserTestID, QuestionID1, AnswerID1, QuestionID2, AnswerID2);

INSERT INTO Table3
(
    UserTestID
    ,QuestionID
    ,AnswerID
)
SELECT UserTestID
    ,QuestionID1
    ,AnswerID1
FROM #answers
UNION
SELECT UserTestID
    ,QuestionID2
    ,AnswerID2
FROM #answers;

function getChanges(){
    var listItems=page.getListItems();
    var update;
    var datePublished;
    for(var i=0;i<listItems.length;++i){
        update=item[i].getLastUpdate();
        datePublished=item[i].getDatePublished();

        list of stuff to do like compare with the content of your database;
    }
}

create table t3 as 
  select * from 
    (select * from t1 where not exists (select 1 from T2 where T1col1=t2col1 and t1col2=t2col2)) M1,
    (select * from t2 where not exists (select 1 from T1 where T1col1=t2col1 and t1col2=t2col2)) M2
    where M1.t1col1=M2.t2col1;

SELECT @param = min(p.Value) + ' ' + max(p.Value)
FROM    Vendors v
JOIN    PConfig p ON v.VendorId = p.Vendor_Id
JOIN    ConfigItems c ON p.ConfigId = c.ConfigId 
WHERE   v.Description = @vendor
AND     ItemName IN ('XPS_Paid', 'XPS_UnPaid')

select * from (/* your SQL statement without "order by"*/) a order by a.message_id desc

SELECT name,capital FROM world
WHERE capital LIKE '%name&'

SET DATEFIRST 6;

SELECT *
FROM INFORMATION_SCHEMA.Table_Constraints tc
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
        ON tc.TABLE_NAME = kcu.TABLE_NAME
            AND tc.TABLE_SCHEMA = kcu.TABLE_SCHEMA
            AND tc.TABLE_CATALOG = kcu.TABLE_CATALOG
            AND tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
WHERE tc.TABLE_NAME = 'table_name'  

WITH MasterCount AS
(
   SELECT Master, Count(Detail) as D_Count, ROW_NUMBER() OVER () AS Ord
   FROM YourTableName
   GROUP BY Master
), MakeBuket AS
(
   SELECT Ord,D_Count AS Total_Count, Master, 1 AS Bucket
   FROM MasterCount
   WHERE Ord = 1
 UNION ALL
   SELECT Next.Ord, 
          CASE WHEN Last.Total_Count+Next.D_Count < @MaxSize 
               THEN Last.Total_Count+Next.D_Count 
               ELSE Next.D_Count END AS Total_Count,
          Master,
          CASE WHEN Last.Total_Count+Next.D_Count < @MaxSize 
               THEN Last.Bucket
               ELSE Last.Bucket+1 END AS Bucket
   FROM MakeBucket Last
   JOIN MasterCount Next ON Last.Ord = Next.Ord - 1
)
SELECT Master, Bucket 
FROM MakeBucket

SELECT top 10
C.ChangeSetId, 
V.FullPath, 
V.ParentPath, 
REPLACE(V.ChildItem,'\','') as [FileName], 
C.CreationDate, 
I.DisplayName,
C.Comment
FROM tbl_Version(nolock) V
INNER JOIN tbl_File (nolock) F ON V.ItemId = F.ItemId
INNER JOIN tbl_Changeset (nolock) C ON V.VersionTo = C.ChangeSetId
INNER JOIN tbl_Identity (nolock) I ON C.CommitterId = I.IdentityId
where v.ParentPath like '$\' + (select name from [TfsWorkItemTracking].[dbo].[treenodes] where parentid=0 and fdeleted=0 and id=524) + '\%'
order by C.CreationDate desc

Select p.*,r.*
from pc p
    inner join 
    Results r 
    on p.ID_pc = r.ID_pc
Where r.Code_reslt = (Select MAX(code_rslt) from results where ID_pc = p.ID_PC)

create table T_Test
(
  pk_test number(10),
  val     number(10)
)
partition by hash (val)
(
  partition p1,
  partition p2,
  partition p3

);

insert into t_test values (1,3);
insert into t_test values (2,2);
insert into t_test values (3,5);
insert into t_test values (5,6);
insert into t_test values (6,7);
insert into t_test values (7,4);

commit;

create index ix_test on t_test(val);

select partitioned from user_indexes where index_name = 'IX_TEST';
>> NO

WHERE 1 =
  CASE ISNUMERIC(@productId)
    WHEN 0 THEN
      CASE WHEN DTH.TaskId IS NULL OR PDT.PK_Product LIKE @productId THEN 1 END
    WHEN 1 THEN
      CASE WHEN DTH.TaskId IS NOT NULL AND PDT.PK_Product = @productId THEN 1 END
  END

DELETE Table
WHERE ID NOT IN (SELECT MIN(id)
                  FROM Table
                  GROUP BY gname, pname, value)

select
      case when cs(User-Agent) like "%android%" then "Android"
           when cs(User-Agent) like "%black%" then "Blackberry"
           when cs(User-Agent) like "%windows%" then "Windows"
           when cs(User-Agent) like "%iphone%" then "iPhone"
           else "Other" end as Browser,
      count(*) as TotalHits
   from
      YourTable.logFile
   group by
      Browser
   order by
      TotalHits desc

SELECT CASE 
         WHEN Count(*) >= 1 THEN 'true' 
         ELSE 'false' 
       END AS Answer 
FROM   (SELECT a.ixUserAuthorization 
        FROM   tblechecklistuserroleassignmentxref r 
               INNER JOIN tblechecklistuserrole u 
                 ON u.ixUserRole = r.ixUserRole 
                    AND u.sname = 'Initiator' 
               INNER JOIN tblechecklistuserauthorization a 
                 ON a.ixUserAuthorization = r.ixUserAuthorization 
                    AND a.ixcustomer = '1' 
                    AND a.ixprogram = '1' 
                    AND a.ixworkpackage = '1' 
                    AND a.ixactivity = '1' 
                    AND a.ixUser = '626e28e8-e67a-4d11-8d2c-129d0ab79e96') a 

select 'uvt' as which, user_id
from u_v_t
where user_id not in (select user_id from users)
union all
select 'ulp' as which, user_id
from u_l_p
where user_id not in (select user_id from users)
union all
select 'uj', user_id
from u_j
where user_id not in (select user_id from users)
union all
select 'uw', user_id
from u_w
where user_id not in (select user_id from users)
union all
select 'pu', user_id
from p_u
where user_id not in (select user_id from users);

SELECT T1.idA, T1.infos
FROM XXX T1
JOIN
(
    SELECT idA
    FROM XXX
    GROUP BY idA
    HAVING COUNT(*) >= 2
) T2
ON T1.idA = T2.idA

select *
from table as t_children
where t_children.parent_id in (
    select *
    from table as t_parent
    where t_parent.parent_id is null
)

context.Table.Where(k => k.TURKCE_ADI.ToLower().Contains("lpg")).ToList();

/*******  DATA PREPARATION *****/

IF OBJECT_ID('tempdb..#Collisions') IS NOT NULL
DROP TABLE #Collisions

IF OBJECT_ID('tempdb..#Localization') IS NOT NULL
DROP TABLE #Localization

CREATE TABLE #Collisions (PK_ID INT, cashLoss INT, deaths INT, city varchar(20), state varchar(20), country varchar(20))
CREATE TABLE #Localization (LocalizationId INT IDENTITY (1, 1), city varchar(20), state varchar(20), country varchar(20))

INSERT INTO #Collisions (PK_ID, cashLoss, deaths, city, state, country)
SELECT PK_ID, cashLoss, deaths, city, state, country
FROM (VALUES
(1, 3, 6, 'CityA', 'StateA', 'CountryA' ),
(2, 56, 1, 'CityB', 'StateA', 'CountryA'),
(3, 54, 0, 'CityA', 'StateA', 'CountryA'),
(4, 3, 0, 'CityB', 'StateA', 'CountryA' ),
(5, 23, 0, 'CityA', 'StateB', 'CountryB')) AS T(PK_ID, cashLoss, deaths, city, state, country)



/*******  CREATE/UPDATE TABLES *****/

--Create Localization table with unique values
INSERT INTO #Localization (city, state, country)
SELECT DISTINCT city, state, country
FROM #Collisions

--Add new LocalizationId column to #Collisions
ALTER TABLE #Collisions ADD LocalizationId INT 

--Would be nice to add foreign key on #Collisions.LocalizationId

--Update LocalizationId
UPDATE C
    SET LocalizationId = L.LocalizationId
FROM #Collisions AS C
INNER JOIN #Localization AS L
    ON L.city = C.city
    AND L.state = C.state
    AND L.country = C.country

--Drop 3 columns
ALTER TABLE #Collisions DROP COLUMN city, state, country

--RESULT
SELECT * 
FROM #Collisions

SELECT 
  *, AVG(ratings.rating) AS avg_rating_count 
FROM 
  restaurants 
    INNER JOIN ratings ON ratings.restaurant_id = restaurants.id 
GROUP BY 
  restaurants.id

select t1.ItemNumber,t1.CountRows,t2.CountTest
from TableA t1, TableB t2
WHERE t1.ItemNumber=t2.ItemNumber

select (case when min(category) <> max(category) then 'Both A and B'
             when min(category) = 'A' then 'A only'
             when min(category) = 'B' then 'B only'
         end)
from t
where code in (1, 2) and category in ('A', 'B');

SELECT TABLE_SCHEMA + '.' + TABLE_NAME AS ColumnZ 
FROM information_schema.tables

select * from your_table
where col1 in 
(
   select col1
   from your_table
   where col2 in ('0080', '0010')
   group by col1
   having count(distinct col2) = 2
)

select a.* 
  from temp_data a
  left
  join(select key, count(*) cnt
         from historical
        group
           by key
      ) b
    on a.key = b.key
 where nvl(b.cnt, 0) < 2;   

SELECT Country, COUNT(Name) as People
FROM Citizen 
GROUP BY Country
HAVING COUNT(Name) = (select max(cnt)
                      from (select COUNT(Name) as cnt
                            from Citizen
                            group by Country
                           ) c
                     );

DELETE FROM Table1 
WHERE NOT EXISTS(SELECT 1  
                   FROM Table2          
                  WHERE Table2.i > 0 
                    AND Table2.value = Table1.value)

SELECT ID, ENVIRONMENT, EDITION, CONTACT FROM RESULTS_PRIOR
WHERE ID NOT IN (SELECT ID FROM RESULTS_CURRENT)
UNION
SELECT ID, ENVIRONMENT, EDITION, CONTACT FROM RESULTS_CURRENT
WHERE ID NOT IN (SELECT ID FROM RESULTS_PRIOR)

SELECT project.name
FROM service
LEFT JOIN project ON project.id = service.project_id
GROUP BY project_id
ORDER BY SUM(time_stop - time_start)
LIMIT 100

create table #photo
(
    Path varchar(100)
)
go

insert into #photo values ('Path1')
insert into #photo values ('Path2')
insert into #photo values ('Path3')
insert into #photo values ('Path4')
insert into #photo values ('Path5')
insert into #photo values ('Path6')
insert into #photo values ('Path7')
insert into #photo values ('Path8')

go

WITH Ordered AS (
SELECT ROW_NUMBER() OVER (ORDER BY Path)-1 AS RowNumber, Path
FROM #photo)
SELECT Ord1.Path as Col1Path, Ord2.Path as Col2Path, ord3.Path as Col3Path
FROM Ordered Ord1
left outer join
Ordered Ord2
on Ord1.RowNumber = Ord2.RowNumber - 1
left outer join 
Ordered Ord3
on Ord3.RowNumber = Ord2.RowNumber + 1
where Ord1.RowNumber % 3 = 0


drop table #photo

select @max =  max(field_name), @min = min(field_name)
from table_name

DECLARE @Q VARCHAR(MAX),@ID INT
SET @ID=(Select DISTINCT ID from Aliases where Alias = 'TestTable') -- CHECK TO RETURN JUST ON RESULT
SET @Q='SELECT * FROM A'+CAST(@ID AS VARCHAR(10))
EXEC(@Q)

SELECT 100*AVG(CASE WHEN table_b.First_Name IS NULL THEN 0 ELSE 1 END) percent
FROM table_a 
LEFT JOIN table_b
  ON table_a.First_Name  = table_b.First_Name
 AND table_a.Family_Name = table_b.Family_Name

BEGIN
  FOR aName IN (SELECT 'john'  AS EMP_NAME FROM DUAL
                UNION ALL
                SELECT 'sam'   AS EMP_NAME FROM DUAL
                UNION ALL
                SELECT 'peter' AS EMP_NAME FROM DUAL
                UNION ALL
                SELECT 'jack'  AS EMP_NAME FROM DUAL)
  LOOP
    FOR emp IN (SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '%' || aName.EMP_NAME || '%')
    LOOP
      DELETE FROM ACCOUNT_DETAILS a WHERE a.EMP_ID = emp.EMP_ID;
      DELETE FROM HR_DETAILS h WHERE h.EMP_ID = emp.EMP_ID;
      DELETE FROM PAY_ROLE_DETAILS p WHERE p.EMP_ID = emp.EMP_ID;

      DBMS_OUTPUT.PUT_LINE('Deleted data for employee with EMP_ID=' || emp.EMP_ID);
    END LOOP;  -- emp
  END LOOP; -- aName
END;

Client c;

c.Customer.[...]
c.Supplier.[...]

SELECT
 ...
 ...
 CASE WHEN LEFT(ver_klass, 1) <> 'S' AND LEFT(ver_klass, 1) <> 'M' THEN ver_klass ELSE NULL END AS ver_rayon,
 CASE WHEN LEFT(ver_klass, 1) = 'M' THEN ver_klass ELSE NULL END AS ver_metier,
 CASE WHEN LEFT(ver_klass, 1) = 'S' THEN ver_klass ELSE NULL END AS ver_secteur,

DECLARE @cols AS NVARCHAR(MAX),
    @query  AS NVARCHAR(MAX);

select @cols = STUFF((SELECT distinct ',' + QUOTENAME(aid) 
            FROM m 
            FOR XML PATH(''), TYPE
            ).value('.', 'NVARCHAR(MAX)') 
        ,1,1,'')

set @query = 'SELECT s, ' + @cols + ' from 
            (
                select grade, aid, s
                from m
           ) x
            pivot 
            (
                sum(grade)
                for aid in (' + @cols + ')
            ) p 
            ORDER BY p.s'

execute(@query)

SELECT  *
FROM    (
        SELECT  *
        FROM    mytable
        ORDER BY
                dbms_random.value
        )
WHERE rownum <= 1000

select sum(case when type = 1 OR type = 2 then value else - value end)
from table t
group by year; 

WITH recordList
AS
(
    SELECT  ID, buildingID, [order], title,
            ROW_NUMBER() OVER (PARTITION BY buildingID
                                ORDER BY ID) rn
    FROM    tableName
)
UPDATE recordList
SET [order] = rn - 1

SELECT u.UserID, UserLastName, UserFirstName, UserName, Notified, 
CycleNumber, CycleCurrentStep, CycleDateReported, cycleid
FROM [User] u 
left join Cycle c on (u.UserID = c.UserID) 
join UserDivSection us on (u.UserID = us.UserID and us.DivSectionID=26) 
where cyclenumber = ( select max(cyclenumber) from cycle where cycle.userid = u.userid)

USE BetfairFootballDB

CREATE TABLE #CSVTest_Data
(FirstTimeTaken DATETIME,
LatestTimeTaken DATETIME,
Market VARCHAR(50),
Outcome VARCHAR(50),
Odds DECIMAL,
NumberOfBets TINYINT,
VolumeMatched DECIMAL,
InPlay TINYINT)

CREATE TABLE #CSVTest_Match
(Header VARCHAR(50),
Data VARCHAR(50))

BULK
 INSERT #CSVTest_Data
FROM 'D:\Data\csvtest.csv' -- CSV file containing data
WITH
(
FIRSTROW =4,
FIELDTERMINATOR = ',',
ROWTERMINATOR = '\n'
)

BULK
 INSERT #CSVTest_Match
FROM 'D:\Data\csvtest.csv' -- CSV file containing data
WITH
(
FIRSTROW =2,
LASTROW=7,
FIELDTERMINATOR = ',',
ROWTERMINATOR = '\n'
)

----Check the content of the table.
--SELECT *
--FROM #CSVTest_Data

----Check the content of the table.
--SELECT *
--FROM #CSVTest_Match

------------------------------------

-- Convert imported CSV data from row data to column data
CREATE TABLE #temp1 (
    CompetitionID tinyint, 
    DateKickOff datetime, 
    TimeKickOff time(7),
    TeamIDHome tinyint, 
    TeamIDAway tinyint,
    TeamNameHome varchar(50), 
    TeamNameAway varchar(50), 
    ScoreHome tinyint, 
    ScoreAway tinyint,
)
--ALTER TABLE #temp1 ADD CONSTRAINT DF_CompetitionID DEFAULT 2 FOR CompetitionID;
ALTER TABLE #temp1 ADD DEFAULT 2 FOR CompetitionID --Set as default value that must be manually modified until I find a better way to specify this

INSERT INTO #temp1 (DateKickOff, TimeKickOff, TeamNameHome, TeamNameAway, ScoreHome, ScoreAway)
SELECT * FROM
(SELECT Header, Data FROM #CSVTest_Match) AS T
PIVOT (Min(Data) FOR Header IN ([Kick Off Date], [Kick Off Time], [Home Team], [Away Team], [Home Goals], [Away Goals])) AS T2

CREATE TABLE #temp2 (
    TeamIDHome tinyint, 
    TeamIDAway tinyint, 
)
INSERT INTO #temp2 (TeamIDHome, TeamIDAway)
select HomeTeam.TeamID as TeamIDHome, AwayTeam.TeamID as TeamIDAway
from #temp1 as U
join BetfairFootballDB..Team as HomeTeam on U.TeamNameHome = HomeTeam.TeamName
join BetfairFootballDB..Team as AwayTeam on U.TeamNameAway = AwayTeam.TeamName

ALTER TABLE #temp1
DROP COLUMN TeamNameHome
ALTER TABLE #temp1
DROP COLUMN TeamNameAway

UPDATE #temp1
SET #temp1.TeamIDHome = #temp2.TeamIDHome 
FROM #temp2
UPDATE #temp1
SET #temp1.TeamIDAway = #temp2.TeamIDAway
FROM #temp2

INSERT INTO  BetfairFootballDB..Match --(CompetitionID, DateKickOff, TimeKickOff, TeamIDHome, TeamIDAway, ScoreHome, ScoreAway)
SELECT *
FROM #temp1

--Process Match END
-----------------------------------------------------------
--Process Data BEGIN

ALTER TABLE #CSVTest_Data ADD MatchID INT


update #CSVTest_Data
     Set MatchID = (SELECT TOP 1 MatchID FROM BetfairFootballDB..Match
                   ORDER BY MatchID DESC)


--This code should write the data to the Data table correctly once I have the MatchID column filled in the temp table
INSERT INTO  BetfairFootballDB..Data (MatchID, OddsFirstTimeTaken, OddsLastTimeTaken, MarketName, Outcome, Odds, NumberOfBets, VolumeMatched, InPlay)
SELECT MatchID, FirstTimeTaken, LatestTimeTaken, Market, Outcome, Odds, NumberOfBets, VolumeMatched, InPlay
FROM #CSVTest_Data


SELECT *
   FROM BetfairFootballDB..Match
SELECT *
   FROM BetfairFootballDB..Data
-------------------------------------------------------------
DROP TABLE #temp1
DROP TABLE #temp2
DROP TABLE #CSVTest_Data
DROP TABLE #CSVTest_Match

SELECT TOP 1 * 
FROM MYVIEW 
WHERE VALID_FROM IS NULL OR getdate() BETWEEN VALID_FROM AND VALID_UNTIL
ORDER BY CASE WHEN VALID_FROM IS NOT NULL THEN 1 ELSE 2 END

AND (NVL(T.Col_One,'NuLl') NOT LIKE 'AString'
      OR NVL(T.Col_Two,'NuLl') NOT IN ('BString','CString')) 

@echo select version from system; | sqlplus username/password@database 

select c.clientname, i.description, p.price, 
   stuff((select ', ' + a.AgentName 
    from SalesAgent sa join PurchaseSalesAgent psa on psa.AgentID = sa.AgentID
    where psa.PurchaseID = p.purchaseID
    for xml path('')),1,2,'') as Agents
from client c 
join purchase p on p.clientid = c.clientid
join item i on i.itemid = p.itemid
;

File > Options > Query Tool > Max. characters per column

-- This part gets data for everyone that took a break.
-- Hopefully they took only ONE break
-- (if they took more, we'll get multiple rows here)
Select A.EventDate      'Date'
      ,A.PersonFullName 'Employee'
      ,A.StartDtm       'ShiftStart'
      ,A.OutPunchDtm    'BreakStart'
      ,B.StartDtm       'BreakEnd'
      ,B.OutPunchDtm    'ShiftEnd'
  From vp_TimeSheetPunch A
  Join vp_TimeSheetPunch B On A.EventDate=B.EventDate
                         And A.PersonNum=B.PersonNum
                         And A.StartDtm<B.StartDtm
Union
-- This part gets data for everyone that did not take a break.
Select C.EventDate      'Date'
      ,C.PersonFullName 'Employee'
      ,C.StartDtm       'ShiftStart'
      ,Null             'BreakStart'
      ,Null             'BreakEnd'
      ,C.OutPunchDtm    'ShiftEnd'
  From vp_TimeSheetPunch C
 Where Not Exists(Select *
                    From vp_timesheetpunch D
                   Where C.EventDate=D.EventDate
                     And C.PersonNum=D.PersonNum
                     And C.StartDtm<>D.StartDtm)

-- This orders the result using column numbers
Order By 1,2,3,4

cbind(data[1], as.data.frame(lapply(data[-1], function(x) 
                              description$label[match(x, description$feature)])))

  individual feature1  feature2
1      Steve     foot   curling
2        Bob     golf       ski
3      Simon     golf      foot
4       Lisa  curling No answer

SELECT MemberId, MIN(Date) AS "Min_Date"
FROM (
    SELECT MemberId, Cov_End_Date  AS "Date" FROM Cov_End
    UNION ALL
    SELECT MemberId, Opt_out_date  AS "Date" FROM Opt_Out
    UNION ALL
    SELECT MemberId, Deceased_Date AS "Date" FROM Decsd_Date
) src
GROUP BY MemberId

select t.documentname, t.fname, count(ejd.id) present
from (
    select d.documentname, d.id documentid, e.fname, e.id employeeid 
    from JoinigDocument d cross join EmployeeDetail e 
) t left join EmployeeJoiningDocument ejd on 
       t.documentid = ejd.joiningdocumentid and t.employeeid = ejd.employeeid
group by t.documentname, t.fname

SELECT FORMAT(t1.completionDate,"mmm-yy") AS [month], (
        SELECT SUM(t2.amount)
        FROM projects AS t2
        WHERE MONTH(t2.completionDate) <= MONTH(t1.completionDate)
    ) AS [amount]
FROM projects AS t1;

SELECT c.chr, n.num
FROM chars c, nums n
 WHERE NOT EXISTS (SELECT 1
                     FROM mix m
                    WHERE m.chr = c.chr AND m.num = n.num)

with cte as (
 select row_number() over (partition by Brand, Category order by Date) as rn
, FirstValue
from Table)
update cte
set FirstValue = case when rn = 1 then 1 else 0 end;

Delete from A where id in 
             (
                Select id from ((select id from A) minus (select id from B))
             );

select *
from (
    select 1 as Rank, id, add_date from Table 
    union all
    select 2 as Rank, id, add_date from Table where distance < 5
    union all
    select 3 as Rank, id, add_date from Table where distance between 5 and 15
) a
order by rank, id, add_date desc

SELECT * 
FROM Table
WHERE 
  ((@selctDescription IS NULL OR @selctDescription = '') 
   OR
   (t.[description] LIKE '%' + @selctDescription +'%'))

join(mainTable, 
  requiredFieldTable1, 
  requiredFieldTable2, 
  optionalFieldTable1.leftOuter, 
  optionalFieldTable2.leftOuter)((main,r1,r2,o1,o2) => 
  select(main,o1,o2,r1,r2)
  on(main.someId1 === r1.id, 
     main.someId2 === r2.id,
     main.optId1 === o1.map(_.id),
     main.optId2 === o2.map(_.id)))

DECLARE @id VARCHAR(10)

DECLARE myCursor CURSOR LOCAL FAST_FORWARD FOR
    SELECT [String] AS 'ID' 
    FROM [dbo].[ConvertStringToTable]('1,2,3,4')
OPEN myCursor
FETCH NEXT FROM myCursor INTO @id
WHILE @@FETCH_STATUS = 0 BEGIN
    PRINT @id
    -- do your tasks here

    FETCH NEXT FROM myCursor INTO @id

END

CLOSE myCursor
DEALLOCATE myCursor

WITH cte AS
(
    SELECT [CircuitID], [Voltage], [Phase], [PanelID], [Cct], [Cct] AS [Ref]  
    FROM [Power]
    UNION ALL
    SELECT [CircuitID], [Voltage], [Phase], [PanelID], [Cct] + 1, [Ref]  
    FROM cte 
    WHERE [Cct] + 1 < [Phase]  + [Ref] 
)
SELECT [CircuitID], [PanelID], [Cct] 
FROM cte
ORDER BY [CircuitID]

DECLARE @tbl AS TABLE (Seq int, Security varchar(3), Quantity int, Price int, Consid int) ;
INSERT INTO @tbl VALUES
(1, 'IBM', 1000, 20, -20000)
,(2, 'IBM', 2000, 22, -44000)
,(3, 'IBM', -1000, 30, 30000)
,(4, 'IBM', -2000, 20, 40000)
,(5, 'IBM', -2000, 20, -20000);

WITH RunningInventory AS (
SELECT l.Seq, SUM(r.Quantity) AS Inv
FROM @tbl AS l
LEFT JOIN @tbl r
ON r.Seq <= l.Seq
GROUP BY l.Seq
)
SELECT *
FROM @tbl AS trx
INNER JOIN RunningInventory
    ON trx.Seq = RunningInventory.Seq
WHERE RunningInventory.Inv >= 0 ;

SELECT a.*
FROM student_score a
WHERE Score = 
(
    SELECT MAX(Score)
    FROM student_score
)

SELECT * FROM flags where flag=1
and ID NOT in( SELECT ID FROM flags where flag !=1 OR flag IS NULL)

SELECT
  ID,
  MIN(Sequence) AS Sequence,
  Val,
  COUNT(*) AS cnt
FROM
(
  SELECT
    ID,
    Sequence,
    Sequence - ROW_NUMBER() OVER (ORDER BY ID, Val, Sequence) AS g,
    Val
  FROM
    yourtable
) AS s
GROUP BY
  ID, Val, g

select s.column1,
       s.column2
into v_column1,v_column2
from cards s
where s.column3= in_column3;

SELECT *
FROM  (
    SELECT length 
    FROM   action
    WHERE  type = Y 
    AND    start < X
    ORDER  BY start DESC
    )
WHERE rownum = 1;

SELECT cat.caravan_type,  AVG(Rental_amount) 
FROM Caravan c
INNER JOIN Category cat
ON c.caravan_type_id = cat.caravan_type_id
GROUP BY cat.caravan_type

CAST(CONVERT(VARCHAR(10), date, 120) AS DATETIME)

  for(int i=0; i<256; i++)
  {
    Statement select = con.createStatement();
    ResultSet result = select.executeQuery("select CHR(" + i +") from DUAL");
    while(result.next())
    {
      int unicodePoint = result.getString(1).codePointBefore(1);
      //int unicodePoint = result.getString(1).codePointAt(0);
      if (unicodePoint != i)
        System.out.println("CHR: " + i + "\tUNICODE: " + unicodePoint);
    }
    result.close();
    result = null;
    select.close();
    select = null;
  }

db.collection.aggregate([
    { "$group": {
        "_id": { "sid": "$sid", "geo": "$geo" }
    }},
    { "$group": {
        "_id": "$_id.sid",
        "geo_count": { "$sum": 1 }
    }}
]}

SELECT 
    * 
FROM 
    table_name 
WHERE 
    MONTH(Display_Date) = MONTH(CURDATE())
AND YEAR(Display_Date) = YEAR(CURDATE())

SELECT  ISNULL
        (
        (
        SELECT  userId
        FROM    users
        WHERE   userName = @userName
                AND password = @password
        ),
        0
        )

DECLARE @tbl1 TABLE (
    IDNO VARCHAR(8),
    Code VARCHAR(4),
    Amt VARCHAR(18)
)
INSERT INTO
    @tbl1
VALUES
    ( '0283883', 'ABC', '20' ),
    ( '0374747', 'DHF', '10' )

SELECT (
    SELECT 
        CAST(IDNO AS VARCHAR(8)) AS [IDNO],
        CAST(Code AS VARCHAR(4)) AS [CODE],
        CAST(Amt AS VARCHAR(18)) AS [Amt]         
    FROM
        @tbl1
    FOR XML PATH('ITEM'), ROOT('Table1'), TYPE 
    ), (
    SELECT 
        '' AS INAME
        ,'' AS UNQ_ID
        ,'' AS STATUS
    FOR XML PATH('IT_RETURN'), TYPE
) FOR XML PATH('')

select t.CreatorMasterCustomerId as MasterCustomerId
     , t..NewClubKeyId
     , min(t.DateCreated) as DateAssigned
from (<...>) t
group by t.MasterCustomerId
       , t.NewClubKeyId

select  *
from    table1 t1
cross join
        (
        select  distinct mapping_id
        from    table2
        ) mappings
where   not exists
        (
        select  *
        from    table2 t2
        where   t2.id = t1.id
                and t2.mapping_id = mappings.mapping_id
        )

select productid, count(*) totalhits, 
    count(distinct 
        concat(ip,
            date_format(hittime, '%Y%m%d%H'),
            round(date_format(hittime, '%i') / 5) * 5)
        ) uniquehits
from table
group by productid

select * from
((SELECT matches.*, teams.*, outcomes.against as goals
FROM matches,teams,outcomes
WHERE
    matches.home_team_id=11
    AND matches.away_team_id=teams.team_id  
    AND matches.score_id=outcomes.outcome_id
)
UNION
(SELECT matches.*, teams.*, outcomes.for as goals
FROM matches,teams,outcomes 
WHERE matches.away_team_id=11
    AND matches.home_team_id=teams.team_id  
    AND matches.score_id=outcomes.outcome_id
)) as union_table
order by goals, date desc limit 0,20;

<asp:Label ID="lblProductName" runat="server" Text='<%#Eval("ProductName") %>' CssClass="productHead" />

<asp:Label ID="lblModelName" runat="server" Text='<%#Eval("ModelName") %>' CssClass="productHead" />

<asp:Label ID="lblSubCategoryName" runat="server" Text='<%#Eval("SubCategoryName") %>' CssClass="productHead" />

<asp:Label ID="lblBrandName" runat="server" Text='<%#Eval("BrandName") %>' CssClass="productHead" />



SELECT        Product.ProductID, Product.Name ProductName, tblBrand.Name BrandName, SubCategory.Name SubCategoryName, tblModel.Name ModelName
FROM Product INNER JOIN tblBrand ON Product.BrandID = tblBrand.BrandID INNER JOIN tblModel ON Product.ModelID = tblModel.ModelID INNER JOIN SubCategory ON Product.SubCategoryID = SubCategory.SubCategoryID WHERE (Product.ProductID = @ProductID)

patients (id, name, ....)
meds (id, brand, name, ...)
patient_meds (patient_id, med_id, dosage, ...)

select year, id, name, city, q1, q2, q3, q4,
    (nvl(q1, 0)+nvl(q2, 0)+nvl(q3, 0)+nvl(q4, 0)) 
      / (nvl2(q1,1,0)+nvl2(q2,1,0)+nvl2(q3,1,0)+nvl2(q4,1,0)) s_avg,
    (nvl(q1, 0)+nvl(q2, 0)+nvl(q3, 0)+nvl(q4, 0)) / 4 s_avg4,
    nvl(q1, 0)+nvl(q2, 0)+nvl(q3, 0)+nvl(q4, 0) s_sum
  from (
    select substr(q.descr, 1, 2) qtr, substr(q.descr, 7, 2) year, 
           sr.id, sr.name, sr.city, s.sales
      from salesrep sr join sales s on s.salesrepid = sr.id 
      join qtr q on q.qtrid = s.qtrid)
  pivot (sum(sales) for qtr in ('Q1' Q1, 'Q2' Q2, 'Q3' Q3, 'Q4' Q4))
  order by year, id

==============================================================================

YEAR ID NAME       CITY          Q1    Q2    Q3    Q4    S_AVG   S_AVG4  S_SUM
---- -- ---------- ---------- ----- ----- ----- ----- -------- -------- ------
14    1 Agent A    Chennai     1000  2500                 1750      875   3500
14    2 Agent B    Delhi       3450  4300   230  1367  2336,75  2336,75   9347
14    4 Agent D    Bangalore                500   750      625    312,5   1250
14    5 Agent E    Patna                          450      450    112,5    450
15    1 Agent A    Chennai     4455                       4455  1113,75   4455

DECLARE @Query VARCHAR(MAX)

SET @Query = '
SELECT * from ( SELECT Amount, FYYear, column1, column2,column3 from BUYSCTE ) BUY 
PIVOT( SUM(Amount) FOR FYYear in ('+ @Year + ') ) pvt'

EXEC(@Query)

SELECT * 
FROM table1 
WHERE (( chapter = 1 AND sentence >= 3 ) OR chapter > 1)
  AND (( chapter = 3 AND sentence <= 4 ) OR chapter < 3)

SELECT Name, COUNT(*) FROM EntryLog WHERE CheckIn GROUP BY Name

SELECT Product, MAX(Price)
FROM YourTable
GROUP BY Product

SQL> SELECT * FROM tutor_school;

  SCHOOLID NAME
---------- --------------------
         1 School A
         2 School B
         3 School C


SQL> SELECT * FROM tutor_attends;

    USERID   SCHOOLID
---------- ----------
         1          1
         2          1
         3          2


SQL> SELECT * FROM tutor_tutors_in;

    USERID SUBJECT
---------- --------------------
         1 Math
         1 Science
         1 English
         2 English
         3 Math


SQL> SELECT tutor_school.name, COUNT(DISTINCT tutor_tutors_in.userid)
  2  FROM tutor_school, tutor_attends, tutor_tutors_in
  3  WHERE tutor_school.schoolid=tutor_attends.schoolid
  4  AND tutor_attends.userid=tutor_tutors_in.userid
  5  GROUP BY tutor_school.name
  6  /

NAME                 COUNT(DISTINCTTUTOR_TUTORS_IN.USERID)
-------------------- -------------------------------------
School A                                                 2
School B                                                 1

select some_category_1
     , some_category_2
     , sum(case
             when     some_category_3 = 'value a'
                  and oc.week_start_date between sysdate-(52*7) and sysdate
               then ms.cash_sales
             else 0
           end) a_ty_cashsales
     , sum(case
             when     some_category_3 = 'value a'
                  and oc.week_start_date between sysdate-(52*7) and sysdate
               then ms.unit_sales
             else 0
           end) a_ty_unitsales
     , sum(case
             when     some_category_3 = 'value a'
                  and oc.week_start_date between sysdate-(104*7) and sysdate-(53*7)
               then ms.cash_sales
             else 0
           end) a_ly_cashsales
     , sum(case
             when     some_category_3 = 'value a'
                  and oc.week_start_date between sysdate-(104*7) and sysdate-(53*7)
               then ms.unit_sales
             else 0
           end) a_ly_unitsales
     , sum(case
             when     some_category_3 = 'value b'
                  and oc.week_start_date between sysdate-(52*7) and sysdate
               then ms.cash_sales
             else 0
           end) b_ty_cashsales
     , sum(case
             when     some_category_3 = 'value b'
                  and oc.week_start_date between sysdate-(52*7) and sysdate
               then ms.unit_sales
             else 0
           end) b_ty_unitsales
     , sum(case
             when     some_category_3 = 'value b'
                  and oc.week_start_date between sysdate-(104*7) and sysdate-(53*7)
               then ms.cash_sales
             else 0
           end) b_ly_cashsales
     , sum(case
             when     some_category_3 = 'value b'
                  and oc.week_start_date between sysdate-(104*7) and sysdate-(53*7)
               then ms.unit_sales
             else 0
           end) b_ly_unitsales
from my_table mt
     join my_other_table mot
       on mot.mykey = mt.mykey
     join calendar_table ct
       on ct.week_id = ms.week_id
group by some_category_1
       , some_category_2
order by some_category_1
       , some_category_2

SELECT CASE
  WHEN x.COL_1 LIKE 'AAAA' OR
  x.COL_1 LIKE 'BBBB' OR
  x.COL_1 LIKE 'CCCC' OR
  x.COL_1 LIKE 'DDDD' THEN 1 ELSE 0 END AS Code
FROM (
SELECT
  CASE WHEN RIGHT(CAST(COLUMN_A as nvarchar(max)),1) = '.' THEN
  SUBSTRING (COLUMN_A, DATALENGTH(COLUMN_A) - 4, 4) ELSE
  SUBSTRING (COLUMN_A, DATALENGTH(COLUMN_A) - 3, 4) END AS COL_1
) x

SELECT
  a.mkey, c.type_desc DOC_TYPE, a.doc_no INWARD_NO, 
  convert(varchar, a.doc_date,103) date, a.to_user, a.No_of_pages, Ref_No, d.type_desc DEPT_RECEIVED, 
  b.first_name + ' ' + b.last_name SENDER, b.first_name + ' ' + b.last_name   NAME, b.email 
FROM inward_doc_tracking_hdr a 
-- LEFT ?
JOIN user_mst b ON a.to_user = b.mkey 
JOIN type_mst_a c ON a.doc_type = c.master_mkey 
JOIN type_mst_a d ON a.dept_received = d.Master_mkey 
WHERE 
  a.to_user = '1279'

UPDATE data 
   SET data = CONCAT('word=',(SELECT id 
                                FROM words 
                               WHERE words.word = SUBSTRING_INDEX(data.data,'=',-1)))

UPDATE table1 
SET col1 = YourCount, col2 = YourAverage, col3 = YourSum
FROM table1 t1
INNER JOIN (
    SELECT table2Id, COUNT(*) AS YourCount, AVG(someCol1) YourAverage, 
        SUM(someCol2) YourSum
    FROM table2
    GROUP BY table2Id
) t2 ON t1.table1Id = t2.table2Id

update a set gender = case b.Gender
                                when 'Male' then 0
                                when 'Female' then 1
                          end
from users a inner join
    tempTable b on b.Username = a.Username

select cast(translate(col, ', %', '.') as float)

SELECT        p.name,r.name role
FROM          user_has_role AS ur
JOIN          role AS r
ON            ur.role_id = r.id
JOIN          role_has_permission AS rp
ON            r.id = rp.role_id
LEFT JOIN     permission AS p
ON            rp.permission_id = p.id
WHERE         ur.user_id = [USER_ID]
UNION
   SELECT p.name, 'super_admin' 
   FROM permission 
   WHERE EXISTS (SELECT * FROM user_has_role, role 
              WHERE ur.user_id = [USER_ID] and role.role_id = user_has_role.role_id and             
              role.name = 'super_admin')

SELECT
  Movie.*,
  Rating.Stars
FROM
  Movie
INNER JOIN
  Rating
    ON Movie.mid = Rating.mid
WHERE
  Rating.Stars = (SELECT MAX(Stars) FROM Rating)

SET @id = 1;

SELECT sections.BUSINESS_UNITS, sections.CIA, sections.AREAS,
    IFNULL(states.state_0, 0) AS STATE_0,
    IFNULL(states.state_1, 0) AS STATE_1,
    IFNULL(states.state_2, 0) AS STATE_2
    FROM (
        SELECT
            pb.id AS bus_id, pb.name AS BUSINESS_UNITS,
            ce.id AS cia_id, ce.name AS CIA,
            ca.name AS AREAS
            FROM policies p 
            INNER JOIN policy_business_units pb
            ON pb.id = p.policy_business_unit_id
            INNER JOIN comercial_areas ca
            ON ca.id = pb.comercial_area_id
            INNER JOIN cia_ensures ce
            WHERE ca.id = @id
    ) AS sections
    LEFT OUTER JOIN (
        SELECT
            pb.id AS bus_id,
            ce.id AS cia_id,
            if (p.state = 0, 1, 0) AS state_0,
            if (p.state = 1, 1, 0) AS state_1,
            if (p.state = 2, 1, 0) AS state_2
            FROM policies p 
            INNER JOIN policy_business_units pb
            ON pb.id = p.policy_business_unit_id
            INNER JOIN comercial_areas ca
            ON ca.id = pb.comercial_area_id
            INNER JOIN cia_ensures ce
            ON ce.id = p.cia_ensure_id
            WHERE ca.id = @id
    ) AS states
    ON sections.bus_id = states.bus_id
    AND sections.cia_id = states.cia_id
    ORDER BY sections.cia_id;

Public Sub Macro1(byval storedProc as string, byval ws as worksheet)
' Create a connection object.
Dim cnPubs As ADODB.Connection
Set cnPubs = New ADODB.Connection

' Provide the connection string.
Dim strConn As String

'Use the SQL Server OLE DB Provider.
strConn = "PROVIDER=SQLOLEDB;"

'Connect to the Pubs database on the local server.
strConn = strConn & "DATA SOURCE=PC\SQL2014;INITIAL CATALOG=Option Database;"

'Use an integrated login.
strConn = strConn & " INTEGRATED SECURITY=sspi;"

'Now open the connection.
cnPubs.Open strConn

' Create a recordset object.
Dim rsPubs As ADODB.Recordset
Set rsPubs = New ADODB.Recordset

With rsPubs
' Assign the Connection object.
.ActiveConnection = cnPubs
' Extract the required records.
.Open storedProc
' Copy the records into cell A1 on Sheet1.
ws.Range("A2").CopyFromRecordset rsPubs
For intColIndex = 0 To rsPubs.Fields.Count - 1
ws.Range("A1").Offset(0, intColIndex).Value = rsPubs.Fields(intColIndex).Name
Next

' Tidy up
.Close
End With

cnPubs.Close
Set rsPubs = Nothing
Set cnPubs = Nothing
'
End Sub

select max([Date]) FROM #Date WHERE [Date] <@Todays_Date

with percentiles as (
      SELECT MAX(colName) as upperVal, (CAST(Percentile as float) / 10.0) as Percentile
      FROM (SELECT colName, NTILE(10) OVER(ORDER BY colNameASC) AS Percentile
            FROM tableName AS a
           ) as b
      GROUP BY Percentile
     )
select kv.value,
       (select top 1 Percentile
        from percentiles p
        where p.upperVal >= kv.value
        order by upperVal
       )
from KnownValues kv;

SELECT
    country,
    count(DISTINCT ip) views
FROM views
GROUP BY country
ORDER BY country;

select a.Station, c.aging from                   
    (select Station, ROW_NUMBER() over (order by totalseq asc) AS rownumber1 
    from [SFCKM].[dbo].[T_DB_Subline] where Track_Point_No = '3d1') a
    left join
    (*,aging,ROW_NUMBER() over (order by commit_time desc) AS rownumber
    FROM [SFCKM].[dbo].[T_Work_Actual] where Track_Point_No = '3d1') c
on a.rownumber1 = c.rownumber
order by a.rownumber1

SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, 
    NUMERIC_PRECISION, NUMERIC_SCALE
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = 'YourTable'

where category_code in (select category_code from category_skus where (category_code       between '70699' and '70791') or (category_code in ('60130','60420')))
and products.created_date > ...

CREATE NONCLUSTERED INDEX [IX_SupportContacts_ForeignIdAsc_IdDesc] 
ON SupportContacts ([ForeignId] ASC, [Id] DESC)
INCLUDE (Details);

Declare @weekDay Table (
      mask      int
    , maskValue varchar(32)
);

Insert Into @weekDay
Select 1, 'Sunday'  Union All
Select 2, 'Monday'  Union All
Select 4, 'Tuesday'  Union All
Select 8, 'Wednesday'  Union All
Select 16, 'Thursday'  Union All
Select 32, 'Friday'  Union All
Select 64, 'Saturday';

With myCTE
As(
    Select sched.name As 'scheduleName'
        , sched.schedule_id
        , jobsched.job_id
        , Case When sched.freq_type = 1 Then 'Once' 
            When sched.freq_type = 4 
                And sched.freq_interval = 1 
                    Then 'Daily'
            When sched.freq_type = 4 
                Then 'Every ' + Cast(sched.freq_interval As varchar(5)) + ' days'
            When sched.freq_type = 8 Then 
                Replace( Replace( Replace(( 
                    Select maskValue 
                    From @weekDay As x 
                    Where sched.freq_interval & x.mask <> 0 
                    Order By mask For XML Raw)
                , '"/><row maskValue="', ', '), '<row maskValue="', ''), '"/>', '') 
                + Case When sched.freq_recurrence_factor <> 0 
                        And sched.freq_recurrence_factor = 1 
                            Then '; weekly' 
                    When sched.freq_recurrence_factor <> 0 Then '; every ' 
                + Cast(sched.freq_recurrence_factor As varchar(10)) + ' weeks' End
            When sched.freq_type = 16 Then 'On day ' 
                + Cast(sched.freq_interval As varchar(10)) + ' of every '
                + Cast(sched.freq_recurrence_factor As varchar(10)) + ' months' 
            When sched.freq_type = 32 Then 
                Case When sched.freq_relative_interval = 1 Then 'First'
                    When sched.freq_relative_interval = 2 Then 'Second'
                    When sched.freq_relative_interval = 4 Then 'Third'
                    When sched.freq_relative_interval = 8 Then 'Fourth'
                    When sched.freq_relative_interval = 16 Then 'Last'
                End + 
                Case When sched.freq_interval = 1 Then ' Sunday'
                    When sched.freq_interval = 2 Then ' Monday'
                    When sched.freq_interval = 3 Then ' Tuesday'
                    When sched.freq_interval = 4 Then ' Wednesday'
                    When sched.freq_interval = 5 Then ' Thursday'
                    When sched.freq_interval = 6 Then ' Friday'
                    When sched.freq_interval = 7 Then ' Saturday'
                    When sched.freq_interval = 8 Then ' Day'
                    When sched.freq_interval = 9 Then ' Weekday'
                    When sched.freq_interval = 10 Then ' Weekend'
                End
                + Case When sched.freq_recurrence_factor <> 0 
                        And sched.freq_recurrence_factor = 1 Then '; monthly'
                    When sched.freq_recurrence_factor <> 0 Then '; every ' 
                + Cast(sched.freq_recurrence_factor As varchar(10)) + ' months' End
            When sched.freq_type = 64 Then 'StartUp'
            When sched.freq_type = 128 Then 'Idle'
          End As 'frequency'
        , IsNull('Every ' + Cast(sched.freq_subday_interval As varchar(10)) + 
            Case When sched.freq_subday_type = 2 Then ' seconds'
                When sched.freq_subday_type = 4 Then ' minutes'
                When sched.freq_subday_type = 8 Then ' hours'
            End, 'Once') As 'subFrequency'
        , Replicate('0', 6 - Len(sched.active_start_time)) 
            + Cast(sched.active_start_time As varchar(6)) As 'startTime'
        , Replicate('0', 6 - Len(sched.active_end_time)) 
            + Cast(sched.active_end_time As varchar(6)) As 'endTime'
        , Replicate('0', 6 - Len(jobsched.next_run_time)) 
            + Cast(jobsched.next_run_time As varchar(6)) As 'nextRunTime'
        , Cast(jobsched.next_run_date As char(8)) As 'nextRunDate'
    From msdb.dbo.sysschedules As sched
    Join msdb.dbo.sysjobschedules As jobsched
        On sched.schedule_id = jobsched.schedule_id
    Where sched.enabled = 1
)

Select job.name As 'jobName'
    , sched.scheduleName
    , sched.frequency
    , sched.subFrequency
    , SubString(sched.startTime, 1, 2) + ':' 
        + SubString(sched.startTime, 3, 2) + ' - ' 
        + SubString(sched.endTime, 1, 2) + ':' 
        + SubString(sched.endTime, 3, 2) 
        As 'scheduleTime' -- HH:MM
    , SubString(sched.nextRunDate, 1, 4) + '/' 
        + SubString(sched.nextRunDate, 5, 2) + '/' 
        + SubString(sched.nextRunDate, 7, 2) + ' ' 
        + SubString(sched.nextRunTime, 1, 2) + ':' 
        + SubString(sched.nextRunTime, 3, 2) As 'nextRunDate'
      /* Note: the sysjobschedules table refreshes every 20 min, 
        so nextRunDate may be out of date */
    , 'Execute msdb.dbo.sp_update_job @job_id = ''' 
        + Cast(job.job_id As char(36)) + ''', @enabled = 0;' As 'disableScript'
From msdb.dbo.sysjobs As job
Join myCTE As sched
    On job.job_id = sched.job_id
Where job.enabled = 1 -- do not display disabled jobs
Order By nextRunDate;

Insert Into main_table
  select t.* 
    from temp_table t
    left outer join main_Table m
      on t.line_id=m.line_id
   where m.line_id is null

ALTER SESSION SET current_schema = other_user;

UPDATE mytable
SET mydatetimecolumn =
    CAST(CONVERT(date, @date) as datetime) + CONVERT(time, mydatetimecolumn)
WHERE <my_where_clause>

SELECT *
FROM your_table 
ORDER BY your_table.geom <-> "your location..."
LIMIT 5;

SELECT CAST(0 AS varchar)        -- Output: '0'
SELECT CAST('' AS smallint)      -- Output: 0

SELECT SQL_CALC_FOUND_ROWS * FROM blah WHERE disabled = '0'  LIMIT 10,20
SELECT FOUND_ROWS();

CREATE TABLE transaction (
    id INT NOT NULL,
    accountnumber VARCHAR2(30) NOT NULL,
    stmtvaluedate DATE NOT NULL
)
PARTITION BY RANGE (stmtvaluedate)
INTERVAL (NUMTOYMINTERVAL (1,'MONTH')) ( partition transaction_old values less than (to_date('01-JAN-2000','DD-MON-YYYY') ));

SELECT CASE 
        WHEN MOD(ROW_NUMBER() OVER(ORDER BY number), 4) = 1 THEN 'joe'
        WHEN MOD(ROW_NUMBER() OVER(ORDER BY number), 4) = 2 THEN 'jim'
        WHEN MOD(ROW_NUMBER() OVER(ORDER BY number), 4) = 3 THEN 'gill'
        WHEN MOD(ROW_NUMBER() OVER(ORDER BY number), 4) = 0 THEN 'jack'
    END
FROM t

ALTER SESSION SET current_schema = UserA;

SELECT adminTags.Tag, URL, Votes FROM `adminTags` 
LEFT JOIN `Tags` ON adminTags.Tag = Tags.Tag AND Tags.URL = "$site"

DECLARE @Tsql VARCHAR(MAX) 
SET @Tsql = 'SELECT Id, Name FROM MyClientTable WHERE <condition to identify problem rows> AND ID IN ('

SELECT @Tsql = @Tsql + CAST(ID AS VARCHAR) + ','
FROM MyServerTable
WHERE <Condition to identify problem row candidates>

--Remove last trailing comma, append closing parentheses.
SELECT @Tsql = LEFT(@Tsql, LEN(@Tsql) - 1) + ')'

PRINT @Tsql

-- =============================================
-- Procedure Name   : dbo.ageTest
-- Usage Example    : EXECUTE [dbo].[ageTest] '19511214';
-- =============================================
ALTER PROCEDURE [dbo].[ageTest]
(
    @curDate DATE
)
AS
BEGIN
    SET NOCOUNT ON;
    BEGIN TRY
        SELECT DATEDIFF(MM, @curDate, CURRENT_TIMESTAMP) / 12 AS Years
            , DATEDIFF(MM, @curDate, CURRENT_TIMESTAMP) % 12 AS Months;
    END TRY
    BEGIN CATCH
        SELECT ERROR_NUMBER(), ERROR_MESSAGE();
    END CATCH
END

SELECT COLNAME, COLNO, TYPENAME, NULLS FROM SYSCAT.COLUMNS 
       WHERE TABSCHEMA = ? and TABNAME = ? order by colno

Are they equivalent?

Declare @strSQL nVarChar (Max) = ';
'

select @strSQL = @strSQL  + 'Drop Table ' + T.TABLE_SCHEMA + '.'+ TABLE_NAME + ';
'
From INFORMATION_SCHEMA.TABLES   T
Where Table_Name Like '%ABC1234%'

Print @strSQL
Exec Sp_ExecuteSQL @strSQL

 WITH last_entry as (
     SELECT *, ROW_NUMBER() OVER(PARTITION BY Name ORDER BY Entry DESC) AS row
     FROM table1
     WHERE entry > DATE_SUB(NOW(), INTERVAL 1 HOUR)
 )
 SELECT *
 FROM last_entry
 WHERE 
     row = 1
 and CheckIn = 0

select sort_id, level, security
from (select t.*, min(case when authorized = 'U' then id end) over (partition by grp) as minuid
      from (select t.*,
                   (row_number() over (order by id) - level) as grp
            from table t
           ) t
     ) t
where id > minuid;

DECLARE @AlertDateTime DATETIME
SELECT @AlertDateTime = DATEADD(mi, -30, GETDATE())  

SELECT * 
FROM dbo.SendAlertLog
WHERE AlertDateTime >= @AlertDateTime 
    AND ISNULL(Skipflag, 'E') IN ('E', 'O', 'N')  

ALTER TABLE dbo.YourTableName
  ADD LowerFieldName AS LOWER(YourFieldName) PERSISTED

CREATE NONCLUSTERED INDEX IX_YourTableName_LowerFieldName
  ON dbo.YourTableName(YourFieldName)

create table decisions (
  did hierarchyid primary key,
  fac char,
  split decimal(10,4),
  val decimal(10,4),
  sourceline int
)

insert decisions values
  (cast('/0/' as hierarchyid), 'a', 64,null,1), 
  (cast('/0/0/' as hierarchyid), 'd', 71.5,null,2),
  (cast('/0/0/0/' as hierarchyid), 'a', 49.5,null,3),
  (cast('/0/0/0/0/' as hierarchyid), 'd', 23.5,null,4),
  (cast('/0/0/0/0/0/' as hierarchyid), NULL, NULL,19.44,4),
  (cast('/0/0/0/0/1/' as hierarchyid), NULL, NULL, 24.25,5),
  (cast('/0/0/0/1/' as hierarchyid), NULL, NULL, 30.8,6),
  (cast('/0/0/1/' as hierarchyid), NULL, NULL, 33.6,7),
  (cast('/0/1/' as hierarchyid), 'd', 83.5,null,9),
  (cast('/0/1/0/' as hierarchyid), 'a', 91,null,10),
  (cast('/0/1/1/' as hierarchyid), NULL, NULL, 47.1,20),
  (cast('/0/1/0/0/' as hierarchyid), 'e', 93.5,null,11),
  (cast('/0/1/0/0/0/' as hierarchyid), 'd', 45,null,12),
  (cast('/0/1/0/0/0/0/' as hierarchyid), null,null,31.9,12),
  (cast('/0/1/0/0/0/1/' as hierarchyid), 'e', 21.5,null,14),
  (cast('/0/1/0/0/0/1/0/' as hierarchyid), null,null,44.1,14),
  (cast('/0/1/0/0/0/1/1/' as hierarchyid), 'a', 77.5,null,16),
  (cast('/0/1/0/0/0/1/1/0/' as hierarchyid), NULL,NULL,33.45,16),
  (cast('/0/1/0/0/0/1/1/1/' as hierarchyid), NULL,NULL,39.46,17),
  (cast('/0/1/0/0/1/' as hierarchyid), NULL,NULL,45.97,18),
  (cast('/0/1/0/1/' as hierarchyid), NULL,NULL, 42.26,19);

MATCH (u:User)-[:FRIEND]-(f)-[:POSTED]->(post) 
WHERE u.name = "Rachel Green" 
RETURN f.name AS friend, post.text AS content

using System;
using System.Data.OleDb;
using Dapper;

namespace DapperExample
{
    class Program
    {
        static void Main(string[] args)
        {
            using (var con = new OleDbConnection("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=test.mdb"))
            {
                var list = con.Query<Product>("select * from products");

                Console.WriteLine("map to a strongly typed list:");
                foreach (var item in list)
                {
                    Console.WriteLine(item.ProductNumber + " : " + item.Description);
                }

                Console.WriteLine();

                var list2 = con.Query("select * from products");

                Console.WriteLine("map to a list of dynamic objects:");
                foreach (var item in list2)
                {
                    Console.WriteLine(item.ProductNumber + " : " + item.Description);
                }

                Console.ReadLine();
            }
        }
    }

    public class Product
    {
        public string ProductNumber { get; set; }
        public string Description { get; set; }
    }
}

SELECT t1.id, t1.[Group], t1.Value
     , coalesce(MAX(t2.Value),0) As Prev_Value
     , t1.Value - coalesce(MAX(t2.Value),0) As Result
FROM MyTable t1
LEFT JOIN MyTable t2 ON t2.[Group] = t1.[Group] and t2.Value < t1.Value
GROUP BY t1.id, t1.[Group], t1.Value

SELECT g.gemid as ggemid, g.title as gtitle, gemdetail.filename as gfilename, r.filename as rfilename, rt.sum_rating
FROM (SELECT gems.* FROM gems ) g 
LEFT JOIN 
(SELECT title, x.gemid, x.replygemid, x.userid, y.filename  from gems x 
LEFT JOIN gemdetail y ON x.gemid = y.gemid ) r ON g.gemid = r.replygemid 
LEFT JOIN gemdetail ON g.gemid = gemdetail.gemid 
LEFT JOIN (SELECT gemid, SUM(rating) as sum_rating from rating GROUP BY gemid) rt ON g.gemid = rt.gemid

If [ Requests::nTickets > 40 ]  
Show Custom Dialog [ 
>>>Title: "Limited Number of Tickets"; 
>>>Message: "The number of tickets available for purchase is limited to 40. Please re-enter the amount of tickets you would like to purchase.";
>>>Default Button: “OK”, Commit: “Yes”;
]    
Go to Field [ FTS_Questions::nTickets ]
Exit Script
End If

SQL> create table Work_times(
  2    work_time
  3  ) as
  4  (
  5  select to_date('01.01.2012 19:03:00', 'dd.mm.yyyy hh24:mi:ss') from dual union all
  6  select to_date('01.01.2012 20:00:00', 'dd.mm.yyyy hh24:mi:ss') from dual union all
  7  select to_date('01.01.2012 21:02:00', 'dd.mm.yyyy hh24:mi:ss') from dual union all
  8  select to_date('01.01.2012 21:54:00', 'dd.mm.yyyy hh24:mi:ss') from dual union all
  9  select to_date('01.01.2012 23:04:00', 'dd.mm.yyyy hh24:mi:ss') from dual union all
 10  select to_date('02.01.2012 00:02:00', 'dd.mm.yyyy hh24:mi:ss') from dual
 11  )
 12  /

Table created

SQL> 
SQL> select to_char(t.work_time, 'hh24.mi.ss') work_time
  2         , (t.work_time -
  3            lag(t.work_time) over(order by WORK_TIME)) day(1) to second(0) Res
  4  from work_times t
  5  ;

WORK_TIME RES
--------- -------------------------------------------------------------------------------
19.03.00  
20.00.00  +0 00:57:00
21.02.00  +0 01:02:00
21.54.00  +0 00:52:00
23.04.00  +0 01:10:00
00.02.00  +0 00:58:00

6 rows selected

select new map( max(bodyWeight) as max, min(bodyWeight) as min, count(*) as n ) from Cat cat

update Sales 
set `amount-sold` = 
  `sold-items` * 
  (select ifnull(price, 0) 
   from Product 
   where Product.id=Sales.product_id);

SELECT Length(lastname)
FROM MyTable
GROUP BY Length(lastname)

SELECT * FROM `team` WHERE FIND_IN_SET('72',`team_members`)

SET @column_alias1 := NOW() - INTERVAL 1 WEEK;
SET @column_alias2 := NOW() - INTERVAL 2 WEEK;
SET @query := CONCAT('SELECT SUM(...) AS `', @column_alias1, '`, SUM(...) AS `', @column_alias2, '` FROM ...');
PREPARE dynamic_statement FROM @query;
EXECUTE dynamic_statement;

Dim db as Database
Dim rec as Recordset

Set db = CurrentDB
Set rec = db.OpenRecordset("Select * from ProjectsF WHERE ProjectID = " & Me.ProjectID & "")

cFilePath = rec("FilePath")

SQL> WITH q AS (
SELECT '/01/02/007/008/009' a FROM dual
UNION
SELECT '/01/02/007/008' FROM dual
UNION
SELECT '/01/02/007' FROM dual
UNION
SELECT '/01/02' FROM dual
UNION 
SELECT '/01' FROM dual)
SELECT a, CASE WHEN INSTR(a,'/',1,4) > 0 THEN SUBSTR(a,2,INSTR(a,'/',1,4)-2)
               WHEN INSTR(a,'/',1,3) > 0 THEN SUBSTR(a,2)
               WHEN INSTR(a,'/',1,2) > 0 THEN SUBSTR(a,2)||'/NA'
               ELSE SUBSTR(a,2)||'/NA/NA'
          END RESULT
  FROM q;          

A                  RESULT
--------------     -------------------
/01                01/NA/NA
/01/02             01/02/NA
/01/02/007         01/02/007
/01/02/007/008     01/02/007
/01/02/007/008/009 01/02/007

SQL> 

with A as (select 1 PRID, 1 PRTRNSID from dual
          union all
          select 1, 2 from dual
          union all
          select 1, 3 from dual
          union all
          select 2, 1 from dual
          union all
          select 2, 2 from dual),
     B as (select 1 EVENTTRNID, 1 PRID, 1 PRTRNSID from dual
          union all
          select 2, 1, 2 from dual
          union all
          select 3, 2, 1 from dual
          union all
          select 4, 2, 2 from dual)

select A.prid, case when min(case when B.EVENTTRNID is null then 0 else B.EVENTTRNID end) = 0 then 'Pending' else 'Done' end Status
  from A left join B on B.PRID = A.PRID and B.PRTRNSID = A.PRTRNSID
 group by A.prid

SELECT
  service_type,
  COUNT(service_type) AS GrandTotal,
  COUNT(CASE WHEN created_on BETWEEN '2013-01-01' AND '2013-06-30' THEN 1 END) AS FirstHalf2013
FROM qba_customers
GROUP BY service_type
ORDER BY GrandTotal

select count(*) 
from (select 1 as y 
     from farmer data 
     group by farmer Name 
     having count(distinct Variety Of Crop)>1) x

SET @sql = null;

SELECT
  CONCAT('INSERT INTO test.customer (',
    group_concat(CONCAT('`', COLUMN_NAME, '`') separator ','),
    ') SELECT ',
    group_concat(CONCAT('`', COLUMN_NAME, '`') separator ','),
    ' FROM live.customer WHERE NOT EXISTS(SELECT * from test.customer)')
FROM `INFORMATION_SCHEMA`.`COLUMNS` 
WHERE `TABLE_NAME`='customer' AND `TABLE_SCHEMA`='test'
INTO @sql;

PREPARE stmt FROM @sql;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;

SELECT * FROM test_customer;

SELECT CASE Month
            WHEN '1' THEN 'January'
            WHEN '2' THEN 'February'
            WHEN '3' THEN 'March'
            WHEN '4' THEN 'April'
            ...
      END+'-'+Year
FROM TABLE

SELECT {fn TRIM(LEADING '0' FROM LEFT(col_name, 2) || ':' || RIGHT(col_name, 2)) }
FROM table_name

SELECT
        [name]
       ,create_date
       ,modify_date
FROM
        sys.tables

select table_two.tid, 
       table_one.id, 
       table_one.email 
 from  table_two 
       left join table_one on table_one.id = table_two.tid

SELECT case when col2 is null then col1 
else col2 end as col FROM
(SELECT  @first as col1,@parent_id :=
    (
    SELECT id
    FROM    mytable
    WHERE   parent_id = @parent_id
    ) AS col2
FROM    (
    SELECT @parent_id := @first
    ) var2,
    (
    SELECT  @first := 7
    ) var1
STRAIGHT_JOIN
    mytable
WHERE   @parent_id IS NOT NULL)tab

select a.foo, a.bar, a.baz, b.baz, b.fee, b.fie
from a
join b
on a.foo = b.foo and a.bar = b.bar and ((a.baz = b.baz) OR b.baz = 'DEFAULT')
where not exists (select 1
                  from b as b1
                  where a.foo = b1.foo and
                        a.bar = b1.bar and 
                        b.baz = 'DEFAULT' and
                        b1.baz = a.baz)

SELECT * FROM Payments
INNER JOIN (SELECT Min([Date]) AS MinDate, UserID 
            FROM Payments GROUP BY UserID) AS M
ON M.MinDate = Payments.Date AND M.UserID = Payments.UserID

   $term =mysql_real_escape_string($_REQUEST['term']); 
   $rs = mysql_query("
                      select StateInitials, City 
                      from locations 
                      where City like '$term%' 
                      GROUP BY StateInitials, City
                      limit 0,15", $dblink);

SELECT x.a, 
       x.b
  FROM TABLE_X x
 WHERE x.a = 'mung'
UNION
SELECT y.a, 
       y.b
  FROM TABLE_Y y
 WHERE y.a = 'mung'

select .....
from A left outer join B
on (A.ApkColumn=B.AfkColumn)

UPDATE s
    SET country_id = c.country_id
    FROM tbl_states s
        INNER JOIN tbl_countries c
            ON s.country_id = c.country_id_id

CREATE TRIGGER trigger_name ON your_table
AFTER UPDATE AS 
    BEGIN
       UPDATE your_table
       SET your_table.last_update = GETDATE()
       FROM your_table t
       JOIN inserted i ON t.id = i.id
    END

SELECT 
    EID,
    Name,
    (
        CASE 
            WHEN NOT changed_id IS NULL OR NOT changed_id = 'NULL' 
            THEN 'Y' 
            ELSE 'N' 
        END 
    )AS FLAG
FROM 
    EMPLOYEE

select distinct group_concat(person2 order by person2)
from t
group by person1;

select sum(x.col2) as sum
from (
    select case 
           when col1 in (select letter from letters_table) then col2 
           else 0 
           end as col2
    from YourTableName
) x

SELECT p.*, r.*
FROM products AS p
  JOIN revisions AS r USING (product_id)
  LEFT OUTER JOIN revisions AS r2 
    ON (r.product_id = r2.product_id AND r.modified < r2.modified)
WHERE r2.revision_id IS NULL;

where tblRTC.CODE IN ('C1', 'C2', 'C3')
and CAST(tblDET.START_DATE AS Date) >= CAST (@start_date AS Date)
and CAST(tblDET.END_DATE AS Date) <= CAST (@end_date AS Date)
and tblSTACON.DESCRIPTION = (case when @station  not in( 'Unspecified') then @station else tblSTACON.DESCRIPTION end)

SELECT t.accounts.bidd.baseID, MAX(t.accounts.balance)
FROM order o, table(c.accounts) t
WHERE t.accounts.acctype = 'verified'
GROUP BY t.accounts.bidd.baseID;

select d1.id,d2.id from datesBooked d1
   inner join datesBooked d2 on 
      d1.cottageid=d2.cottageid
      and d1.from = d2.from
      and d1.to = d2.to
      and d1.id<d2.id

Select ClaimId
,InterestSubsidyClaimId
,BankId,BankName
,UpdatedPrincipalAmountofOutStanding
,[date] 

From InterestSubsidyReviseClaim 

Where ClaimId=(

                   Select max(ClaimId)
                   From InterestSubsidyReviseClaim 
                   Where IsActive = 1 and InterestSubsidyReviseClaim.InterestSubsidyClaimId=1 
                   group by BankId

              )

SELECT 
  CAST('2014-01-03' AS DATE) AS tape_date
  ,'alice' AS empl   
  ,'K' AS val
INTO #temp_table;
INSERT INTO #temp_table VALUES('2014-01-08', 'bob', 'A');
INSERT INTO #temp_table VALUES('2014-01-01', 'bob', 'G');
INSERT INTO #temp_table VALUES('2014-01-02', 'bob', 'D');
INSERT INTO #temp_table VALUES('2014-01-05', 'bob', 'E');


-- USING SYBASE ONLY LIST FUNCTION
SELECT empl, SUBSTR(LIST(val ORDER BY tape_date), 1, 5)
FROM #temp_table
GROUP BY empl;

-- THE GENERIC WAY
SELECT 
  empl
  ,MAX(CASE rank WHEN 1 THEN val ELSE '' END) 
    + ',' 
    + MAX(CASE rank WHEN 2 THEN val ELSE '' END)
    + ',' 
    + MAX(CASE rank WHEN 2 THEN val ELSE '' END)
FROM (
SELECT
  RANK() OVER (PARTITION BY empl ORDER BY tape_date) AS rank
  ,*  
FROM #temp_table) a
WHERE rank <= 3
GROUP BY 
  empl  

SELECT * 
INTO NewTable
FROM combined
LEFT OUTER JOIN isbn_price
ON combined.isbn13 = isbn_price.isbn;

SELECT * 
FROM appointments app 
where app.patient_id = 123 AND appointment_start_dt > Now()
order by appointment_start_dt ASC LIMIT 1;

SELECT node_id, count(distinct way_id)
FROM way_nodes
GROUP BY node_id
HAVING count(distinct way_id) > 1

INSERT INTO target_table(OldID,Fruit,Apples)
SELECT NewID,Fruit,Apples FROM source_table

DECLARE @currentKEY INT
DECLARE @maxKey INT

SELECT @currentKey = MIN(subjectID), @maxKey = MAX(subjectID) FROM mytable

WHILE @currentKey <= @maxKEY
BEGIN
  UPDATE myTable
  SET SUBJECT = HASHBYTES('SHA1', SUBJECT)
  WHERE subjectID = @currentKEY

  SELECT @currentKey = MIN(subjectID) FROM mytable WHERE subjectID > @currentKey
END

SELECT MAX(DataValue) - MIN(DataValue) FROM TABLE
WHERE ([TimeStamp] < GETDATE()-0
AND ([TimeStamp] > GETDATE()-31)

SELECT
  [ID]
 ,[Product $] / COUNT(*) OVER(PARTITION BY [ID])
 ,[Shipping $]
FROM MyTable

DECLARE @mySchema NVARCHAR(MAX);  
SET @mySchema = N'';  
SET @mySchema =@mySchema  +   
(
  SELECT * FROM ChartSetting1 
  FOR XML AUTO, ELEMENTS, XMLSCHEMA('ChartSetting1')
);

SET @mySchema =@mySchema  +   
(
  SELECT * FROM ChartSetting2 
  FOR XML AUTO, ELEMENTS, XMLSCHEMA('ChartSetting2')
);

CREATE XML SCHEMA COLLECTION [name] AS @mySchema;

-- we don't need these tables , drop them  
DROP TABLE ChartSetting1,ChartSetting2

                 int rowsEffected = database.update(...);

select a.name,a.[group],2 as [status] from animal a
where exists(select * from mammal b where b.name = a.name and b.[group]=a.[group])

SELECT d.title, COUNT(dc.comment_id) AS total_comments
    FROM departments d
        LEFT JOIN department_commments dc
            INNER JOIN comments c
                ON dc.commment_id = c.id
                    AND c.year_code = 1011
            ON d.id = dc.department_id
    GROUP BY d.title

SELECT a.username, b.type,
SUM(case when b.type = 'tip' then 1 else 0 end) as "tipsCount",
SUM(case when b.type = 'request' then 1 else 0 end) as "requestsCount"
FROM users as a
LEFT JOIN submissions as b
ON a.id = b.user_id 
GROUP BY a.username, b.type; 

select a.location_name, sum(netvalue155), sum(netvalue135) from
(select l.id ,l.location_name,
case when v.net_value = 155 then 1 else 0 end as netvalue155,
case when v.net_value = 135 then 1 else 0 end as netvalue135
from locations l left join bookings b
on l.id = b.location_id
left join vouchers v
on  b.voucher_code = v.voucher_code) a
right join locations l on l.id = a.id
group by a.location_name

SELECT
    news.newsTitle, COUNT(comments.ID) AS `Total Comments`
FROM news INNER JOIN comments ON
    news.newsId = comments.newsID AND news.newsDate BETWEEN '20120414' AND '20130414'
GROUP BY news.newsId
ORDER BY `Total Comments` DESC
LIMIT 10;

UPDATE `web`.`pro`
SET `pro`.`st` = `pro`.`st` + `s`.`Quantity`
FROM `web`.`pro`
JOIN `shopping cart` `s`
  ON `s`.`Pro_id` = `pro`.`ProdID`;

type unicodefile > ansifile

with member [Measures].[a] as "welcome"
member [Measures].[b] as iif([Measures].[a] = "welcome", "raj"+","+ "venkat", null)

select [Measures].[b] on 0 from [mycube]

insert  [jsec_user_role_rel]
        ([version], [role_id], [user_id])
select  distinct 0
,       1
,       id 
from    jsec_user u
where   not exists
        (
        select  * 
        from    jsec_user_role_rel ur
        where   ur.user_id = u.id
                and ur.role_id = 1
        )

create table #Product (
	ID		int identity(1, 1) primary key,
	Name		varchar(800),
	DateAdded	datetime default getdate()
)

insert	#Product(Name) select 'Chocolate'
insert	#Product(Name,DateAdded) select 'Candy', GETDATE() + 1
insert	#Product(Name,DateAdded) select 'Chocolate', GETDATE() + 5
select * from #Product

;with Ranked as (
	select	ID, 
		dense_rank() 
		over (partition by Name order by DateAdded desc) as DupeCount
	from	#Product P
)
delete	R
from	Ranked R
where	R.DupeCount > 1

select * from #Product

declare @from time = '10:10:01', @to time = '10:10:31'

declare @interval int = datediff(millisecond, @from, @to) / 10

select dateadd(millisecond, @interval * (i-1), @from) as [From], 
  dateadd(millisecond, @interval * i, @from) as [To]
from (values (1), (2), (3), (4), (5), (6), (7), (8), (9), (10)) x(i)

CREATE TABLE #test
(
    num int
)

CREATE TABLE #test2
(
    num int
)

INSERT INTO #test (num)
SELECT 1 UNION ALL
SELECT 2 UNION ALL
SELECT 3 UNION ALL
SELECT 4 UNION ALL
SELECT 6 UNION ALL
SELECT 7 

INSERT INTO #test2 (num)
SELECT 1 UNION ALL
SELECT 2 UNION ALL
SELECT 3 UNION ALL
SELECT 4 UNION ALL
SELECT 5 UNION ALL
SELECT 6 UNION ALL 
SELECT 7

SELECT MIN(t1.num)+1 FROM #test t1
    LEFT JOIN #test t2 ON t1.num+1 = t2.num
    WHERE t2.num IS NULL

SELECT MIN(t1.num)+1 FROM #test2 t1
    LEFT JOIN #test2 t2 ON t1.num+1 = t2.num
    WHERE t2.num IS NULL

EVERY (will do logical and)
SOME (will do logical or)

SELECT q.Make, Count(q.ID)
FROM
(
SELECT ID,Make,Model 
FROM cars 
WHERE active='true'  
ORDER BY make ASC, model ASC 
OFFSET 0 ROWS FETCH NEXT 5 ROWS ONLY
) AS q
GROUP BY q.make
ORDER BY q.make ASC;

SELECT ID
FROM TABLE_A
GROUP BY ID
HAVING COUNT(*) = COUNT(CASE WHEN SUBSTR(code,3,1) = '6' THEN 1 END)

SELECT  id_cat, id_city, COUNT(*) cat_Count
FROM    tableName 
GROUP   BY id_cat, id_city

select column1, column2
from myTable 
group by column1, column2
having count(*) = 1

  DENSE_RANK() OVER(Order By [shade]) as t_index

     EXISTS (SELECT 1 FROM review r WHERE r.product_id = p.product_id) AS has_review,
     EXISTS (SELECT 1 FROM thread t WHERE t.product_id = p.product_id) AS has_thread,
     EXISTS (SELECT 1 FROM award a WHERE a.product_id = p.product_id) AS has_award,

SELECT ROUND(avg(rate_per_sqft)) as RatePerSqFt 
  FROM ratepersqft
 WHERE common_location = 'ECR' AND
       1 <= MONTH(date) AND MONTH(date) <3  
       group by common_location
UNION
SELECT ROUND(avg(rate_per_sqft)) as RatePerSqFt 
  FROM ratepersqft
 WHERE common_location = 'ECR' AND
       3 <= MONTH(date) AND MONTH(date)<6  
       group by common_location
UNION
SELECT ROUND(avg(rate_per_sqft)) as RatePerSqFt 
  FROM ratepersqft
 WHERE common_location = 'ECR' AND
       6 <= MONTH(date) AND MONTH(date)<9  
       group by common_location
UNION
SELECT ROUND(avg(rate_per_sqft)) as RatePerSqFt 
  FROM ratepersqft
 WHERE common_location = 'ECR' AND
       9 <= MONTH(date) AND MONTH(date)<=12
       group by common_location;  

declare @target_site as Int = 1
select distinct a.site, a.id, a.name, b.mark
  from @t1 as a inner join
    @t2 as b on a.site = @target_site and a.id = b.id and
      ( a.site = b.site or ( b.site = 0 and not exists ( select 42 from @t2 where site = @target_site and id = a.id ) ) )

CREATE SEQUENCE EMP.SEQ_ID
START WITH 41
NOMAXVALUE
CACHE 50;

query = columns.map {|col| "#{col} = ?"}.join(" AND ")
@finalValues = MyTable.find(:all, :conditions => [query, *vals])

WITH cteFiles AS (
    SELECT Product
          ,Material
          ,XXIMPORT
          ,Field1
          ,Field2
          ,Field3
          ,Field4
          ,Field5
          ,ROW_NUMBER() OVER(PARTITION BY Product, Material ORDER BY Field1, Field2) AS RowNum
        FROM dbo.Files
)
SELECT *
    FROM cteFiles
    WHERE RowNum = 1;

select avg(if (diff < 0, 0, diff))
from (
    select datediff(min(t2.start), t1.end) as diff
    from Table1 t1
    inner join Table1 t2 on t1.id < t2.id
    group by t1.end
) a

Declare @colName VARCHAR(20)
SET @colName = 'Feb'

Exec('select '+ @colName+' from TableA')

SELECT
   CUSTOMER_NAME,
   SUM(CASE WHEN TIMEFRAME = 'CURRENT'  THEN GROSS_SALES END)
   /
   SUM(CASE WHEN TIMEFRAME = 'PREVIOUS' THEN GROSS_SALES END)  AS SALES_FACTOR
FROM
   yourTable
GROUP BY
   CUSTOMER_NAME

SELECT count(*), STATUS FROM V_CUSTOMER
Where STATUS='a' OR STATUS='d'
GROUP BY STATUS

CREATE OR REPLACE VIEW OrderHistory
AS SELECT cast(OrderLine.ShopOrderID as varchar(255)) as ShopOrderId, Book.Title, OrderLine.UnitSellingPrice, OrderLine.Quantity,  
SUM(Quantity*UnitSellingPrice) AS total
FROM OrderLine
INNER JOIN Book
ON OrderLine.BookID = Book.BookID
WHERE OrderLine.BookID = 2
GROUP BY OrderLine.ShopOrderID, Book.Title, OrderLine.Quantity, OrderLine.UnitSellingPrice;

SELECT * FROM OrderHistory

UNION SELECT 'Summary', NULL, NULL, SUM(Quantity), SUM(Quantity*UnitSellingPrice) 
FROM OrderHistory
ORDER BY total;

SELECT a.itemid, b.description, a.total
FROM
    (
        SELECT itemid, sum(qty) as total
        FROM transactions
        GROUP BY itemid WITH ROLLUP
    ) as a
    LEFT JOIN item b ON a.itemid=b.itemid

select * from my_table t1
join 
(select ID, year, max(week) maxWeek
from my_table
where year = 2000 and
binary_flag = 1
group by Id,year) t2
on
(t1.Id=t2.id) and (t1.year=t2.year) and (t1.week=t2.maxWeek)

func serializeFoo(scanner interface{Scan(dest ...interface{}) error}) (*Foo, error) {

}

SELECT MyDate, Min(DateType)
From
(
  SELECT MyDate + T1.RecordType AS MyDate, T1.DateType
  FROM
  (
    Select 1 AS RecordType, 2 AS DateType
    Union ALL
    Select 0 AS RecordType, 1 AS DateType
    Union ALL
    Select -1 AS RecordType, 2 AS DateType
  ) AS T1
  CROSS JOIN myTable
  Where myTable.fkId = @MyFkId
) AS CombinedTable
Group By MyDate

IF @Version = '1.0'
BEGIN
    --Drop it if it already exists
    IF OBJECT_ID('uspCreateAccount', 'P') IS NOT NULL
        EXEC ('DROP PROCEDURE uspCreateAccount')
    --Recreate it.
    EXEC('
          CREATE PROCEDURE uspCreateAccount
          AS BEGIN
          --The rest of the code goes here
          END
    ')
END

GROUP_CONCAT(distinct link) link 

SELECT ID, Dept, 
    MIN(StartTime) [StartTime],
    MAX(EndTime) [EndTime],
    SUM(Wages) [Wages]
FROM Table 
GROUP BY ID, Dept

select t1.*,
       (select max(t2.value)
        from table2 t2
        where t2.date between t1.date1 and t1.date2
       ) as maxvalue
from table1 t1;

SELECT (select COUNT(*) from MzMesDb.SysLog) as CN, 
       Id,
       DateTime
FROM   MzMesDb.SysLog
WHERE  Deleted='F' 
order by id asc 
LIMIT 0,3;

SELECT
  players.Game AS Game,
  players.Name AS Name,
  'W' AS Result,
  'F' as Stage
FROM
  MyTable stage
  JOIN MyTable players
    ON stage.Game = players.Game
WHERE
  stage.stage = 'F'
  AND players.result = 'W'

INNER JOIN dbo.Listings AS L ON P.accountID = L.accountID

select s1.id, s1.name s1.points, count(s2.points)
from score s1, score s2
where s2.points > s1.points
group by s1.id, s1.name s1.points
having count(s2.points) <= (select count(*)*.1 from score)

SELECT  user_id, address1 
FROM    transaction t 
WHERE   user_id = 70005 
    AND row_id = 
        IFNULL(
          (SELECT MAX(row_id) 
         FROM transaction ti 
         WHERE ti.user_id = t.user_id AND address1 IS NOT NULL),

         (SELECT MAX(row_id) 
         FROM transaction ti 
         WHERE ti.user_id = t.user_id ) 
        );

$this->db->select('SUM(IF(pay_type = 1, pay_amount, 0)) mess_pay, SUM(IF(pay_type=2, pay_amount, 0)) est_pay', false);

select o.CustomerId, o.ProductId, p.ProductType
from orders o join
     products p
     on o.productId = p.Id left join
     bills b
     on b.orderId = o.Id
where b.id is null;

SELECT *
FROM reports AS r
JOIN reportvalues AS rv ON rv.report_id = r.report_id
JOIN metrics AS m ON m.metric_id = rv.metric_id
WHERE NOT EXISTS (SELECT 1 
        FROM exclude_report e 
        WHERE e.report_id = r.report_id)

CREATE TABLE [dbo].[EventLog](
    [EventId] [int] NOT NULL,
    [UserId] [int] NOT NULL,
    [Time] [datetime] NOT NULL,
    [Timestamp] [timestamp] NOT NULL,
    PRIMARY KEY([EventId],[UserId])

CREATE TABLE "Author/Title" (
    author_name VARCHAR(50),
    isbn VARCHAR(13) REFERENCES "Item Details",
    PRIMARY KEY (author_name, isbn)
)

SELECT id1, id2, sum(count), sum(sum) 
FROM (SELECT rt1.product_id as id1, rt2.product_id as id2, 1 as count, rt1.rate - rt2.rate as sum 
        FROM rating as rt1 
        JOIN rating as rt2 ON rt1.user_id = rt2.user_id AND rt1.product_id != rt2.product_id) as temptab
GROUP BY id1, id2

regarding single vs multiple requests:

public ActionResult SearchOrders(string searchString)
{
    var q = searchString.Trim().ToLower();

    var searchedOrders = dbContextObject.Orders.Where( t =>
                           t.CustomerEmail.ToLower().Contains(q) ||
                           t.OrderId.ToLower().Contains(q) ||
                           t.PostelCode.ToLower().Contains(q));
    if (searchedOrders.Count > 0)
    {
        return View("_searchedOrders", searchedOrders);
    }
    else
    {
        return Json("No Record found");
    }
}

SELECT username, AVG(average) AS average
  , GROUP_CONCAT(CONCAT('Course: ', teachers.course_id,' with score ', COALESCE(average,'No Score Found'))) AS detail
FROM (
    SELECT mdl_course.id AS course_id, mdl_user.username AS username
    FROM mdl_course
    INNER JOIN mdl_context ON mdl_context.instanceid = mdl_course.id
    INNER JOIN mdl_role_assignments ON mdl_context.id = mdl_role_assignments.contextid
    INNER JOIN mdl_role ON mdl_role.id = mdl_role_assignments.roleid
    INNER JOIN mdl_user ON mdl_user.id = mdl_role_assignments.userid
    WHERE mdl_role.id = 3 ) AS teachers
LEFT JOIN (
    SELECT mdl_feedback.course AS course_id, AVG(mdl_feedback_value.value) as average
    FROM mdl_feedback_value 
    INNER JOIN mdl_feedback_item ON mdl_feedback_value.item = mdl_feedback_item.id 
    INNER JOIN mdl_feedback ON mdl_feedback.id = mdl_feedback_item.feedback
    INNER JOIN mdl_feedback_completed ON mdl_feedback.id = mdl_feedback_completed.feedback
    INNER JOIN mdl_user ON mdl_feedback_completed.userid = mdl_user.id
    GROUP BY mdl_feedback.course) AS scores
  ON teachers.course_id = scores.course_id
GROUP BY username

select SUM(fact.cheques) as TotalChequeAmount,
       SUM(CASE 
              WHEN YEAR(time1.Date) = 2016 
                 THEN fact.revenusIntermediationToDate + fact.cheques 
              ELSE 0 
           END) as YTD ,
       SUM(CASE 
              WHEN YEAR(time1.Date) = 2015 
                 THEN fact.revenusIntermediationToDate + fact.cheques 
              ELSE 0 
           END) as YTDN1,
       SUM(revenusIntermediationToDate) as TotalRevenuIntermediationToDate,    
       acc.beCompanyCode as Codecompany,
       acc.Country as Pays,
       acc.Name as Name,
       acc.AccountTypeSec as AccountType,
       acc.Segmentation as Segmentation,
       acc.City as City,
       acc.OfficialGroup as OfficialGroup , 
       acc.ActualYearBudget as Budget2016,
       acc.SegmentationResSec as SegmentSecurities    
from dbo.Fact_Profit_And_Loss fact
left outer join dbo.Dim_Accounts acc  
   on ( acc.Accounts_TechKey = fact.FK_Account)
left outer join dbo.DimTemps time1 on (time1.Temps_PK = fact.FK_Time)
where YEAR(time1.Date) IN (2015, 2016)
group by acc.beCompanyCode, acc.Country , 
         acc.Name , acc.AccountTypeSec , 
         acc.Segmentation , acc.City , 
         acc.OfficialGroup , acc.ActualYearBudget, 
         acc.SegmentationResSec 

CREATE OR REPLACE TRIGGER MYSCHEMA.TRIGGER_NAME 
BEFORE INSERT ON MYSCHEMA.REGISTERED_PERSON
FOR EACH ROW
WHEN ( NEW.REGISTERED_PERSON_ID IS NULL )
BEGIN
  SELECT MY_SEQUENCE.NEXTVAL INTO :NEW.REGISTERED_PERSON_ID FROM dual;
END;

UPDATE tablename
SET col3 = CAST(LEFT(col1, 10) + " " + col2 + ":00", DATETIME)

  SELECT season, player, 
         SUM(CASE WHEN tour_position = 1 THEN 1 ELSE 0 END) AS WINS
    FROM your_table
GROUP BY season, player
ORDER BY season, player

CREATE OR REPLACE TRIGGER trg_table_name_set_id
  BEFORE INSERT 
  ON table_name
  FOR EACH ROW
BEGIN

  SELECT table_seq.nextval INTO :new.id FROM DUAL; --id would be the id column in your table

--or, if you are on 11g, simply
--:new.id := table_seq.nextval;

END trg_table_name_set_id;

SELECT HOTEL.H_NAME "HOTEL NAME", ROUND(AVG (R_PRICE), 1) "AVERAGE ROOM PRICE"
FROM ROOM JOIN HOTEL ON HOTEL.HOTEL_NO = ROOM.HOTEL_NO
WHERE HOTEL.H_NAME = 'Shangra_La'
OR HOTEL.H_NAME = 'Hilton'
OR HOTEL.H_NAME = 'Sheraton'
GROUP BY HOTEL.H_NAME
ORDER BY HOTEL.H_NAME;

select deviceid
from yourtable
where key = 1
group by deviceid
having count(key) > 1

SELECT max(insert_date) AS insert_date, creative_id, creative_object
from rtb_creatives 
where adgroup_id='agid1608844879' and is_delete in (0)
group by creative_id, creative_object

IF EXISTS (Select * from sysobjects where name = 'tblname')
Begin

Select *
from tbl

End
Else
Begin
--Do something else
End

SELECT DISTINCT
  distance,
  LEAST(origin, dest) AS endpoint1,
  GREATEST(origin, dest) AS endpoint2
FROM flights f
ORDER BY distance DESC LIMIT 10

declare
    @DeletablePeriodStart datetime,
    @BusinessDays int

set @DeletablePeriodStart = dateadd(d,0,datediff(d,0,getdate()))
set @BusinessDays = 0

while @BusinessDays < 3
begin
    set @DeletablePeriodStart = dateadd(d,-1,@DeletablePeriodStart)
    if datepart(dw,@DeletablePeriodStart) not in (1,7) and
        not exists (select * from HolidayTable where Holiday = @DeletablePeriodStart)
    begin
        set @BusinessDays = @BusinessDays + 1
    end
end

result = db.Query("SELECT ACTUAL_N_WELLS, TARGET_N_WELLS, \"YTD ACTUAL\" AS YTD_ACTUAL....");

insert into table2
(
    col2, col3, col4
)
select col1, col2, col3
from table1

CREATE TABLE mytable(
  a VARCHAR(20000),       -- 20002
  b VARCHAR(20000),       -- 20002
  c VARCHAR(20000),       -- 20002
  d VARCHAR(5535)         --  5537
) CHARACTER SET=latin1;--    65543 !!!! 8 Bytes to much

SELECT m.Company_id, m.Company_name, SUM(m.Price)
FROM 
(
  SELECT DISTINCT Company_id, Company_name, Price
  FROM MyTable 
) AS m
GROUP BY m.Company_id, m.Company_name

select distinct t.serialNo, e.controlNo, t.addDate
from tst_EquipmentItem e
join (
    select serialNo, max(addDate) as addDate
    from tst_EquipmentItem 
    group by serialNo
) t on t.serialNo = e.serialNo and t.addDate = e.addDate

(select col1 as "col 1",col2 as "col 2",col4 as "col 3" from t1)
union
(select col1 as "col 1",col3 as "col 2",col4 as "col 3" from t1)
order by `col 2`,`col 3`

SELECT * 
FROM 
  tracklisting t 
  INNER JOIN catelouge c on c.catno=t.catno 
WHERE t.id = 1

@staticmethod
def fromFieldHash(h):
    row = MyModel()
    cols = list(row.__table__._columns)
    for k, v in h.iteritems():
        col = find(lambda c: c.key == k, cols)
        # See http://www.sqlalchemy.org/trac/wiki/06Migration#AnImportantExpressionLanguageGotcha
        if col is not None:
            prop = row.__mapper__._columntoproperty[col].key
            setattr(row, prop, v)
    return row

SELECT  *
FROM    Crawl_Results AS oCR
JOIN    Products AS oP 
ON      oCR.product = oP.id
JOIN    Crawls AS oC 
ON      oCR.crawl = oC.id
JOIN    (
        SELECT  iP.id
        FROM    Products AS iP
        JOIN    Crawl_Results AS iCR 
        ON      iP.id = iCR.product
        WHERE   iP.category =2
        GROUP BY 
                iP.id
        HAVING  (MAX(iCR.price) - MIN(iCR.price)) > 1
        ) filter
ON      OP.id = filter.id

ALTER TABLE Employee ADD EmployeeID int identity(1,1) PRIMARY KEY;

WHILE EXISTS (SELECT COUNT(*) FROM Employee GROUP BY EmpID, EmpSSN HAVING COUNT(*) > 1)
BEGIN
    DELETE FROM Employee WHERE EmployeeID IN 
    (
        SELECT MIN(EmployeeID) as [DeleteID]
        FROM Employee
        GROUP BY EmpID, EmpSSN
        HAVING COUNT(*) > 1
    )
END

,(CASE
    WHEN YEAR(SomeDateField) = 1900
        THEN NULL
    ELSE
        SomeDateField
    END
)As 'Confirmed Date'

@extends('layouts.master')

@section('content')
    <h1>{{$product->title}}</h1>
    <p>{{$product->text}}</p>
@endsection



SELECT pagetag.id, page.name, group_concat(tag.name) FROM 
(page LEFT JOIN pagetag on page.id = pagetag.pageid) 
LEFT JOIN tag on pagetag.tagid = tag.id
group by page.id;

SELECT S1.A
FROM S1
INNER JOIN S2 on S1.A = S2.A
GROUP BY S1.A
HAVING COUNT(*) > 1

   SELECT location_status, 
          COUNT(DISTINCT(location))
     FROM table
 GROUP BY location_status

declare
  myCol1 varchar2(1000);
  myCol2 varchar2(1000);
  myCol3 varchar2(1000);
  myCol4 number;
  myCol5 number;
begin
  for line in
  (
    SELECT
        'SELECT ''' || atc.column_name || ''', ''' || atc.table_name || ''', ''' ||     atc.data_type || ''', 
    SUM(CASE WHEN temp.'|| atc.column_name || ' IS NULL THEN 0 ELSE 1 END)  "Filled     Values", 
        COUNT(temp.' || atc.column_name || ') "Total Records" 
        FROM all_tab_columns atc 
        JOIN '|| atc.table_name || ' temp ON atc.column_name = ''' || 
        atc.column_name ||''' AND atc.table_name = ''' || atc.table_name || '''' AS SQLRow 
    FROM all_tab_columns atc
  )
  loop
    dbms_output.put_line(myCol1 || ' | ' || myCol2 || ' | ' || myCol3 || ' | ' || myCol4 || ' | ' || myCol5);
    execute immediate line.Sqlrow into myCol1, myCol2, myCol3, myCol4, myCol5;
  end loop;
end;
/

SELECT  A.ID, 
        A.`Name`,
        GROUP_CONCAT(`TAGS`.`TAG`) AS tags 
FROM   ARTICLES A
       LEFT JOIN TAGS 
               ON TAGS.ID = A.ID 
WHERE   NOT EXISTS( SELECT 1 FROM TAGS 
                    WHERE ID = A.ID
                    AND Tag = 'search term')
GROUP  BY ARTICLES.ID, ARTICLES.`Name`; 

SUM(GREATEST(ordered_item.amount, 0)) as purchases

SELECT AVG(`rating`) FROM `car_ratings` WHERE `user_car` LIKE '%_56748'

with User1Totals as 
(
  select [Name], sum(Total) as Total, [Date]
  from YourTable
  where [Name] = 'User1'
  group by [Name], [Date]
), 
OtherUsersTotals as
(
  select sum(Total) as Total, [Date]
  from YourTable
  where [Name] <> 'User1'
  group by [Date]
)

select isnull(t2.Total, 0) - isnull(t1.Total, 0), coalesce(t2.[Date], t1.[Date])
from User1Totals t1
full outer join OtherUsersTotals t2 on t1.[Date] = t2.[Date]
​
select job_number, 
   row_number() over (partition by job_number order by time_submitted asc) as SRno
from tbl

;WITH cte (id, [Date], Amount) AS
 (
  SELECT ROW_NUMBER() OVER (ORDER BY [Date] ASC) AS id,
         [Date], Amount
  FROM dbo.your_table t1
  ), cte2 (id, [Date], [LevelDate], Amount) AS
 (         
  SELECT c1.id, c1.[Date], DATEDIFF(day, c1.[Date], c2.[Date]) AS [LevelDate], c1.Amount
  FROM cte c1 LEFT JOIN cte c2 ON c1.id = c2.id - 1
  ), cte3 (id, [Date], Amount, [Level]) AS
 (
  SELECT  id, [Date], Amount, 1 AS [Level]
  FROM cte2 c
  UNION ALL
  SELECT c.id, DATEADD(day, 1, ct.[Date]) AS [Date], c.Amount, ct.[Level] + 1
  FROM cte2 c JOIN cte3 ct ON c.id = ct.id
  WHERE c.[LevelDate] > ct.[Level]
  )
  SELECT [Date], Amount
  FROM cte3
  ORDER BY Date
  OPTION (maxrecursion 0)

WITH SampleData(UserID, Val) AS(
    SELECT 'User1', -10 UNION ALL
    SELECT 'User2', 10 UNION ALL
    SELECT 'User3', -15 UNION ALL
    SELECT 'User4', -10 UNION ALL
    SELECT 'User5', -15 UNION ALL
    SELECT 'User6', -10 UNION ALL
    SELECT 'User7', 10 UNION ALL
    SELECT 'User8', 15 
)
,Numbered AS(
    SELECT
        UserID,
        Val,
        BaseVal = ABS(Val),
        RN = ROW_NUMBER() OVER(PARTITION BY ABS(Val), Val ORDER BY UserId)
    FROM SampleData
)
SELECT 
    n1.UserID,
    n1.Val
FROM Numbered n1
LEFT JOIN Numbered n2 
    ON n2.BaseVal = n1.BaseVal
    AND n2.RN = n1.rn
    AND n2.UserID <> n1.UserID
WHERE n2.UserID IS NULL
ORDER BY n1.UserID

Query q = entityManager.createQuery("from someTable tbl order by tbl.id asc");
q.setFirstResult((pageNum -1)*pagesize).setMaxResults(pagesize); 

select subq.*, 
  st_before.quantity QUANTITY_BEFORE, 
  st_after.quantity QUANTITY_AFTER,  
  st_before.price PRICE_BEFORE,
  st_after.price PRICE_AFTER
from ( 
  select 
    max_id stock_id, 
    date_before,
    date_after 
  from
  (
    SELECT id max_id,max(date) date_after
    FROM STOCK
    GROUP BY ID 
  ) mx
  join 
  (  
    SELECT stock.id min_id,min(stock.date) date_before
    FROM STOCK 
    join (
       SELECT id,max(date) date_after
       FROM STOCK
       GROUP BY ID 
    ) mmx
    on stock.id = mmx.id
    and datediff(mmx.date_after, stock.date) < 1
    GROUP BY stock.ID 
  ) mn 
  on  mx.max_id = mn.min_id 
  ) subq 
  join stock st_before 
  on st_before.id = subq.stock_id 
  and st_before.date = subq.date_before 
  join stock st_after 
  on st_after.id = subq.stock_id 
  and st_after.date = subq.date_after 
  order by stock_id
;

with dates as
(
select number,DATEADD(day,number,'20130101') as dt
    from master..spt_values
    where number between 0 and 1000 AND TYPE='P'
)
select
    m.start_date as org_start_date,
    m.end_date as org_end_date,
    min(d.dt) as new_start_date,
    max(d.dt) as new_end_date,
    m.amount*count(distinct month(d.dt))/(datediff(month,m.start_date,m.end_date)+1) as amount
from 
    MonthSplit m
join
    dates d
on 
    d.dt between m.start_date and m.end_date
group by 
    m.start_date, m.end_date, year(d.dt),m.amount

BatterGames = rsBatQual("TotalPA")
DIM rsBatterLU, sqlBatterLU

sqlBatterLU = "SELECT games FROM tblLookupPSBatters "
sqlBatterLU = sqlBatterLU & "WHERE ((('" & BatterGames & "') Between ISNULL([minVal],-999999) And ISNULL([maxVal],999999)));"

set rsBatterLU = Server.CreateObject ("ADODB.RecordSet")
rsBatterLU.Open sqlBatterLU,conn  

DELIMITER $$ 
CREATE TRIGGER after_insert  -- remove ;
AFTER INSERT ON table_first
  FOR EACH ROW BEGIN 
    INSERT INTO table_second 
      (value1, rvalue2, value3)
    VALUES 
      ('123456', '654321', 'hello trigger');    -- add ;
  END
$$ -- add $$

DELIMITER ;

SELECT t1.Filepath 
FORM MyDuplicateTable t1
INNER JOIN (
  SELECT Filesize, Filename 
  FROM MyDuplicateTable 
  GROUP BY FILENAME, Filesize 
  HAVING COUNT(*) > 1
) t2 ON t1.Filesize = t2.Filesize AND t1.Filename = t2.Filename

SELECT * FROM table1 WHERE column1 IN (SELECT CASE WHEN ISNUMERIC(column2) = 1 THEN CAST(column2 AS INT) END FROM table2)

string TagId = "-1";
string TagList = "";
bool IsFirstRow = true;

public override void Input0_ProcessInputRow(Input0Buffer Row)
{
    if (Row.TAGSId.ToString() == TagId)
    {
        TagList += Row.TAG + ",";
    }
    else
    {
        if (IsFirstRow)
        {
            Output0Buffer.AddRow();
            IsFirstRow = false;
        }

        TagId = Row.TAGSId.ToString();
        TagList = Row.TAG.ToString() + ",";
    }

    Output0Buffer.TagId = int.Parse(TagId);
    Output0Buffer.TagList = TagList;
    Output0Buffer.TagLength = TagList.Length;

    //variable used in subsequent queries
    this.Variables.TagList = TagList;
}

AND irs.timeStamp >= CONVERT(DATE, DATEADD(DAY, -1, GETDATE()))
AND irs.timeStamp < CONVERT(DATE, GETDATE());

begin
  for rcPersons in (select * from Persons) loop
    for rcSubscriptions in (select * from Subscriptions where personId= rcPersons.Id) loop
       for rcEvents in (select * from Events where id = rcSubscriptions.eventId) loop
          null; --<do some logic here>      
       end loop;
    end loop;
  end loop;
end;

UPDATE your_table
SET id = id + (SELECT MAX(id) FROM your_table)

SELECT code, name, ST_Force2D(geom) 
FROM mytable 
WHERE mytable.city = 'Greater Sydney'

UNION 

SELECT '0', 'Remaining Countries', ST_Collect(geom) 
FROM mytable 
WHERE mytable.city <> 'Greater Sydney';

public static Session[] GetSessions(
    params Expression<Func<Session, bool>>[] filters)
{
    // I've created an auto-generate Linq-to-SQL context object with
    // a Sessions table.
    using (var ctx = new DataSourceDataContext())
    {
        // Begin with all "active" sessions
        IQueryable<Session> sessions = ctx.Sessions
             .Where(x => x.LogoutTime == null);
        foreach (var filter in filters)
            sessions = sessions.Where(filter);
        return sessions.ToArray();
    }
}

UPDATE persondata SET age=age+1;

select * from products p 
left join product_categories pc on p.id=pc.product_id 
where pc.product_id is null

select created_at, s.label, amount
from 
(
    select count(r.Source) as amount, r.source, r.created_at
    from  related_table r
    group by r.source, r.created_at) a  inner join source_table s
   on a.source = s.source_id
where created_at between '2013-12-01' and '2013-12-31'
order by amount desc, created_at desc

select 
  tab1.group_name,
  MAX(CASE WHEN tab1.rank_number = 1 THEN tab1.album_name ELSE NULL END) AS ALBUM_1,
  MAX(CASE WHEN tab1.rank_number = 2 THEN tab1.album_name ELSE NULL END) AS ALBUM_2,
  MAX(CASE WHEN tab1.rank_number = 3 THEN tab1.album_name ELSE NULL END) AS ALBUM_3,
  MAX(CASE WHEN tab1.rank_number = 4 THEN tab1.album_name ELSE NULL END) AS ALBUM_4
from (
  select group_name, album_name,
    row_number() over (partition by group_name order by album_name) as rank_number
  from tablea
) tab1
group by tab1.group_name;

select * from
(
    select
        max(case when distance <> 0 then 1 else 0 end)
            over (partition by child_node_id) has_non_zero_distance
        ,transitive_closure.*
    from transitive_closure
)
where distance = 0
    and has_non_zero_distance = 0;

SELECT a.nm
FROM tablea a
cross apply (select top 1 * 
         from tableb b
         join tablec c on b.id2 = c.id
         where a.id = b.id1
         order by c.nm) bc
order by bc.nm

select  ...
,       case when profile = 'admin' then 'self' end as admin
,       case when coalesce(profile,'') <> 'admin' then 'self' end as user
from    table.users

WITH Answers
AS
(
SELECT 1 AS xxxid , 1 AS userid, 'true' AS answer UNION ALL
SELECT 2 AS xxxid , 1 AS userid, 'true' AS answer UNION ALL
SELECT 3 AS xxxid , 1 AS userid, 'false' AS answer UNION ALL
SELECT 4 AS xxxid , 1 AS userid, 'true' AS answer UNION ALL
SELECT 5 AS xxxid , 1 AS userid, 'true' AS answer UNION ALL
SELECT 6 AS xxxid , 1 AS userid, 'true' AS answer UNION ALL
SELECT 7 AS xxxid , 2 AS userid, 'true' AS answer UNION ALL
SELECT 8 AS xxxid , 1 AS userid, 'true' AS answer )

SELECT   userid,
         COUNT(*) AS [COUNT]
FROM     Answers A
WHERE    NOT EXISTS
         (SELECT *
         FROM    Answers a2
         WHERE   answer    = 'false' /*change this to 0 if using bit datatype*/
         AND     a2.userid = a.userid
         )
OR       xxxid >
         (SELECT MAX(xxxid)
         FROM    Answers a2
         WHERE   answer    = 'false' /*change this to 0 if using bit datatype*/
         AND     a2.userid = a.userid
         )
GROUP BY userid

SELECT *
FROM COMPANY
WHERE ID BETWEEN
    ( SELECT MIN(ID)  
      FROM   COMPANY
      WHERE  COMPANY_NAME IS NOT NULL ) AND
    ( SELECT MIN(ID) - 1
      FROM   COMPANY
      WHERE  COMPANY_NAME IS NULL
      AND    ID > ( SELECT MIN(ID) MIN_ID 
                    FROM   COMPANY
                    WHERE  COMPANY_NAME IS NOT NULL ) ) 

    FROM Pages LEFT JOIN 
         Users AS Users_Modified
         ON Users_Modified.UserId = Pages.UserId_ModifiedBy LEFT JOIN
         Users AS Users_Created
         ON Users_Created.UserId = Pages.UserId_CreatedBy

 UPDATE F
SET F.ExtractedId = E.Id
FROM Feature as F 
INNER JOIN ExtractedFeature as E 
    ON F.ExtractedId = E.Number

select 
[Member_Code], 
max([Price List 1]),
max([Price List 1%]),
max([Price List 2]), 
max([Price List 2%]), 
max([Price List 3]),
max([Price List 3%])
from Table1 
group by [Member_Code]

SELECT id
FROM myTable
WHERE value = 'd'

SELECT a.appointment_id, ms.do_by, a.sale_id
(
      SELECT a2.sale_id as sale_id, MIN(a2.do_by) as do_by
      FROM [Askus7].[CRM7].[APPOINTMENT] a2 JOIN [Askus7].[CRM7].[SALE] s2
      ON a2.sale_id=s2.sale_id
      GROUP BY a2.sale_id
)ms
JOIN [Askus7].[CRM7].[APPOINTMENT] a
ON a.sale_id = ms.sale_id and a.do_by = ms.do_by;

SELECT EmpName, Age, (SELECT AVG(Age) FROM Employee) AverageAge
FROM Employee
WHERE Age > (SELECT AVG(Age) FROM Employee);

SELECT LastName, FirstName, IsHeadOfHousehold
FROM families f
join person p
  on f.PersonID_fk = p.ID
where f.Id = 1
order by IsHeadOfHousehold desc, 
  row_number() over(partition by lastname order by IsHeadOfHousehold desc) desc, 
  lastname, firstname;

LIKE '%[ .,!?]' + keyword + '[ .,!?]%'

select *
from enum
order by regexp_replace(code, '[0-9]', ''), 
         to_number(regexp_replace(code, '[^0-9]', ''))

insert into TFIDF (documentID, terms, tf_idf)
select abstractID, df.term, (log(10, 132225)-log(10, doccount)+1)*(tf.freq)
from tf, df
where tf.term = df.term;

NSString *sqlString = 
   [NSString 
      stringWithContentsOfFile:@"yourqueryfile.sql" 
      encoding:NSUTF8StringEncoding
      errors:nil //unless yuo are interested in errors.
   ];

CREATE TEMP TABLE tmp1 ( col2 varchar(20), col3 varchar(20) );
INSERT INTO tmp1 (col2, col3) VALUES ('Scottish Terrier', 'black')
                                   , ('Golden Retriever', 'brown');
SELECT * 
FROM dog_manners x
JOIN tmp1
    ON tmp1.col2 = x.col2
   AND tmp1.col3 = x.col3;

SELECT  con.conLastName as [Last Name], 
        con.conFirstName as [First Name],
        con.conMiddleInitial as [Middle Initial],   
        lawsonXRef.memERPCode as [Franchise],
        contactType.ctpDisplayName as [Type],
        contactStatus.ctpDisplayName as [Status]
    FROM (select conLastName, conFirstName, conMiddleInitial
          from Contacts
          group by conLastName, conFirstName, conMiddleInitial
          having count(distinct fraID) > 1) con
    inner join Contacts 
        on con.conLastName = Contacts.conLastName and 
           con.conFirstName = Contacts.conFirstName and 
           con.conMiddleInitial = Contacts.conMiddleInitial
    inner join lawsonXRef 
        on lawsonXRef.fraID = Contacts.fraID
    inner join SalesRepresentatives 
        on Contacts.conID = SalesRepresentatives.conID  
    inner join CategoryPopulation contactType
        on contactType.ctpID = Contacts.conTypeId   
    inner join CategoryPopulation contactStatus
        on contactStatus.ctpID = Contacts.conStatusId
    WHERE 
        srActive = 1 -- is Sales Rep.
        and 
            (Contacts.conLastName <> ''     and Contacts.conFirstName <> '')

select 
 coalesce( a.TransactionCurrencyId,
            (
                 select c.TransactionCurrencyId
                 from CRM_accountbase c
                 join crm_pricelevelbase a
                 on c.defaultpricelevelid=a.pricelevelid
                 where a.pricelevelid=(
                            select a.DefaultPriceLevelId 
                            from
                                 (
                                     select a.DefaultPriceLevelId,c.iCompanyId
                                     from crm_accountbase a
                                     join onyx..company C
                                     on c.iCompanyId=a.accountnumber
                                 ) a 
                              where a.iCompanyId=c.iCompanyId
                              ) 
            ) --TransactionCurrencyId   <--Need to not alias the subquery here
          )  --< Need to add this parenthesis
 from mytable a

SELECT id, col1
FROM tab
WHERE col1 = (SELECT MAX(col1) FROM tab);

data test;
input Col1 $ Col2;
datalines;
A 1
A 1
A 2
B 3
B 3
B 2
B 1
C 4
C 4
D 1
;;
run;

data test_out;
set test;
by Col1;
format Col3 $64.;
retain Col3;
if first.Col1 then
    Col3 = strip(Col1);

Col3 = catx("_",col3,col2);

if last.Col1 then
    output;
run;

select t1.fiber_id, t2.fiber_id as fiber_id2
from tbl_map_closure_fiber AS t1
join tbl_map_closure_fiber AS t2
on t1.fiber_id = t2.closure_id

SELECT cat
FROM foo
WHERE color IN ('maroon', 'orange')
GROUP BY cat
HAVING COUNT(*) = 2
;

SELECT
   t1.record_number,
   T1.record_created_by,
   T2.last_name,
   T2.first_name,
   T2.employee_no,
   t2.position_number,
   T2.position_reports_to AS SUPID,
   sup.last_name AS sup_last_name
FROM T1
LEFT JOIN T2 ON T1.record_created_by=T2.employee_no
LEFT JOIN T2 sup ON sup.SID=T2.position_nbr
WHERE t1.record_create_date=current_date

Sub sofMain20141472Access()

  Dim cnn, rst

  On Error GoTo ErrHandler

  Set cnn = CreateObject("ADODB.Connection")
  cnn.ConnectionString = "Provider=Microsoft.ACE.OLEDB.12.0" _
    & ";Data Source=\\vmware-host\Shared Folders\Luca\Desktop\barcode ean.xlsx" _
    & ";Extended Properties=""Excel 12.0 Xml;HDR=YES"""
  cnn.Open

'
  Set rst = cnn.Execute("SELECT * FROM [Foglio1$];")

'
' do stuffs on Recordset rst...
'
' ...
'
' close ADO objects:
'
  rst.Close
  Set rst = Nothing

  cnn.Close
  Set cnn = Nothing

  Exit Sub
ErrHandler:
  MsgBox Err.Description
  Set cnn = Nothing

End Sub

CREATE OR REPLACE TRIGGER person_insert_id_change 
BEFORE INSERT ON person 
REFERENCING NEW AS n
FOR EACH ROW
WHEN n.id = 127777
BEGIN ATOMIC
  SET n.id = 1577761;
END

WITH
ClientSms AS
(
  SELECT
    Client.Client_id,
    Sms.Content,
    ROW_NUMBER() OVER
    (
      PARTITION BY Client.Client_id
      ORDER BY Sms.Content
    ) AS RowNumber
  FROM Client
    INNER JOIN Delivery ON Delivery.Client_id = Client.Client_id
    INNER JOIN Sms ON Sms.Delivery_id = Delivery.Delivery_id
)
SELECT
    Client.Client_id,
    Sms.Content
FROM ClientSms
WHERE RowNumber <= 10
ORDER BY
    Client.Client_id,
    Sms.Content

CREATE TABLE #TEXTFILE_1(
    FIELD1 varchar(100) ,
    FIELD2 varchar(100) ,
    FIELD3 varchar(100) ,
    FIELD4 varchar(100));

BULK INSERT #TEXTFILE_1 FROM 'C:\STUFF.TXT'
WITH (FIELDTERMINATOR =' | ',ROWTERMINATOR =' \n')

/*You now have your bulk data*/

insert into yourtable (field1, field2, field3, field4, field5, field6)
select txt.FIELD1, txt.FIELD2, txt.FIELD3, txt.FIELD4, 'something else1', 'something else2' 
from #TEXTFILE_1 txt

drop table #TEXTFILE_1

select fieldtypeid,level 
from [table]
WHERE fieldtypeid <> 2 
OR level = 1

CREATE OR REPLACE TRIGGER TR_AI_ACTIVEMQ_MSGS
AFTER INSERT ON ACTIVEMQ_MSGS
FOR EACH ROW
BEGIN
  INSERT INTO MSG_BACKUP (f1, f2, f3)
  VALUES (:new.f1, :new.f2, :new.f3);            
END TR_AI_ACTIVEMQ_MSGS;

SELECT 
       Node,
       ISNULL(TodaysAvgLoadTime, 0)
       ISNULL(HistoricalLoadTime, 0)
FROM 
        (
            SELECT 
                 Node, 
                 AVG(LoadTime) 'TodaysAvgLoadTime'
            FROM 
                 dbo.Table
            WHERE 
                 Failed != 1
            AND  DATEDIFF(day, DateTimeCST, GETDATE()) = 0 
            GROUP BY Node
        ) AS A
        FULL OUTER JOIN
        (
            SELECT 
                 Node, 
                 AVG(LoadTime) 'HistoricalLoadTime'
            FROM 
                 dbo.Table
            WHERE 
                 Failed != 1
            GROUP BY Node
        ) AS B
        ON A.Node = B.Node

SELECT Task.Id, Task.TaskDescription, TaskAttempt.Id, TaskAttempt.User, 
    TaskSubmission.Id, TaskSubmission.Data
FROM Task
   JOIN TaskAttempt
       ON Task.Id = TaskAttempt.TaskId
   JOIN TaskSubmission
       ON TaskAttempt.Id = TaskSubmission.TaskAttempId

WITH ids AS (
  SELECT 
    ID,
    ID AS orig FROM Data d1 WHERE CXL IS NULL
  UNION ALL
  SELECT 
    d2.ID,
    orig
  FROM ids i
  INNER JOIN Data d2 ON d2.CXL = i.ID
)

SELECT 
  orig AS [Original Id],
  MAX(ID) AS [Latest Good Id]
FROM ids
GROUP BY orig

WITH d1 AS (
    SELECT timestamp'2015-03-24 13:05:22' AS mydate
         , '125:36.25' AS mytime FROM dual
)
SELECT mydate - NUMTODSINTERVAL( TO_NUMBER(SUBSTR(mytime, 1, INSTR(mytime, ':') - 1))*3600
                               + TO_NUMBER(SUBSTR(mytime, INSTR(mytime, ':') + 1, 2))*60
                               + TO_NUMBER(SUBSTR(mytime, INSTR(mytime, '.') + 1, 2)), 'SECOND')
  FROM d1;

UPDATE targetTable
SET LessonTaken = 'Y'
WHERE EXISTS (
   SELECT 1
   FROM anotherTable
   WHERE targetTable.col1 = anotherTable.col2
)

select count(*) from myTable 
where (FLAG1 = 0 or FLAG2 = 0)
and ID = 202

with Sales as (
    select
        t.Barcode,
        t.Date_Created as Sale_Date,
        row_number() over (partition by t.Barcode order by t.Sale_Date) as Load_Seq
    from <Transactions> as t
    where Description = 'Card Sale'
    group by Barcode
),
RedemptionWindows as (
    select
        s1.Barcode,
        s1.Load_Seq
        s1.Sale_Date,
        coalesce(s2.Sale_Date, dateadd(year, 1, s1.Sale_Date)) as End_Date,
    from Sales as s1 left outer join Sales s2
        on s2.Barcode = s1.Barcode and s2.Load_Seq = s1.Load_Seq + 1
)
select
    Barcode
      + case 
             when Load_Seq > 1 
             then '(' + cast(Load_Seq as varchar(3)) + ')' 
             else '' end as Barcode,
    Days_Between_Usage,
    case when RedemptionCount < 2 then 'Yes' else 'No' Balance_Still_Remains,
    5.00 - 2.50 * RedemptionCount as Balance_Remaining
from
    RedemptionWindows as rw
    cross apply
    (
        select
            datediff(day,min(r.Date_Created),max(r.Date_Created)) as Days_Between_Usage,
            count(*) as RedemptionCount
        from <Transactions> as r /* redemptions */
        where Description = 'Card Red'
            and r.Barcode = rw.Barcode
            and r.Date_Created >= rw.Sale_Date 
            and r.Date_Created <  rw.End_Date
    ) r_summary

declare @cols nvarchar(max)

select @cols = coalesce(@cols + ', ' + column_name, column_name)
from information_schema.COLUMNS
where TABLE_NAME = 'mytable'

declare @sql nvarchar(max)
select @sql = 'select ' + @cols + ' from myTable where Id = 1'

exec sp_executesql @sql

DELIMITER$$
CREATE TRIGGER trigger_name AFTER INSERT
ON table_one FOR EACH ROW
BEGIN
  INSERT INTO table_two(clmn_id, clmn_one) VALUES(NEW.clmn_id_fk,NEW.clmn_a)
  ON DUPLICATE KEY UPDATE fine_amount = clmn_one + NEW.clmn_a;
END$$
DELIMITER;

SELECT county_code,
      sum(iif(chem_code = "465", lbs_chem, 0))
FROM chem_apps_1991
GROUP BY county_code
ORDER BY county_code;

SELECT A.*, (SELECT COUNT(*) FROM B WHERE B.a_id = A.id) AS TOT FROM A

select * from tablename
where (start_date, end_date) OVERLAPS ('2015-05-05', '2015-06-05')

SELECT * 
FROM xx
WHERE f_COLOUR = "GREEN"
UNION
SELECT * 
FROM xx 
WHERE PRODUCTID not in 
                (SELECT PRODUCTID
                 FROM xx 
                 WHERE f_COLOUR = "GREEN");

with somenums as (
      select 1 as n union all select 2 union all select 3 union all select 4 union all select 5
     ),
     nums as (
      select ROW_NUMBER() over (order by (select NULL)) as n
      from somenums s cross join somenums s2
     ),
     test as (
         select 'JohnAlanSmith' as name union all
         select 'MaryElizabethChou'
     ),
     caps as (
      select name, n
      from test join
           nums
           on ascii(SUBSTRING(test.name, nums.n, 1)) between ascii('A') and ascii('Z')
    ),
    nameparts as (
     select name, n, nextn, SUBSTRING(name, n, coalesce(nextn - n, 1000)) as namepart
     from (select name, n,
                  (select min(n) from caps c2 where c2.name = c.name and c2.n > c.n
                  ) as nextn
           from caps c
          ) c
    )
select name,
       STUFF((select ' '+namepart
              from nameparts np2
              where np2.name = np.name
              order by n
              for xml path ('')
             ), 1, 1, ''
            ) as betterName
from nameparts np
group by name

SELECT s.SellerId, s.FirstName, s.LastName, SUM(ps.QuantitySold) 
FROM Salesmen S JOIN 
    ProductsSales PS ON S.sellerid = PS.salesmanid 
WHERE S.FirstName = 'Boris' AND S.LastName = 'Davidovich'
GROUP BY s.SellerId, s.FirstName, s.LastName

session.createQuery("select cat from Cat cat where cat.id in (:ids)").setParameterList("ids", new Long[]{1,2,3,4,5})

SELECT * FROM a WHERE field IN (-1, CAST("1" AS INT));

SELECT SUM(LIPQOH) as x, IBLITM 
FROM CPJDDTA81.F4101JD 
WHERE IBLITM IN('123456','1254484')
GROUP BY IBLITM

;with addressListWithID 
AS 
(
    SELECT name, address1, adress2, city, state, zip, 
           ROW_NUMBER() OVER(partition by zip   order by newid()) as Row
    FROM AddressList 
)
SELECT A.name, A.address1, A.adress2, A.city, A.state, A.zip
FROM addressListWithID A 
    INNER JOIN CatalogRequests C
        ON C.zip = A.zip 
            AND A.row <= C.QuantityRequested 

SELECT
  calendar.calendar_date,
  COUNT(*)
FROM
  calendar
LEFT JOIN
  yourData
    ON  yourData.timeStamp >= calendar.calendar_date
    AND yourData.timeStamp <  calendar.calendar_date + 1
WHERE
      calendar.calendar_date >= '01 Jan 2012'
  AND calendar.calendar_date <  '04 Jan 2012'
GROUP BY
  calendar.calendar_date

CREATE TEMPORARY TABLE tmp 
    SELECT MAX(id) as id, value1, value2
    FROM table1 GROUP BY value1, value2;

UPDATE table2
JOIN table1 t1 ON t1.id = table1_fk
JOIN tmp t ON t.value1 = t11.value1 AND t.value2 = t11.value2
SET table2.table1_fk = t.id;

DELETE FROM table1 WHERE id NOT IN (SELECT id FROM tmp);

SELECT i.*
FROM images AS i
JOIN news AS n on n.id_gallery = i.id_gallery
WHERE n.id_news = <selected news>

where ',' + col + ',' like '%,abc,%'

> db.people.find({ crowd : { $nin: ["cool"] }});

<cache ...>
  <cacheEventListenerFactory class="your.listener.FactoryClass" />
  ...
</cache>

SELECT a.soft_id,
  a.soft_name,
  b.p_cnt AS quantity,
  c.o_cnt AS owner_count
FROM soft a
INNER JOIN
  (SELECT soft_id, SUM(pu_quantity) AS p_cnt FROM product GROUP BY soft_id
  ) b
ON a.soft_id = b.soft_id
INNER JOIN
  (SELECT soft_id, COUNT(*) AS o_cnt FROM owner GROUP BY soft_id
  ) c
ON b.soft_id = c.soft_id
GROUP BY a.soft_id,
  a.soft_name

INSERT INTO Books (Bookname, Bookedition) VALUES ('Birds', 'a12')

SELECT ...
FROM TABLE_A AS A
JOIN TABLE_B AS B
  ON CAST(SUBSTR(DIGITS(A.STR_NBR),3,3)AS CHAR(4)) = B.LOCN_NO

select p.article_id
from Article a
inner join Structure s on s.article_above_id = article_id
inner join Article p on p.article_id = s.article_id
where a.article_number in (3,7,45,186,203)
group by p.article_id
having count(*) = 5


select
   *
from
   TABLE_A a
   cross apply
   (select top 1 Number from TABLE_B b order by abs(b.Number - a.Number)) b2

INSERT INTO shipment (orderid, Price, Date, DateDue)
SELECT orderid, @Price, @Date, @DateDue FROM @temptable;

DELETE FROM @temptable;

SELECT A.CABLE_NO,A.LOC_A,A.LOC_B,
    ISNULL(B.LENGTH,'SITE') AS CABLE_LENGTH
FROM TABLE_A AS A, TABLE_B AS B
WHERE A.id =B.id 

CREATE OR REPLACE FUNCTION GetNearestDate(reference_date DATE, day_of_year NUMBER) RETURN DATE IS  
    nearest_date DATE ;  
BEGIN  
    SELECT valid_date INTO nearest_date  
    FROM  
    (  
        SELECT first_date + day_of_year - 1 AS valid_date  
        FROM  
        (  
            SELECT add_months(trunc(reference_date, 'YYYY'), (rownum-10) * 12) AS first_date  
            FROM all_objects  
            WHERE rownum <= 20  
        )  
        WHERE to_char(first_date, 'YYYY') = to_char(first_date + day_of_year - 1, 'YYYY')  
        ORDER BY abs(first_date + day_of_year - 1 - reference_date), first_date  
    )  
    WHERE rownum < 2 ;  

    RETURN nearest_date ;  

EXCEPTION WHEN OTHERS THEN  
    RETURN nvl(reference_date, sysdate) ;  
END ;  
/  

IF NOT EXISTS (SELECT * FROM Locks WHERE CustomerID=@customerId) --if customerid does not exist, insert the row
BEGIN
    INSERT INTO Locks (CustomerID) 
    VALUES (@customerId)
END
SELECT CustomerID FROM Locks WITH (HOLDLOCK XLOCK ROWLOCK) WHERE CustomerID=@customerId --lock on row
--(check if customer has enough balance, then perform withdraw from customer account)

INSERT INTO combats (combat_killer, combat_victim, combat_weapon, combat_time, combat_server)
SELECT a.player_id, b.player_id, 'Diamond Sword', CURRENT_TIMESTAMP, 1
FROM (SELECT player_id from players where player_username = 'Kvazos') a
JOIN (SELECT player_id from players where player_username = 'paulaagee') b
WHERE a.player_id is not null
  AND b.player_id is not null;

LOAD DATA INFILE

select chapter, c.output, page
from   table_chapters c join table_pages p
   on c.output like '%' || p.output || '%'
order by chapter, page

   insert into Fee_temp SELECT   std_info.Reg_no,std_info.std_name,tut_fee.fee_month,class.class_name FROM
std_info Left  JOIN tut_fee on std_info.Reg_no=tut_fee.Reg_no Left JOIN promot on  std_info.Reg_no=promot.Reg_no Left JOIN
class on class.class_id=promot.class_id
WHERE std_info.Reg_no not in (select  Reg_no FROM tut_fee where  tut_fee.fee_month=3   and tut_fee.fee_year=2014)
 SELECT * from Fee_temp
  With A as
 (
 select Fee_temp.Reg_no,Fee_temp.std_name,Fee_temp.fee_month,Fee_temp.class_name,ROW_NUMBER() 
 OVER (Partition by Reg_no ORDER BY Fee_temp.std_name) As Number from Fee_temp
)
DELETE FROM A WHERE Number>1
SELECT * FROM Fee_temp

let user = PFUser()
user.username = username
user.email = userEmail
user.password = password

Select 
  posts.id
  posts.text
From 
  posts
Where 
  posts.id in (select PostID from userposts where UserID in (1,2))

fetchRequest.predicate = [NSPredicate predicateWithFormat:@"SUBQUERY(tracks, $t, ANY $t.playlistItems.playlist == %@).@count != 0", section.playlist];

<sql:query var="results" dataSource="${datasource}">
    SELECT COUNT(field) AS count, SUM(otherField) AS sum FROM table WHERE name='xy'
</sql:query>

<c:forEach items="${results.rows}" var="result">
    ${result.count} : ${result.sum}
</c:forEach>

UPDATE document_invoice t1 
SET company_name = t2.company_name
FROM account_company t2 
WHERE t1.company_id = t2.company_id

SELECT u.userID, u.HolidaysAllowed,
u.holidaysAllowed - 
COALESCE( 
    (SELECT SUM( DATEDIFF( h1.dateTo, h1.dateFrom) + 1) 
         FROM holiday h1 
         INNER JOIN status s1
         ON s1.holidayID = h1.holidayID
         WHERE h1.userID = u.userID
         AND s1.statusID = 1
     ), 0) AS HolidaysLeft,
COALESCE( 
    (SELECT SUM( DATEDIFF( h2.dateTo, h2.dateFrom) + 1) 
         FROM holiday h2 
         INNER JOIN status s2
         ON s2.holidayID = h2.holidayID
         WHERE h2.userID = u.userID
         AND s2.statusID = 1
     ), 0) AS HolidaysTaken
FROM userSettings u
;

SELECT t1.sex, employed, count(*) AS `count`, count(*) / t2.total AS percent
  FROM my_table AS t1
  JOIN (
    SELECT sex, count(*) AS total 
      FROM my_table
      GROUP BY sex
  ) AS t2
  ON t1.sex = t2.sex
  GROUP BY t1.sex, employed;

SELECT min(name),regexp_replace(UPPER(name), '&amp;(amp;)*|\\+', '&', 'gi') AS name
FROM names
GROUP BY regexp_replace(UPPER(name), '&amp;(amp;)*|\\+', '&', 'gi')

select number, name from table where code is NULL
minus
select number, name from table where code = 1

class Task
  include MongoMapper::Document
  key :title, String , :required => true

  key :user_ids , Array
  has_many :users, :in => user_ids     # , :as => :assigned_users

  key :creator_id , ObjectId
  belongs_to: user, :as => :creator

end

class User
  include MongoMapper::Document
  key: name, String, :required => true

  has_many :tasks           # , :as => :assigned_tasks

  has_many :tasks, :as => :created_tasks
end

SELECT  *
FROM    T
        INNER JOIN
        (   SELECT  [Date] = DATEADD(MONTH, - Number, @Date)
            FROM    Master..spt_values
            WHERE   Type = 'P'
            AND     Number % 6 = 0
        ) D
            ON D.Date = T.LastSalesDate

SELECT d.id, d.name, l.message
FROM device AS d
LEFT JOIN (
  SELECT l1.device_id, l1.message
  FROM log AS l1
  WHERE l1.when = (
        SELECT MAX(l2.when)
        FROM log AS l2
        WHERE l2.device_id = l1.device_id
  ) l ON l.device_id = d.id
WHERE d.active = 1
ORDER BY d.id ASC;

INSERT INTO person_data 
            ( ` KEY ` , 
             value, 
             person_id) 
SELECT 'aaa', 
       'bbb', 
       1 
FROM   person_data; 

CREATE UNIQUE INDEX IX_NODES_CUSTOMVARS ON NODES_CUSTOMVARS(nodeId, customvarId);

SELECT sno, 
iif(Len([Code])<=5,[Code],iif(ASCII([Code])>57,Right([Code],Len([Code])-1),Mid([Code],3)))
AS Codeno FROM table1

SELECT service_id,COUNT(*)
FROM your_table
GROUP BY service_id

SELECT Max(CASE 
             WHEN t1.material LIKE '%Refuse%' THEN t1.disposal 
           END) AS msw_disp, 
       Max(CASE 
             WHEN t1.material LIKE '%Met%' THEN t1.disposal 
           END) AS mgp_disp, 
       Max(CASE 
             WHEN t1.material LIKE '%Paper%' THEN t1.disposal 
           END) AS pap_disp, 
       t1.district 
FROM   dsny_net t1 
GROUP  BY t1.district 

SELECT  ca.*
FROM    Contribution с
JOIN    IntegerSeries s
ON      IntegerID < CHAR_LENGTH(c.path)
        AND SUBSTRING_INDEX(c.path, '.', IntegerID) <> SUBSTRING_INDEX(c.path, '.', IntegerID + 1)
JOIN    Contribution ca
ON      ca.path = CONCAT(SUBSTRING_INDEX(c.path, '.', IntegerID), '.')
WHERE   c.ContributionID = 3

WITH maxemp AS
 (select max(joining_date) as maxdate from Employee where emp_id = ?)
 SELECT name from Employee 
WHERE  joining_DATE >= 
 case maxemp.maxdate 
then maxemp.maxdate 
else  start_date end

select t.fk1_account_id,t.fk3_job_role_id,t.salary,t.no_of_placements
,d.time_id 
from 
(SELECT fk1_account_id, fk3_job_role_id, Sum(actual_salary) as salary, Count(1) as no_of_placements, MAX(EXTRACT(YEAR FROM plt_estimated_end_date)) AS YEAR 
FROM lds_placement
GROUP BY fk1_account_id, fk3_job_role_id, EXTRACT(YEAR FROM plt_estimated_end_date)
)t
left join time_dim d
on t.year=d.year
order by t.fk1_account_id

sqlite> SELECT datetime("2012-08-3 00:00:00");

sqlite> SELECT datetime("2012-08-03 00:00:00");
2012-08-03 00:00:00

SELECT 
    C1.C2 AS C1, C2.C2 AS C2
FROM
    T1 INNER JOIN
    T2 C1 ON T1.C1 = C1.C1 INNER JOIN
    T2 C2 ON T1.C2 = C2.C1

CREATE OR REPLACE PROCEDURE SET_SEQ_TO(p_name IN VARCHAR2, p_val IN NUMBER)
AS
   l_num   NUMBER;
BEGIN
   EXECUTE IMMEDIATE 'select ' || p_name || '.nextval from dual' INTO l_num;

   -- Added check for 0 to avoid "ORA-04002: INCREMENT must be a non-zero integer"
   IF (p_val - l_num - 1) != 0
   THEN
      EXECUTE IMMEDIATE 'alter sequence ' || p_name || ' increment by ' || (p_val - l_num - 1) || ' minvalue 0';
   END IF;

   EXECUTE IMMEDIATE 'select ' || p_name || '.nextval from dual' INTO l_num;

   EXECUTE IMMEDIATE 'alter sequence ' || p_name || ' increment by 1 ';

   DBMS_OUTPUT.put_line('Sequence ' || p_name || ' is now at ' || p_val);
END;

CREATE OR REPLACE PROCEDURE SET_SEQ_TO_DATA(seq_name IN VARCHAR2, table_name IN VARCHAR2, col_name IN VARCHAR2)
AS
   nextnum   NUMBER;
BEGIN
   EXECUTE IMMEDIATE 'SELECT MAX(' || col_name || ') + 1 AS n FROM ' || table_name INTO nextnum;

   SET_SEQ_TO(seq_name, nextnum);
END;

select name, score from (
  select name, score, dense_rank() over(order by score desc nulls last) rank
  --                                                        ^^^^^^^^^^
  --                                                 reject NULL score at the end
  from t
) V
where rank < 4
order by rank, name

select a.pk_a, b.pk_b, count(c.pk_c) 
from a 
inner join b on a.pk_a = b.pk_a 
left outer join c on b.pk_b = c.pk_b 
group by a.pk_a, b.pk_b;

select cast(avg(case when runtime = '1' then 1.0 else 0 end) as decimal(10, 2))

SELECT 
    @YourTeam ,
    SUM(
        CASE
            WHEN dt.TeamInGR=@YourTeam THEN dt.GoalsIn
            WHEN dt.TeamGR=@YourTeam THEN GoalsOut
            ELSE 0
        END
       ) AS Goals
    FROM (

         --YOUR QUERY HERE

         ) dt

UPDATE trg
  SET col1 = src.col1,
      col2 = src.col2, 
      ...
  FROM DB1.dbo.table AS trg
  INNER JOIN DB2.dbo.table AS src
    ON trg.ID = src.ID;

 UPDATE table_spec_data SET coverage=33 WHERE 
     (specification_id = 247 AND data_id = 1)
     OR (specification_id = 248 AND data_id = 2)
     OR (specification_id = 249 AND data_id = 3)

UPDATE MyTable SET col5 = col1 + col2 + col3 + col4 WHERE id = 232

SELECT  a.ID, a.FirstName, a.Lastname,
        CASE WHEN COUNT(b.CustID) > 0 THEN 'YES' ELSE 'NO' END AS HasOrders
FROM    Customer a
        LEFT JOIN Orders b
            ON a.ID = b.CustID        -- <<== the linking column on both tables
GROUP   BY a.ID, a.FirstName, a.Lastname

SELECT constraint_name, delete_rule
  FROM dba_constraints
 WHERE r_constraint_name = <<name of the primary key constraint>>
   AND r_owner = <<owner of the primary key constraint>>
   AND delete_rule = 'CASCADE'

SELECT
    SUBSTRING(Filepath, 1, CHARINDEX('_', Filepath) - 1)
FROM
   Tblfileinfo

select number, details.code as code, details.price as price from (select prop.number as number, prop.details as details from (select prop from test unwind prop) unwind details)

SELECT  [Name],
        MAX(Col1) Col1,
        MAX(Col2) Col2,
        MAX(Col3) Col3,
        MAX(Col4) Col4,
        MAX(Col5) Col5
FROM #Temp
GROUP BY [Name]

  SELECT * 
    FROM scores 
   WHERE score >= n
ORDER BY score ASC
   LIMIT 6

 UNION

  SELECT * 
    FROM scores 
   WHERE score < n
ORDER BY score DESC
   LIMIT 5

CREATE TRIGGER update_table AFTER INSERT ON followers
        FOR EACH ROW
            BEGIN
              followers f left outer join followers f2   on f2.id = f.id
              set f.Growth = f.Growth_Speed/(SELECT AVG(f.Growth_Speed) FROM (SELECTf.Growth_Speed from followers f WHERE f.id <= f.id+1));            

            END

SELECT *
FROM directory
WHERE
    userType = 'employee'
    OR userID NOT IN (
        SELECT userID
        FROM directory
        WHERE userType = 'employee'
    )

select t1.MESSAGEID,t1.MESSAGE, concat('from ',USERNAME) FROM_USER
from tblMsg t1 inner join 
    (select MAX(MESSAGEID) MESSAGEID,FROM_USERID
     from tblMsg
     group by FROM_USERID) t2 on t1.MESSAGEID=t2.MESSAGEID
    inner join tblUser u on t1.FROM_USERID=u.USERID

SELECT * FROM UserTable
WHERE userid NOT IN
(SELECT userid FROM UserStatus WHERE status = 3)

SET @rowcount = 0;
SELECT @rowCount:=@rowcount+1 as rowcount, userId, amount FROM 
 (
    SELECT userId, sum(amount) as amount 
    FROM bids 
    WHERE product = xxxxx 
    GROUP BY userId 
    ORDER BY amount DESC
 ) t 

select DISTINCT f1.COSTUMER_ID 
from finance f1
where (DATEPAID >= '2014-01-01' 
    and DATEPAID < '2014-07-01') 
and datediff(d, (
    select top 1 f2.DATEPAID
    from finance  f2
    where DATEPAID <> f1.DATEPAID
    and f1.COSTUMER_ID=f2.COSTUMER_ID
    order by f2.DATEPAID desc)
    ,f1.DATEPAID)>365

SELECT x, y
FROM table
ORDER BY x, y;

DELETE FROM S WHERE S.value < (SELECT MIN(value) FROM Y)

SELECT MANAGER, USER, NUM1, NUM2, NUM3
FROM
    (SELECT 
      MANAGER, USER, NUM1, NUM2, 
      ROW_NUMBER() over (partition by MANAGER, USER /* order by ....*/) AS USERROWNUMBER,
      SUM(NUM3) over (partition by MANAGER, USER) AS NUM3
    FROM MYTABLE)
WHERE
  USERROWNUMBER = 1

select * from TABLE where FIELD like ('%' || :text || '%')

SELECT C.Name,
       G1.Lookup_Name,
       G2.Lookup_Name
FROM   Contacts C
       LEFT JOIN Lookup G1 ON G1.Lookup_Id = C.Group_1
       LEFT JOIN Lookup G2 ON G2.Lookup_Id = C.Group_4

inner join table2 t2 on t1.t1Id = t2.t1Id and t2.someOtherId = @parameter
where t2.aThirdId = @otherParameter

SELECT 
k.[mg_KarId] AS [mg_KarId],
k.[SymKar] AS [SymKar],
k.[OpiKar] AS [OpiKar],
k.[Status] AS [Status],
(
    SELECT TOP 1 kml.SymLok
    FROM dbo.mg_KarMagLok kml
    WHERE kml.Mag LIKE 'GLS1' 
    AND kml ON k.SymKar = kmlg.SymKar
) ,
(
    SELECT TOP 1 kml.SymLok
    FROM dbo.mg_KarMagLok kml
    WHERE kml.Mag LIKE 'KRS1'
    AND k.SymKar = kml.SymKar
) ,
(
    SELECT TOP 1 kml.SymLok
    FROM dbo.mg_KarMagLok kml
    WHERE kml.Mag LIKE 'WLS1'
    AND kmlw ON k.SymKar = kml.SymKar  
) 
FROM dbo.[mg_vv_Kar_All] AS k WITH (NOLOCK)
WHERE k.Status <> 'W'
and k.SymKar = '0006438';

SELECT  a.*,
        b.firstName as SenderName,
        c.FirstName as RecieverName
FROM    transactions a
        INNER JOIN users b
            ON a.sender_ID = b.user_ID
        INNER JOIN users c
            ON a.reciever_id = c.user_ID

 select * from mytable
 where mystring like '10__8__0__'

DB[:a].
  left_outer_join(DB[:b].group_and_count(:a_id).as(:b), :a_id=>:id).
  order(:cnt).
  select_all(:a).
  select_more{IFNULL(:b__cnt, 0).as(:cnt)}

select u.*
from (User as u
      join Paiduser as p on u.id<>p.user_id)

UPDATE table2 t2
   SET t2.value = ( SELECT t1.value FROM table1 t1
                     WHERE t1.ID = t2.ID )
 WHERE EXISTS ( SELECT 1 FROM table1 t1
                 WHERE t1.ID = t2.ID );

SELECT *
FROM
(
    SELECT OutletId, CampaignId, ItemId, Qty
FROM Reporting) AS p
PIVOT
(
    SUM(Qty)
    FOR ItemId IN (SELECT ItemId FROM Reporting WHERE campaignId =1) 
) as pvt

SELECT  a.ID, AVG(a.grade) AVG_GRADE
FROM    TableName a
        INNER JOIN
        (
            SELECT  ID, Subject, MAX(date) max_date
            FROM    TableName
            WHERE   ID = 1            -- <<== change it to p_id
            GROUP   BY ID, Subject
        ) b ON  a.ID = b.ID AND
                a.Subject = b.Subject AND
                a.date = b.max_date
WHERE   a.ID = 1                      -- <<==  change it to p_id
GROUP   BY a.ID

;with cte as
(
  SELECT i.ItemDescription AS Desc, s.Name AS Manufacturer, inv.SerialNumber AS [Serial Number]
  FROM Assets a 
  LEFT OUTER JOIN Inventory inv ON a.InventoryID = inv.InventoryID 
  LEFT OUTER JOIN Items i ON inv.ItemID = i.ItemID 
  LEFT OUTER JOIN Rooms r ON a.RoomID = r.RoomID 
  LEFT OUTER JOIN Locations l ON r.LocationID = l.LocationID 
  LEFT OUTER JOIN Suppliers s ON i.ManufacturerID = s.SupplierID 
  WHERE l.LocationID = 5
),
totals as
(
  select [Desc], count(*) TotalCount
  from cte
  group by [desc]
)
select c.[desc],
  c.Manufacturer,
  case 
    when t.TotalCount > 1 
    then cast(t.TotalCount as varchar(50))
    else [Serial Number]
  end [Serial Number/Qnty]
from cte c
inner join totals t
  on c.[desc] = t.[desc]

SELECT ART_REF 
FROM tablename 
WHERE SEMESTER_NUM=28 
AND ART_REF <0

SELECT 
    field_value, field_label, record_id, data_element, data_id 
FROM substance_data 
WHERE 
    record_id = 8 
OR  record_id IN (SELECT DISTINCT 
                      data_id 
                  FROM 
                      substance_data 
                  WHERE 
                      record_id = 8
                 )

select *
from table1
union all
select *
from  table2 a
where  not exists (select null from table1 where user_id = a.user_id);

select t.id,case when tt.StableRecords is null then 0 else tt.StableRecords end
as StableRecords,case when tt.expiredRecords is null then 0 else tt.expiredRecords
end as expiredRecords from towns t left join
(select ph.id, count(case when pr.status='stable' then 1 end) as StableRecords,
count(Case when pr.status='expire' then 1 end) as expiredRecords
from patientsRecords pr inner join 
patientsHome ph on ph.serial_number=pr.serial_number
group by ph.id ) as tt 
on t.id=tt.id

DROP DATABASE `/`; 

SELECT LAST_DAY(ADD_MONTHS(yourdate,-1))

;WITH x AS 
(
    SELECT ID, NAME, [DATE], 
      rn = ROW_NUMBER() OVER 
      (PARTITION BY NAME ORDER BY [DATE] DESC)
    FROM @TESTABLE
)
SELECT ID, NAME, [DATE] FROM x WHERE rn = 1
  ORDER BY [DATE] DESC;

SELECT 
    ID, 
    Price, 
    IsMonthlyPrice, 
    CASE IsMonthlyPrice
    WHEN 1 THEN Price * 12 / 52
    ELSE price
    END
FROM [TABLE]
    order by 
        4

FOR EACH customer NO-LOCK:
  DISPLAY customer.
END.

create view dbo.vw_StudentInfo
as
select  StudentID
,       Age
,       StartDate
,       EndDarte
,       datediff(day, StartDate, EndDate) as TotalDays
from    dbo.StudentInfo

SELECT DISTINCT
to_char(C.RECEIPTDATE,'DD/MM/YYYY'),
(I.CLIENTID ||' - '||PO.CLIENTNAME) AS CLIENT,
D.INVOICEID,
D.SVCFROMDATE,
D.SVCTODATE,
D.SVCCODE
FROM M_EQP_ORDERS
WHERE.....

 SELECT a.PolicyNumber, a.effecitveDate a.insuredName as InsuredName1,   
        b.insuredName as InsuredName2
 FROM table a 
 INNER JOIN table b 
   ON a.policyNumber = b.policyNumber
  and A.effectiveDate = b.effectiveDate

hive>SHOW FUNCTIONS;
hive>DESCRIBE FUNCTION <function_name>;
hive>DESCRIBE FUNCTION EXTENDED <function_name>;

AND
      CASE 
           WHEN @SearchBy = 'IISAppPool' AND sComponentType = 'IIS_APP_POOL' THEN sComponentName 
           WHEN @SearchBy = 'ScheduledTask' AND sComponentType = 'SCHED_TASK' THEN sComponentName
           WHEN @SearchBy = 'WindowsService' AND sComponentType = 'WIN_SERVICE' THEN sComponentName
           WHEN @SearchBy = 'COM+' AND sComponentType = 'COM_PLUS' THEN sComponentName
           WHEN @SearchBy = 'ServiceAccount' THEN sServiceAccount
           WHEN @SearchBy = 'Server' THEN sServerName
           WHEN @SearchBy = 'IMCCReference' THEN sIMCCReference
           WHEN @SearchBy = 'User' THEN sManager
      END LIKE('%' + @SearchCriteria + '%')

CREATE TABLE #myPIDs
(
     PID VARCHAR(30)
);

INSERT INTO #myPIDs
VALUES
(....),
(....);

SELECT
  [Local Area]
FROM
  Table1 t1
  -- Matches the Region back to the Local Area
  LEFT JOIN Table2 T2 ON LEFT(t1.[Local Area], 3) = t2.Region
WHERE
  -- For those which have no Region match in Table2
  t1.ManagerId = 1234
  -- And to get the Table1 records which start with the Region from Table2
  OR t2.ManagerId = 1234

SQL> SELECT event, MIN(dt), MAX(dt) FROM (
  2     SELECT event, dt,
  3            SUM(discontinuity) over(ORDER BY dt, event) continuous_group
  4       FROM (SELECT event, dt,
  5                     CASE
  6                        WHEN lag(event) over(ORDER BY dt, event) = event THEN
  7                         0
  8                        ELSE
  9                         1
 10                     END discontinuity
 11                FROM DATA)
 12     )
 13   WHERE event = 'ANOTHER'
 14  GROUP BY event, continuous_group;

EVENT     MIN(DT)       MAX(DT)
--------- ------------- -------------
ANOTHER   20091109 1738 20091109 1751
ANOTHER   20091109 1721 20091109 1737

  SELECT t.month,
         t.year, 
         SUM(s.sum_of_jobs_processed)
    FROM bspm_dim_time t
    JOIN bspm_sum_jobs_day s
      ON t.time_id = s.time_id
GROUP BY t.month,
         t.year
ORDER BY t.year,
         t.month

create table t_temp as select * from t_iot;
-- do maintenance
create table t_new_iot as select * from t_temp;

select t.* from
fn_trace_getinfo(default) i 
cross apply 
 sys.fn_trace_gettable(cast(i.value as nvarchar(4000)),DEFAULT) t
 where i.traceid=1 and i.property=2

where h.Date_Created between (Sysdate - 4) and (Sysdate - interval '15' minute) ;

SELECT COUNT(*) FROM users 
WHERE num_games_won > (SELECT num_games_won FROM users WHERE id = 723)

SELECT * FROM Table1
WHERE
(@var = 1 AND ID = 5) OR
(@var = 2 AND Name = 'Bob') OR
(@var = 3 AND Color = 'Green')

WITH RECURSIVE next_in_line AS (
    SELECT u.id AS unit_id, u.parent_id, a.unit_id AS acl
    FROM   unit u
    LEFT   JOIN acl a ON a.unit_id = u.id

    UNION  ALL
    SELECT n.unit_id, u.parent_id, a.unit_id
    FROM   next_in_line n
    JOIN   unit u ON u.id = n.parent_id AND n.acl IS NULL
    LEFT   JOIN acl a ON a.unit_id = u.id
    )
SELECT unit_id, acl
FROM   next_in_line
WHERE  acl IS NOT NULL
ORDER  BY unit_id

SELECT Products.Active,
CASE Products.Active
 WHEN  'false' THEN  '' 
 ELSE  Products.product
END  AS 'HIDDEN COLUMN'
FROM Products

IF (EXISTS (SELECT * 
         FROM INFORMATION_SCHEMA.TABLES 
         WHERE TABLE_NAME = 'tbl2'))
BEGIN
    -- tbl2 exists, so just copy rows
    INSERT INTO tbl2 SELECT * FROM tbl1;
END
ELSE BEGIN
    -- tbl2 doesn't exist, so create new table tbl2 and copy rows 
    SELECT * INTO tbl2 FROM tbl1;
    DROP tbl1;
END

select t.*,
       sum(case when def = 'add' then amount
                when def = 'remove' then - amount
                else 0
           end) over (order by date, id)
from atable t;

SELECT
     CASE nod
         WHEN 'N/A' THEN 'N/A'
         ELSE CONVERT(VARCHAR(50), 
                      DATEADD(dd, 
                              -1 * CONVERT(INT, nod), 
                              GETDATE()
                             )
                     ) 
     END
FROM @temp

DECLARE @customer varchar(10) = '1111111111' 
DECLARE @from date = '12/07/12'
DECLARE @till date = DATEADD(DAY, 2, @from)
DECLARE @exclusiveTill date = DATEADD(DAY, 1, @till) 
-- added @exclusiveTill based on the comments

SELECT
  [sub].[custid],
  MAX([sub].[LatestDop]) AS [dateid],
  SUM([sub].[PriceSum]) AS [price]
FROM
(
  SELECT
    [custid],
    MAX([dop]) AS [LatestDop],
    [sku],
    SUM([price]) AS [PriceSum],
    SUM(CASE WHEN [price] >= 0 THEN 1 ELSE 0 END) AS [numberOfPositives]
  FROM [sale]
  WHERE
    [custid] = @customer
    AND [dop] >= @from
    AND (CASE WHEN [price] < 0 THEN @till ELSE [dop] END) < @exclusiveTill
  GROUP BY
    [custid],
    [sku]
) AS [sub]
WHERE 
  [sub].[numberOfPositives] > 0
GROUP BY 
  [sub].[custid]

SELECT DATE_FORMAT(hour_column, '%r');

select qt.*
from query_table qt
where LOWER(column_name) LIKE LOWER('%vAlUe%');

select person,
       sum(case when week in (1) then item1 + item2 + item3 else 0 end) as week1,
       sum(case when week in (1, 2) then item1 + item2 + item3 else 0 end) as week2
       sum(case when week in (1, 2, 3) then item1 + item2 + item3 else 0 end) as week3
from table t
where not exists (select 1
                  from table t2
                  where t2.person = t.person and
                        t2.week = t.week and
                        t2.iteration > t.iteration
                 )
group by person;

EXEC dbo.SEL_My_Func 'arg1','arg2','ar3'

SELECT 
    CASE 
        WHEN 
            MAX(CASE WHEN GD.Grade = 'No Grade' OR GD.Grade = ' ' THEN 1 ELSE 0 END) = 1 THEN ' '
        ELSE 
            ROUND(SUM((G.UnitsAcademic*GD.Grade))/SUM(G.UnitsAcademic),3)  
    END AS 'GWA'  
FROM Gradesheet G  
INNER JOIN GradeSheetDetail AS GD  
      ON GD.GradesheetId = G.GradesheetId 

 DROP TABLE IF EXISTS table_a;

 CREATE TABLE Table_A
 (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
 ,paper CHAR(2) NOT NULL
 ,stone CHAR(2) NOT NULL
 );

 INSERT INTO table_a (paper,stone) VALUES
 ('A1','B1'),
 ('A2','B2'),
 ('A3','B3');

 DROP TABLE IF EXISTS table_b;

 CREATE TABLE Table_B
 (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
 ,paper CHAR(2) NOT NULL
 ,stone CHAR(2) NOT NULL
 );

 INSERT INTO table_b (paper,stone) VALUES
 ('A1','B1'),
 ('A1','B3'),
 ('A1','B1'),
 ('A2','B2');

 SELECT DISTINCT a.*
               , b.stone
            FROM table_a a
            LEFT
            JOIN table_b b
              ON b.paper = a.paper 
             AND b.stone = a.stone;

 +----+-------+-------+-------+
 | id | paper | stone | stone |
 +----+-------+-------+-------+
 |  1 | A1    | B1    | B1    |
 |  2 | A2    | B2    | B2    |
 |  3 | A3    | B3    | NULL  |
 +----+-------+-------+-------+

public void TestRandomIdGenerator()
{
    // create five IDs of six, base 62 characters
    for (int i=0; i<5; i++) Console.WriteLine(RandomIdGenerator.GetBase62(6));

    // create five IDs of eight base 36 characters
    for (int i=0; i<5; i++) Console.WriteLine(RandomIdGenerator.GetBase36(8));
}

public static class RandomIdGenerator 
{
    private static char[] _base62chars = 
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
        .ToCharArray();

    private static Random _random = new Random();

    public static string GetBase62(int length) 
    {
        var sb = new StringBuilder(length);

        for (int i=0; i<length; i++) 
            sb.Append(_base62chars[_random.Next(62)]);

        return sb.ToString();
    }       

    public static string GetBase36(int length) 
    {
        var sb = new StringBuilder(length);

        for (int i=0; i<length; i++) 
            sb.Append(_base62chars[_random.Next(36)]);

        return sb.ToString();
    }
}

SELECT groupofficecom.cal_events.id,
    source.C221CODECLIENT,
    '' AS col_5,
    '0' AS col_6,
    source.C218NOM,
    source.C219PRNOM,
    source.TYPEACTIONS,
    source.ID_ELEMENT
FROM source
INNER JOIN groupofficecom.cal_events
    ON groupofficecom.cal_events.calendar_id = 5
    AND groupofficecom.cal_events.user_id = 3
    AND groupofficecom.cal_events.start_time = UNIX_TIMESTAMP(source.DATEDEBUT)
    AND groupofficecom.cal_events.end_time = UNIX_TIMESTAMP(source.DATEFIN)
    ...
LEFT JOIN cf_cal_events
    ON groupofficecom.cf_cal_events.model_id = groupofficecom.cal_events.id
WHERE groupofficecom.cf_cal_events.model_id IS NULL

SELECT a.id,a.name,
IFNULL(b.imageurl, 'default image url') AS 'imageurl',
IFNULL(b.imagecategory, '34') AS 'imagecategory',
IFNULL(b.imagetype, 't') AS 'imagetype'
FROM summary a
LEFT JOIN images b ON a.id = b.id AND
                      b.imagetype = 'thumbnail' AND 
                      b.imagecategory = '99'

SELECT history_contract_no, 
       history_run_date, 
       history_dataset_code, 
       contract_status, 
       confund_blg_method,
       confund_blg_status,
       SUM(premium_trx_amt)  

FROM   HISTORY LEFT JOIN PREMIUM
ON     history_field = premium_contract_no JOIN CONFUND 
ON     history_field = confund_contract_no JOIN CONTRACT
ON     confund_contract_no = contract_contract_no

WHERE  history_dataset_code in ('CONTINU1', 'CONTINU2')
AND    history_run_date between 20140118 and 20140124

GROUP BY history_contract_no
, history_run_date
, history_dataset_code
, contract_status
, confund_blg_method
,confund_blg_status

DECLARE @clients TABLE (ID int IDENTITY(1,1), name VARCHAR(20))
INSERT @clients (name)
SELECT 'John Smith' UNION ALL SELECT 'Mark Jackson' UNION ALL SELECT 'Ann Boo'

DECLARE @texts TABLE (ID int IDENTITY(1,1), [text] VARCHAR(200))

INSERT @texts ([text]) VALUES ('John Smith and Ann Boo are my best friends.')
INSERT @texts ([text]) VALUES ('I really don''t like Mark Jackson and John Smith.')

SELECT T.id  [Text.id], C.id [Client.id], C.name [Client.name] 
FROM @CLIENTS C 
JOIN @TEXTS T 
ON T.[text] LIKE '%' + C.NAME + '%'

RESULT

Text.id     Client.id   Client.name
----------- ----------- --------------------
1           1           John Smith
1           3           Ann Boo
2           1           John Smith
2           2           Mark Jackson

SELECT measuremententry * 1000 AS measuremententry 
  FROM log

Dim strSQL As String
Dim strSQL1 As String

strSQL1 = [Reports]![SMT_PULL_SHEET]![Text59].Value

strSQL = "INSERT INTO tblJobRecordID (Job, JobRev, JobDate, PrintTime, LotQty) VALUES ('" & strSQL1 & "', '" & Me!Text63.Value & "', '" & Format(Now(), "MM/DD/YY") & "', '" & Format(Now(), "h:mm AMPM") & "', '" & Me!Text67.Value & "');"

DoCmd.SetWarnings False


For intCounter = 1 To [Reports]![SMT_PULL_SHEET]![Text67].Value
DoCmd.RunSQL (strSQL)
Next

DoCmd.SetWarnings True`

SELECT
    Detail.[DateTime],
    -- you didn't tell us the name of this column
    Status.[YOUR HUMAN READABLE NAME],
    SUM(Detail.[RawStatus]) AS Clients
FROM
    [SolarWindsOrion].[dbo].[CustomPollerStatistics_Detail]
        AS Detail
    INNER JOIN [SolarWindsOrion].[dbo].[CustomPollerStatus]
        AS Status
        ON Left(Detail.[RowID], Len(Detail.[RowID]) - 2) = Status.[RowID]
WHERE
    Detail.[CustomPollerAssignmentID] = '6C4E621B-A7D3-439C-8402-D692BE67743A'
GROUP BY
    Detail.[DateTime],
    Status.[YOUR HUMAN READABLE NAME]

@{
var db = Database.Open("StayInFlorida");

var getresortval = Request.QueryString["resval"];
var type = Request.QueryString["type"];
var res = Request.QueryString["res"];
var area = Request.QueryString["area"];

var allresorts = "SELECT ResortID, ResortName FROM ResortInfo";
if(!getresortval.IsEmpty()){
    allresorts += " WHERE AreaName = @0";
}
var qallresorts = db.Query(allresorts, getresortval);

if(type == "resortupdate") {
    foreach(var row in qallresorts){
    <option value='@row.ResortID'>@row.ResortName</option>
    }
}

<%
    set conn = CreateObject("ADODB.Connection")
    on error resume next
    conn.open "remote connection string"
    if err.number <> 0 then
        response.write "unable to connect, trying other"
        conn.open "alternate connection string"
    end if
    on error goto 0
%>

select

  case
  -- one way or writing OR
  when country = 'brasil' or country = 'chile' then '....'
  -- another way of writing OR
  when country in ('china', 'japan') then '...'
  else '..'
  end

from tablename;

SELECT n.* 
FROM tblpm n 
INNER JOIN (
  SELECT control_number, MAX(date_updated) AS date_updated
  FROM tblpm GROUP BY control_number
) AS max USING (control_number, date_updated);

declare @StDate datetime = '01/01/2013 00:00.000'
declare @Enddate datetime = '07/07/2043 00:00.000'
declare @stime datetime = '00:00:00'
declare @etime datetime = '23:45:00'

declare @value as int = 387
declare @id as int = 999


;with cte as
(
 select DATEADD(MINUTE,DATEDIFF(Minute,0,@stime),0) as Stime
 union all
 select DATEADD(MINUTE,15,Stime) from cte where Stime < @etime

 ), cte2 as (
 select DATEADD(MONTH,DATEDIFF(MONTH,0,@StDate),0) as Sdate 
 union all
 select DATEADD(day,1,SDate) from cte2 where SDate < @Enddate
 ) 

Insert into [dbo].[_DV_Prognose_Werte_Temp](pr_id,prognosen_Nummer,zeitstempel,[time],leistungsprognose,nvv) (select '1','1',  Combined = CAST(SDate AS DATETIME) + CAST(stime AS DATETIME),stime, @value,'2' from cte cross join cte2)
OPTION (maxrecursion 0)

UPDATE tablename
SET col1 = CASE WHEN name = 'name1' THEN 5 
                WHEN name = 'name2' THEN 3 
                ELSE 0 
           END
 , col2 = CASE WHEN name = 'name1' THEN '' 
               WHEN name = 'name2' THEN 'whatever' 
               ELSE '' 
          END
;

CREATE TABLE db_target.cloned_table 
SELECT * 
FROM db_source.source_table;

SELECT OBJECT_NAME(OBJECT_ID) TableName, st.row_count
FROM sys.dm_db_partition_stats st
WHERE index_id < 2
ORDER BY st.row_count DESC

SELECT ID,1
FROM YOURTABLE
CONNECT BY LEVEL <= COUNT1
   AND PRIOR id = id
   AND PRIOR sys_guid() IS NOT NULL; 

with mq as(select a.rowid
                ,b.columnid
                ,case when (a.rowid % b.columnid) = 0 then 'X' else null end as coord
           from row_table a
                inner join column_table b on 1=1)

select  rowid,[1], [2], [3], [4],[5], [6], [7], [8], [9]
from mq
pivot( max(coord) for columnid in ([1], [2], [3], [4],[5], [6], [7], [8], [9])) as pv

SELECT * 
FROM Tab 
ORDER BY LEN(REPLACE(val,' ','X'));

select p1.mo,
    p1.[wkCmpl_1], p1.[wkCmplPct_1], p1.[wkCmpl_2], p1.[wkCmplPct_2],
    p1.[wkCmpl_3], p1.[wkCmplPct_3], p1.[wkCmpl_4], p1.[wkCmplPct_4],
    p1.[wkCmpl_5], p1.[wkCmplPct_5],
    t1.WkAvg,
    t1.MoCmpl,
    t2.M_YTD_Total,
    t1.PctGoal
from 
(
  select mo,
    [wkCmpl_1], [wkCmplPct_1], [wkCmpl_2], [wkCmplPct_2],
    [wkCmpl_3], [wkCmplPct_3], [wkCmpl_4], [wkCmplPct_4],
    [wkCmpl_5], [wkCmplPct_5]
  from 
  (
    select datepart(month, wk_endt) mo,
        value,
        col + '_' + cast(wkNum as varchar(10)) col
    from 
    (
      select wk_endt,
        wkNum,
        cast(wkCmpl as decimal(10, 2)) wkCmpl,
        wkCmplPct
      from yourtable
    ) x
    unpivot
    (
      value
      for col in (wkCmpl, wkCmplPct)
    ) u
  ) x1
  pivot
  (
    max(value)
    for col in ([wkCmpl_1], [wkCmplPct_1], [wkCmpl_2], [wkCmplPct_2],
               [wkCmpl_3], [wkCmplPct_3], [wkCmpl_4], [wkCmplPct_4],
               [wkCmpl_5], [wkCmplPct_5])
  ) p
) p1
inner join
(
  select month(wk_endt) mo,
    wkcmpl,
    avg(WkAvg) as WkAvg,
    MoCmpl,
    max(M_YTD_Total) M_YTD_Total,
    PctGoal
  from yourtable
  group by month(wk_endt), wkcmpl, MoCmpl, PctGoal
) t1
  on p1.mo = t1.mo
  and p1.wkCmpl_1 = t1.wkcmpl
inner join
(
    select month(wk_endt) mo, max(M_YTD_Total) M_YTD_Total, MAX(wknum) wknum
    from yourtable
    group by month(wk_endt)
) t2
    on t1.mo = t2.mo

InsertSQL("INSERT INTO " + table_name + " (" + columns + ") VALUES (round(" + question_marks + "))", csv_data);

select company_code , 
SUM(case when product_code = 10 then 1 else 0 end) as product_10 , 
SUM(case when product_code = 20 then 1 else 0 end) as product_20
from product
group by company_code

select a.ID as A_ID, a.Desc as A_Desc, b.ID as B_ID, b.Desc as B_DESC
from Table_A as a left outer join Mapping_Table as m on a.ID = m.A_ID
full outer join Table_B as b on m.B_ID = b.ID

SELECT 
  MAX(id) as id,
  MAX(staff_id) as staff_id, 
  skill_id, 
  MAX(mainskill) as mainskill
FROM MyTable
GROUP BY skill_id
HAVING COUNT(1)=1

SELECT  currency, SUM(price) totalPrice
FROM    tableName
GROUP   BY currency

Dim floors = From row In FbuildingSettings.camButtonDtable.AsEnumerable() _
             Where row.Field(Of String)("Building").Contains("Megamart") _
             Select row.Field(Of Integer)("Floor") Distinct

WHILE (1 = 1)
BEGIN
    SET NOCOUNT ON;
    select * from [test_p]
    WAITFOR DELAY '00:00:02'
END

SELECT City FROM customers ORDER BY Country, City

SELECT airport, market, state
FROM (
  SELECT airports.name AS airport
        ,markets.name AS market
        ,states.abbr AS state
        ,count(DISTINCT airports.state) OVER (PARTITION BY airports.market)
         AS states_per_market
  FROM   airports
  JOIN   markets
  ON     airports.market = markets.id
  JOIN   states
  ON     airports.state = states.fips
) WHERE states_per_market > 1;

SELECT t2.`itemname` 
FROM `tabletwo` AS t2
JOIN (    
   SELECT count(`itemid`) AS cnt, `itemid`
   FROM `tableone`
   WHERE `some_codition`="satisfied"
   GROUP BY `itemid`
) AS t1 ON t1.`itemid` = t2.`id`
ORDER BY t1.cnt DESC

WITH min_eval AS
(
SELECT
    a.DataMatch,
    a.max_EvalID,
    a.EligTypeRecalc,
    b.evaluationid,
    b.EstablishedDelays
FROM Outcomes a
JOIN Evaluations b
    ON a.min_EvalID=b.evaluationid
    WHERE a.EligTypeRecalc<>3
),
max_eval AS
(
SELECT
    a.DataMatch,
    a.max_EvalID,
    a.EligTypeRecalc,
    b.evaluationid,
    b.EstablishedDelays
FROM Outcomes a
JOIN Evaluations b
    ON a.max_EvalID=b.evaluationid
    WHERE a.EligTypeRecalc<>3
)
SELECT "NewEligType"=
    COUNT (*),
    SUM (CASE WHEN  a.EligTypeRecalc IN (1,4,5,7) THEN 1 ELSE 0 END) 'Established Condition',
    SUM (CASE WHEN  a.EligTypeRecalc=6 THEN 1 ELSE 0 END) 'Established Delay & At-Risk',
    SUM (CASE WHEN  (a.EligTypeRecalc=2 AND a.EstablishedDelays=1) OR (a.EligTypeRecalc=2 AND a.EstablishedDelays=0 AND b.EligTypeRecalc=2 AND b.EstablishedDelays=1) THEN 1 ELSE 0 END) 'Established Delay only: One Delay',
    SUM (CASE WHEN  (a.EligTypeRecalc=2 AND a.EstablishedDelays=2) OR (a.EligTypeRecalc=2 AND a.EstablishedDelays=0 AND b.EligTypeRecalc=2 AND b.EstablishedDelays=2)  THEN 1 ELSE 0 END) 'Established Delay only: Two Delays',
    SUM (CASE WHEN  (a.EligTypeRecalc=2 AND a.EstablishedDelays>=3) OR (a.EligTypeRecalc=2 AND a.EstablishedDelays=0 AND b.EligTypeRecalc=2 AND b.EstablishedDelays>=3)  THEN 1 ELSE 0 END) 'Established Delay only: Three+ Delays',
    SUM (CASE WHEN  a.EligTypeRecalc=8 THEN 1 ELSE 0 END) 'Clinical Judgement'

FROM max_eval a
JOIN min_eval b
    ON a.DataMatch=b.DataMatch

create unique index unq_example_orderid_transdate on example(orderID, trans_date);

SELECT server_id,
       CONCAT(GROUP_CONCAT(st.tag),',') as tag_list 
FROM servers AS s 
INNER JOIN servers_tags AS st ON (st.server_id=s.server_id) 
WHERE st.tag IN ("example","example2","example3") 
GROUP BY s.server_id 
HAVING COUNT(DISTINCT st.tag) >= 2
       AND (INSTR(tag_list, 'example,')>0 OR INSTR(tag_list, 'example1,')>0)
       AND INSTR(tag_list, 'example3,')>0

AVG(CASE 
WHEN TO_NUMBER(tck.MARK) = 1 THEN 5
WHEN TO_NUMBER(tck.MARK) = 2 THEN 4 
WHEN TO_NUMBER(tck.MARK) = 3 THEN 3 
WHEN TO_NUMBER(tck.MARK) = 4 THEN 2 
ELSE 99
END) AS Mark

SELECT t1.date
   , t1.time
   , t2.time
   , t2.A
   , t2.B
FROM TotalTimeTable t1
CROSS APPLY (
 SELECT TOP(1)
  T2.time
 , T2.A
 , T2.B
FROM FinalListA t2
WHERE T2.date = T1.date
AND T2.time <= t1.time
ORDER BY T2.time DESC
) AS T2
ORDER BY t1.date,
     t1.time

SELECT
    ROUND((
        SUM(CASE WHEN antwoorden.coach_id = 0 THEN score ELSE 0 END) /
        SUM(CASE WHEN antwoorden.coach_id = 0 THEN 1 ELSE 0 END) * 10
    ), 1) as score_0,
    ROUND((
        SUM(CASE WHEN antwoorden.coach_id = 1 THEN score ELSE 0 END) /
        SUM(CASE WHEN antwoorden.coach_id = 1 THEN 1 ELSE 0 END) * 10
    ), 1) as score_1
FROM antwoorden
JOIN vragen
    ON vragen.id = antwoorden.vraag_id
JOIN categorieen
    ON categorieen.id = vragen.categorie_id
WHERE antwoorden.werknemer_id = 105 AND antwoorden.coach_id IN (0,1)
GROUP BY categorieen.id

select to_char(date,'Mon') as mon,
       extract(year from date) as yyyy,
       sum("Sales") as "Sales"
from yourtable
group by 1,2

MERGE INTO My_table AS TGT
USING Remote_table AS SRC
  ON TGT.PROJECT = SRC.PROJECT, -- This is the matching condition. 
     TGT.YEAR    = SRC.YEAR,
   ---
WHEN NOT MATCHED THEN
  INSERT(PROJECT, JOB_TYPE, MONTH, YEAR, HOURS, IS_DELETED)
  VALUES(SRC.PROJECT, SRC.JOB_TYPE, SRC.MONTH, SRC.YEAR, SRC.HOURS,
         SRC.IS_DELETED);

onCreate(SQLiteDatabase db);
onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion);

SELECT regexp_matches('JIW.sql;XXX.txt;Qwij.DLL;saasa.sql;ttt.txt;lok.SQL;ddd.jpg;aas.sql', '[0-9A-z]*.sql', 'g');

SELECT b.id, group_concat(c.a) a
FROM a_b
  JOIN a ON a.id = a_b.a
  JOIN b ON b.id = a_b.b
  JOIN a_b c on b.id = c.b
WHERE a.name = 'bob'
GROUP BY b.id

select distinct [DATE_PULL] as D, 
    stuff((select ', ' + [OWNER] + ': ' + convert(varchar(20), sum(VM_COUNT)) + '' as [text()]
                from [VCENTER_INFO_HIST] c where c.[DATE_PULL] = v.[DATE_PULL]
                group by c.[OWNER] 
                for xml path('')), 1, 1, '') as value
    from [VCENTER_INFO_HIST] v

create table listing (
    SELECT nutrdesc, nutr_no, date_time, units 
    FROM meals, nutr_def 
    WHERE meals.users_userid = '2' 
        AND date_time BETWEEN '2009-8-12' AND '2009-9-12' 
        AND (
            nutr_no <100000 OR nutr_no IN (
                SELECT nutr_def_nutr_no 
                FROM nutr_rights 
                WHERE nutr_rights.users_userid = '2'
                )
            )
    );

create table data (
    SELECT nutrdesc, date_time, nut_data.nutr_no, sum(ingred_gram_mass*entry_qty_num*nutr_val/100) AS total_nutr_mass 
    FROM nut_data, recipe_ingredients, food_entries, meals, nutr_def 
    WHERE nut_data.nutr_no = nutr_def.nutr_no 
        AND ndb_no = ingred_ndb_no 
        AND foods_food_id = entry_ident 
        AND meals_meal_id = meal_id 
        AND users_userid = '2' 
        AND date_time BETWEEN '2009-8-12' AND '2009-9-12' 
    GROUP BY date_time,nut_data.nutr_no
);

create index joiner on data(nutr_no, date_time);
create index joiner on listing(nutr_no, date_time);

SELECT listing.date_time,listing.nutrdesc,data.total_nutr_mass,listing.units
FROM listing
LEFT JOIN data
ON data.date_time = listing.date_time
AND listing.nutr_no = data.nutr_no
ORDER BY listing.date_time,listing.nutrdesc,listing.units;

SELECT 
    [TableName] = so.name, 
    [RowCount] = MAX(si.rows) 
FROM 
    sysobjects so, 
    sysindexes si 
WHERE 
    so.xtype = 'U' 
    AND 
    si.id = OBJECT_ID(so.name) 
GROUP BY 
    so.name 
ORDER BY 
    2 DESC

exec stored_proc_name @param_name='Ram''s'

require 'oci8'
oci = OCI8.new('****','***','****.***')
oci.exec('select * from table') do |record|
  puts record.join(',')
end

Criteria crit = session.createCriteria(Person.class);
crit.add(Restrictions.ilike('town', '%fran%');
List results = crit.list();

SELECT StudentID, Year, Subject,  AVG(TestScore) AS AvgScore
  FROM
(
  SELECT StudentID, Year, Subject, TestScore
   FROM MyTable t
   WHERE TestID IN
  (
   SELECT TOP 3 TestID 
     FROM MyTable
    WHERE StudentID = t.StudentID
      AND Year = t.Year
      AND Subject = t.Subject
    ORDER BY TestScore DESC, TestID
  )
) q
 GROUP BY StudentID, Year, Subject
 ORDER BY StudentID, Year, Subject;

Select * From YourTable
Where 
    IsDate([myDtField])
    And
    DateDiff("d", DateValue([myDtField]), Date()) > 120

;WITH CTE AS
(
    SELECT
        ROW_NUMBER() OVER(PARTITION BY Tenant.MemberPropertyDepositID ORDER BY Tenant.MemberPropertyDepositID) AS RowNbr,
        Tenant.MemberPropertyDepositID,
        Tenant.FirstNames,
        Tenant.LastNames
    FROM
        tblMemberPropertyDepositTenantHistory AS Tenant
)
SELECT
    Tenant.FirstNames AS LeadTenantFirstName, 
    Tenant.LastNames AS LeadTenantLastNames,
    Deposit.CertificateNumber AS DPCNumber
FROM 
    tblMemberPropertyDeposits AS Deposit 
    LEFT JOIN CTE AS Tenant
        ON Tenant.MemberPropertyDepositID=Deposit.MemberPropertyDepositID
        AND Tenant.RowNbr=1

SELECT *, (
    SELECT COUNT(id) FROM abc_menu b WHERE b.parentId=a.id) 
FROM abc_menu a 
ORDER BY ordering ASC

INSERT INTO LOCATION
  SELECT t.name,
         t.originallocationid
    FROM ORIGINAL_TABLE t
GROUP BY t.name, t.originallocationid

INSERT INTO COUNTRY 
SELECT DISTINCT
       t.isocode,
       l.locationid
  FROM ORIGINAL_TABLE t
  JOIN LOCATION l ON l.name = t.name
                 AND l.originallocationid = t.originalocationid

INSERT INTO BOUNDARY
SELECT DISTINCT
       l.locationid,
       t.centrepoint,
       t.originalboundary,
       t.largereducedboundary,
       t.mediumreducedboundary,
       t.smallreducedboundary
  FROM ORIGINAL_TABLE t
  JOIN LOCATION l ON l.name = t.name
                 AND l.originallocationid = t.originalocationid

select student,
       ((coalesce(score1, 0) + coalesce(score2, 0)) /
        nullif(nvl2(score1, 1, 0) + nvl2(score2, 1, 0), 0)
       ) as score_avg

SELECT a1.dataID
FROM
    Attributes a1
    JOIN Attributes a2 ON
        a1.dataID=a2.dataID
    JOIN Attributes a3 ON
        a2.dataID=a3.dataID
WHERE
    a1.dataID = 1 AND
    a1.attributeID = 1 AND
    a2.attributeID = 2 AND
    a3.attributeID = 3;

CREATE TYPE A AS TABLE
(
    A_Id int
)

GO


CREATE TYPE B AS TABLE
(
    B_Id int,
    A_Id int -- "FK"
)
GO

buyer_id | {"prod1_id","prod2_id",...} | date

SELECT c.name, invoice_number, 
       (SELECT rate
          FROM company_rate 
         WHERE company_id = i.company_id
           AND effective_date <= i.paid_date
         ORDER BY effective_date DESC
         LIMIT 1) rate,
       paid_amount,
       paid_date
  FROM invoice i JOIN company c
    ON i.company_id = c.id 

NSString *dbPath = [[NSBundle mainBundle] pathForResource:@"Pubs" ofType:@"db"];
NSData   *myData = [NSData dataWithContentsOfFile:dbPath];


[mailComposeVC addAttachmentData:myData mimeType:@"application/x-sqlite3" fileName:@"Pubs.db"];

SELECT 1 FROM your_table a
INNER JOIN your_table b ON a.tag = b.tag
WHERE a.article = 1 AND b.article = 2

CREATE TABLE Student 
(
 Studentid int IDENTITY (1, 1) NOT NULL PRIMARY KEY,
 Firstname nvarchar (200) NULL,
 Lastname nvarchar (200),
 Email nvarchar (100) NULL
)

insert into Student (Firstname,Lastname,Email)
Values('Vivek', 'Johari', ‘vivekjohari@abc.com');

SET @PkStudentid  = SCOPE_IDENTITY();

print @PkStudentid

mysql> select event_name, status -- from events where event_name =
    -> from information_schema.events where event_name = 'event_scheduling_sample';
+-------------------------+---------+
| event_name              | status  |
+-------------------------+---------+
| event_scheduling_sample | ENABLED |
+-------------------------+---------+
1 row in set (0.01 sec)

SELECT * FROM contacts WHERE firstName LIKE ? OR lastName LIKE ? OR email LIKE ?

 SELECT Product_ID, p.Category_ID, Product_Name, Product_Cost, Product_Price, Category_Name
 FROM Product p
 INNER JOIN Category c ON p.Category_ID = c.Category_ID

SELECT Col1
FROM Table
GROUP BY Col1
HAVING COUNT(DISTINCT col2) > 1 AND 
       COUNT(CASE WHEN col2 = 'Banana' THEN 1 END) >= 1

regexp_replace(tasusumma, '\*\*.*', '', 'g')

SELECT 
    COALESCE(t1.MyName COLLATE DATABASE_DEFAULT, t2.MyName )  AS MyName
    ,CASE WHEN t2.MyLevel > t1.MyLevel THEN t2.MyDescr COLLATE DATABASE_DEFAULT ELSE t1.MyDescr   END AS MyDescr
    ,CASE WHEN t2.MyLevel > t1.MyLevel THEN t2.MyLevel ELSE t1.MyLevel END AS MyLevel
    ,CASE WHEN t2.MyLevel > t1.MyLevel THEN t2.FromDB COLLATE DATABASE_DEFAULT ELSE t1.FromDB  END  AS FromDB
FROM TableOne t1  
FULL JOIN TableTwo t2 ON t1.MyName = t2.MyName COLLATE DATABASE_DEFAULT

Invoke-Sqlcmd -Query "SELECT @@VERSION;" -QueryTimeout 3

select distinct on (user_id) * from user_stats order by datestamp desc;

>>> from django.contrib.auth.models import User
>>> pk_list = (1, 3, 6)
>>> User.objects.raw('SELECT * FROM auth_user WHERE id IN %s', params=[pk_list])
<RawQuerySet: 'SELECT * FROM auth_user WHERE id IN (1, 3, 6)'>

data want;
set current;
rx_1 = prxparse("/\^f\(‘(\w*?)’\)\^/");
rc_1 = prxmatch(rx_1,currently);
if rc_1 ne 0 then have = prxposn(rx_1,1,currently);
run;

select s.site_id, count(*) as totalhits
from sites s join hits h
on s.site_id = h.site_id
group by s.site_id

CREATE TRIGGER trgAfterInsert ON [dbo].[table2] 
        FOR INSERT
        AS
BEGIN
   SET NOCOUNT ON;

    insert into table2_Audit (c1,c2,Audit_Action,Audit_Timestamp) 
    SELECT C1 
         , C2 
         , 'Inserted Record -- After Insert Trigger.' 
         , GETDATE() 
   FROM inserted ;

PRINT 'AFTER INSERT trigger fired.'
END
GO

SELECT T2.ST_DT, T2.END_DT, 
(
    SELECT SUM(T1.NO_OF_PAX)
    FROM TABLE1 T1
    WHERE T1.DT BETWEEN T2.ST_DT AND T2.END_DT
) NO_OF_PAX
FROM TABLE2 T2
ORDER BY T2.ST_DT ASC

with t as (
  select 'L10 1TY' as postcode from dual
  union all select 'WF2 5TG' from dual
  union all select 'W7 5RR' from dual
)
select postcode, regexp_substr(postcode, '^[[:alpha:]]+', 1, 1) as region
from t;

POSTCODE REGION 
-------- -------
L10 1TY  L       
WF2 5TG  WF      
W7 5RR   W       

SELECT AVG(price) AS averageSpend, customerName
FROM customers, transactions
WHERE customers.customerId = transactions.customerId
AND transactiontypeId = 1
GROUP BY customers.customerId

SELECT SUM(ISNULL(s.Amount,0)) as TotalSales, p.ProductName
FROM SALES s 
RIGHT JOIN Product p ON s.ProductID = p.ID
GROUP BY p.ProductName

SELECT sh.shop_name,
       SUM(CASE WHEN i.item_name LIKE '%Coca Cola%' THEN st.sold ELSE 0 END) as Coke,
       SUM(CASE WHEN i.item_name LIKE '%Pepsi%' THEN st.sold ELSE 0 END) as Pepsi,
       (CASE WHEN SUM(CASE WHEN i.item_name LIKE '%Coca Cola%' THEN st.sold ELSE 0 END) > 
                  SUM(CASE WHEN i.item_name LIKE '%Pepsi%' THEN st.sold ELSE 0 END)
             THEN 'yes' ELSE 'no'
        END) as CokeMoreThanPepsi
FROM tbl_stock st JOIN
     tbl_shops sh
     USING (<appropriate columns here>)
     tbl_items i
     USING (<appropriate columns here>)
WHERE i.item_name LIKE '%Coca Cola%' OR i.item_name LIKE '%Pepsi%'
GROUP BY sh.shop_name

SELECT task_id, task_group_id, task_name, completed, priority 
FROM tasks WHERE user = ? and task_group_id = ? and completed = 0 ORDER BY priority ASC

where (Book_Author LIKE '*" & TextBox.Text & "*' or Book_Author = '')

DECLARE VARIABLE ID INTEGER;
BEGIN
    ID = SELECT GEN_ID(MY_GENERATOR, 1) FROM RDB$DATABASE;
    INSERT INTO MY_TABLE (ID, DESCRIPTION) VALUES (:ID, "Foo");

select 
datediff(second,depart_dt, arrived_dt)/86400 as Day,
datediff(second,depart_dt, arrived_dt)/3600%24 as Hour,
datediff(second,depart_dt, arrived_dt)/60%60 as Minute,
datediff(second,depart_dt, arrived_dt)%60 as Second
from yourtable

select t.*,
       dense_rank() over (partition by caseid order by grp_log_date) as EventNum
from (select t.*, min(log_date) over (partition by caseid, grp) as grp_log_date
      from (select t.*,
                   (row_number() over (partition by caseid order by log_date) -
                    row_number() over (partition by caseid, userid, cast(log_date) as date
                                       order by log_date
                                      )
                   ) as grp
            from table t
           ) t
      ) t;

CREATE VIEW dbo.vname
AS
    SELECT [Row] = ROW_NUMBER() OVER (ORDER BY A), A, B, C FROM
    ( <UNION query here> ) AS x;

select t1.id, t1.name, v1.name, v2.name, v3.name
from table1 t1
join vars v1 on v1.id = t1.var1
join vars v2 on v2.id = t1.var2
join vars v3 on v3.id = t1.var3

    select h.auto_inc,h.query_prot_id,h.taxon_schema, h.domain_name 
    from hmmscan1 as h 
    inner join arath_scan on h.domain_name=arath_scan.domain_name
    GROUP BY h.domain_name;

where  classifier = 'X' and date between '2012-01-01' and '2012-02-01'
       or
       classifier = 'Y' and date between '2012-02-01' and '2012-03-01'

SELECT  item.*
FROM    tree tm
JOIN    tree tc
ON      tc.lft >= tm.lft
        AND tc.rgt <= tm.rgt
JOIN    item
ON      item.tree_id = tc.id
WHERE   tm.type = x

WITH AppAndEmp AS
(
    SELECT
        AppID
        , EmpID
        , EmpName
        , ROW_NUMBER() OVER(PARTITION BY AppId
                       ORDER BY (CASE WHEN EmpName IS NULL THEN 0 ELSE 1 END) DESC
                                , EmpName) AS EmpOrder

    FROM
        dbo.App
        LEFT JOIN dbo.Emp
            ON  App.AppId = Emp.AppId
)

SELECT
    *

FROM
    AppAndEmp

WHERE
    EmpOrder = 1

SELECT count(a) nb_a_not_null,
       count(b) nb_b_not_null,
       count(*) - count(a) nb_a_null,
       count(*) - count(b) nb_b_null,
       count(case when a is not null and b is not null then 1 end)nb_a_b_not_null
       count(case when a is null and b is null then 1 end) nb_a_and_b_null
  FROM my_table

SELECT col1, col2, col3 INTO newTable FROM existingTable;

SELECT n
FROM (VALUES(1),(2),(3),(4),(5),(6)) AS Nums(n)
EXCEPT
SELECT RecoveryID from table1 

declare @startDate as datetime
set @startDate = '1/1/13'

declare @currentDate as datetime
set @currentDate = '6/6/13'

select
     month(@currentDate) as monthOfDate
    ,year(@currentDate) as yearOfDate
into #allDates
where 1=0

while (@startDate <= @currentDate)
begin
    insert into #allDates values (month(@startDate),year(@startDate))
    set @startDate = dateadd(m,1,@startDate)
end

select 
     _monthYear.yearofDate
    ,_monthYear.monthOfDate
    , COUNT(p.pId) as total
from #allDates _monthYear
left join profile p with(nolock)
    on month(p.createStamp) = _monthYear.monthOfDate
    and year(p.createStamp) = _monthYear.yearOfDate
group by
     _monthYear.yearofDate
    ,_monthYear.montOfDate

drop table #allDates

SELECT * 
FROM 
  ( SELECT * FROM things ORDER BY id DESC LIMIT 10) xxx
ORDER BY id ASC

select 0f/0 from dual;

0F/0
----
NaN  

SELECT * FROM TABLE1 
   WHERE wavelenght BETWEEN 341 AND 348 
         OR wavelenght BETWEEN 551 AND 664  
         OR wavelenght BETWEEN 998 AND 1021  

CREATE TABLE #myTable
(
myColumn VARCHAR(100)
)

INSERT INTO #myTable
VALUES
    ('abcd/eftthis.text/31/sadflh adslkjh'),
    ('abcd/eftthis.text/44/khjgb ljgnkhj this.text/447/lhkjgnkjh'),
    ('ljgkhjgadsvlkgnl'),
    ('uygouyg/this.text/31/luinluinlugnthis.text/31/ouygnouyg'),
    ('khjgbkjyghbk')


;WITH CTE
AS
(
    SELECT MyColumn, 
    CHARINDEX('this.text/', myColumn, 0)  AS startPos,
    CHARINDEX('/', myColumn, CHARINDEX('this.text/', myColumn, 1) + 10) AS endPos
    FROM #myTable
    WHERE myColumn LIKE '%this.text/%'
    UNION ALL
    SELECT T1.MyColumn, 
    CHARINDEX('this.text/', T1.myColumn, C.endPos) AS startPos,
    CHARINDEX('/', T1.myColumn, CHARINDEX('this.text/', T1.myColumn, c.endPos) + 10) AS endPos
    FROM #myTable T1
    INNER JOIN CTE C
        ON C.myColumn = T1.myColumn
    WHERE SUBSTRING(T1.MyColumn, C.EndPos, 100) LIKE '%this.text/%'

)
SELECT DISTINCT SUBSTRING(myColumn, startPos, EndPos - startPos)
FROM CTE

SELECT CONVERT(nvarchar(10), thisDate, 103) As newDate, thisDate
FROM YourTable
ORDER BY thisDate ASC

SELECT User_ID, Cash_In, Cash_out 
FROM 
(SELECT wa.User_ID, count(case when tt.ID = '1' then 1 else null end) Cash_In,
        count(case when tt.ID = '2' then 1 else null end)  Cash_out 
FROM mwt_wallet_transactions t, mwt_txn_types tt, mwt_user_wallet wa
WHERE t.txn_code = tt.ID and
t.a_number = wa.id
GROUP BY wa.User_ID)
ORDER BY mobile_no;

select owner, index_name, text
  from (select t.*,
               count(*) over(partition by text, index_name) both_match,
               count(*) over(partition by text) text_match
          from COLUMNS_TAB t)
 where text_match > 1
   and both_match = 1;

select product, 
       count(*) as total_count
       sum(
         case when opinion='pos' then 1 
         else 0 end
       ) as pos_count
from the_table
group by product;

SELECT u.username, p1.* FROM photos AS p1
 INNER JOIN users AS u ON u.id=p1.user_id
 LEFT OUTER JOIN photos AS p2 ON p2.user_id=p1.user_id and p2.id <= p1.id
 GROUP BY p1.id
 HAVING COUNT(p2.id) <= 3
 LIMIT 30;
Objects 
-------
id (PRIMARY_KEY)
name

Keys
----
id (PRIMARY_KEY)
value

KeyValuePairs
-------------
id (PRIMARY_KEY)
keyId (FOREIGN_KEY(Keys))
value

Objects_KeyValuePairs
---------------------
objectId (PRIMARY_KEY, FOREIGN KEY (Objects))
kvpId (PRIMARY_KEY, FOREIGN KEY (KeyValuePairs))

-- Create demo data
CREATE TABLE #temp(SrNo int, Class nvarchar(5), Name nvarchar(50), Marks int)

INSERT INTO #temp(SrNo, Class, Name, Marks)
VALUES  (1,'1A','Student1',67),
        (2,'1A','Student2',62),
        (3,'1A','Student3',65),
        (4,'1A','Student4',78),
        (5,'1A','Student5',28),
        (6,'1B','Student6',57),
        (7,'1B','Student7',65),
        (8,'1B','Student8',85),
        (9,'1B','Student9',18),
        (10,'1B','Student10',8)

-- your part
SELECT t.*
FROM (
    SELECT  Class,
            MIN(Marks) as min_marks,
            AVG(Marks) as avg_marks,
            MAX(Marks) as max_marks
    FROM #temp 
    GROUP BY class
) as data
OUTER APPLY (
    SELECT TOP 1 t.marks as nearest_avg
    FROM #temp as t
    WHERE t.class = data.Class
    ORDER BY CASE WHEN data.avg_marks-marks >= 0 THEN data.avg_marks-Marks ELSE Marks-data.avg_marks END
) as avg_data
INNER JOIN #temp as t
        ON t.Class = data.Class
        AND( 
            t.Marks = data.min_marks
            OR t.marks = avg_data.nearest_avg
            OR t.marks = data.max_marks
        )

-- Cleanup
DROP TABLE #temp

ALTER TABLE table {ADD {COLUMN field type[(size)] [NOT NULL]     [CONSTRAINT index] |     ALTER COLUMN field type[(size)] |     CONSTRAINT multifieldindex} |     DROP {COLUMN field I CONSTRAINT indexname} }

... beginning of your query ...
START WITH A.TREE_Name = 'MDA_GRN_KK'
connect by nocycle prior  A.TREE_NODE = A.PARENT_NODE_NAME

SELECT POWER(10, CONVERT(INT, LOG10(@Input)))

   select
   datediff(now(),'2009-12-12 13:13:13') * 24
    + extract(hour from now())
    - extract(hour from '2009-12-12 13:13:13') as hour_diff

`SELECT * FROM table limit 100` -- get 1st 100 records
`SELECT * FROM table limit 100, 200` -- get 200 records after row 101

select TO_CHAR(date1,'HH24:MI:SS') time_in,
       (CASE WHEN TO_CHAR(date1,'HH24:MI:SS') between '06:00:00' AND '18:00:00'
             THEN 'day_shift'
             WHEN TO_CHAR(date1,'HH24:MI:SS') BETWEEN '18:00:00' AND '24:00:00'           
             THEN 'night_shift' 
             WHEN TO_CHAR(date1,'HH24:MI:SS') BETWEEN '00:00:00' AND '06:00:00'          
             THEN 'night_shift'
        END) AS shift
from blah

select * from mealdb where userid='mistu4u' and substr(daydate,4,3)='JUL';

...
begin
INSERT INTO customerbkp(cid,cname,cemail,phone,operation) 
    VALUES (NEW.cid, NEW.cname, NEW.cemail, NEW.phone, 'insert');
end;
...

INSERT INTO #TempTable
   SELECT id, name 
   FROM TableC ("This selection will return multiple records")

INSERT INTO TableA
   SELECT (fieldlist) FROM #TempTable

INSERT INTO TableB
   SELECT (fieldlist) FROM #TempTable

select table_name,owner from all_tables where table_name like '%CONTINENT%'

select top 20 news.*, count(news_comment.id) as no_of_comment from news inner join news_comment on news.id = news_comment.newsid order by no_of_comment desc

TO_DATE('04082014', 'DDMMYYYY')

select h.*, sum(i.debit) as debsum, sum(i.credit) as credsum, sum(i.debit) - sum(i.credit) as rolling_sum
from have h inner join have i
on h.id >= i.id
group by h.id, h.debit, h.credit
order by h.id

Driver={SQL Server};server=*****;uid=**;database=database_name;Pwd=password

SELECT DISTINCT ON(user) user, phone, value
FROM table
WHERE value < 8
ORDER BY user, value DESC;

   SELECT * 
    from test
    order by (case when [Date] is null then 0 
             when [Date] >= getdate() then 1 
             when [Date] < getdate() then 2 
             end ) asc ,
             case when [Date] >= getdate() then [Date] end asc,
             case when [Date] < getdate() then [Date] end desc

SELECT SQL_CALC_FOUND_ROWS a.vid_id, count(a.id) as idCount
FROM scruseronline as a
INNER JOIN tag_map as b
ON b.vid_id = a.vid_id
INNER JOIN tags2 as c
ON c.tag_id = b.tag_id
AND c.name IN (?)
GROUP BY a.vid_id
ORDER BY idCount DESC

select data,
  MIN(CASE WHEN no = 1 THEN answer END) as no1,
  MIN(CASE WHEN no = 2 THEN answer END) as no2,
  MIN(CASE WHEN no = 3 THEN answer END) as no3,
  MIN(CASE WHEN no = 4 THEN answer END) as no4,
  MIN(CASE WHEN no = 5 THEN answer END) as no5
from test
group by data

SELECT ja.*
FROM (SELECT j.job_role_desc AS "Job Role Description" ,   
             SUM(a.no_of_placements) AS "Number Of Placements",
             ROW_NUMBER() OVER (ORDER BY SUM(a.no_of_placements) DESC) as seqnum
      FROM fact_accounts a INNER JOIN
           job_role_dim j
           ON j.job_role_id = a.fk3_job_role_id
      GROUP BY j.job_role_desc
     ) ja
WHERE seqnum = 1;

    SELECT C.ID
           ,C.ClockDateTimeIn as 'Date' 
           ,DATENAME(dw, C.ClockDateTimeIn) as 'DayOfWeek'
           ,C.UserID
           ,C.ClockDateTimeIn as 'ClockInTime'
           ,C.ClockDateTimeOut as 'ClockOutTime'
           ,SUM(convert(time,(b.TimeOut - b.TimeIn))) Att_time
           ,SUM(DATEDIFF(MI, ClockDateTimeIn, ClockDateTimeOut)) Att_minute
           ,SUM(DATEDIFF(HH, ClockDateTimeIn, ClockDateTimeOut)) Att_hour
      FROM clockinlogs C
      JOIN breaks b 
        ON C.ID = b.CID
      JOIN Users u 
        ON CID=ID
  GROUP BY C.ID
           ,C.UserID
           ,C.ClockDateTimeIn
           ,C.ClockDateTimeOut

    CREATE VIEW  RDMAVWSANDBOX.VwNIM001usersAndDlCount AS
    SELECT VwNIMEventFct.NIM_USER_ID
   ,SUM(CASE WHEN NIM_EVENT_TYPE_ID = 884 then 1 else 0 end) AS DownloadCount
   ,SUM(CASE WHEN NIM_EVENT_TYPE_ID = 885 then 1 else 0 end) AS Something
   ,SUM(CASE WHEN NIM_EVENT_TYPE_ID = 886 then 1 else 0 end) AS Something
   ,SUM(CASE WHEN NIM_EVENT_TYPE_ID = 887 then 1 else 0 end) AS Something
    FROM RDMAVWSANDBOX.VwNIMEventFct
    GROUP BY NIM_USER_ID

select to_char(date_trunc('week', '2013-02-01'::date), 'yyyy-mm-dd');

SELECT `hotel_id`
  FROM test
 WHERE `date` BETWEEN '2013-05-06' AND '2013-05-10'
   AND `qty` >= 2
 GROUP BY `hotel_id`
 HAVING COUNT(*) = (DATEDIFF('2013-05-10', '2013-05-06') + 1)

select count(case when "Types" @> array['A'] then 1 end) as "COUNT A",
       count(case when "Types" @> array['B'] then 1 end) as "COUNT B",
       count(case when "Types" @> array['C'] then 1 end) as "COUNT C",
       count(case when "Types" @> array['A','B'] then 1 end) as "COUNT A^B",
       count(case when "Types" @> array['A','C'] then 1 end) as "COUNT A^C",
       count(case when "Types" @> array['B','C'] then 1 end) as "COUNT B^C",
       count(case when "Types" @> array['A','B','C'] then 1 end) as "COUNT A^B^C"
  from ( select array_agg("Type"::text) as "Types"
           from "B"
          group by "UserId"
       ) t
;

Select A.TransactionID, IsNull(B.ReceivedDate, C.ReceivedDate)  as ReceivedDate, A.Value
    From TransactionTable as A 
        Left outer join EmailTable as B 
            on A.FileNo = B.EmailFileNo 
                and A.FileType='E'
        Left outer join DocumentsTable as C 
            on A.FileNo = C.DocFileNo 
                and A.FileType = 'D'
    where A.Status = 'P'

SELECT u.id AS user_id,s.*, u.name
FROM submissions s
LEFT OUTER JOIN users u
ON s.user_id = u.id

WHERE NOT EXISTS (
    SELECT USER_ID
    FROM submissions tmp
    WHERE tmp.User_ID = s.User_ID
    AND tmp.status = 'approved'
    )

AND STATUS = 'rejected'

select CONVERT(VARCHAR(10),
              DATEADD(MONTH, DATEDIFF(MONTH, 0, GETDATE())-1, 0) + 14
              ,103)

 Result: 15/07/2015

organization external
(
type oracle_loader 
default directory ext_tab_dir
access parameters (
records delimited by '\r\n'
characterset 'utf8'
badfile 'SOD_RULE_SET_bad.txt' 
logfile 'SOD_RULE_SET_log.txt' 
skip 1
fields terminated by ',' Optionally Enclosed by '"'
missing field values are null 
reject rows with all null fields 
) 
location ('SOD_RULE_SET.csv')

public void onUpgrade(SQLiteDatabase db,
    int oldVersion, int newVersion)
{
    if (oldVersion < 1) {
        db.execSQL(
             "CREATE TABLE IF NOT EXISTS newtable ("
             + "id INTEGER PRIMARY KEY, "
             + "name VARCHAR(20)"
             + ")"
        );
    }
}

-- Preparing a test table
INSERT INTO #tmpTable(ID, Identifier, DateAdded, DataColumn)
SELECT 1, 1001, 15400, 'Newest Value'
UNION
SELECT 1, 1001, 15000, 'Oldest Value'
UNION
SELECT  1, 1001, 15200, 'Older Value'
UNION
SELECT  1, 1002, 16000, 'Newest Value'
UNION
SELECT  2, 1001, 16000, 'Newest Value'

-- Actual Select
SELECT b.ID, b.Identifier, b.DateAdded, DataColumn
FROM 
    (SELECT ID, Identifier, MAX(DateAdded) AS DateAdded
   FROM #tmpTable
   WHERE DateAdded < 16001
   GROUP BY ID, Identifier) a
INNER JOIN #tmpTable b ON a.DateAdded = b.DateAdded
AND a.ID = b.ID
AND a.Identifier = b.Identifier

SELECT  sumQuantityBase as [Quantity Sold],
        minIP * sumQuantityBase as [Stock Value],
        sumQuantityBase as [Quantity Stock]
FROM
    (SELECT MIN(I.[IP Total (Manual)] )as minIP,
            No_
     FROM I 
     WHERE [No_] like '140003000007'
     GROUP BY No_) MinI INNER JOIN
    (SELECT SUM([Quantity]) as sumQuantity,
            [Item No_]
     FROM WE 
    WHERE [Location Code] = 'BU' 
      AND [Bin Code] <> 'SHIPPING'  
      AND [Bin Code] <> 'WORKSHOP' 
      AND [Bin Code] <> 'OUTBOX'  
      AND [Bin Code] <> 'CUT' 
      AND [Bin Code] <> 'VERZEND'    
      GROUP BY [Item No_] ) SumWE
  ON MinI.[No_]  = SumWE[Item No_] INNER JOIN
  (SELECT SUM([Quantity (Base)]) as sumQuantityBase,
          No_
   FROM S 
   WHERE [Shipment Date] > '07/01/2015' 
     AND [Shipment Date] IS NOT NULL  
     AND [Document Type] = 1 
  GROUP BY No_ ) SumS
 ON SumS.[No_] = MinI.[No_]

UPDATE S
SET S.Offering_Details = REPLACE(S.Offering_Details, nchar(65533) COLLATE Latin1_General_BIN, '...')
FROM tblSacrifices S

-- declare table variable
DECLARE @Input TABLE (CompaintID INT, ClientID INT)

-- save the rows into a table variable
INSERT INTO @Input (ComplaintID, ClientID)
   SELECT ComplaintID, ClientID
   FROM dbo.Complaint
   WHERE ComplaintStatusId = 5
     AND waitingForCustomerCloseDateTime <= GETDATE()

UPDATE a 
SET ActivityStatus = 4, 
    CompletionDate = GETDATE(),
    ClosedBy = u.Code
FROM dbo.Activity a
INNER JOIN @Input i ON a.ComplaintId = i.ComplaintId
INNER JOIN dbo.resp_users u ON i.ClientId = u.ClientId

UPDATE dbo.Complaint
SET ComplaintStatusId = 2 
WHERE 
    ComplaintStatusId = 5
    AND waitingForCustomerCloseDateTime <= GETDATE()

INSERT INTO dbo.Note ([Note_Description], [ClientId], [User_Code], [Visible_Internal],
                      [ComplaintId], [Note_DateTime], [ComplainantId],
                      [OneStopDesk_CustomerEmail], [OneStopDesk_CustomerUsername], [Private])
    SELECT
        N'Automatically closed by system after ' + sc.waitingForCustomerCloseTime, 
        i.ClientId, u.Code, 1,
        i.ComplaintId, GETDATE(), null, null, null, 1
    FROM
        @Input i
    INNER JOIN
        dbo.SystemConfiguration sc ON i.ClientId = sc.ClientId
    INNER JOIN
        dbo.resp_user u ON u.ClientId = i.ClientId

SELECT ID FROM CONTEST WHERE CONTEST_DATE = '2004-03-01';

select nvl(cast(enrol.OUAC_APPLNO as varchar2(10)), 'blank') 

select id, trunc(a_val, 2) from table_B
minus select id, trunc(b_val, 2) from table_B

WITH Temp1 (ID)
AS
(
    -- Do some calculation and generate #Temp1
    -- ... contains other selects
)

, Temp2 (ID)
AS
(
    -- Do some calculation and generate #Temp2
    -- ... contains other selects
)

-- Select statement 1
SELECT * FROM Foo
JOIN Temp1 tmp on tmp.ID = Foo.ID
WHERE Foo.Deleted = 1

UNION

-- Select statement 2
SELECT * FROM Foo
JOIN Temp2 tmp on tmp.ID = Foo.ID
WHERE Foo.Deleted = 1

WHERE
   (
      (
          @Series like '% SA %' and
          Cttn.CttnName like '%ALL SA%'
      )
      OR
      Cttn.CttnNme LIKE Isnull(@Series, Cttn.CttnNme)
   )
   AND
   ...

SELECT id FROM prompts WHERE (id IN (array(SELECT properties->>'prompt_ids'::integer FROM "prompts"
WHERE (type = 'Aggregate'))));  

select t.*, t_r12.col_r
from t outer apply
     (select replace(t.col, 'in1', 'out1') as col_r) t_r01 outer apply
     (select replace(t_r01.col_r, 'in2', 'out2') as col_r) t_r02 outer apply
     (select replace(t_r02.col_r, 'in3', 'out3') as col_r) t_r03 outer apply
     . . .;

SELECT ID, Value, Gr_Id, (
           SELECT MAX(Value)
           FROM tableName t2 
           WHERE t1.Gr_Id = t2.Gr_Id
) as Gr_Value
FROM tableName t1

CREATE TABLE Foo
(
    ID INT
);
declare @type NVARCHAR(20) = N'INT'; -- Substitute your Type here.
declare @tableName NVARCHAR(50) = 'Foo';
declare @value sql_variant;
set @value = 1234;
DECLARE @Sql AS NVARCHAR(MAX) = N'INSERT INTO [dbo].'+ @tableName +
           N' VALUES(CAST(@value AS ' + @type + '))';
EXECUTE sp_executesql @Sql, N'@value sql_variant', @value = @value;  

|BoardName|SensorId| ReadingTime | SensorValue | 
------------------------------------------------
|BoardA   |    1   | 1224201301  |          18 |
|BoardA   |    2   | 1224201301  |          24 |

SELECT Code
FROM TableA
WHERE AID IN
(
    SELECT AID
    FROM TableB
    GROUP BY AID
    HAVING COUNT(*) > 1
)

select c.*, a.activity
from calltable c outer apply
     (select top 1 a.*
      from activitytable a
      where a.memberId = c.memberId and
            a.datetime <= c.datetime
      order by a.datetime asc
     ) a;

update  b
set     project = r.projcet
from    backup b
join    resources r
on      b.ResourceID = r.ResourceID
where   b.project is null

$ python manage.py inspectdb > models.py

SELECT * FROM  
    #Table2 C 
     INNER JOIN Mapping F  
                  ON C.ID1 = F.ID1 AND 
                  C.ID2 = ISNULL(F.ID2, C.ID2)

for db in dbname1 dbname2 dbname3...
do
 psql -d $db -U username << EOF
ALTER TABLE authentication DROP CONSTRAINT  uk_authentication_01;
ALTER TABLE authentication ADD CONSTRAINT uk_authentication_01 UNIQUE (authenticator, method);
EOF
done

select Sum(s.amount) as TotalAmount From SomeTable s
inner join Select sum(l.amount) as LocationAmount From SomeTable l where l.loc1 = @location

CREATE TABLE [dbo].[employee](
    [id] [int] IDENTITY(1,1) NOT NULL,
    [name] [varchar](255) NOT NULL,
    [birth_date] [datetime2](7) NOT NULL,
    [phone] [varchar](17) NOT NULL,
    [address] [text] NOT NULL,
 CONSTRAINT [PK_employee] PRIMARY KEY CLUSTERED 
(
    [id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

 SELECT @concat =COALESCE(@concat, ' ') +  clcontact
 FROM
 (

    SELECT DISTINCT  clcontact + ', ' AS clcontact
    FROM    dbo.client
    WHERE crelated = @clnum
    AND NOT clcontact IS NULL
  ) T

SELECT *
FROM
    sys.dm_exec_query_stats s
    CROSS APPLY
    sys.dm_exec_sql_text( s.sql_handle ) t
    CROSS APPLY
    sys.dm_exec_query_plan(s.plan_handle) foo
WHERE
    foo.dbid = DB_ID('My_DB')
ORDER BY
    s.max_elapsed_time DESC

select * from mg_customers_conversation where DATE_FORMAT(timecreated,'%Y-%m-%d')>='2014-09-09'

    WITH t as
    (
     select AAAA as High, BBBB as Med, CCCC as Low from TABLE1 where company like '%3m%'
      union all
      select  
      (select round(XXX,2) from TABLE2 where company like '%3m%' and XXX!=0)as High,
     (select round(YYY),2) from TABLE2 where company like '%3m%' and YYY!=0) as Med,
     (select round(ZZZ,2) from TABLE2 where company like '%3m%' and ZZZ!=0) as Low
    )
SELECT 
ROUND(AVG(case when company like '%3m%'and ABC <> 0 then High else null end), 2) High,
ROUND(AVG(case when company like '%3m%'and DEF <> 0 then Medium else null end), 2) Medium,
ROUND(AVG(case when company like '%3m%'and GHI <> 0 then Low else null end), 2) Low
from t;

   da=new SqlDataAdapter("select  Ga1_ID from table where  Ga1_ID=@pkVal",conn);
    DataSet=new DataSet();
    da.fill(ds);

//pass parameter for @pkVal

    da.SelectCommand.Parameters(1).Value = pkValue;    

    if(ds.Tables[0].Rows.Count>0) //If number of rows >0 then record exists
     BEGIN
     messagebox.show("Primary key present");
     END

select * into [DPRO2].[OGEN].[SCH_C_RESOURCES_bkup] from [DPRO2].[OGEN].[SCH_C_RESOURCES]

Where Name Like 'S___' 

WHILE (@MeterNumber <= (SELECT COUNT(*) FROM Sites
    WHERE SiteID = 1)


BEGIN
SET  @TheMetername = @Name + ' ' + cast(@MeterNumber as varchar(20))
PRINT @Name + ' ' + cast(@MeterNumber as varchar(20))

INSERT INTO METER (MeterName, SiteID) VALUES( @MeterName, 1)

SET  @MeterNumber = @MeterNumber + 1
END

IF (friend.block = 1) THEN
    'Yes'
ELSE
    'No'
END IF

expdp system/password@db10g full=Y directory=TEST_DIR dumpfile=DB10G.dmp logfile=expdpDB10G.log
impdp system/password@db10g full=Y directory=TEST_DIR dumpfile=DB10G.dmp logfile=impdpDB10G.log

WHERE xmlcolumn.value('(/path/to/tag)[1]', 'int') = @QueryValue

SELECT
  O.Id,
  O.Type,
  O.MyAmountCol,
  (SELECT
     sum(MyAmountCol) FROM Table1
   WHERE Id <= O.Id) 'RunningTotal'
FROM Table1 O
HAVING RunningTotal <= 7

SELECT PatientID, CaseNo, Gender, Name
  FROM 
(
  SELECT PatientID, CaseNo, Gender, Name, 
         ROW_NUMBER() OVER (PARTITION BY CaseNo ORDER BY Gender) rnum,
         COUNT(*) OVER (PARTITION BY CaseNo) rcnt
    FROM Patients
) q
 WHERE CaseNo IS NULL 
    OR rcnt = 1
    OR (rcnt > 1 AND rnum = 1)
 ORDER  BY Name

select id
,      sla_id
,      leng
,      group_id
,      (row_number() over (partition by id order by leng desc)) rn 
from 
(
SELECT a.id, a.sla_id, MAX(LENGTH(ag.area_prefix)) leng, ag.group_id
FROM areas a INNER JOIN areas_groups ag
    ON (SUBSTR(a.sla_id, 0, LENGTH(ag.area_prefix)) = ag.area_prefix)
WHERE a.sla_id IS NOT NULL
GROUP BY a.id, a.sla_id, ag.group_id
)
where rn = 1

def build_color_query(sphere_color_range):

    c = sphere_color_range[:3] # Sphere center
    r2 = sphere_color_range[3]**2 # Radius-squared

    # Use the "POWER" function is the database is MySQL
    if settings.DATABASES['default']['ENGINE'] == 'django.db.backends.mysql':

        color_query = """POWER((tcolor.r - %(a)s),2)
         + POWER((color.g - %(b)s),2)
         + POWER((color.b - %(c)s),2) <= %(r2)s""" % ({
            'a':str(c[0]),
            'b':str(c[1]),
            'c':str(c[2]),
            'r2':str(r2),
        })

    # Otherwise we use multiplication
    else:

        color_query = """(color.r - %(a)s) * (color.r - %(a)s)
         + (color.g - %(b)s) * (color.g - %(b)s)
         + (color.b - %(c)s) * (color.b - %(c)s) <= %(r2)s""" % ({
            'a':str(c[0]),
            'b':str(c[1]),
            'c':str(c[2]),
            'r2':str(r2),
        })

    # I had to include the `.filter(r__gte=0)` here in order for the 
    # right table joins to have been performed for me `extra` to work.
    # (It may not be necessary in this simplified version)
    return Color.objects.filter(r__gte=0).extra(where=[color_query])

SELECT meta_value  
FROM `wp_postmeta` 
WHERE STR_TO_DATE(meta_value,'%d/%m/%Y %H:%i' ) > NOW() 
AND meta_key='project_end'

INSERT INTO db2.users (steamid, name,`group`) SELECT steamid, nickname FROM db1.ttt_stats WHERE steamid NOT IN (SELECT steamid FROM db2.users)

select @TransactionTypeName = TT.Name
from inserted as i
    left outer join TransactionTypes as TT on TT.TransactionTypeId = i.TransactionType_TransactionTypeId

CREATE PROCEDURE dbo.InsertPickup
    @ClientID int,
    @PickupDate date 
AS
   IF NOT EXISTS (SELECT * FROM Pickup 
                  WHERE ClientID = @ClientID 
                    AND MONTH(PickupDate) = MONTH(@PickupDate) 
                    AND YEAR(PickupDate) = YEAR(@PickupDate) )
      INSERT INTO Pickup (ClientID, PickupDate)
      VALUES (@ClientID, @PickupDate)

SELECT original_name FROM `renamed` WHERE `key`='fb166'

Users
  UserID int

Events
  EventID int
  <dates, or whatever>

EventUsers
  UserID int (Foreign key to Users.UserID)
  EventID int (Foreign key to Events.EventID)

temp_sql = "UPDATE table_a SET column_a ='abc' WHERE column_b = 1"
result = ActiveRecord::Base.establish_connection(@db).connection.execute(temp_sql)
number_of_records = result.cmd_tuples

Follow the following recursive steps for the design (or for each substep) 
    I.   Develop the initial ERD.
    II.  Identify the attributes and primary keys that adequately describe the entities.
    III. Revise and review the ERD.
    IV.  Repeat steps until satisfactory output

You may also use entity clustering to further simplify your design process.

DECLARE @Number varchar(50)

--SET @Number='07800 000647(mobile)'
--SET @Number='07500 000189 USE 1ST'
--SET @Number='SEE NOTES'
--SET @Number='07900 000415 HO ONLY'
--SET @Number='try 1st 0770 0000694 then home'
SET @Number='07500 000465 Cannot '



SELECT REPLACE(SUBSTRING(@Number, case when CHARINDEX ('07',@Number ) =0 then Null 
else CHARINDEX ('07',@Number )end , 12),' ','')

// Database Version
private static final int DB_VERSION = 1;

// Database Name
private static String DB_NAME = "DB.sqlite";

//The default system path of your application database.
private static String DB_PATH = "/data/data/com.namespace.xxx/databases/";

public Database(Context context) {
    super(context, DB_NAME, null, DB_VERSION);
    this.myContext = context;
}   

public void createDataBase() throws IOException{

    Log.d(LOG, "Calling checkDataBase() Method");

    boolean dbExist = checkDataBase();

    if(dbExist){
        //do nothing - database already exist
        Log.d(LOG, "!!!Database Found!!!");
    }else{
        //Empty database will be created into the default system path
        Log.d(LOG, "!!!Creating Empy Database!!!");
        this.getReadableDatabase();
        this.close();
        try {
            Log.d(LOG, "!!!Coping Database!!!");
            copyDataBase();
        } catch (IOException e) {
            throw new Error(e);
        }
    } 
}

private boolean checkDataBase(){

    SQLiteDatabase checkDB = null;

    try{
        String myPath = DB_PATH + DB_NAME;

        Log.d(LOG, "looking database at " + myPath);

        checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY);

    }catch(SQLiteException e){
        //database does't exist yet.
        Log.e(LOG, "Exception: database does not exist yet");
    }

    if(checkDB != null){
        checkDB.close();
    }
    return checkDB != null ? true : false;
}

// Copies your database from your local assets-folder
// to the created empty database
private void copyDataBase() throws IOException{
    //Open your local db as the input stream
    InputStream myInput = myContext.getAssets().open(DB_NAME);

    // Path to the just created empty db
    String outFileName = DB_PATH + DB_NAME;

    Log.d(LOG, "Coping database from " + myInput + ", to " + outFileName);

    //Open the empty db as the output stream
    OutputStream myOutput = new FileOutputStream(outFileName);

    //transfer bytes from the inputfile to the outputfile
    byte[] buffer = new byte[1024];
    int length;
    while ((length = myInput.read(buffer))>0){
        myOutput.write(buffer, 0, length);
    }

    //Close the streams
    myOutput.flush();
    myOutput.close();
    myInput.close();
}

SELECT *
FROM   (
  SELECT dt AS date_from,
         LEAD( dt ) OVER ( ORDER BY dt ) AS date_to
         SUM( startend ) OVER ( ORDER BY dt ) AS num_events
  FROM   (
    SELECT date_from AS dt, 1 AS startend FROM event
    UNION ALL
    SELECT date_to, -1 FROM event
  )
)
WHERE date_from < date_to;

WHERE 0 in (col1, col2)
  OR '' in (col3, col4)

SELECT COUNT(*) 
FROM table_1 
FULL OUTER JOIN table_2 ON (table_1.id=table_2.id)

SELECT
      Id
     ,Name
     --Convert To Date Time
     ,CONVERT(datetime,
                -- Add 20 to the final 2 numbers to represent the year i.e 2013
                ('20' + SUBSTRING(REGISTRATION_DT,5,2)
                    + '-' + 
                -- the first 2 numbers to represent the Month i.e 09
                SUBSTRING(REGISTRATION_DT,1,2)
                    + '-' + 
                -- the middle 2 numbers to represent the day i.e 30
                SUBSTRING(REGISTRATION_DT,3,2))) 
     as REGISTRATION_DT
from YourTable

strDB = xlWb.Path & "\database\dbQueries.accdb"
conn.Open "Driver={Microsoft Access Driver (*.mdb, *.accdb)};" & _
   "Dbq=" & strDB & ";" & _
   "Trusted_Connection=Yes;"


SELECT * FROM T1 NATURAL JOIN T2;

DECLARE
  l_some_bool BOOLEAN := true;
BEGIN
  IF( l_some_bool )
  THEN
    dbms_output.put_line( 'true' );
  END IF;
END;

var query = from c in dc.Clients
            where c.Age > 25
            select new
            {
                Client = c,
                FullName = c.firstname + " " + c.lastname
            };

foreach (var item in query)
{
    // item.Client.Id
    // item.FullName
    // item.Client.FirstName
}

WITH AllStudents
AS (
  SELECT * FROM Students
  UNION
  SELECT * FROM OldStudents
)
SELECT 
    'StudentName' As Student,
    'Class'   As Class,
    'Subject' As Subject
    DATEDIFF( HOUR, hoursSpent.ClassStartTime, hoursSpent.ClassEndTime ) As HoursSpent
  FROM (
        SELECT stu.StudentName from AllStudents stu
        INNER JOIN Subjects  sub
        WHERE stu.StudentId = sub.StudentId
       ) hoursSpent

SELECT bk, search, ckey, dn
FROM 
(
  SELECT t1_bk_no AS 'bk', 
         t1_full_key AS 'ckey', 
         CAST(t1_info1 AS VARCHAR(100)) AS [1],
         CAST(t1_info2 AS VARCHAR(100)) AS [2],
         CAST(t1_info3 AS VARCHAR(100)) AS [3],
         CAST(t1_info4 AS VARCHAR(100)) AS [4],
         CAST(t1_info5 AS VARCHAR(100)) AS [5]
   FROM dbo.FirstTable
) PNT
UNPIVOT( search FOR dn IN ( [1],[2],[3],[4],[5] ) ) AS UPV
WHERE search NOT IN ( '0', '999999999', '') AND search IS NOT NULL
UNION ALL
SELECT bk, search, ckey, dn
FROM 
(
   SELECT t2_bk_no AS 'bk', 
         t2_full_key AS 'ckey', 
         CAST(t2_info1 AS VARCHAR(100)) AS [6],
         CAST(t2_info2 AS VARCHAR(100)) AS [7],
         CAST(t2_info3 AS VARCHAR(100)) AS [8]
   FROM dbo.SecondTable
) PNT
UNPIVOT( search FOR dnIN ( [1],[5],[7] ) ) AS UPV
WHERE search NOT IN ( '0', '999999999', '') AND search IS NOT NULL;

qryCourseStatus ON qryEmployeeCourse.[EMP ID] = qryCourseStatus.Username AND qryEmployeeCourse.AssetID = qryCourseStatus.AssetID

create or replace function test_to_json()
returns json language plpgsql
as $$
declare
    rec1 record;
    rec2 record;
    res text;
begin
    res = '{"node": [';
    for rec1 in
        select a, count(b) ct
        from tt
        group by 1
    loop
        res = format('%s{"child": [', res);
        for rec2 in
            select a, b, count(b) ct
            from tt
            where a = rec1.a
            group by 1,2
        loop
            res = res || format('{"value": %s, "name": %s},', rec2.ct, rec2.b);
        end loop;
        res = rtrim(res, ',');
        res = format('%s],"value": %s, "name": %s},', res, rec1.ct, rec1.a);
    end loop;
    res = rtrim(res, ',');
    res = format('%s], "value": %s}', res, (select count(b) from tt));
    return res:: json;
end $$;

select test_to_json();

DROP VIEW IF EXISTS combinedTableView ;

CREATE VIEW combinedTableView AS 

SELECT 
`name`,
`date`,
price,
description
FROM table1

UNION ALL

SELECT 
`name`,
`date`,
price,
description
FROM table2

UNION ALL

SELECT 
`name`,
`date`,
price,
description
FROM table3

UNION ALL

SELECT 
`name`,
`date`,
price,
description
FROM table4

BEGIN TRANSACTION

MERGE Target AS T
USING Source AS S
ON (T.EmployeeID = S.EmployeeID) 
WHEN NOT MATCHED BY TARGET AND S.EmployeeName LIKE 'S%' 
    THEN INSERT(EmployeeID, EmployeeName) VALUES(S.EmployeeID, S.EmployeeName)
    --THEN DELETE INSERTED ITEM------------------------------
WHEN MATCHED 
    THEN UPDATE SET T.EmployeeName = S.EmployeeName
WHEN NOT MATCHED BY SOURCE AND T.EmployeeName LIKE 'S%'
    THEN DELETE
OUTPUT inserted.EmployeeID INTO #TempTable

DELETE FROM Source
WHERE EmployeeID IN (SELECT EmployeeID FROM #TempTable)

COMMIT TRANSACTION

INSERT INTO db1.dbo.SmallerTable
SELECT *
  FROM linked_server.db.dbo.LargerTable lt
 WHERE NOT EXISTS(SELECT NULL
                    FROM db1.dbo.SmallerTable st
                   WHERE st.col = lt.col) 

SELECT t.City
FROM 
(SELECT City, COUNT(sup_id) as [totalSuppliers]
    FROM tb_supplier
    GROUP BY City 
    HAVING COUNT(sup_id) > 1) as t

select * 
from order
where order_number in
    (select order_number
     from order_details
     group by order_number
     having count(*) = 1)

select sum(ln(rownum)) ln_fact
from dual
connect by level <= 7;

select custname, case  
                    when city = 'London' then 'Brussels' 
                    else city 
                 end as city
from customer;

Select * from Table1
   Except
     Select * from Table2

select str
from (
  select 0 as id, 'apple' as str
  union all
  select 1, 'banana'
  union all
  select 2, 'orange'
  union all
  select 3, 'cherry'
  union all
  select 4, 'lemon'
) x
where id = floor(rand() * 5)

SELECT name FROM names 
WHERE (colA = @colA) OR (colA = 'ALL' AND NOT EXISTS(
                                                SELECT name FROM names 
                                                WHERE colA = @colA)) 

select numbers.name from 
(
      select 'one'   name union all
      select 'two'   name union all
      select 'three' name union all -- neither %o% nor %i%
      select 'four'  name union all
      select 'five'  name union all
      select 'six'   name union all
      select 'seven' name union all -- neither %o% nor %i%
      select 'eight' name union all
      select 'nine'  name union all
      select 'ten'   name           -- neither %o% nor %i%
) numbers
where not exists (select null
                    from (
                             select '%o%'  expression union all
                             select '%i%'  expression
                         ) patterns
                   where numbers.name like patterns.expression)

select time, activities, count(*) from table group by time, activities;

SELECT
    SomeTable.*,    
    col1.RANK + col2.RANK
FROM 
    SomeTable
INNER JOIN CONTAINSTABLE(SomeTable, Column1, 'word1 OR word2') as col1 ON 
    col1.[KEY] = SomeTable.ID
INNER JOIN CONTAINSTABLE(SomeTable, Column2, 'word3 OR word4') as col2 ON 
    col2.[KEY] = SomeTable.ID

END
GO

---Automatic replacement of GO keyword, need to recheck IF conditional:
IF whatever
BEGIN

select coalesce(a.usr_id,b.usr_id) usr_id,
coalesce(a.col1,b.col1) col1,
coalesce(a.col2,b.col2) col2
from tablea a full join tableb b
on a.usr_id = b.usr_id

DECLARE
  CURSOR t IS
  SELECT LEAD(contractid,4) OVER (PARTITION BY assetid ORDER BY lasttradedate ASC) lead_contractid
    FROM table1
    FOR UPDATE;
BEGIN
  FOR r IN t LOOP
     UPDATE table1 SET nextcontractid = r.lead_contractid
       WHERE CURRENT OF t;
  END LOOP;
END;

SELECT  MeasureDate, col1, col2
FROM Table1
WHERE Col3 = 2
  or (Col3 = 1 AND Col4 = 7000);


SELECT  sum(col1) / sum(col2) AS Percentage , GROUP BY MeasureDate
FROM Table1
WHERE Col3 = 2
  or (Col3 = 1 AND Col4 = 7000)
GROUP BY MeasureDate;

SELECT 
  C.Candidate_ID,
  C.Surname, 
  C.Name, 
  SUM(V.ClassA * M.Multiplier) AS ClassA, 
  SUM(V.ClassB * M.Multiplier) AS ClassB, 
  SUM(V.ClassC * M.Multiplier) AS ClassC
FROM 
  ( ( Candidates C 
      INNER JOIN Votes V ON C.Candidate_ID = V.Candidate_ID )
    INNER JOIN Parties P ON V.Party_ID = P.Party_ID )
  INNER JOIN Multiplier M ON P.Party_Type = M.Party_Type
GROUP BY 
  C.Candidate_ID, 
  C.Surname, 
  C.Name;

insert into table_name
(date_field)
values
(to_date('2010/01/04 09:00:00', 'yyyy/mm/dd hh24:mi:ss'));

SELECT
    TO_NUMBER(TO_CHAR(DATE'2016-02-01', 'DDD')),
    TO_NUMBER(TO_CHAR(SYSDATE, 'DDD')),
    TO_NUMBER(TO_CHAR(DATE'2016-12-31', 'DDD'))
FROM
    dual

update 1 : set from "NULL" to "0"
update 2 : set from "0" to "something else"
update 3 : Rollback changes (rollback to which state)?

CREATE OR REPLACE TRIGGER2
BEFORE INSERT
ON TEST_TABLE
FOR EACH ROW

CREATE OR REPLACE TRIGGER4
BEFORE INSERT
ON TEST_TABLE
FOR EACH ROW
FOLLOWS TRIGGER2

CREATE OR REPLACE TRIGGER3
BEFORE INSERT
ON TEST_TABLE
FOR EACH ROW
FOLLOWS TRIGGER4

SELECT first_name, last_name, car_rego
FROM   staff
JOIN   carallocation ON (carallocation.staff_id = staff.staff_id)
JOIN   car ON (car.car_id = carallocation.car_id)
WHERE  staff.office = 'Glasgow' OR staff.office = 'Bearsden';

select
  f.`record` as `record`,
  f.`value` as `first name`, 
  l.`value` as `last name`,
  e.`value` as `email`
from 
  jos_facileforms_subrecords f
  inner join jos_facileforms_subrecords l on f.record = l.record
  inner join jos_facileforms_subrecords e on f.record = e.record
where
  f.name = 'firstname'
  and l.name = 'lastname'
  and e.name = 'email'
group by f.`record`

<cfquery name="get_folders" datasource="#application.dsn#">
    select folder_id, parent_folder_id, folder_name
    from folders
    order by folder_name
</cfquery>

<!--- Read all roots (no parent ID) --->
<cfquery name="get_parent_folders" dbtype="query">
    select folder_id, folder_name
    from get_folders
    where parent_folder_id is null
</cfquery>

<ul class="tree">
    <cfloop query="get_parent_folders">
        <cfset processTreeNode(folderId=get_parent_folders.folderId, folderName=get_parent_folders.folder_name) />
    </cfloop>
</ul>

<cffunction name="processTreeNode" output="true">
    <cfargument name="folderId" type="numeric" />
    <cfargument name="folderName" type="string" />
    <!--- Check for any nodes that have *this* node as a parent --->
    <cfquery name="LOCAL.qFindChildren" dbtype="query">
        select folder_id, folder_name
        from get_folders
        where parent_folder_id = <cfqueryparam value="#arguments.folderId#" cfsqltype="cf_sql_integer" />
    </cfquery>
    <li>#arguments.folderName#
        <cfif LOCAL.qFindChildren.recordcount>
            <!--- We have another list! --->
            <ul>
                <!--- We have children, so process these first --->
                <cfloop query="LOCAL.qFindChildren">
                    <!--- Recursively call function --->
                    <cfset processTreeNode(folderId=LOCAL.qFindChildren.folder_id, folderName=LOCAL.qFindChildren.folder_name) />
                </cfloop>
            </ul>
        </cfif>
    </li>
</cffunction>

select 'This came from table A' as SourceTable, Id, Name
  from TableA
--
union
--
select 'This came from table B' as SourceTable, Id, Name
  from TableB

SELECT COL1||'_asd_', T.*
FROM MYTABLE T;

SELECT qId,
       SUM(CASE WHEN TOGGLE_VALUE='Yes' THEN 1 ELSE 0 END) AS YesQty,
       SUM(CASE WHEN TOGGLE_VALUE='No' THEN 1 ELSE 0 END) AS NoQty,
       SUM(CASE WHEN TOGGLE_VALUE='NA' THEN 1 ELSE 0 END) AS NAQty,
       SUM(CASE WHEN TOGGLE_VALUE='Resolved' THEN 1 ELSE 0 END) AS ResolvedQty
  FROM ANSWERS 
 GROUP BY qId

SELECT id, name, 'projects' AS table_name 
FROM projects WHERE name like '%querystriong%' UNION SELECT id, name, 'documents' AS table_name
FROM documents WHERE name like '%querystriong%'

DECLARE @STARTDATE DATETIME = '1989-12-31'
    , @ENDDATE DATETIME = '2015-10-31 23:59:59'

SELECT
     c.calendarDate,
     Count(e.empid) as Number_Hired,
     datepart(week, c.calendarDate) as [Week],
     datepart(month, c.calendarDate) as [Month],
     datepart(year, c.calendarDate) as [Year],
     ew.WeekCount Number_Hired_This_Week,
     em.MonthCount Number_Hired_This_Month,
     ey.YearCount Number_Hired_This_Year
FROM
    intranet.dbo.igbl_calendar c
    LEFT JOIN intranet.dbo.iemp_employee e on c.calendarDate = e.hireDate AND aliasID = 'P'
    LEFT JOIN (SELECT DATEPART(ww, hireDate) [Week]
        , DATEPART(yy, hireDate) [Year]
        , COUNT(empid) [WeekCount]
        FROM intranet.dbo.iemp_employee
        GROUP BY DATEPART(ww, hireDate), DATEPART(yy, hireDate)) ew
        ON ew.[Week] = DATEPART(ww, c.calendarDate)
        AND ew.[Year] = DATEPART(yy, c.calendarDate)
    LEFT JOIN (SELECT DATEPART(mm, hireDate) [Month]
        , DATEPART(yy, hireDate) [Year]
        , COUNT(empid) [MonthCount]
        FROM intranet.dbo.iemp_employee
        GROUP BY DATEPART(mm, hireDate), DATEPART(yy, hireDate)) em
        ON em.[Month] = DATEPART(mm, c.calendarDate)
        AND em.[Year] = DATEPART(yy, c.calendarDate)
    LEFT JOIN (SELECT  DATEPART(yy, hireDate) [Year]
        , COUNT(empid) [YearCount]
        FROM intranet.dbo.iemp_employee
        GROUP BY DATEPART(yy, hireDate)) ey
        ON ey.[Year] = DATEPART(yy, c.calendarDate)
WHERE
    c.calendarDate BETWEEN @STARTDATE AND @ENDDATE
GROUP BY
    c.calendarDate, ew.WeekCount, em.MonthCount, ey.YearCount
ORDER BY
    c.calendarDate

SELECT table1.Client_Name, table2.Client_Info
FROM table1
RIGHT JOIN table2 ON table1.ID_Number = table2.ID_Number

MERGE INTO users dest
  USING( SELECT 1 user_id, 10 points FROM dual) src
     ON( dest.user_id = src.user_id )
 WHEN MATCHED THEN
   UPDATE SET points = src.points
 WHEN NOT MATCHED THEN
   INSERT( user_id, points ) 
     VALUES( src.user_id, src.points );

union SELECT null as [EMPL ID], 'NULL' as [EMPL NAME]

    for (int i = 0; i < lvProductInfo.Items.Count; i++)
    {
        ProductCode = Convert.ToInt32(lvProductInfo.Items[i].SubItems[1].Text);
        ProductQuantity = Convert.ToInt32(lvProductInfo.Items[i].SubItems[2].Text);
        ProductPrice = Convert.ToInt32(lvProductInfo.Items[i].SubItems[3].Text);
        totalPrice = Convert.ToInt32(lvProductInfo.Items[i].SubItems[4].Text);


        sql = "";
        sql = "INSERT INTO PurchaseLog (ProductCode,ProductQuantity,ProductPrice,TotalPrice)"
            + " VALUES ('" + ProductCode + "','" + ProductQuantity + "','" + ProductPrice + "','" + totalPrice + "')";

        clsConnection clsCn = new clsConnection();
        SqlConnection cn = null;
        SqlCommand cmd = new SqlCommand();

        clsCn.fnc_ConnectToDB(ref cn);

        cmd.Connection = cn;
        cmd.CommandText = sql;
        cmd.ExecuteNonQuery();


        this.Close();
    }

}

DECLARE @user geography = 'POINT(31.97542 35.911285)'
SELECT TOP 50 FROM Users ORDER BY @user.STDistance(Position)

SELECT * FROM table t 
WHERE Exists
   (Select * From table
    Where field1 = t.field1
       And field2 = 5)

unixScript.ksh db_schemaParm "sqlScript.sql parmForSqlScript"

select t.person, t.product, count(*) as cnt, max(t.date) as date
from table t
group by t.person, t.product, cast(t.date as date);

select  *
,       (
        select  max(t2.id)
        from    table2 t2
        where   t2.id between t1.range_from and t1.range_to
        ) as max_id_in_range
from    table1 t1

SELECT 
      E.firstname, 
      E.lastname, 
      case when S.Empl_ID IS NULL then 'NO' else 'YES' end as Iss
   from
      Employee E
         LEFT JOIN Supervisor S
            on E.Empl_ID = S.Empl_ID

select p.*,
       (p.price - 
        (select p2.price
         from product p2
         where p2.id = p.id and p2.period < p.period
         order by period desc
         limit 1
        ) - 1
       ) * 100 as PercentageChange
from product p
order by category;

CREATE TABLE Country (CountryID int, Name varchar(50))
CERATE TABLE State (StateID int, CountryID int, Name varchar(50))
CREATE TABLE City (CityID int, StateID int, Name varchar(50))

WITH
CTE
AS
(
  SELECT
    ID
    ,Status
    ,dt
    ,Job
    ,Note
    ,ROW_NUMBER() OVER (PARTITION BY ID, Job ORDER BY dt ASC) AS rnASC
    ,ROW_NUMBER() OVER (PARTITION BY ID, Job ORDER BY dt DESC) AS rnDESC
  FROM T
)
SELECT 
    ID
    ,Status
    ,dt
    ,Job
    ,Note
FROM CTE
WHERE rnAsc=1 OR rnDesc=1
ORDER BY ID, Job, dt

where dateadd(day, -1, IntervalDate) >= getdate()-60

select i.item, m.material, m.begin_time
from items i join
     materials m
     on m.begin_time  between i.begin_time and i.end_time
union all
select item, material, begin_time
from (select i.item, m.material, m.begin_time,
             row_number() over (partition by i.item order by m.begin_time desc) as seqnum
      from items i join
           materials m
           on m.begin_time < i.begin_time 
     ) im
where seqnum <= 2;

select * from posts order by timestamp desc limit 100

<input type="text" name="name_117" value="Some value">
<input type="text" name="name_118" value="Some other value">
<input type="text" name="name_1243" value="Yet another value">

b4 =average($a$1:a4)

SELECT 
    users.username, users.address, 
    GROUP_CONCAT(projects SEPARATOR ', ') AS projects
FROM
    users JOIN projects_to_users 
        ON users.user_id = projects_to_users.user_id
    JOIN projects
        ON projects_to_users.project_id = projects.project_id
GROUP BY
    users.user_id;

WITH t AS
  (SELECT name AS l FROM <your query>
  )
SELECT SUBSTR(l,instr(l,' ',-1)+1,LENGTH(l)) FROM t;

if object_id('tempdb..#Temp') is not null drop table #Temp
create table #Temp (FirmName nvarchar(50))

insert into #Temp (FirmName) 
values ('Emlak 17'),
   ('Sanane Emlak'),
   ('GE Emlak => Result'),
   ('45 Emlak'),
   ('Emlak 3Z'),
   ('Burak Emlak')

select * from #Temp
    where Len(LEFT(FirmName, charindex(' ',FirmName, 0))) = 2
       or LEN(RIGHT(FirmName,LEN(FirmName)-CHARINDEX(' ',FirmName))) = 2

Select Distinct QualificationField
  Into #TEMPTABLE
  From dbo.Q_PersonWithPass;

DECLARE
@SQLQuery nvarchar(4000),
@QField nvarchar(10)
BEGIN

Set @SQLQuery = 'select PWP.PersonId, PWP.PassType, PWP.QualificationField, PWP.QualificationAnswer,  Case ';

While EXISTS(Select * from #TEMPTABLE)
Begin
    Select Top 1 @QField = QualificationField From #TEMPTABLE;
    Set @SQLQuery = @SQLQuery + 'When PWP.QualificationField = ' + @QField + ' Then P.' + @QFIELD + ' ';
    Delete from #TEMPTABLE Where QualificationField = @QField;
End

Set @SQLQuery = @SQLQuery + ' end AS QualFld FROM dbo.Q_PersonWithPass PWP JOIN dbo.Person P on P.PersonID = PWP.PersonID';

EXECUTE sp_executesql  @SQLQuery

END;

SELECT
    COALESCE(t1.FirstName,t2.FirstName) as FirstName,
    COALESCE(t1.LastName,t2.LastName) as LastName,
    COALESCE(t1.value,0) as t1value,
    COALESCE(t2.value,0) as t2value
FROM
    (select FirstName,LastName,SUM(value) as value
     from table1
     group by FirstName,LastName) t1
        full outer join
    (select FirstName,LastName,SUM(value) as value
     from table2
     group by FirstName,LastName) t2
        on
            t1.FirstName= t2.FirstName and
            t1.LastName=  t2.LastName

Declare @input varbinary(128) = 0x50006100720074006900740069006F006E005400650073007400
Declare @Temp as VARCHAR(350)
Set @Temp = CONVERT(VARCHAR(350), @input ,2)
declare @length int
set @length = len(@Temp)
select @length
declare @i int = 3


WHILE @i < @length/2+2
BEGIN
    Set @Temp = Stuff(@Temp, @i, 2, '')
    set @i = @i +2

END

select '0x' + @Temp

select u.id, u.username, p.id, p.user_id, p.port
from users u
  join ports p on u.id = p.user_id
where u.username = :userparam

select c_1
from t
where c_1 != 'A'
group by c_1
having collect(c_2) = (select collect(c_2) from t where c_1 = 'A' group by c_1)
/

SELECT *lots*
FROM db1 INNER JOIN
db2 ON db1.id = db2.id
WHERE (db1.num = 2353) AND 
(db1.specific = 'OO' OR db1.specific = 'AA')

declare @state varchar(20)
set @state = 'Proposed'

create table #tt_Result
(
  Area varchar(max),
  [Active] int,
  [Proposed] int
)

insert into #tt_Result
select Area, [Active], [Proposed]
from
(
  select Area, State from AreaState
) as src
pivot
(
   count(State) for State in ([Active], [Proposed])
) as pvt

select Area, 
case
  when @state = 'Active' then [Active]
  when @state = 'Proposed' then [Proposed]
end as [Count]
from #tt_Result

drop table #tt_Result

SELECT  pe.Name,
        pe.Surname
FROM Player AS pl
INNER JOIN PlayerContract AS pc
    ON pl.ID = pc.Player
INNER JOIN Team AS t
    ON pc.Team = t.ID
INNER JOIN Person AS pe
    ON pc.Person = pe.ID
WHERE t.Name = 'X'

WITH x AS
(
    SELECT 
        eventDate, MAC, IP, eventCode, 
        rn = ROW_NUMBER() OVER
        (
            PARTITION BY DATEDIFF(DAY, 0, eventDate),
            MAC, IP, eventCode
            ORDER BY eventDate
        )
        FROM EventsLog
)
SELECT
    eventDate, MAC, IP, eventCode
FROM x
WHERE rn = 1
ORDER BY EventDate;

SELECT NAME,
       SUM(AMOUNT) AS AMOUNT,
       SUM(CASE WHEN COUNTRY = 'US' THEN 1 ELSE 0 END) AS US_COUNT,
       SUM(CASE WHEN COUNTRY = 'US' THEN 0 ELSE 1 END) AS NON_US_COUNT,
       SUM(CASE WHEN COUNTRY = 'US' THEN [No. ITEM] ELSE 0 END) AS US_NO_ITEM,
       SUM(CASE WHEN COUNTRY = 'US' THEN 0 ELSE [No. ITEM] END) AS NON_US_NO_ITEM
FROM   Table
GROUP BY NAME,
       COUNTRY

SELECT   Trunc(EMP_JN_DT,'MM') Emp_Jn_Mth,
         Count(*)
FROM     EMP_REG
WHERE    EMP_JN_DT between date '2009-01-01' AND date '2009-12-31'
GROUP BY Trunc(EMP_JN_DT,'MM')
ORDER BY 1;

 CREATE TABLE NEW_TABLE
 (
     EMP_NUM NUMBER(5, 0) NOT NULL PRIMARY KEY, 
     RTG_CODE CHAR(5 BYTE) NOT NULL,
     EARNED_DATE DATE NOT NULL,
     FOREIGN KEY (RTG_CODE) REFERENCES RTG(RTG_CODE)
 );

select s.name, r.name Region, c.name Country
     from supplier s
     join region r on r.id = s.regionid
     join region c on c.id = isnull(r.pid, r.id)
     inner join (select s.name, r.name Region, c.name Country
                from supplier s
                join region r on r.id = s.regionid
                join region c on c.id = isnull(r.pid, r.id)
                group by s.name, r.name, c.name
                having count(s.name) >1 ) dups
     ON s.name = dups.name
        and r.name = dups.region
        and c.name = dups.country

SELECT ab.follower_id AS a_id,
       ab.followee_id AS b_id,
       ac.followee_id AS c_id
FROM following AS ab
JOIN following AS ba ON ab.followee_id = ba.follower_id
                    AND ab.follower_id = ba.followee_id
JOIN following AS ac ON ab.follower_id = ac.follower_id
JOIN following AS cb ON ac.followee_id = cb.follower_id
                    AND ab.followee_id = cb.followee_id
LEFT OUTER JOIN following AS ca ON ac.followee_id = ca.follower_id
                               AND ac.follower_id = ca.followee_id
LEFT OUTER JOIN following AS bc ON cb.followee_id = bc.follower_id
                               AND cb.follower_id = bc.followee_id
WHERE ab.follower_id < ab.followee_id
  AND ab.followee_id < ac.followee_id
  AND ca.follower_id IS NULL
  AND bc.follower_id IS NULL

select 
        s._id sid,
        s.name, 
        null iid
    from 
        section s
union all
select 
        i.section_id sid, 
        i.name, 
        i._id iid
    from
        item i
    order by
        sid, iid

SELECT 
  StudentNum, 
  max(RSubjectCode) as RSubjectCode, 
  Year, 
  SessionTerm 
FROM 
  <TABLE> 
WHERE 
  Year ='2012' 
  AND SESSIONTERM = '3'
GROUP BY
  StudentNum, 
  Year, 
  SessionTerm 
HAVING
  count(*) = 1

DECLARE @productType INT = 1
DECLARE @table  NVARCHAR(MAX)
DECLARE @sql    NVARCHAR(MAX)

SELECT @table = 
    CASE @productType
        WHEN 1 THEN 'products1'
        WHEN 2 THEN 'products2'
    END

SELECT @sql = 'SELECT * FROM ' + QUOTENAME(@table);

EXEC(@sql)

SELECT account_number,
       Balance,
       `0-30` - (total_invoices - Balance - LEAST(`90+` + `60-90` + `30-60`, total_invoices - Balance)) AS `0-30`,
       `30-60` - (total_invoices - Balance - LEAST(`90+` + `60-90`, total_invoices - Balance)) AS `30-60`,
       `60-90` - (total_invoices - Balance - LEAST(`90+`, total_invoices - Balance)) AS `60-90`,
       GREATEST(0, `90+` - (total_invoices - Balance)) AS `90+`
FROM (...)

SELECT 
P.ITEM_NUMBER,
P.PROJECT_NUMBER,       
MIN(L.LOCATION) KEEP (DENSE_RANK FIRST ORDER BY L.SORT1, L.SORT2 DESC) LOCATION
FROM   
LOCATIONS L
INNER JOIN
PROJECT P
ON L.ITEM_NUMBER=P.ITEM_NUMBER
AND L.PROJECT_NUMBER=P.PROJECT_NUMBER
GROUP BY
P.ITEM_NUMBER,
P.PROJECT_NUMBER

    Select (id1_a + ' ' +id2_a + ' ' +id3_a) as key, col1  , col2  , col3 , 
    null as col4 , null as col5 , null as col6 from Table1 
    union 
    Select (id1_b + ' ' +id2_b + ' ' +id3_b) as key, null as col1  , null as col2  , 
    null as col3 , col4 , col5 , col6 from Table2

select  Change_Ticket.status, nvl(sum(service_req), 0) as SUM_REQ 
from Change_Ticket, Change
where Change.company_id (+) = '0' 
  and Change.month (+)='07'
  and Change.Id  (+) = Change_Ticket.Change_Id 
group by Change_Ticket.status
union all
select '' as STATUS, 0 as SUM_REQ
from dual
where not exists (select null from Change_ticket)

BEGIN
  EXECUTE IMMEDIATE 'TRUNCATE TABLE DATASET1';
  EXECUTE IMMEDIATE 'TRUNCATE TABLE DATASET2';

  -- logic to load temp tables with fresh data goes here

  -- logic to compare tables goes here
END;

select
 from_id as contact_id
from messages
where to_id = 12
union
select
 to_id
from messages
where from_id = 12
Select ID,
    STR(SUM(CASE Type WHEN 'FLM' THEN DateDiff(s,[Start Date],[End Date]) END)/3600) +
    RIGHT(CONVERT(char(8),DATEADD(s,SUM(CASE Type WHEN 'FLM' THEN DateDiff(s,[Start Date],[End Date]) END),0),108),6) [FLM],
    STR(SUM(CASE Type WHEN 'SLM' THEN DateDiff(s,[Start Date],[End Date]) END)/3600) +
    RIGHT(CONVERT(char(8),DATEADD(s,SUM(CASE Type WHEN 'SLM' THEN DateDiff(s,[Start Date],[End Date]) END),0),108),6) [SLM]
From #_TicketType 
GROUP BY ID

UPDATE  a
SET     a.Schools = b.SchoolList
FROM    Districts a
        INNER JOIN
        (
            SELECT  DistrictId,
                    STUFF((SELECT ', ' + SchoolName
                            FROM Schools
                            WHERE DistrictId = a.DistrictId
                            FOR XML PATH (''))
                        , 1, 1, '')  AS SchoolList
            FROM    Districts AS a
            GROUP   BY DistrictId
        ) b ON A.DistrictId = b.DistrictId
WHERE   b.SchoolList IS NOT NULL

EDIT: Sorry, my first code mixed the captions!
CREATE TABLE dbo.Test(ID INT,Product VARCHAR(100),Colour VARCHAR(100),Material VARCHAR(100));
INSERT INTO dbo.Test VALUES(1,'Coat','Purple','Polyester,Nylon');

WITH XMLNAMESPACES('test' AS p)
SELECT 'Product' AS [p:attributName/@name]
      ,Product AS [p:attributName]
      ,''
      ,'Colour' AS [p:attributName/@name]
      ,Colour AS [p:attributName]
      ,''
      ,'Material' AS [p:attributName/@name]
      ,Material AS [p:attributName]
FROM dbo.Test
FOR XML PATH('Item')

DROP TABLE dbo.Test;

/*
<Item xmlns:p="test">
  <p:attributName name="Product">Coat</p:attributName>
  <p:attributName name="Colour">Purple</p:attributName>
  <p:attributName name="Material">Polyester,Nylon</p:attributName>
</Item>
*/

$dbh->trace($dbh->parse_trace_flags('SQL|1|test'));

SELECT * FROM myTable 
WHERE account_id IN (
    SELECT account_id FROM myTable WHERE balance < 0
)

SELECT  ID, 
        SUBSTR(xmlserialize(xmlagg(xmltext(CONCAT( ', ',text))) as VARCHAR(1024)), 3)
FROM    tableName
GROUP   BY ID;

INSERT INTO 
    questionsets    (
    Q1,
    Q2,
    .
    .
    Q20)
SELECT * FROM(
    SELECT *, ROW_NUMBER() OVER (ORDER BY questionid) RNum FROM(
        SELECT TOP 20 questionid FROM questions ORDER BY NEWID()
)x)y PIVOT (MAX(questionid) FOR RNum IN ([1], [2], [3], ..., [20]))as pvt

 select * from 
       (select count(tp.reg#) as cn,t.reg#,  CAPACITY
       from truck t
       join trip tp 
       on  t.reg# = tp.reg#
       group by tp.reg#,  CAPACITY, t.reg#)
  where cn = (select min(cn) from (select count(tp.reg#) as cn,t.reg#,  CAPACITY
                                      from truck t
                                      join trip tp 
                                      on  t.reg# = tp.reg#
                                      where cn > 0
                                      group by tp.reg#,  CAPACITY, t.reg#))

select cls_id,
    cls_name,
    MAX(case when rn = 1 then users_id end) user_id1,
    MAX(case when rn = 2 then users_id end) user_id2
from
(
    SELECT cr.cls_id, 
        cr.cls_name, 
        u1.users_id,
        ROW_NUMBER() over(partition by cr.cls_id order by u1.users_id) rn
    FROM classroom cr
    INNER JOIN clsown co
        ON co.cls_id = cr.cls_id 
    INNER JOIN users AS u1 
        ON co.users_id = u1.users_id 
) d
group by cls_id, cls_name;

SELECT C.id
FROM checkids C
LEFT JOIN mytable M
ON M.id = C.id
WHERE M.id IS NULL

 SELECT a.ID_OF, a.Col, a.BNT,    
    SUM(a.size1) - SUM(b.size1) As size1, 
    SUM(a.size2) - SUM(b.size2) As size2,
    SUM(a.size3) - SUM(b.size3) As size3,
    SUM(a.size4) - SUM(b.size4) As size4,
    SUM(a.size5) - SUM(b.size5) As size5,
    SUM(a.size6) - SUM(b.size6) As size6,
    SUM(a.size7) - SUM(b.size7) As size7,
    SUM(a.size8) - SUM(b.size8) As size8,
    SUM(a.size9) - SUM(b.size9) As size9,
    SUM(a.size10) - SUM(b.size10) As size10,
    SUM(a.total) - SUM(b.total) As total,
    a.ref
    FROM tblTailleOFALL a 
    JOIN  tblTailleALL b
      ON a.ID_OF = b.ID_OF
     AND a.Col = b.Col
     AND a.BNT = b.BNT
GROUP BY a.ID_OF, a.Col, a.BNT, a.ref 

SELECT E.EntityID, E.ShortName, S.ScheduleID
FROM  tblEntities E 
     Left Join tblScheduling S 
        ON S.EntityID = E.EntityID
           And S.SchedulingYearID = @SchedulingYearID 
WHERE E.Active = 1
ORDER BY E.EntityID

SELECT u.name
     , u.picture_url
     , m.id_user_winner
     , m.id_user_loser
     , e.name
     , e.picture_url
     , m.date_match 
FROM matches m JOIN users u ON u.id_user = m.id_user_winner AND u.id_user = 3
               JOIN users e ON e.id_user = m.id_user_loser

/**
 * Call once per row.
 * 
 * @param data
 *            Text containing data for each cell.
 * @param rowId
 *            unique id for OnClickListener
 */
public void addRow(String[] data, int[] rowId) {
    for (int i = 0; i < data.length; i++) {
        TextView tv = getTextViewAndMakeThemPretty(data[i]);
        tv.setId(rowId[i]);
        tv.setFocusable(false);
        tv.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                /**
                 * Do your stuff here.
                 */

            }
        });
        this.addView(tv);
        /**
         * Adds the TextView to Row as Cell
         */
    }
}

SELECT     inner.cworderid,
           inner.cwcreated,
           inner.organisationtype,
           inner.custref,
           inner.tetranumber,
           inner.buildingname,
           inner.streetname,
           inner.posttown,
           inner.postcode,
           inner.country
FROM(           
  SELECT   h.cworderid,
           h.cwcreated,
           h.organisationtype,
           h.custref,
           h.tetranumber,
           c.buildingname,
           c.streetname,
           c.posttown,
           c.postcode,
           c.country,
           COUNT(DISTINCT tetranumber) OVER(PARTITION BY h.custref) cnt
    FROM   cdsheader h, custandaddr c
    WHERE  h.custref = c.cwdocid 
       AND c.addresstype = 'C'
      )inner
  WHERE inner.cnt>1 
 ORDER BY inner.custref, inner.tetranumber, inner.cworderid;  

Select country
     , count(*)
  from theTable
 group by country
having count(*) > 1
 order by country

SELECT *
FROM table
WHERE field LIKE "Hel%"

SELECT CONVERT(DECIMAL(10,2),SUM(PAPostedTotalCostN)) AS Total_Cost 
FROM PA01201
WHERE PA01201.PAcontid = '00900'

;with cte AS
(
SELECT name, data, ROW_NUMBER() OVER (PARTITION BY name ORDER BY data DESC) AS RN
FROM YourTable
)
SELECT name, data
FROM cte 
WHERE RN<=2
ORDER BY name, data

SELECT
    max_level,
    count(*)
FROM
(
    SELECT
        max(level) AS max_level
    FROM table1
    GROUP BY Record
) max_levels
GROUP BY max_level
ORDER BY max_level;

select 
  title, 
  count(DISTINCT customerid) as `count`
from 
  yourTable
group by 
  title
order by 
  `count` desc

impdp ... Content=data_only exclude=TABLE:"IN ('table1', 'table2')"

ALTER TABLE dbo.Students
...
[ADD CONSTRAINT constraint_name]
FOREIGN KEY (UniversityId)
REFERENCES dbo.University (UniversityId)

CREATE GLOBAL TEMPORARY TABLE today_sales
   ON COMMIT PRESERVE ROWS 
   AS SELECT * FROM orders WHERE order_date = SYSDATE;

;WITH trip_cte AS
(
    SELECT
        T1.dir,
        T1.linkl AS start,
        T1.linkh AS finish
    FROM
        dbo.Trips T1
    UNION ALL
    SELECT
        CTE.dir,
        CTE.start,
        T.linkh AS finish
    FROM
        trip_cte CTE
    INNER JOIN dbo.Trips T ON
        T.linkl = CTE.finish
)
SELECT
    dir,
    start,
    finish
FROM
    trip_cte

SELECT ID, Date,Toy_object, currency, budget, 
       CASE currency 
          WHEN 'GBP' THEN budget*1.67 
          WHEN 'EUR' THEN budget*1.3 
       ELSE budget END AS USD_Value,
       SUM(CASE currency 
              WHEN 'GBP' THEN budget*1.67 
              WHEN 'EUR' THEN budget*1.3 
              ELSE budget 
            END) OVER() AS Total_Budget 
FROM PROJECT_DETAILS

SELECT 
    m.FullName, gm.ID
FROM 
    Members m
INNER JOIN 
    GroupMembers gm ON m.ID = gm.MemberID
WHERE 
    gm.GroupID = 'foo'

-- MySQL Script generated by MySQL Workbench
-- 07/30/14 05:51:12
-- Model: New Model    Version: 1.0
SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci ;
USE `mydb` ;

-- -----------------------------------------------------
-- Table `mydb`.`people`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`people` (
  `idpeople` INT UNSIGNED NOT NULL,
  `name` VARCHAR(45) NULL,
  `birthday` DATE NULL,
  `sex` CHAR(1) NULL,
  PRIMARY KEY (`idpeople`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`teachers`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`teachers` (
  `people_idpeople` INT UNSIGNED NOT NULL,
  `unique_column` VARCHAR(45) NULL,
  PRIMARY KEY (`people_idpeople`),
  CONSTRAINT `fk_teachers_people`
    FOREIGN KEY (`people_idpeople`)
    REFERENCES `mydb`.`people` (`idpeople`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`students`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`students` (
  `people_idpeople` INT UNSIGNED NOT NULL,
  `unique_column` VARCHAR(45) NULL,
  PRIMARY KEY (`people_idpeople`),
  CONSTRAINT `fk_students_people1`
    FOREIGN KEY (`people_idpeople`)
    REFERENCES `mydb`.`people` (`idpeople`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `mydb`.`staff`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`staff` (
  `people_idpeople` INT UNSIGNED NOT NULL,
  `unique_column` VARCHAR(45) NULL,
  PRIMARY KEY (`people_idpeople`),
  CONSTRAINT `fk_staff_people1`
    FOREIGN KEY (`people_idpeople`)
    REFERENCES `mydb`.`people` (`idpeople`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

SELECT *
FROM Product p
JOIN Apple a ON (p.ProductType = 1 AND p.ProductId = a.Id)
JOIN Orange o ON (p.ProductType = 2 AND p.ProductId = o.Id)

Insert Into dbo.SubCategories (UpperId, Title, Description)

Select 0, Title, Description
From dbo.Categories

select t.*
from (select t.*, row_number() over (partition by t.id order by ind desc) as seqnum
      from table t outer apply
           splitstring(t.[desc])(str, ind)
     ) t
where seqnum = 2;

CREATE TRIGGER trgD_StudentAccount_Delete
ON dbo.StudentAccount
INSTEAD OF DELETE
AS
BEGIN
    IF EXISTS (
        SELECT  *
        FROM    deleted d
        WHERE   d.AmountOwing <> 0
    )
    BEGIN
        ROLLBACK;
        RAISERROR('Delete error: there are students with Amount <> 0', 16, 1);
    END
    ELSE
    BEGIN
        DELETE  StudentAccount 
        WHERE   EXISTS( SELECT * FROM deleted d WHERE d.[SID] = StudentAccount.[SID] )
    END
END

SELECT t1.column_name, ch.id
FROM information_schema.Columns t1
LEFT JOIN checkbox ch
  ON t1.column_name = ch.column
WHERE t1.table_name = 'tab_col'
ORDER BY t1.column_name;

SELECT COUNT(*) as `count`,
      `region`, 
       YEAR(`date`) as `year`,
       MONTH(`date`)  as `month`
   FROM my_stores.stats 
        WHERE  YEAR(`date`) in (2012,2013)
 GROUP BY `region`, YEAR(`date`),MONTH(`date`)

SELECT T1.ID, IFNULL(T1.name, T2.name) AS name
FROM firsttable T1
LEFT JOIN secondtable T2
ON T1.T2_id = T2.id

SELECT
    Matches.ID,
    Matches.Score_Home,
    Matches.Score_Away,
    HomeTeam.Name Home_Team_Name,
    AwayTeam.Name Away_Team_Name
FROM
    Matches
    INNER JOIN Teams HomeTeam ON Matches.Home_Team_ID = HomeTeam.ID
    INNER JOIN Teams AwayTeam ON Matches.Away_Team_ID = AwayTeam.ID

-- CREATE SAMPLE DATA
IF OBJECT_ID(N'tempdb..#tbl_news', 'U') IS NOT NULL DROP TABLE #tbl_news;
CREATE TABLE #tbl_news (NewsID INT IDENTITY);
INSERT #tbl_news DEFAULT VALUES;
INSERT #tbl_news DEFAULT VALUES;
INSERT #tbl_news DEFAULT VALUES;
INSERT #tbl_news DEFAULT VALUES;
INSERT #tbl_news DEFAULT VALUES;

-- DEFINE YOUR SORT KEY
DECLARE @Key INT = 15;

SELECT  *
FROM    #tbl_news
ORDER BY HASHBYTES('MD5', CONVERT(VARCHAR(10), NewsID + @Key));

-- SAME ORDER AS FIRST SELECT TO SHOW SORT IS REPEATABLE
SELECT  *
FROM    #tbl_news
ORDER BY HASHBYTES('MD5', CONVERT(VARCHAR(10), NewsID + @Key));


SET @Key = 36;

-- WITH A NEW KEY SHOW DIFFERENT ORDER
SELECT  *
FROM    #tbl_news
ORDER BY HASHBYTES('MD5', CONVERT(VARCHAR(10), NewsID + @Key));

-- BUT NEW ORDER IS STILL REPEATABLE
SELECT  *
FROM    #tbl_news
ORDER BY HASHBYTES('MD5', CONVERT(VARCHAR(10), NewsID + @Key));

SELECT 
User_id, 
CASE WHEN (MIN(mode) <> MAX(mode))
THEN
    'Multiple' 
ELSE
    MIN(mode)
END
as "Start Mode"
FROM sessions
--Where condition here
GROUP BY user_id

SELECT      n.nspname as schema, t.typname as type 
FROM        pg_type t 
LEFT JOIN   pg_catalog.pg_namespace n ON n.oid = t.typnamespace 
WHERE       (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid)) 
AND     NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
AND     n.nspname NOT IN ('pg_catalog', 'information_schema')

SELECT AVG(price) AS P FROM
(
    SELECT price FROM test
    UNION ALL
    SELECT price FROM test1
) AS TMP

UPDATE Cust
SET Cust.InvAddress1 = Temp.InvAddress1,
    Cust.InvAddress2 = Temp.InvAddress2,
    ...
FROM [Test].[dbo].[Customer] Cust INNER JOIN
    [Test].[dbo].[InvAdd-Temp] Temp ON Cust.CustomerId = Temp.CustomerId

<?php

global $wpdb;
$result = $wpdb->get_results("SHOW TABLE STATUS FROM database_name LIKE 'table_name';");
foreach ($result as $data) {
    $updatetime = $data->Update_time;
}

$date = substr($updatetime, 0, -3);
echo $date;

?>

SELECT
    t.KeyId,
    t.TypeName,
    t.GroupId,
    t.SpecialType
FROM @Table t
ORDER BY 
    KeyId,
    CASE WHEN SpecialType = 'R' THEN 1 ELSE 2 END,
    COUNT(CASE WHEN t.SpecialType = 'R' THEN SpecialType END) OVER (PARTITION BY t.GroupId) DESC,
    GroupId,
    SpecialType

SELECT
    IDY, Count(DISTINCT IDX) As IDXCount
FROM
    TableName
Group BY
    IDY

select points_for
from fantasysports.leagues.standings
where league_key='331.l.777399'
and standings.teams.team.%.team_id='2'

select c.id,c.reg,c.type
from cars c
where not exists 
(
  select NULL
  from jobs j
  where j.id = c.id
  and j.date >= CURRENT_DATE - INTERVAL 3 WEEK
);

WITH cte AS (
  SELECT "ID", "Category", "Status", "Seq", "Start DT", "End DT", 
    SUM("Seq") OVER (ORDER BY "Start DT", "End DT", "Seq") "Seq2"
  FROM mytable
) 
SELECT "ID", "Category", "Status", 
  CASE WHEN "Seq"=0 
       THEN 'A' || CAST("Seq2" AS VARCHAR(32))
       ELSE CAST("Seq" AS VARCHAR(32)) 
       END "Seq",
  "Start DT", "End DT" 
FROM cte

select 
    bar = case 
               when foo = 1 then 'one'
               when foo = 2 then 'two'
               else 'baz' 
          end
from myTable 

SELECT r.hotel_id, count(distinct k.room_id) as numrooms,
       count(distinct kr.room_id) as numreserved
FROM room k left outer join
     room_reservation kr
     on kr.room_id = k.room_id 
group by r.hotel_id 

SELECT
  PARSENAME(REPLACE(COLUMN_NAME,'&','.'),1) AS 'User',
  PARSENAME(REPLACE(COLUMN_NAME,'&','.'),2) AS 'Company_ID',
  PARSENAME(REPLACE(COLUMN_NAME,'&','.'),3) AS 'Status',
  PARSENAME(REPLACE(COLUMN_NAME,'&','.'),4) AS 'Count',
FROM TABLE_NAME

SELECT 
  ROW_NUMBER() OVER (ORDER BY Data) AS 'ID',
  Data
FROM 
  dbo.YourTable

select sum1      = s.sum1      ,
       sum2      = s.sum2      ,
       delta     = sum1 - sum2 ,
       delta_pct = 100.0 * ( sum1 - sum2 ) / sum2
from ( select sum1 = sum(case when t.c1='a' and t.c2='b' and t.c3='c' then 1 else 0 end) ,
              sum2 = sum(case when t.c1='x' and t.c2='y' and t.c3='z' then 1 else 0 end)
       from table1 t
     ) s

SELECT a.id, a.item, b.price 
FROM a 
LEFT OUTER JOIN b ON a.id = b.item_id AND b.user_id = 32;

Update table set col = IF(score < 10,1, col) where userId = 5

SELECT firstname, lastname, hiredate
FROM   employees
WHERE  hiredate IS NOT NULL
AND    Case When Month(hiredate) = 2 And Day(hiredate) = 29 Then
           DateAdd(Day, DatePart(DayOfYear, hiredate) - 1, DateFromParts(Year(getdate()), 1, 1))
   Else    DateFromParts(Year(getdate()), Month(hiredate), Day(hiredate))
End BETWEEN getDate() AND DateAdd(day,7,getDate())

SELECT column FROM table
ORDER BY RAND()
LIMIT 1

SELECT Adult.Adname, Children.Chname
FROM Adult INNER JOIN Children
ON Children.Adult_Id = Adult.ID
WHERE Adult.ID IN
(SELECT Adult_id 
FROM Children
GROUP BY Adult_id
HAVING COUNT (Children.Adult_id) > 2)

SELECT * FROM posts
ORDER BY front_weight DESC LIMIT 40

select id, duplicateid, name, col1, col2, col3
  from (select id, duplicateid, name, col1, col2, col3,
               row_number() over (partition by duplicateid order by id) rn
          from your_tab)
 where rn = 1;

SELECT EmployeeID, 
    ROW_NUMBER() OVER (PARTITION BY EmployeeID ORDER BY JobStartDate) AS SeqNo,
    JobStartDate
FROM [TABLE]

select  *
from    (
        select  salary-2000 as deducted_salary
        ,       *
        from 
                EmployeeDetails 
        ) SubQueryAlias
where   Deductedsalary > 5000

SELECT 
  member_id, 
  /* Total libraries borrowed from by member */
  COUNT(DISTINCT Borrowed.lib_id) AS num_libs_borrowed,
  /* Total libs in the member's city */
  COUNT(DISTINCT Libraries.lib_id) AS total_city_libs
FROM 
  Members
  /* JOIN the city between Members & Libraries */
  JOIN Libraries ON Members.city = Libraries.lib_city
  /* JOIN member to borrowed */
  JOIN Borrowed ON Members.member_id = Borrowed.member_id
GROUP BY member_id 
/* If the number of libs borrowed from = the total libs in the city... */
HAVING num_libs_borrowed = total_city_libs

select a.au_fname,
  a.au_lname,
  b.book_title
from books b
inner join authors a
  on b.au_id = a.au_id
where a.au_lname = 'lastname'

SELECT dfname, dlname
FROM   DONOR
WHERE NOT EXISTS 
   (SELECT * FROM YEAR WHERE NOT EXISTS 
      (SELECT * FROM GIFT WHERE year = YEAR.year AND donor = DONOR.donor));

UPDATE table
   SET country_code =
          CASE
             WHEN ph_no LIKE '00%'
                THEN SUBSTR (ph_no, 3, 2)
             ELSE SUBSTR (ph_no, 1, 2)
          END
 WHERE call_dest = 'IV';

select
contact,
max(phone),
max(address),
max(email)
from table_name
group by contact

SELECT  b.QuoteItemID, 
        a.QuoteNo,
        a.CustomerName,
        b.ItemCode,
        c.BatchList
FROM    QuotationMaster a
        INNER JOIN QuoteItemDetails b
            ON a.QuoteID = b.QuoteID
        INNER JOIN
        (
          SELECT
               QuoteID, 
               ItemID,
               STUFF(
                   (SELECT ', ' + BatchNo
                    FROM   QuoteBatchDetails
                    WHERE  QuoteID = a.QuoteID AND
                           ItemID = a.ItemID
                    FOR XML PATH (''))
                    , 1, 1, '')  AS BatchList
          FROM  QuoteBatchDetails AS a
          GROUP BY QuoteID, ItemID
        ) c ON  b.QuoteID = c.QuoteID  AND
                b.ItemID = c.ItemID;

select job             "Some job",
       Count(a.bossID) "Number Of bosses"
from   boss a
       join place_boss ba
         on ba.bossid = a.bossid
       join places b
         on ba.placeid = b.placeid
group  by job
having Count(a.bossID) > 1;  

SELECT EMP 
FROM Z_INSUR 
WHERE INSUR_TYPE = 'M'
GROUP BY EMP 
HAVING count(*) > 1;

select distinct on (from,to) * from airports order by from,to,price asc;

declare @result1 int
execute basic_und6 Amit,'amit@abc.com', @result1 OUTPUT
print @result1

CREATE TABLE users {
 user_id  int UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
 user_type  int NOT NULL REFERENCES user_types(user_type_id),
 ssn      char(10) NOT NULL,
 password  varchar(40) NOT NULL,
 first_name  varchar(30) NOT NULL,
 last_name varchar(30) NOT NULL,
 address     varchar(80) NOT NULL,
 admin_id int REFERENCES users(user_id)
} engine = InnoDB;

select your_original_columns, 
sum(SumOfProfit) OVER(PARTITION BY Customer) AS 'Total'
...

SELECT advisor AS advisor,
count(*) AS approved
FROM shift_report 
WHERE `team`!=6 AND date>20150720 AND date<20150728 and `outcome` LIKE '%TPS_Approved%'
GROUP BY `advisor` 
ORDER BY `advisor`

select func2(a,b,c,d)
from x
join y using (id)
join z using (id2)
where....

Insert INTO TableA (col1, col2,col3,col4)
  SELECT b.col1, c.col2, d.col3, @myparam
  FROM TableB as b
  INNER JOIN TableC as c
    ON b.id = c.id
  INNER JOIN TableD as d
    on c.id = d.id

select case 
       when initial_extent is null then null
       when substr(initial_extent,-2,1) = '1' 
            then initial_extent || 'th'
       else case substr(initial_extent,-1,1)
            when '1' then initial_extent || 'st'
            when '2' then initial_extent || 'nd'
            when '3' then initial_extent || 'rd'
            else initial_extent || 'th'
            end
       end as formatted_number
from user_tables

select sum((case when m.month = 1 then Jan else 0 end) +
           (case when m.month = 2 then Feb else 0 end) +
           . . .
           (case when m.month = 12 then Dec else 0 end)
          )
from atable a cross join
     @Months m;

SELECT ROWID
  FROM InterestingTable
 WHERE SomeColumn = xxx
   AND AnotherColumn < yyy;

SELECT  r.courseid, r.username, r.`day`,r.score
FROM    result r
JOIN (SELECT username, MIN(score) score 
      FROM result 
      where courseid = '2'
      GROUP BY username) r1
ON(r.username = r1.username and r.score = r1.score)
order by r.score
limit 10

select id, name, salary, department
from (select t.*,
             row_number() over (partition by department order by department) as seqnum
      from t
     ) t
where seqnum = 1

SELECT DATE_FORMAT(curdate(), '%M') month_name
union
SELECT DATE_FORMAT(date_add(curdate(),interval -1 month), '%M') month_name
union
SELECT DATE_FORMAT(date_add(curdate(),interval -2 month), '%M') month_name

select distinct(ipod.user_id )
from sales ipod
    inner join sales shoes on shoes.user_id = ipod.user_id 
    inner join sales bike on bike.user_id = ipod.user_id 
where ipod.item  = 'ipod' 
    and shoes.item = 'shoes'
    and bike.item = 'bicycle'

SELECT *
  FROM (SELECT person,
               type,
               color,
               RANK() OVER( PARTITION BY person
                                ORDER BY type asc ) rnk
          FROM <<person_table>>)
 WHERE rnk = 1

declare @Year int = 2003
declare @Day int = 100
declare @Hour int = 13

select dateadd(hour, @Hour, dateadd(dayofyear, @Day - 1, dateadd(year, @Year - 1900, 0)))

SELECT u.id, u.first_name, u.last_name
FROM users u JOIN answers a
  ON a.user_id = u.id
JOIN questions q
  ON a.question_id = q.id
JOIN question_options o
  ON a.option_id = o.id
WHERE (q.question = 'Language known' AND o.OPTION IN ('French','Russian'))
   OR (q.question = 'height' AND o.OPTION = '1.51 - 1.7')
GROUP BY u.id, u.first_name, u.last_name
HAVING
  SUM(CASE WHEN (q.question = 'Language known' AND o.OPTION IN ('French','Russian')) THEN 1 ELSE 0 END) >=1
AND 
  SUM(CASE WHEN (q.question = 'height'         AND o.OPTION = '1.51 - 1.7')          THEN 1 ELSE 0 END) >= 1
;

SELECT DISTINCT c.* 
  FROM categories AS c 
    INNER JOIN cat_pages AS cp ON c.id = cp.cat_id

 IF NOT EXISTS( SELECT 1 FROM tbl_ref_staff WHERE name = @name AND sex = @sex AND hq_code = @hq_code;)
 BEGIN
 INSERT INTO tbl_ref_staff VALUES (@name, @sex, @hq_code)
 END

With Categories_CTE As
(
    Select Id, Name, ParentId
    From category.Categories
    Where Id = **SOME CATEGORY ID**

    Union All
    Select t.Id, t.Name, t.ParentId
    From category.Categories t
    Inner Join Categories_CTE c On c.Id = t.ParentId
)

Select p.*
From Categories_CTE c INNER JOIN product.Products p on p.CategoryId = c.Id;

select T.id,
       max(T.timestamp) as timestamp
from (
     select R.X.value('(id/text())[1]', 'int') as id,
            R.X.value('(timestamp/text())[1]', 'datetime') as timestamp
     from dbo.YourTable as T
       cross apply T.X.nodes('/root/row') as R(X)
    ) as T
group by T.id;

select to_char(sysdate, 'DD-MON-YY')

With UserActivityData as  (
SELECT *,
    ROW_NUMBER() OVER(ORDER BY ActivityDate DESC) as RowNum,
    ROW_NUMBER() OVER(ORDER BY ActivityDate ASC) as InverseRowNum 
    FROM Activities
    WHERE UserID = @uid
    ) 

SELECT * from UserActivityData where RowNum between @StartIndex and @StartIndex + 4    

from items
left join sales on ITEMS.ITEM_CD =sales.ITEM_CD
left join purchase on items.ITEM_CD =purchase.ITEM_CD

select dbo.Master_Table.Master_ID,
       dbo.Master_Table.Name,
       Activites_Table.Activity_Name ,
       t.Total_Balance
From   dbo.Master_Table INNER JOIN dbo.Activites_Table
       ON 
       dbo.Master_Table.Master_ID = dbo.Activites_Table.Master_ID

       inner join (select Master_ID, 
                          fn_calc_balance_for_user(t.Master_ID) as Total_Balance
                     from (select distinct Master_ID
                             from Master_Table)t)t
       on t.Master_ID = dbo.Activites_Table.Master_ID;

Select * from 
(
Select DepartmentCode,ScheduledStartDate,[Tmain.TotalSlots]
,(Select SUM(T1.TotalSlots) from tempSlotsAssignedForDept  T1 where t1.departmentCode=a.DepartmentCode
and T1.ScheduledStartDate = dateadd(day, -1, a.ScheduledStartDate )) T1SubTotalSlots 
,(Select SUM(T1.TotalSlots) from tempSlotsAssignedForDept  T1 where t1.departmentCode=a.DepartmentCode
and T1.ScheduledStartDate = dateadd(day, -2, a.ScheduledStartDate )) T2SubTotalSlots 
from 
(
SELECT  Tmain.DepartmentCode, 
CONVERT(VARCHAR(20), Tmain.ScheduledStartDate, 101) ScheduledStartDate,
SUM(Tmain.TotalSlots) 'Tmain.TotalSlots'
--,(Select SUM(T1.TotalSlots) from tempSlotsAssignedForDept t1 where t1.DepartmentCode=tmain.departmentcode 
--and T1.ScheduledStartDate = dateadd(day, -1, tmain.ScheduledStartDate ))
FROM    tempSlotsAssignedForDept Tmain
GROUP BY    Tmain.DepartmentCode,Tmain.ScheduledStartDate
) a) b where [Tmain.TotalSlots] is not null and T1SubTotalSlots is not null and T2SubTotalSlots is not null

SELECT name, SUM(CommentCount) AS TotalCommentCount
FROM (
  SELECT U.name, COUNT(C.cid) AS CommentCount
  FROM dr_users AS U
  INNER JOIN dr_comments AS C ON U.uid = C.uid
  GROUP BY U.name

  UNION ALL

  SELECT U2.username AS name, COUNT(C2.post_id) AS CommentCount
  FROM phpbb_users AS U2
  INNER JOIN phpbb_posts AS C2 ON U2.user_id = C2.poster_id
  GROUP BY U2.username

) temp GROUP BY name

    select 
    Count(*) as ResponseCount,
    PropertyValue As Answer ,
 convert ( dec(28,2) ,Count(*))*100/(sum(count(*)) over ()) as ResponsePercentage
from 
    table 
where 
    Questionid = 42 and formid = 1 
group by 
    propertyvalue

select holeid, "from", "to", fmn
from (
    select
        holeid,
        first_value("from") over(partition by p order by "from") as "from",
        first_value("to") over(partition by p order by "to" desc) as "to",
        fmn
    from (
        select
            holeid, "from", "to", fmn,
            count(p or null) over(partition by holeid order by "from") p
        from (
            select
                holeid, "from", "to", fmn,
                lag(fmn, 1, '') over(partition by holeid order by "from") != fmn p
            from table1
        ) s
    ) s
) s
group by 1, 2, 3, 4
order by 1, 2

type NUMBER is NUMBER_BASE;
 subtype FLOAT is NUMBER; -- NUMBER(126)
 subtype REAL is FLOAT; -- FLOAT(63)
 subtype "DOUBLE PRECISION" is FLOAT;
 subtype INTEGER is NUMBER(38,0);

SELECT c.*, cc.*, ce.* 
FROM courses c INNER JOIN
     course_enrollment ce
     ON c.course_id = ce.course_id LEFT JOIN 
     completed_courses cc
     ON ce.course_id = cc.course_id AND
        ce.user_id = cc.user_id
WHERE ce.user_id = '91' AND
      cc.course_id IS NULL ;

SELECT
    A.TaskID,
    min(B.GroupName) as GroupName
FROM [TableA] A
    JOIN [TableB] B
    ON B.GroupID = A.ReferenceID
GROUP BY A.TaskID

SELECT IIf([colA] = [colB], [colA], [colA] & '(' & colB & ')') AS formattedCol 
FROM mytable WHERE

SELECT
  CASE 
     WHEN t1.RANGE_START = t1.RANGE_END 
        THEN t1.RANGE_START
       ELSE t1.RANGE_END
     END AS Value,
  column1,
  column2,
  column3
FROM dbo.t1

select 
sum(Case when a.p_type = 'sell' then a.unit else null end) as sellUnit, 
sum(Case when a.p_type = 'CancelSell' then a.unit else null end) as CancelSellUnit,
sum(Case when a.p_type = 'Bank' then a.unit else null end) as BankUnit ,
sum(Case when a.p_type = 'CancelBank' then a.unit else null end) as CancelBankUnit  
from table1 a where and a.id=1 and a.fid=2 

    SELECT ReportDate, SUM(Received) as ReceivedSum,
           SUM(Answered) as AnsweredSum ,AVG(WaitTime) as WaitTimeAVG
    FROM a
    GROUP BY ReportDate
    ORDER BY ReportDate

declare @val decimal(8, 2)
set     @val = 15.80
select  @val, @val % 1

SELECT FieldB, FieldC
FROM   TableA
WHERE  LEFT(FieldA,3) = @paramA 
       AND RIGHT(FieldA,3) = @paramB;

getContentResolver().query(uri, projection, "MAX(COLUMN_NAME)", null, sortOrder);

CREATE TABLE #DaTable(MyString VARCHAR(255)) 
INSERT INTO #DaTable(MyString) VALUES ('99 0882300 25 YATES ANTHONY V MAY 01 12 04 123456 12345678')

INSERT INTO FInalTable(Col1, Col2, Col3, Name)
SELECT CAST(SUBSTRINg(MyString, 1, 3) AS INT) as Col1,
    CAST(SUBSTRING(MyString, 4, 7) AS INT) as Col2,
    CAST(SUBSTRING(MyString, 12, 3) AS INT) as Col3,
    SUBSTRING(MyString, 15, 6) as Name
FROM #DaTable

result: 99  882300  25  YATES 

SELECT p.id, p.prev_id1, p.prev_id2
FROM (
        SELECT id, LAG(id, 1) OVER(ORDER BY id) prev_id1, LAG(id, 2) OVER(ORDER BY id) prev_id2
        FROM places
     ) p
WHERE p.prev_id1 = id-1 
AND   p.prev_id2 = id-2

data max_date/view=max_date;
   set table: indsname=source;
   dset=source;
   keep date dset;
run;

proc sql;
  create table maximum_date as
  select max(date) as Latest_Date 
  from max_date
  group by dset;
 quit;

$query = $em->createQueryBuilder()
    ->select(array('f.id', 'f.frage', 'f.sortierung', 'a.antwort', 'g.name'))
    ->from('MySuperBundle:BogenFragen', 'f')
    ->leftJoin('f.bogenantworten', 'a', 'WITH', 'a.personen = :pid')
    ->from('MySuperBundle:BogenTyp', 't')
    ->from('MySuperBundle:BogenFragenGruppe', 'g')
    ->where('t.id = :tid')
    ->andWhere('t.id = f.bogentypen')
    ->andWhere('g.id = f.bogenfragengruppe')
    ->orderBy('f.sortierung', 'ASC')
    ->setParameter('tid', 1)
    ->setParameter('pid', 3)
    ->getQuery();

scope :sum_column_name, lambda{
    sum("column name")}

CREATE TABLE boys_info AS
SELECT status, point, profession
FROM boys

With CTE1 as
(
-- Total number of persons on a trip:
select count(T.personId) as CountA , tripId
from TripPerson T
group by T.tripId
),
CTE2 as 
(
    -- Total number of people who are on a trip that have also been on 
    -- at least one other trip with type of '2'.
    select Count (T2.personId)as CountB , CTE1.tripId ,CTE1.CountA
    from TripPerson T2
    inner join  TripPerson T3 on T2.personId = T3.personId and T3.tripId =2
    right join CTE1 on CTE1.tripId = T2.tripId
    group by CTE1.tripId,CTE1.CountA
) 
select CTE2.tripId, CTE2.CountA, CTE2.CountB, Trip.tripType, Trip.tripName
from CTE2
inner join Trip on Trip.tripId = CTE2.tripId
inner join Portfolio P on P.portfolioId = Trip.portfolioId

select sum(value1-value2) as Result 
from tbl

CREATE
OR REPLACE PROCEDURE testproc(inputVar IN number)

AS

BEGIN

EXECUTE IMMEDIATE 'DELETE FROM TABLE_X WHERE ID = (SELECT ID FROM TABLE_Z WHERE OBJ_ID=:num)' USING IN inputVar;

EXECUTE IMMEDIATE 'DELETE FROM TABLE_Y WHERE ID = (SELECT ID FROM TABLE_Z WHERE OBJ_ID=:num)' USING IN inputVar;

EXECUTE IMMEDIATE 'DELETE FROM TABLE_USER WHERE ID = (SELECT ID FROM TABLE_Z WHERE OBJ_ID=:num) AND USER_ID NOT IN (SELECT USER_ID FROM MAIN_TABLE)' USING IN inputVar;

COMMIT;

EXCEPTION

WHEN
OTHERS

THEN

dbms_output.put_line
(SQLERRM);

END;

select (case when DATEADD(year, datediff(year, hiredate, getdate()), hiredate) < GETDATE()
             then DATEDIFF(dd, DATEADD(year, datediff(year, hiredate, getdate()), hiredate), getdate())
             else DATEDIFF(dd, DATEADD(year, datediff(year, hiredate, getdate()) - 1, hiredate), getdate())
        end)
from preh;

SELECT
    a.id,
    a.resolution,
    b.*
FROM 
    Table1 a
CROSS JOIN
    (
        SELECT
            CONCAT(SUM(aa.resolution = 'pass'), '/', COUNT(*)) AS attempts,
            CONCAT((SUM(aa.resolution = 'pass') / COUNT(*)) * 100, '%') AS percent_attempts,
            CONCAT(SUM(bb.mindate IS NOT NULL AND resolution = 'pass'), '/', SUM(resolution = 'pass')) AS first_attempt 
        FROM
            Table1 aa
        LEFT JOIN 
            (
                SELECT 
                    MIN(`date`) AS mindate 
                FROM 
                    Table1
            ) bb ON aa.`date` = bb.mindate
    ) b

SELECT * INTO #TempTable FROM myView 

 FROM tartikel p1 
 JOIN tartikelpict p2 
   ON p1.kArtikel = p2.kArtikel 
  AND p2.nNr = 1
WHERE p1.dErstellt >= DATE(NOW()) - INTERVAL 7 DAY
ORDER BY p1.kArtikel DESC

SELECT
  par.wo,
  l.addr,
  eml.maildate,
  lp.workdate
FROM
  parsed AS par
  INNER JOIN emails AS eml      ON eml.id = par.origid
  INNER JOIN list AS l          ON par.wo = l.wo
  INNER JOIN locateparsed AS lp ON par.wo = lp.wo
  LEFT  JOIN completed          ON par.wo = completed.wo
WHERE
  par.status != 0 
  AND completed.wo IS NULL

  SELECT * FROM tablename where Rank > 5  and Statid in (0,1);

SELECT * FROM Table WITH (NOLOCK);

a = A.arel_table  
b = B.arel_table

subquery = b.project(b[:a_id].as('A_id')).where{c > 4}  
subquery = subquery.as('intm_table')  
query = A.join(subquery).on(subquery[:A_id].eq(a[:id]))

UPDATE Table1
    SET T2OpenDate = (SELECT MAX(Table2.T2OpenDate)
                      FROM Table2 
                      WHERE Table2.T2OpenDate < Table1.T1OpenDate)                       
FROM Table1

SELECT email, GROUP_CONCAT(skill ORDER BY skill) skill
FROM
(
    SELECT email, skill FROM acting
    UNION
    SELECT email, skill FROM writing
    UNION
    SELECT email, skill FROM film
    UNION
    SELECT email, skill FROM tech
) x
GROUP BY email

select t1.ks, t1.[# Tasks], coalesce(t2.[# Late], 0) as [# Late]
from 
    (SELECT ks, COUNT(*) AS '# Tasks' FROM Table GROUP BY ks) t1
left join
    (SELECT ks, COUNT(*) AS '# Late' FROM Table WHERE Age > Palt GROUP BY ks) t2
on
    t1.ks = t2.ks

IF NOT EXISTS (SELECT 1 FROM City WHERE City = 'Paris')
Insert INTO City (City) VALUES ('Paris')

DECLARE @Cid int = (SELECT CityID FROM City WHERE City = 'Paris')

INSERT INTO people (lname, fname, city, age, salary) 
VALUES (' Doe','John', @cid, '25','1000$' )

INSERT INTO Songs (songname,genre) 
SELECT 'blablabla', S.VALUE
FROM SECONDTABLE S
WHERE genrename = 3

declare @part varchar(20)

while exists ((select top 1 * from part1 p where isnull(brojRacuna,'')='' and partija='1111'))
begin
begin tran
update part1
set  BrojRacuna= (select dbo.dev_brojracuna ('1111'))
where partija like '1111'
commit
end

------------------------------------------------------------
--Create temp table for testing
IF OBJECT_ID('Tempdb..#Z') IS NOT NULL 
    DROP TABLE #Z
CREATE TABLE #Z
    (
      ID INT ,
      SomeText VARCHAR(3)
    )
INSERT  INTO #Z
        ( ID, SomeText )
VALUES  ( 1, 'AAA' ),
        ( 2, 'BBB' ),
        ( 3, 'CCC' ),
        ( 1, 'ZZZ' ),
        ( 1, 'XXX' ),
        ( 2, 'YYY' )
------------------------------------------------------------
--1. Concatenate
SELECT  SUBSTRING(( SELECT  ',' + SomeText
                    FROM    #Z
                  FOR
                    XML PATH('')
                  ), 2, 1000) AS Concatenated
------------------------------------------------------------
--2. Concatenate for each ID
SELECT DISTINCT
        Z_out.id ,
        SUBSTRING(( SELECT  ',' + SomeText
                    FROM    #Z AS Z_in
                    WHERE   Z_in.ID = Z_out.id
                  FOR
                    XML PATH('')
                  ), 2, 1000) AS Concatenated
FROM    #Z AS Z_out

select t1.*,
       (select top 1 value
        from @table2 t2
        where t2.idColumn = t1.idColumn and
              t2.dateColumn <= t1.dateColumn
        order by t2.dateColumn desc
       ) t2value
from @table1 t1;

class Reservation(models.Model):

    # ...

    def relative_id(self):
        return self.id - Reservation.objects.filter(id__lt=self.id).filter(~Q(event=self.event)).all().count()

select Number = floor ( 455.443 )
select Number = cast ( 455.443 as int )
select Number = convert ( int, 455.443 )
select Number = 455.443 - ( 455.443 % 1 )

from u in db.Users join uc in userCourse on u.userId equals uc.Id
                   join c in course on uc.courseId equals c.courseId   
                   where u.userId = uc.userId
                   select c.name

select mm.id, mm.username
    from members mm
    inner join member_friends f on f.id_memb_friend1 = mm.id
    inner join members m on m.id = f.id_memb_friend2 
    where m.username = 'Splendid'
union distinct
select mm.id, mm.username
    from members mm
    inner join member_friends f on f.id_memb_friend2 = mm.id
    inner join members m on m.id = f.id_memb_friend1
    where m.username = 'Splendid'

UPDATE Users
SET Users.Active = CASE WHEN T.UserName is null THEN 0 ELSE 1 END 
FROM Users AS U
LEFT JOIN #TempTable AS T ON U.UserName = T.UserName

INSERT INTO profile_group(profile_id, group_id) 
     SELECT id, 1 FROM profile p 
     LEFT JOIN profile_group pg on (p.id=pg.profile_id) 
     WHERE pg.group_id IS NULL;

CREATE VIEW [dbo].[myview] AS
SELECT   
       dbo.table1.field1
      ,dbo.table2.field2  
      ,
      ...
FROM
      table1
      INNER JOIN table2 ON (...)
      outer apply (
          select dbo.HeavyStoredProcedure(dbo.table1.field1) AS calculated_value 
      ) as CALC
WHERE  
      ...
      AND NOT( EXISTS (SELECT * from table3 
               WHERE (table3.somefield = CALC.calculated_value))
               OR
               EXISTS (SELECT * from table4
               WHERE (table4.anotherfield = CALC.calculated_value))
             )

select 
      t1.SubscriptionID,
      (select GenerationTimes + ', '
       from tableName t2
       where t1.SubscriptionID = t2.SubscriptionID
       for xml path('')) as GenerationTimes
from tableName t1
group by t1.SubscriptionID

=VLOOKUP(A2,Sheet2!A:B,2,0)

INSERT INTO [MyTable]([MyCol])
OUTPUT INSERTED.ID
SELECT [MyCol] FROM [MySourceTable];

DROP TABLE IF EXISTS my_table;

CREATE TABLE my_table
(id INT NOT NULL AUTO_INCREMENT PRIMARY KEY
,name    VARCHAR(12) NOT NULL
,category INT NOT NULL
);

INSERT INTO my_table (name,category) VALUES
('aaa',1),
('bbb',2),
('ccc',1),
('aaa',1),
('aaa',2);

SELECT * FROM my_table;
+----+------+----------+
| id | name | category |
+----+------+----------+
|  1 | aaa  |        1 |
|  2 | bbb  |        2 |
|  3 | ccc  |        1 |
|  4 | aaa  |        1 |
|  5 | aaa  |        2 |
+----+------+----------+


SELECT name
     , COUNT(*) total
     , SUM(category = 1) cat1
     , SUM(category = 2) cat2 
  FROM my_table 
 GROUP 
    BY name;
+------+-------+------+------+
| name | total | cat1 | cat2 |
+------+-------+------+------+
| aaa  |     3 |    2 |    1 |
| bbb  |     1 |    0 |    1 |
| ccc  |     1 |    1 |    0 |
+------+-------+------+------+

/*This script will find any text value in the database*/
/*Output will be directed to the Messages window. Don't forget to look there!!!*/

SET NOCOUNT ON
DECLARE @valuetosearchfor varchar(128), @objectOwner varchar(64)
SET @valuetosearchfor = '%putYourGuidHere%' --should be formatted as a like search 
SET @objectOwner = 'dbo'

DECLARE @potentialcolumns TABLE (id int IDENTITY, sql varchar(4000))

INSERT INTO @potentialcolumns (sql)
SELECT 
    ('if exists (select 1 from [' +
    [tabs].[table_schema] + '].[' +
    [tabs].[table_name] + 
    '] (NOLOCK) where [' + 
    [cols].[column_name] + 
    '] like ''' + @valuetosearchfor + ''' ) print ''SELECT * FROM [' +
    [tabs].[table_schema] + '].[' +
    [tabs].[table_name] + 
    '] (NOLOCK) WHERE [' + 
    [cols].[column_name] + 
    '] LIKE ''''' + @valuetosearchfor + '''''' +
    '''') as 'sql'
FROM information_schema.columns cols
    INNER JOIN information_schema.tables tabs
        ON cols.TABLE_CATALOG = tabs.TABLE_CATALOG
            AND cols.TABLE_SCHEMA = tabs.TABLE_SCHEMA
            AND cols.TABLE_NAME = tabs.TABLE_NAME
WHERE cols.data_type IN ('char', 'varchar', 'nvchar', 'nvarchar','text','ntext')
    AND tabs.table_schema = @objectOwner
    AND tabs.TABLE_TYPE = 'BASE TABLE'
    AND (cols.CHARACTER_MAXIMUM_LENGTH >= (LEN(@valueToSearchFor) - 2) OR cols.CHARACTER_MAXIMUM_LENGTH = -1)
ORDER BY tabs.table_catalog, tabs.table_name, cols.ordinal_position

DECLARE @count int
SET @count = (SELECT MAX(id) FROM @potentialcolumns)
PRINT 'Found ' + CAST(@count as varchar) + ' potential columns.'
PRINT 'Beginning scan...'
PRINT ''
PRINT 'These columns contain the values being searched for...'
PRINT ''
DECLARE @iterator int, @sql varchar(4000)
SET @iterator = 1
WHILE @iterator <= (SELECT Max(id) FROM @potentialcolumns)
BEGIN
    SET @sql = (SELECT [sql] FROM @potentialcolumns where [id] = @iterator)
    IF (@sql IS NOT NULL) and (RTRIM(LTRIM(@sql)) <> '')
    BEGIN
        --SELECT @sql --use when checking sql output
        EXEC (@sql)
    END
    SET @iterator = @iterator + 1
END

PRINT ''
PRINT 'Scan completed'

var result = (from t0 in context.EC_ORDER
               join t1 in context.HIERARCHY on t0.CONSGIPOS == t1.STOREID into t1tmp
                from t1t in t1tmp.DefaultIfEmpty()
               join t2 in context.HIERARCHY on t0.ORDPOS == t2.STOREID into t2tmp
                from t2t in t2tmp.DefaultIfEmpty()
              select {
                         t0.SHOPID, 
                         t0.CONSGIPOS,
                         CStorename = t1t != null ? t1t.StoreName : null,
                         t0.ORDPOS,
                         OStoreName = t2t != null ? t2t.StoreName : null
                      }).ToList();

ALTER TABLE YourTable ADD FirstHalf CHAR (3)
ALTER TABLE YourTable ADD SecondHalf CHAR (3)

UPDATE YourTable
SET
    FirstHalf = LEFT(OriginalColumn, 3),
    SecondHalf = RIGHT(OriginalColumn, 3)

ALTER TABLE YourTable DROP COLUMN OriginalColumn

SELECT name, COUNT(vote) AS total_votes
FROM Voters
GROUP BY name
ORDER BY total_votes DESC
LIMIT 1

WITH CTE1 AS (SELECT ISNULL(p.PaymentAmt, 0) AS PaymentAmt, o.TaxAmt, o.PostAmount,  
   o.OrderDate, o.PublicNotes, u.userid, PostAmount + TaxAmt AS Total, PostAmount -    
    PaymentAmt AS Due 
    FROM Orders o  
    INNER JOIN Payment p ON p.OrderID = o.OrderID 
    INNER JOIN Users u  ON o.EnteredBy = u.UserKey 
    Where o.OrderID = 5267 
    AND o.EnteredBy = u.UserKey )
SELECT CTE1.*
FROM CTE1
UNION ALL
SELECT 0,0, NULL,NULL,NULL,NULL,NULL
WHERE NOT EXISTS (SELECT 1 FROM CTE1)

create or replace PROCEDURE TEST
(
in_ANI in VARCHAR2,
out_all out VARCHAR2
)


AS
    fName VARCHAR2 (40) := '';
    aemail VARCHAR2 (40) := '';


BEGIN

out_all := '';

  SELECT FIRMS.NAME, ADDRESSES.EMAIL
  into fName, aemail
  FROM ADDRESSES
  INNER JOIN FIRMS
  ON FIRMS.RESIDENCEADDRESS_ID = ADDRESSES.ID
  WHERE (replace(REPLACE(ADDRESSES.PHONENUMBER1, ' ', ''), '-', '') LIKE '%'||in_ANI||'%')
  OR (replace(REPLACE(ADDRESSES.PHONENUMBER2, ' ', ''), '-', '') LIKE '%'||in_ANI||'%');


out_ALL := 'Firm:' || fName || '|Email:' || aemail;

    exception
      when TOO_MANY_ROWS then 
        out_ALL := ('Firm:Too Many firms for this phone');

      when NO_DATA_FOUND then 
        out_ALL := ('Firm:No firms for this number');

      when others then 
        raise_application_error(-20011,'Unknown Exception');


END TEST;

IF EXISTS (SELECT * FROM [dbo].[sysobjects]
           WHERE ID = object_id(N'[dbo].[YourProcName]') AND 
                 OBJECTPROPERTY(id, N'IsProcedure') = 1)
    DROP PROCEDURE [dbo].[YourProcName]
GO

add_shortcode('SHORTTAG', 'FUNCTION NAME');

WITH CTE AS
(   SELECT  HostName,
            IP,
            ActionDate,
            Action,
            ROW_NUMBER() OVER(PARTITION BY HostName ORDER BY ActionDate DESC) AS RowNumber
    FROM    Table
)
SELECT  HostName,
        IP,
        ActionDate,
        Action
FROM    CTE
WHERE   RowNumber = 1

select
    UPPER(SUBSTRING(name, 1, 1)) + SUBSTRING(name, 2, LEN(name)),
    UPPER(SUBSTRING(surname, 1, 1)) + SUBSTRING(surname, 2, LEN(surname))
from client;

 Select SecID, ServiceID, UserID from 
 (
    select ROW_NUMBER() OVER (PARTITION BY ServiceID ORDER BY Secid) AS row_number,
    SecID,
    ServiceID,
    UserID
    From tblSecServiceUsers
 ) 
 tempTable
 where row_number = 1

delete table where ...

delete from table where ...

delete table from <query...>

delete from table from <query...>

;WITH CTE AS(
    SELECT *,
        Y = SUM(CASE WHEN Actioned = 'YES' THEN 1 ELSE 0 END) OVER(PARTITION BY TeamName, ProjectCode),
        N = SUM(CASE WHEN Actioned = 'NO' THEN 1 ELSE 0 END) OVER(PARTITION BY TeamName, ProjectCode)
    FROM tbl
)
SELECT 
    TeamName, ProjectCode, Actioned
FROM CTE
WHERE
    (Y = 1 AND Actioned = 'Yes')
    OR (Y = 0)

SELECT 'CREATE PUBLIC DATABASE LINK "'||DB_LINK||'" CONNECT TO '||USERNAME||' IDENTIFIED BY "<PWD>" USING '''||HOST||''';' AS cmd
FROM DBA_DB_LINKS
WHERE owner = 'PUBLIC'
    AND DB_LINK = 'LINKNAME';

SELECT b.*
FROM books b
INNER JOIN
  (SELECT book_id, COUNT(*) as cnt 
  FROM user_has_book 
  WHERE user_id IN ('Frank', 'Joe')    
  GROUP BY book_id
  HAVING cnt=2)x ON (x.book_id = b.book_id)

WITH cte_service_fakturering AS 
(
   SELECT *, ROW_NUMBER() OVER (PARTITION BY service_id ORDER BY id DESC) RN
   FROM service_fakturering 
)
SELECT foretag.namn, foretag.epost, foretag.forlangEj, cte.* 
FROM foretag 
INNER JOIN service ON foretag.id = service.foretagsid 
INNER JOIN cte_service_fakturering cte ON service.id = cte.service_id  AND cte.RN = 1
    WHERE service_fakturering.giltighets_datum <= DATEADD(D, 30, GETDATE())
    ORDER BY bestallnings_datum DESC, id DESC

select count(*) DAYs FROM
    (
     select trunc(ADD_MONTHS(sysdate,-1),'MM') +  level -1 Dates from dual connect by
      level <= ADD_MONTHS(trunc(sysdate,'MM'),1)-1 -  trunc(sysdate,'MM')+1
   ) Where To_char(dates,'DY') NOT IN ('SA','SO')

(DT_DECIMAL, scale)[Sign] + [Price]

declare @amounts table (TotalAmount decimal(8,2),[UF%] decimal(4,2), [UFI%] decimal(4,2)
                                                ,[RA%] decimal(4,2),[RL%] decimal(4,2)
                                                ,[NP%] decimal(4,2));
insert into @amounts values
 (100,0.00,20,9.15,0.75,70.01)  
,(1520.23,64.4,19.1,15.5,0.25,0.75)   
,(158520.03,13.25,35,2.25,19.28,30.22);

select up.TotalAmount
      ,up.Percentag
      ,(up.TotalAmount/100)*up.Percentag AS AmountPercentage
      ,up.Amount AS AmountType
from
(
    select *
    from @amounts  
) AS tbl
unpivot
(
    Percentag FOR Amount IN([UF%],[UFI%],[RA%],[RL%],[NP%])
) AS up

select * from products
where min < $max and max > $min

drop table if exists so.tbl_so_q23644829;
create table so.tbl_so_q23644829( csv_column varchar(1024) );
insert into so.tbl_so_q23644829 values( '52890,56518,53034,53968,34830,...' );

select * from so.tbl_so_q23644829 
 where find_in_set( '52890', csv_column ) > 0
   and csv_column is not null;
+-----------------------------------+
| csv_column                        |
+-----------------------------------+
| 52890,56518,53034,53968,34830,... |
+-----------------------------------+

SELECT t1.*, t2.column1
FROM t1
LEFT OUTER JOIN t2 ...

SELECT QTR, ROUND(AVG(PCT_PERF), 2) AS QTR_PCT FROM ... GROUP BY QTR

SELECT T.TrxNo, 
      MAX(CASE WHEN D.DocNo = 1 THEN D.DocNo ELSE 0 END) AS Doc1,
      MAX(CASE WHEN D.DocNo = 2 THEN D.DocNo ELSE 0 END) AS Doc2,
      MAX(CASE WHEN D.DocNo = 3 THEN D.DocNo ELSE 0 END) AS Doc3
FROM [dbo].[Transaction] T LEFT OUTER JOIN
     [dbo].[Document] D
     ON D.TrxNo = T.TrxNo
GROUP BY T.TrxNo;

select
   Cust.value('*[1]', 'int') AS 'ItemID',
   Cust.value('*[2]', 'Varchar(50)') AS 'Customer Name'
from @xmlval.nodes('/ArrayOfCustomers/Customer') as AOC(Cust) 

INSERT INTO Tbl_PPACA_Report(ssn,lastname,firstname,level1_code,level1,level2_Code,level2,level3_Code,level3,level4_Code,level4,level5_Code,level5,DOH,UNIONCode,PPE,Hours,Grosswages,EmployerId,PayrollActivityDate) 
        SELECT Pr.ssn,Pr.lastname,Pr.firstname,level1code,level1description,level2Code,level2description,level3Code,level3description,level4Code,
        level4description,level5Code,level5description,DateOfHire,ISNULL(Pr.UNIONCode,'') UNIONCode,Pr.PPE,
        sum(Pr.Hours),sum(Pr.Grosswages),Pr.EmployerId,Pr.PayrollActivityDate
        from Tbl_PPACA_Import PR 
        LEFT OUTER JOIN Tbl_PPACA_Report P ON P.SSN=PR.SSN and P.EmployerID=PR.EmployerId and 
        ISNULL(P.Level1_code,'')=ISNULL(PR.LEVEL1CODE,'') and ISNULL(P.Level2_code,'')=ISNULL(PR.LEVEL2CODE,'') 
        and ISNULL(p.Level3_code,'')=ISNULL(Pr.LEVEL3CODE,'') and ISNULL(p.Level4_code,'')=ISNULL(Pr.LEVEL4CODE,'') 
        and ISNULL(p.Level5_code,'')=ISNULL(Pr.LEVEL5CODE,'') and P.DOH=PR.DATEOFHIRE and P.PPE=PR.PPE
        and P.[HOURS]=PR.[HOURS] and P.[GrossWages]=PR.[GrossWages]
        where (p.DOH is null OR P.PPE is null  OR P.[HOURS] is null OR P.[GrossWages] is null or pr.PPE is not null ) and pr.EmployerId=@Employer_Id and PR.SSN is not null and PR.PPE is not null and PR.DATEOFHIRE is not null and ISNUMERIC(PR.SSN)=1 
        group by Pr.ssn,Pr.lastname,Pr.firstname,level1code,level1description,level2Code,level2description,level3Code,level3description,level4Code,level4description,level5Code,level5description,DateOfHire,Pr.UNIONCode,Pr.PPE,
        Pr.EmployerId,Pr.PayrollActivityDate  ;

select
    u.id_user,
    u.name,
    (select p.filename from user_picture as p where p.id_user=u.id_user and ord=1) as userpicture,
    (select max(s.id_sticker) from user_sticker as s where s.id_user_to=u.id_user) as userstickerid
from user as u
where u.id_user = $$$$

SELECT a.server, a.directory, a.`usage`, a.datetime
    FROM usagestats as a INNER JOIN (
        SELECT server, directory, max(datetime) datetime
            FROM usagestats
            GROUP BY server, directory
        ) AS b ON (
            a.server = b.server
            and a.directory = b.directory
            and a.datetime = b.datetime
        )
    ORDER BY a.server, a.directory, a.datetime

;WITH UniqueRows AS (
    SELECT IKey,RCRD_CRN_DATE,FULL_NAME,FATHER_NAME,MOTHER_NAME,SPOUSENAME,FTIN,
        ROW_NUMBER() OVER (PARTITION BY IKey ORDER BY RCRD_CRN_DATE desc) as rn
    FROM TMP_Source
)
MERGE INTO Final_Table t
USING (SELECT * FROM UniqueRows WHERE rn = 1) s
ON t.IKey = s.IKey
WHEN MATCHED THEN UPDATE
      SET [FULLNAME] = s.FULLNAME
         ,[FATHERNAME] = s.FATHERNAME
         ,[MOTHERNAME] = s.MOTHERNAME
         ,[SPOUSENAME] = s.SPOUSENAME
WHEN NOT MATCHED THEN INSERT
    ([IKEy],[FTIN],[FULLNAME],[FATHERNAME],[MOTHERNAME],[SPOUSENAME]) VALUES
    (s.IKEy,s.FTIN,s.FULLNAME,s.FATHERNAME,s.MOTHERNAME,s.SPOUSENAME);

g_SQL = "SELECT 'SUM' = SUM(Units) " & _
    "FROM tblDetail WHERE " & _
    "MemID = " & udtCDtl.Lines(udtCDtlIdx).MemID & " AND " & _
    "CAST(SStartD As DateTime) >= '" & StartDate & "' AND " & _
    "CAST(SStartD As DateTime) <= '" & DateAdd("d", -1, EndDate) & "' AND " & _
    "Service = 166 AND " & _
    "[CODE] IN ('1919')) And " & _
    "NOT (InvoiceNo = " & InvoiceDtlRS!InvoiceHdrNo & " AND DtlNo = " & InvoiceDtlRS!InvoiceDtlNo & ") AND " & _
    "NOT (InvoiceNo = " & InvoiceDtlRS!InvoiceHdrNo & " AND AdjNo = " & InvoiceDtlRS!InvoiceDtlNo & ")"

CREATE TABLE Foo (
    PK INT IDENTITY(1,1) PRIMARY KEY,
    I CHAR(1)
)

CREATE TABLE Bar (
    PK INT IDENTITY(1,1) PRIMARY KEY,
    J INT
)

CREATE TABLE Map (
    FooPK INT,
    BarPK INT
)
GO

INSERT INTO Foo(I) VALUES ('A')

DECLARE @FooPK INT = SCOPE_IDENTITY()

DECLARE @temp TABLE (BarPK INT)

INSERT INTO Bar(J)
OUTPUT INSERTED.PK INTO @temp
VALUES (4), (5),(6),(7)

INSERT INTO Map(FooPK, BarPK)
SELECT @FooPK, BarPK
FROM @temp

SELECT * FROM Foo
SELECT * FROM Bar
SELECT * FROM Map
     GO

DROP TABLE Foo
DROP TABLE Bar
DROP TABLE Map
     GO

insert into CatProduct(CatID, ProductID)
select 1, ProductID
from Product
where Cat1 = 'Y'
union all
select 2, ProductID
from Product
where Cat2 = 'Y'
union all
select 3, ProductID
from Product
where Cat3 = 'Y'

with starting_date(start_date) as
(
   select '2014-06-30'::date
)
select last_day(add_months(date_trunc('month', start_date), idx*3 )) qtr_date
from starting_date
   cross join _v_vector_idx
where qtr_date <= add_months(start_date,12)
-- where idx < 5
order by qtr_date ;

  QTR_DATE
------------
 2014-06-30
 2014-09-30
 2014-12-31
 2015-03-31
 2015-06-30
(5 rows)

SELECT i.id, i.title, i.items_title, f.filters_title FROM
( SELECT
  projects.id,
  projects.title,
  GROUP_CONCAT(project_items.title) AS items_title
  FROM projects
  LEFT JOIN project_items ON project_items.projects_id=projects.id
  group by projects.id,
  projects.title) as i
INNER JOIN
( SELECT
  projects.id,
  projects.title,
  GROUP_CONCAT(filters.title) AS filters_title
  FROM projects
  LEFT JOIN project_filters ON projects.id=project_filters.projects_id
  LEFT JOIN filters ON filters.id=project_filters.filters_id
  group by projects.id,
  projects.title) as f
ON i.id = f.id
WHERE i.id="1"

SELECT a.ID AS A_ID, b.ID AS B_ID, ab.ID AS Relation_Id 
FROM TableA AS a
CROSS JOIN TableB AS b
LEFT JOIN TableAB AS ab ON a.ID = ab.A_ID AND b.ID = ab.B_ID
ORDER BY A_ID, B_ID

SELECT o.id,
       (TO_CHAR(o.price, '0.00') || ' * ' || o.quantity) AS formula
FROM orders o;

(SELECT * FROM mytable WHERE mydate >= xxx)
UNION
(SELECT * FROM mytable WHERE mydate < xxx ORDER BY mydate DESC LIMIT 1)

DECLARE @SingleValue INT = 0

SELECT 
    t1.Field1
    , t1.Field2
    , t1.Field3
FROM 
    tblTable1 t1
    INNER JOIN tblTable2 t2 ON t1.Field1 = t2.Field
WHERE 
    (
        ( @SingleValue <> 0 )
        or
        ( t1.Field2 IN ( SELECT Field1 FROM tblTable3) )
    )
    and
    (
        ( @SingleValue = 0 )
        or
        ( t2.Field2 = @SingleValue )
    )

SELECT CAST(CAST(@ReminderDate AS Date) AS DateTime) + CAST(DATEADD(HOUR,-3,@ReminderTime) AS TIME)

SELECT Customer = CASE WHEN FirstName IS NULL AND LastName IS NULL
                       THEN 'Name Not Provided'
                       WHEN FirstName IS NULL AND LastName IS NOT NULL
                       THEN LastName
                       WHEN FirstName IS NOT NULL AND LastName IS NULL
                       THEN FirstName
                  ELSE LastName + ', ' + FirstName END
FROM dbo.TableName

mysql> DELETE FROM Table WHERE PHONE_NUM NOT RLIKE '[0-9]{10}'

WHERE workdate between STR_TO_DATE('201402 Monday', '%x%v %W') and
                       STR_TO_DATE('201402 Sunday', '%x%v %W')

Dim rS as DAO.Recordset
Dim dbS as DAO.Database
Set dbS = CurrentDb()
Set rS = dbS.OpenRecordset("Select DISTINCT emailaddress FROM <yourquery>",DbOpenSnapshot)
Do While Not rS.EOF
<sometempvar> = rS!emailaddress
'your code to email filtered report using <sometempvar>'
rS.MoveNext
Loop
Set rS = Nothing
Set dbS = Nothing

  SELECT sm.realName, 
         gl.*,
         x.taglist
    FROM GAME_LEVELS gl
    JOIN SMF_MEMBERS sm ON sm.id_member = gl.id_member
    JOIN (SELECT gt.uuid,
                 GROUP_CONCAT(gt.tag) AS taglist
            FROM GAME_TAGS gt
        GROUP BY gt.uuid) x ON x.uuid = gl.uuid
   WHERE x.taglist LIKE 'untagged'    
ORDER BY ID_TOPIC DESC

DELIMITER //

CREATE TRIGGER wp_postmeta_afr_ins 
AFTER INSERT ON wp_postmeta FOR EACH ROW
BEGIN

    insert into wp_postmeta (post_id,meta_key,meta_value)
    select NEW.post_id,
          '_et_listing_lat ' as meta_key,
           substring_index(NEW.meta_value,',',1) 
    from wp_postmeta  
    union all
    select NEW.post_id,
          '_et_listing_lng ' as meta_key,
           substring_index(NEW.meta_value,',',-1) 
    from wp_postmeta ;  

   delete from wp_postmeta where meta_id =NEW.meta_id ;

END //
DELIMITER ;

SELECT a.AveSpace, b.TotalSpace, (CAST(a.AveSpace AS float) / CAST(b.TotalSpace AS float)) as UnitSpace
FROM 
    (
        SELECT TOP 1 AVG(spaceusage) as AveSpace FROM (SELECT TOP 5 * FROM Employee ORDER BY date DESC)
    ) a,
    (
         SELECT TOP 1 TotalSpace FROM SpaceTable ORDER BY date
    ) b

SELECT l.id, l.name, count(u.id)
FROM locations l
LEFT JOIN users u
    ON l.id = u.location_id
GROUP BY l.id, l.name

declare
   name varchar2(200) := 'John';
begin
 if regexp_like(name,'[:lower:]') then
   dbms_output.put_line('lowercase');
 else
    dbms_output.put_line('uppercase');
 end if;
end;

SELECT column, DUMP(column, 1016)
FROM table

SELECT CURDATE()

select ('[' || to_char(work_date, 'dd-MON-yyyy') || '] ' || field_name || ' - ' ||work_desc) d
from DAILY_WORK
where work_date >= to_date('30-Jan-2013','dd-MON-yyyy') - 31
order by work_date desc

DECLARE @table TABLE (colA int, colB int, colC int, ...)

INSERT INTO @table
EXEC StoreProcedureName

SELECT * FROM @table WHERE colC * 10 < colB

DATEADD(d, (7 - DATEPART(dw, [Delivery Date]) + 1) % 7, [Delivery Date]) AS WeekEnd

SELECT TOP (100) PERCENT
    [Delivery Date],
    [Delivery Method],
    [Order Total],
    YEAR([Delivery Date]) AS Year,
    DATEADD(d, (7 - DATEPART(dw, [Delivery Date]) + 1) % 7, [Delivery Date]) AS WeekEnd
FROM dbo.salesdata
ORDER BY [Delivery Date] DESC

    Select pe.*, c1.CitizenName as PatientName, c2.CitizenName as DoctorName 
    from tbPatientEpisode pe
    join tbPatient p on pe.PatientIDF = p.PatientIDP
    join tbDoctor d on pe.DoctorIDF = d.DoctorIDP
    join tbCitizen c1 on p.CitizenIDF = c1.CitizenIDP
    join tbCitizen c2 on d.CitizenIDF = c2.CitizenIDP

order by nlssort(test,'NLS_SORT=BINARY')

select to_char(month,'MONTH')month,mo_incoming,mt_outgoing 
from t_raw_settlement_tara_yearly t
order by t.month

Select p.Status, Count(*) as new_CountofHeaderID
From (select distinct p.status, p.Date, p.Number, pEffectiveDate
      from tbl_Progression as p
     ) as p
Group By p.Status;

select * from Mytable as a join Mytable as b on a.ID=b.ID
where a.Substitute!=b.Location_ID

SELECT USER,
       category,
       count(*) AS num
FROM tblA
WHERE category=1
GROUP BY USER,
         category
ORDER BY num DESC;

SELECT * FROM
table
WHERE MONTH(date) = 4 AND YEAR(date) = 2010

delete from news 
where idnews not in (
  select idnews from (
    select idnews from news
    join (
      select title, text, min(date) as min_date 
      from news
      group by title, text
    ) x 
     on news.title = x.title
    and news.text  = x.text 
    and news.date  = x.min_date
  ) a
);

Row.OutShipDate_IsNull = True

ALTER TABLE
 MODIFY dt_created datetime DEFAULT CURRENT_TIMESTAMP

ALTER TABLE
 MODIFY dt_modified datetime DEFAULT ON UPDATE CURRENT_TIMESTAMP

CREATE FUNCTION GetString
(
    @s NVARCHAR(MAX)
)
RETURNS NVARCHAR(MAX)
AS
BEGIN
    DECLARE @trav                  NVARCHAR(2000) = @s,
            @length                INT,
            @count                 INT = 1,
            @startIndex            INT = 0,
            @endIndex              INT = 0,
            @replaceStartIndex     INT = 0,
            @repalceEndIndex       INT = 0,
            @replaceword           NVARCHAR(2000),
            @newWord               NVARCHAR(2000)

    SELECT @length = LEN(@Trav)
    WHILE ((@count + @startIndex) <= @length)
    BEGIN
        SET @startIndex = CHARINDEX('<strong>', @trav, @startIndex) + LEN('<strong>')
        IF (@startIndex > 8)
        BEGIN
            SET @endIndex = CHARINDEX('</strong>', @trav, @startIndex)
            SET @newWord = SUBSTRING(@trav, @startIndex, (@endIndex - @startIndex))
            SET @replaceStartIndex = CHARINDEX(':', @trav, @startIndex) + 2
            SET @repalceEndIndex = CHARINDEX('>', @trav, @replaceStartIndex)
            SET @replaceword = SUBSTRING(
                    @trav,
                    @replaceStartIndex,
                    (@repalceEndIndex - @replaceStartIndex)
                )
            --SELECT @replaceword as 'repword', @newWord as 'newword'
            SET @trav = REPLACE (@trav, @replaceword, @newWord)
            SET @count = @repalceEndIndex
        END
        ELSE
        BEGIN
            SET @count = @count + 1
        END
    END
    RETURN @trav
END
GO


IF OBJECT_ID('tempdb..#table') IS NOT NULL
    DROP TABLE #table

CREATE TABLE #table
(
    string VARCHAR(1000)
)
INSERT INTO #table
SELECT 
       '1. <strong>abc</strong>:<description1> <strong>bcd</strong>:<description2>'

INSERT INTO #table
SELECT 
       '2. <strong>efg</strong>:<description3> <strong>hgl</strong>:<description7>'


UPDATE #table
SET    string = [dbo].[GetString](#table.string)

SELECT *
FROM   #table

select product, price, version
from
(    
    select 
        *, 
        row_number() over (partition by product order by version desc) rn
    from yourtable
    where @dategiven between startdate and enddate
) v
where rn = 1

   SELECT f.id as f_id, f.message, c.id as c_id, c.user_id as c_user_id, c.comment 
   FROM forum_submission f
   LEFT JOIN submission_comment c
   ON c.forum_id=f.id 
   WHERE f.user_id= ? 
   Order by f.id

SELECT MINUTE, ....
FROM (
    SELECT TO_CHAR(TO_DATE((LEVEL + 419) * 60, 'SSSSS'), 'HH24:MI') MINUTE /* 07:00 - 23:59 */ FROM DUAL CONNECT BY LEVEL <= 1020)
    LEFT JOIN (
        <your grouped subquery>
    ) ON MINUTE = MINUTE_GAP

SELECT ...
   ...
  WHERE username LIKE '% %'

select id,name,rate_score,rate_number,video_image from products where release_on >= '$bef1mo' and (formats like '%XBox 360%' or formats like '%XBox One%') order by id desc limit 0,4

MyNewFields
-------------
a,b,c

SELECT CONVERT(VARCHAR(8), time_in, 108) AS time_in  
FROM job_punch_card  
WHERE emp_key=47 and punch_day<= DATEADD(week, DATEDIFF(day, 0, getdate())/7, 0)

SELECT *
FROM table1
EXCEPT
SELECT *
FROM table1
WHERE table1.MarketTYpe = 'EmergingMarkets'
AND IsBigOne = 1
AND MarketVolume = 'MIDDLE'
AND SomeClass = 'ThirdClass'

UPDATE classes
   SET CL_Status = 3
  FROM programs 
 WHERE classes.Pr_ID = programs.Pr_ID
   AND programs.Ma_ID = 8

   Select count(*) as 'Total Employees',
          SUM(CASE WHEN status='Active' THEN 1 ELSE 0 END ) as TotalActiveEmployees,
          DepartmentID 
    from Employees 
    Group By DepartmentID

/*  INIT  */
DECLARE @ActivityHistory TABLE (id int, bar VARCHAR(3), bam datetime)
INSERT INTO @ActivityHistory 
             SELECT  id='10000', bar='zoo', bam='2011-05-24 03:32:57' 
       UNION SELECT  id='10001', bar='zoo', bam='2011-05-24 03:31:57' 
       UNION SELECT  id='10002', bar='zoo', bam='2011-05-24 03:28:57' 
       UNION SELECT  id='10003', bar='zoo', bam='2011-05-24 03:21:57' 
       UNION SELECT  id= '9990', bar='zoo', bam='2011-05-23 03:32:57' 
       UNION SELECT  id= '9989', bar='zoo', bam='2011-05-23 03:31:57' 
       UNION SELECT  id= '9988', bar='zoo', bam='2011-05-23 03:28:57' 
       UNION SELECT  id= '9987', bar='zoo', bam='2011-05-23 03:21:57' 
       UNION SELECT  id= '9900', bar='zoo', bam='2011-05-22 03:32:57' 
       UNION SELECT  id= '9899', bar='zoo', bam='2011-05-22 03:31:57' 
       UNION SELECT  id= '9898', bar='zoo', bam='2011-05-22 03:28:57' 
       UNION SELECT  id= '9897', bar='zoo', bam='2011-05-22 03:21:57' 

/*  QUERY  */
;WITH 
resALL AS ( SELECT *
      , foo = DATENAME(weekday, bam)+', '+ CONVERT(VARCHAR(30), bam, 107) 
      , food = CONVERT(VARCHAR(10), bam, 121) 
    FROM @ActivityHistory AS Activity
  )
, resD AS ( SELECT DISTINCT foo, food FROM resALL 
  )

SELECT 
 Activities.foo
 , (
    SELECT id, bar, bam 
    FROM resALL AS Activity 
    WHERE foo = Activities.foo 
    ORDER BY bam desc 
    FOR XML AUTO, TYPE
   )
FROM resD AS Activities
ORDER BY Activities.food DESC
FOR XML AUTO, TYPE, ROOT ('ActivityHistory')

/*  OUTPUT
<ActivityHistory>
  <Activities foo="Tuesday, May 24, 2011">
    <Activity id="10000" bar="zoo" bam="2011-05-24T03:32:57" />
    <Activity id="10001" bar="zoo" bam="2011-05-24T03:31:57" />
    <Activity id="10002" bar="zoo" bam="2011-05-24T03:28:57" />
    <Activity id="10003" bar="zoo" bam="2011-05-24T03:21:57" />
  </Activities>
  <Activities foo="Monday, May 23, 2011">
    <Activity id="9990" bar="zoo" bam="2011-05-23T03:32:57" />
    <Activity id="9989" bar="zoo" bam="2011-05-23T03:31:57" />
    <Activity id="9988" bar="zoo" bam="2011-05-23T03:28:57" />
    <Activity id="9987" bar="zoo" bam="2011-05-23T03:21:57" />
  </Activities>
  <Activities foo="Sunday, May 22, 2011">
    <Activity id="9900" bar="zoo" bam="2011-05-22T03:32:57" />
    <Activity id="9899" bar="zoo" bam="2011-05-22T03:31:57" />
    <Activity id="9898" bar="zoo" bam="2011-05-22T03:28:57" />
    <Activity id="9897" bar="zoo" bam="2011-05-22T03:21:57" />
  </Activities>
</ActivityHistory>
*/

SELECT a, COUNT(*) AS b,
   SUM( CASE WHEN c = 'const' THEN 1 ELSE 0 END ) as d,
   from t group by a order by b desc

SELECT
    t.*
FROM
    table t
INNER JOIN
    (SELECT * FROM table WHERE City = 'Seattle') s
WHERE
    (s.Mon = 'Rain' AND t.Mon = 'Rain') OR
    (s.Tue = 'Rain' AND t.Tue = 'Rain') OR
    (s.Wed = 'Rain' AND t.Wed = 'Rain') OR
    (s.Thu = 'Rain' AND t.Thu = 'Rain') OR
    (s.Fri = 'Rain' AND t.Fri = 'Rain') OR
    (s.Sat = 'Rain' AND t.Sat = 'Rain') OR
    (s.Sun = 'Rain' AND t.Sun = 'Rain')
;

SELECT  b.Product,
        b.Qty,
        b.Price,
        Result = CASE WHEN a.product IS NULL THEN 'New'
                    ELSE 'Updated: ' + 
                        STUFF(  CASE WHEN a.Qty != b.Qty THEN ',Qty' ELSE '' END + 
                                CASE WHEN a.Price != b.Price THEN ',Price' ELSE '' END,
                            1, 1, '')
                END
FROM    TableB b    
        LEFT JOIN TableA a
            ON a.Product = b.Product
WHERE   a.Product IS NULL
OR      a.Qty != b.Qty
OR      a.Price != b.Price;

SELECT
  re.ResourceID,
  re.ResourceName,
  ch.UserID,
  AmountCharged = SUM(ch.TotalAmount)
FROM
  Location lo
  CROSS JOIN Charge ch
  CROSS APPLY (
    SELECT DATEDIFF(DAY, lo.StartDate, ch.ChargeDate) % lo.DaysInRoster
  ) x (RosterDay)
  INNER JOIN
    [Resource] re
    LEFT JOIN Roster ro
    ON
      ro.RosterDay = x.RosterDay
      AND ch.ChargeDate BETWEEN ro.StartDate
      AND ro.RecourceID = re.ResourceID
    LEFT JOIN SpecialRoster sr
    ON
      sr.RosterDate = ch.ChargeDate
      AND sr.RecourceID = re.ResourceID
  ON
    ch.UserID = ISNULL(sr.UserID, ro.UserID)
GROUP BY
  re.ResourceID,
  re.ResourceName,
  ch.UserID
WHERE
  lo.LocationID = @LocationID
  AND ch.ChargeDate BETWEEN ...
;

CREATE TABLE #OrderDtl (OrderId INT, Product CHAR(10))

CREATE CLUSTERED INDEX IX_Order ON #OrderDtl (OrderId) 
CREATE NONCLUSTERED INDEX IX_Order_Product ON #OrderDtl (Product) INCLUDE (OrderId)

INSERT #OrderDtl SELECT 1, 'ORANGE'
INSERT #OrderDtl SELECT 1, 'APPLE'
INSERT #OrderDtl SELECT 2, 'SHAMPOO'
INSERT #OrderDtl SELECT 2, 'SOAP'
INSERT #OrderDtl SELECT 2, 'TOOTHPASTE'

SELECT T2.* 
FROM #OrderDtl T1 INNER JOIN #OrderDtl T2
ON T1.OrderId = T2.OrderId
WHERE T1.Product='APPLE'

SELECT *
FROM #OrderDtl
WHERE OrderId in
    (
        SELECT OrderId
        FROM #OrderDtl
        WHERE Product='APPLE'
    )

SELECT id, col2, col3, col4
FROM yourtable
WHERE id IN
(
    SELECT MIN(id)
    FROM yourtable
    GROUP BY col2, col3
)

WITH cteBalances AS
(
    SELECT loan_id, SUM(amount_o-amount_h) AS balance 
    FROM decret d 
    WHERE d.DATE_D <= '2013-10-31'  
      AND type IN (1,2,3,4,11,12,13,18,20,25)
    GROUP BY loan_id
)
SELECT c.*, b.balance 
FROM clients c
LEFT JOIN cteBalances b ON b.loan_id = c.loan_id
WHERE  loan_id IN (SELECT LoanNum 
                   FROM NumsFromEx)

ALTER TABLE tableNAME ADD INDEX (field1)

SELECT DISTINCT room_type_id, room_id
FROM Room R
WHERE NOT EXISTS (
        SELECT *
        FROM Hotel_Reservation H
        WHERE
    (
    @DateStart BETWEEN H.bookingStart AND H.bookingEnd
    OR @DateEnd BETWEEN H.bookingStart AND H.bookingEnd
    or H.bookingStart BETWEEN @DateStart AND @DateEnd  
    or H.bookingEnd BETWEEN @DateStart AND @DateEnd
    )
    and  --here is where we check **that room for that hotel**
    H.hotel_id = R.hotel_id and H.room_id = R.room_id
) 
and 
R.hotel_id = @hotel_id

SELECT * FROM sys.index

select c.*
from INFORMATION_SCHEMA.COLUMNS c
where lower(column_name) like '%address%';

declare
   l_date date;
begin
   if :p24_leaving_date between :p24_bill_ready and (:p24_bill_ready + 365)
   then
      l_date := :p24_leaving_date - 30;
   else
      l_date := :p24_leaving_date;
   end if;
   return l_date;
end;

SELECT 
  c1, 
  row_number() OVER (ORDER BY dummy)-1 AS record_index
FROM 
  (SELECT 
    c1,
    42 AS dummy 
  FROM t1
) AS t1_augmented;

SELECT
        B.waiter_id,
        WA.name, 
        WA.surname, 
        SUM(case when d.dtype = 1 then 1 end) AS Receipts, 
        SUM(case when d.dtype = 1 then D.total end) AS TotReceipts,
        SUM(case when d.dtype = 0 then 1 end) AS Invoices, 
        SUM(case when d.dtype = 0 then D.total end) AS TotInvoices
FROM    
    documents D
    JOIN bills B ON (B.id = D.bill_id)
    JOIN waiters WA ON (WA.id = B.waiter_id)
GROUP BY 
    waiter_id

SELECT AVG(score) avscore
FROM (SELECT debatedate, score
      FROM (SELECT debatedate, hostscore score
            FROM debates
            WHERE hostid = 1
            UNION
            SELECT debatedate, visitscore score
            FROM debates
            WHERE visitid = 1) x
      ORDER BY debatedate DESC
      LIMIT 5) y

total_points = func.sum(Bet.points).label("total_points")
total_hits = func.sum(case(value=Bet.points, whens={3: 1}, else_=0)).label("total_hits")
q = (session.query(
        User.nick,
        total_points,
        total_hits,
        )
    .join(User.bets)
    .group_by(User.nick)
    .order_by(total_points.desc())
    .order_by(total_hits.desc())
    )

select S.IdStudent, MIN(Name) Name, MIN(Age) Age, MIN(Address) Address, MIN(Tel) Tel, MIN(Code) Code
FROM Students S Inner Join Info I  ON S.IDStudent = I.Id
group by S.IdStudent

create or replace
procedure ups(xa number)
as
begin
    merge into mergetest m using dual on (a = xa)
         when not matched then insert (a,b) values (xa,1)
             when matched then update set b = b+1;
end ups;
/
drop table mergetest;
create table mergetest(a number, b number);
call ups(10);
call ups(10);
call ups(20);
select * from mergetest;

A                      B
---------------------- ----------------------
10                     2
20                     1

SELECT COALESCE(a.ProductID, b.ProductID) AS ProductID, 
       a.Price AS Price1, 
       b.Price AS Price2, 
       COALESCE(a.Region, b.Region) AS Region
FROM   
       ( SELECT ProductID, Price, Region
         FROM table1
         WHERE ManufacturerID = 100
       ) AS a
    FULL JOIN 
       ( SELECT ProductID, Price, Region
         FROM table1
         WHERE ManufacturerID = 101
       ) AS b
           ON  a.ProductID = b.ProductID 
           AND a.Region = b.Region      -- not sure if you need this line
;

SELECT u.ID, u.fname, u.lname
      , d1.name as div_1_name
      , d2.name as div_2_name 
FROM USERS u 
LEFT JOIN DIVISIONS d1 ON u.div_1_id = d1.ID 
LEFT JOIN DIVISIONS d2 ON u.div_2_id = d2.ID

SELECT FROM_UNIXTIME(utc_timestamp, 'yyyy-MM-dd'), s
FROM evt
WHERE month = 201311
group by FROM_UNIXTIME(utc_timestamp, 'yyyy-MM-dd'), s

select substring_index(col, '.', 1)

SELECT FirstName, LastName, RoleName 
FROM User 
INNER JOIN UserRole 
ON UserRole.UserId = User.UserId 
INNER JOIN Role 
ON Role.RoleId = UserRole.RoleId 
WHERE User.UserId NOT IN 
    (SELECT UserId
     FROM UserRole AS ur
     WHERE ur.RoleId = (SELECT RoleId FROM Role AS rn WHERE rn.RoleName = 'Admin')
    )

select date_trunc('day', created_at), min(created_at)
from table
group by date_trunc('day', created_at)

DECLARE @table TABLE (id INT NOT NULL PRIMARY KEY, name NVARCHAR(4000) NOT NULL, path HIERARCHYID)

INSERT
INTO    @table
VALUES  
        (1, 'People', '/'),
        (2, 'Girls', '/1/'),
        (3, 'Boys', '/2/'),
        (4, 'Zoey', '/1/1/'),
        (5, 'Kate', '/1/2/'),
        (6, 'Monica', '/1/3/'),
        (7, 'Mark', '/2/1/'),
        (8, 'David', '/2/2/')

;WITH   q AS
        (
        SELECT  *, HIERARCHYID::Parse('/') AS newpath
        FROM    @table
        WHERE   path = HIERARCHYID::GetRoot()
        UNION ALL
        SELECT  t.*, HIERARCHYID::Parse(q.newpath.ToString() + CAST(ROW_NUMBER() OVER (ORDER BY t.name) AS NVARCHAR(MAX)) + '/')
        FROM    q
        JOIN    @table t
        ON      t.path.IsDescendantOf(q.path) = 1
                AND t.path.GetLevel() = q.path.GetLevel() + 1
        )
SELECT  *
FROM    q
ORDER BY
        newpath

select a.shipperid,
       b.orderid,
       b.custid
from shippers a 
left join orders b

on a.shipperid = b.shipperid

SELECT S.*, SUM(Pledge_payment_amt) AS pledged
FROM Test_table2 AS recipients
LEFT JOIN Test_table2 AS pledgers
    ON recipients.Gift_no = pledgers.Pledge_gift_no
GROUP BY S.Gift_No
HAVING S.Pledge_Amount > pledged

DECLARE  @T TABLE (
b1 bit
,b2 bit
,b3 bit
);

DECLARE @T2 TABLE (
b1 bit
,b2 bit
,b3 bit
,b4 bit
,b5 bit
);

INSERT INTO @T VALUES (0,0,0),(1,1,1);
INSERT INTO @T2 VALUES (0,0,0,0,0),(1,1,1,1,1);

SELECT CHECKSUM(*) FROM @T;
SELECT CHECKSUM(*) FROM @T2;

SELECT `id`, `keyword_netword_id`, `text`, `match_type`, `create_date` FROM `keywords` WHERE `text` LIKE '%medicare supplemental insurance%';

UPDATE zonages_region
SET    superficie = ST_AREA(geom::geography)/1000000

select * from tbl_student st 
join tbl_batch ba on ba.college_id=st.college_id
join tbl_section se on se.college_id=st.college_id
join tbl_level le on le.college_id=st.college_id
join tbl_faculty fa on fa.college_id=st.college_id

SELECT FullDate, CalendarYear, IsFirstDayOfWeek, 
       COALESCE(FirstDateOfWeekFullDate,
         LAG(FirstDateOfWeekFullDate,1) OVER (ORDER BY FullDate ASC),
         LAG(FirstDateOfWeekFullDate,2) OVER (ORDER BY FullDate ASC),
         LAG(FirstDateOfWeekFullDate,3) OVER (ORDER BY FullDate ASC),
         LAG(FirstDateOfWeekFullDate,4) OVER (ORDER BY FullDate ASC),
         LAG(FirstDateOfWeekFullDate,5) OVER (ORDER BY FullDate ASC),
         LAG(FirstDateOfWeekFullDate,6) OVER (ORDER BY FullDate ASC))
       as FirstDateOfWeekFullDate
FROM putYourTableNameHere

select 
  itemid, 
  min(name), min(discription), min(enhet1), min(enhet2), min(enhet3), min("sum")
from mytable
group by itemid;

SELECT t1.id, t1.row1, t1.some_data, t2.id, t2.row1, t2.some_data
  FROM first_table t1
  LEFT JOIN second_table t2
    ON t1.row1 = t2.row2
ORDER BY t1.id; 

SELECT 
    Count([F1]) AS F1Count
FROM 
    tblA 
    INNER JOIN 
    Y_tblReferenceData
    ON 
    [tblA].[F1] = [Y_tblReferenceData].[F1Ref];

INSERT INTO ADVNET.dbo.KenCatItemTest
            (CategoryItemId,ItemId,CategoryId)
SELECT Newid(),itemid,'0FCA508F-7EB5-4C2E-8803-DE688C4126E5'
FROM   janel.dbo.item
WHERE  janel.dbo.item.itemnumber LIKE 'c-%'
       AND listprice > 0 

select
  case r when 1 then p.id end as id,
  case r when 1 then name end as name,
  case r when 1 then surname end as surname,
  description,
  contact
from
  person p, (
    select
      id,
      row_number() over (partition by id) as r,
      description,
      contact
    from
      contact
  ) c
where p.id = c.id;

SELECT cast(@avg as varchar(5)) + '%'

UPDATE table_name
   SET first_name = 'NA'
 WHERE length( first_name ) != lengthb( first_name )

UPDATE tblswitchemprequest SET responseDateTime = DATE_ADD(responseDateTime, INTERVAL 5 HOUR)

DECLARE @MonthCode AS INT
SELECT @MonthCode = 11  /* NOVEMBER */

declare @yourtable table(
    startdate datetime
    , enddate datetime
)
insert into @yourtable(
    startdate
    , enddate
)
(
select '8/10/2009', '01/01/2010'
union all
select '8/10/2009' , '11/15/2009'
union all
select '11/15/2009' , '01/01/2010'
union all 
select '11/15/2009' , '11/15/2009'
union all
select '10/01/2010' , '12/31/2010'
union all
select '05/01/2009', '10/30/2009'
)

select *
from @yourtable
where DateDiff(mm, startdate, enddate) > @MonthCode     -- can't go over 11 months without crossing date
    OR (Month(startdate) <= @MonthCode                  -- before Month selected
            AND (month(enddate) >=@MonthCode            -- after month selected
                OR year(enddate) > year(startdate)    -- or crosses into next year
                )
        )
    OR (Month(startdate) >= @MonthCode                  -- starts after in same year after month
            and month(enddate) >= @MonthCode            -- must end on/after same month assume next year
            and year(enddate) > year(startdate)
        )

delete b
from mytable a
join mytable b on a.id < b.id
  and a.parent_id = b.parent_id
  and a.child_id = b.child_id

select sum(IF (@prevBillId IS NULL OR @prevBillId != bi.bill_id,b.amount,0)) as sumAmount, 
       sum(IF (@prevBillId IS NULL OR @prevBillId != bi.bill_id,b.balance,0)) as sumBalance,
       @prevBillId:=bi.bill_id
from bills b left join billing_items bi 
on b.id=bi.bill_id
ORDER BY bi.bill_id;

ALTER TABLE blablub MODIFY test <DATATYPE> NOT NULL WITH DEFAULT 

SELECT r.[Date], r.Count As Received, c.Count As Closed, p.Count AS Pending
FROM
   ( /* Received query here */ ) r
FULL JOIN 
   ( /* Closed query here */) c ON c.[Date] = r.[Date]
FULL JOIN
   ( /* Pending query here */) p ON p.[Date] = r.[Date]

    SELECT 
    ISNULL(SUM(CASE WHEN ta_code = '12' and ta_type='1' THEN Qty ELSE 0 END), 0) as rQty,
    ISNULL(SUM(CASE WHEN ta_code = '15' and ta_type='4' THEN Qty ELSE 0 END), 0) as mQty

    FROM trans AS t

    WHERE t.Site = 127
    GROUP BY itmcode

select data.time,
    vData.time,
    data.Signal,
    drivers.name,
    drivers.lastname,
    vehicles.vehicle,
    data.Reg
from data 
inner join vData on data.id != vData.id and data.serial = vData.serial
inner join drivers on data.FK_ID_driver = drivers.ID_driver
inner join vehicles on data.Reg = vehicles.Reg
where TIMEDIFF(vData.time, data.time) between '00:15:00' and '00:30:00';

select sNames, max(sDate)
from your_table
group by sNames
order by max(sDate) desc

select min(a.id) as person_id,b.id as registration_id 
from
registrations a
join registrations b on ((a.email=b.email or a.phone=b.phone) and a.id<=b.id)
group by b.id

actors = repository(:default).adapter.select(
  "SELECT actors.name, count(actor_movies.actor_name) AS count " +
  "FROM actors " +
  "JOIN actor_movies WHERE actors.name = actor_movies.actor_name " +
  "GROUP BY actors.name " +
  "ORDER BY count(actor_movies.actor_name) desc " +
  "LIMIT 5;"
)

=> [
  #<struct name="Samuel L. Jackson", count=66>,
  #<struct name="Michael Caine", count=64>,
  #<struct name="Robert De Niro", count=59>,
  #<struct name="Harvey Keitel", count=58>,
  #<struct name="Gene Hackman", count=57>
]

CREATE TABLE T (
  Id Int PRIMARY KEY IDENTITY(0, 1)
);

ALTER TABLE T ADD CONSTRAINT Id_Range_Constraint
CHECK (Id BETWEEN 0 AND 9000);

DROP TABLE T;

WITH Dups AS
(
  SELECT tickId, timestamp, price,
    ROW_NUMBER() OVER(PARTITION BY tickid, timestamp ORDER BY (SELECT 0)) AS rn
  FROM stockData
)
DELETE FROM Dups WHERE rn > 1

select power(max(prod_year) - min(prod_year), 2)
from mediaitems mi;

create table #a (CustomerID int, AccountNumber int, AccountStatus varchar(max))

insert into #a values (1,12345,'Open')
insert into #a values (1,54321,'Closed')
insert into #a values (2,77777,'Open')
insert into #a values (2,88888,'Closed')

DECLARE @CustomerID int
DECLARE @accounts xml

DECLARE CurInvoice CURSOR READ_ONLY FAST_FORWARD FOR
    SELECT DISTINCT CustomerID 
    FROM #a  

OPEN CurInvoice

FETCH NEXT FROM CurInvoice INTO @CustomerID
WHILE @@FETCH_STATUS = 0
    BEGIN

    set @accounts = (
    select AccountNumber,AccountStatus
    from #a
    where CustomerID = @CustomerID
    for xml path('Account'), root('Accounts'))

    exec MyProc @XmlInput = @accounts


FETCH NEXT FROM CurInvoice INTO @CustomerID
END
CLOSE CurInvoice
DEALLOCATE CurInvoice

select t1.COUNTRY_BASE,ref.Clmn3,ref1.Clmn3
frorm TBL1 t1
left outer join reftable ref
on SUBSTR(t1.COUNTRY_BASE, -1,1)=ref.Clmn2  
left outer join reftable ref1
on SUBSTR(t1.IS_VALUED, -1,1)=ref.Clmn2;

SELECT LEFT(DATENAME(dw, GETDATE()), 3)

if(@ProdID IS NULL)
begin 
raiserror('The product does not exist',16,1)
return 1
end
return 0

SELECT module, 
COUNT(IF(FROM_UNIXTIME( l.`time` ) BETWEEN  '2014-12-12 00:00:00' AND '2014-12-13 00:00:00', 1, NULL) AS "12/12/2014",
COUNT(IF(FROM_UNIXTIME( l.`time` ) BETWEEN  '2014-12-16 00:00:00' AND '2014-12-17 00:00:00', 1, NULL) AS "12/16/2014"
FROM mdl_log 
group by module 

select order_id, array_agg(x order by rn) as unique_channel_path
from (
  select distinct on (order_id, a.x) order_id, a.x, a.rn
  from dim_conversion_path, unnest(channel_path) with ordinality as a (x,rn)
  order by 1,2,3  
) t
group by order_id

SELECT 'ALTER TABLE ' + QUOTENAME(SCHEMA_NAME(schema_id)) + '.' + QUOTENAME(t.name) + ' ALTER COLUMN ' + QUOTENAME(c.name) + ' NVARCHAR(50)'
FROM sys.tables AS t
INNER JOIN sys.columns c ON t.OBJECT_ID = c.OBJECT_ID
WHERE c.name LIKE '%columniwantchanged%'

CHECK (Appointment_datetime >= GETDATE() AND
       DATEPART(HOUR, GETDATE()) NOT BETWEEN 8 AND 16
      ) 

Members(member_id, name, username, password, islibrarian)

Shelf(shelf_id, caption, dateopened, owner, etc...)
ShelfDetails(id, shelf_id, bookid)

DELETE  FROM batchinfo where rowid='105'
AND EXISTS (SELECT * FROM batchinfo WHERE rowid='105' and something='sometext' and somethingelse='moretext')

select m.[Job Title], m.ap, m.mp, f.ap, f.mp
 from (  Select [Job Title], AVG([Pay Rate]) as ap, max([Pay Rate]) as mp
           From ##JTemp
          Where [Employee Gender] = 'M' 
          Group By [Job Title] ) m
 join (  Select [Job Title], AVG([Pay Rate]) as ap, max([Pay Rate]) as mp
           From ##JTemp
          Where [Employee Gender] = 'F' 
          Group By [Job Title] ) f 
   on m.[Job Title] = f.[Job Title]

SELECT SZ_SK FROM tbl_Class CC
INNER JOIN tbl_Location LR ON ISNULL(CC.LCTN_RSTN, '') = ISNULL(LR.LCTN_RSTN, '')
WHERE LR.LCTN_RSTN = ISNULL(@Location,LR.LCTN_RSTN)

--
-- Create test case
--
DECLARE @myDateTime DATETIME
SET @myDateTime = '2008-05-03'

--
-- Convert string
--
SELECT LEFT(CONVERT(VARCHAR, @myDateTime, 120), 10)

SELECT TO_CHAR(ddatte, 'dd/Mon/yyyy') FROM mytable

select
    sum(case when date between '2012-05-01' AND '2012-06-01' then value else 0 end) as sum1,
    sum(case when date between '2012-05-01' AND '2012-10-01' then value else 0 end) as sum2,
    sum(case when situation like 'Urgent' then 1 else 0 end) as count1
from mytable

SELECT
  DISTINCT i.id AS id,
  i.userid AS userid,
  i.itemname AS itemname,
  COALESCE(LEAD(i.id)        OVER (ORDER BY i.created DESC)
          ,FIRST_VALUE(i.id) OVER (ORDER BY i.created DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS nextitemid,
  COALESCE(LAG(i.id)         OVER (ORDER BY i.created DESC)
          ,LAST_VALUE(i.id)  OVER (ORDER BY i.created DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS previtemid,
  COALESCE(LEAD(i.id)        OVER (PARTITION BY i.userid ORDER BY i.created DESC)
          ,FIRST_VALUE(i.id) OVER (PARTITION BY i.userid ORDER BY i.created DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS nextuseritemid,
  COALESCE(LAG(i.id)         OVER (PARTITION BY i.userid ORDER BY i.created DESC)
          ,LAST_VALUE(i.id)  OVER (PARTITION BY i.userid ORDER BY i.created DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)) AS prevuseritemid,
  i.created AS created
FROM items i
  LEFT JOIN users u
  ON i.userid = u.id
ORDER BY i.created DESC;

SELECT (SUM(r)/SUM(i)) AS tera FROM
((SELECT SUM(reflectance) AS r, 0 AS i FROM table WHERE wavelength BETWEEN 340 AND 345)
UNION
(SELECT 0 AS r, SUM(reflectance) AS i FROM table WHERE wavelength BETWEEN 350 AND 355))
AS total

SELECT tz.id 
FROM Z tz 
WHERE 
    NOT EXISTS (select 1 from X tx where tx.id = tz.id)
    AND NOT EXISTS (select 1 from Y ty where ty.id = tz.id)

SELECT
  CASE WHEN COUNT(*) = 0
    THEN 'empty'
    ELSE COUNT(*) -- CONVERT, TO_CHAR, ...
  END AS result
FROM Database.table where CarID = 12;

Select Balance from myTable where TimeStamp = (select MAX(TimeStamp) as RecentTime from myTable where RecordDate = (Select MAX(RecordDate) from myTable)   Group By RecordDate

update tableName set columnA = 2
where columnA = 1

INSERT INTO dbo.EmployeeBenefits(EmployeeId, BenefitID, StartdateTime, EndDateTime) 
   OUTPUT Inserted.EmployeeBenefitId, Inserted.EmployeeID, Inserted.BenefitID   -- or whatever you want to return here
   SELECT 
      @new_emp_id, BenefitID, GetDate(), @PassedEndDate 
  FROM 
      dbo.Benefits

SELECT a.Account_ID   
    FROM Accounts a
    WHERE ((@FirstName='' and a.FirstName is null) or a.FirstName = @FirstName) /*Add check if @FirstName = '' then a.FirstName IS NULL */ 
        AND a.LastName = @LastName 
        AND a.Middle = @MiddleName
        AND a.Email = @Email 
        AND a.Company = @Company

select sr.role_name
     , sr.id
     , ss.staff_cost
     , ss.confirmed 
from staff_role sr
left join staff_schedule ss on sr.id = ss.staff_role_id
                           and ss.client_booking_id = 1551

$numUsers = Yii::$app->db->createCommand('
      SELECT COUNT(*) FROM "user"."list" ')->queryScalar();

SELECT CCID, 
   COUNT(CASE WHEN TypeID = 5 THEN CCID END) as OurTypeCnt,
   COUNT(CASE WHEN TypeID <> 5 THEN CCID END) as NotOurTypeCnt
FROM CCsTransactions 
GROUP BY CCID
HAVING ((OurTypeCnt >= 1) AND (NotOurTypeCnt < 1))

merge into MY_BOOK MB
using MY_BOOK_HEADER MBH
  on (MB.SK_BOOK_HEADER = MBH.PK_BOOK_HEADER and
      MB.BOOK_TYPE = 4 and
      MBH.HEADER_BOOK_CODE = '127518010109038' and
      MBH.FK_BOOK_GROUP =  '{79B79C33-CE56-4084-912B-6DD9F70B3DC4}')
when matched then
  update set
    MB.BOOK_NAME = 'Book Name1',
    MB.BOOK_DESCRIPTION = 'Book Desfcription1';

CREATE TABLE "business_hours" (
     "id" integer NOT NULL PRIMARY KEY,
     "business_id" integer NOT NULL FOREIGN KEY REFERENCES "businesses",
     "day" integer NOT NULL,
     "open_time" time,
     "close_time" time
)

CREATE TABLE Unavailability 
(Crew_ID varchar (9) NOT NULL,
Available text (3),
Licence_Number int (8),
CONSTRAINT pk11 primary key (Crew_ID));

if(!$ok || $@) { # Connection failed }

SELECT * 
FROM sensors s
JOIN Location_polygon s_lp 
    ON s.FID = s_lp.FID and s.SID = s_lp.SID
WHERE username = '$username' and Datetime = (
    SELECT max(Datetime) FROM sensors)

$ sudo su
# su postgres -c 'createuser msf -P -h localhost'

UPDATE table 
SET (...) 
WHERE (...)  
ORDER BY something
LIMIT 2

ALTER TABLE your_table ADD UNIQUE (name);

SELECT MAX(x.t1_missing_count) AS t1_missing_count, 
       MAX(x.t2_missing_count) AS t2_missing_count
  FROM (
SELECT COUNT(DISTINCT t1.col1) AS t1_missing_count,
       NULL AS t2_missing_count
  FROM TABLE_1 t1
 WHERE t1.col1 NOT IN (SELECT DISTINCT t2.col1 
                         FROM TABLE_2 t2)
UNION ALL
SELECT NULL,
       COUNT(DISTINCT t2.col1),           
  FROM TABLE_2 t2
 WHERE t2.col1 NOT IN (SELECT DISTINCT t1.col1 
                         FROM TABLE_1 t1)) x

SELECT
    userID,
    userName,
    SUM(CASE WHEN ItemID = 2 THEN 1 ELSE 0 END) AS count_of_item1,
    SUM(CASE WHEN ItemID = 3 THEN 1 ELSE 0 END) AS count_of_item2,
    SUM(CASE WHEN ItemID = 4 THEN 1 ELSE 0 END) AS count_of_item3
FROM
    My_Table
GROUP BY
    userID,
    userName

When first enabled, xp_cmdshell requires CONTROL SERVER
permission to execute and the Windows process created by
xp_cmdshell has the same security context as the SQL Server 
service account.

SELECT * 
FROM `products` 
WHERE (products.name REGEXP '[[:<:]]wall[[:>:]]')  
ORDER BY products.updated_at DESC

UPDATE items i
INNER JOIN buffer b ON i.id = b.id
SET i.keywords = CONCAT(i.keywords, ', ', b.value);

SELECT t1.ID, t1.FirstName, t1.LastName, t1.Relation, t2.LastName AS EmployeeName
FROM YourTable AS t1
JOIN YourTable AS t2 ON t1.ID = t2.ID
WHERE t2.Relation = "Employee"
ORDER BY EmployeeName, t1.ID, t1.LastName

SELECT a.id,
       a.person_id,
       a.adate,
       a.resulta,
       a.resultb,
       a.resultc,
       a.resultd,
       (SELECT TOP 1 b.resulta
        FROM   tbl b
        WHERE  b.person_id = a.person_id
               AND b.adate > a.adate
        ORDER  BY b.adate, b.id) AS res
FROM   tbl AS a
WHERE  a.resulta = "P"
       AND a.resultb = "N" 
       AND a.resultc = "N" 
       AND a.resultd = "N" 

SELECT "A"."ID", "B"."ID", "C"."ID", "D"."ID"
FROM "NAVIGATION" AS A LEFT JOIN
     (SELECT N.PARENT, N.ID
      FROM "NAVIGATION"
      UNION ALL
      SELECT NULL, NULL
     ) B
     ON B.PARENT = A.ID
     (SELECT N.PARENT, N.ID
      FROM "NAVIGATION"
      UNION ALL
      SELECT NULL, NULL
     ) C
     ON C.PARENT = B.ID LEFT JOIN
     (SELECT N.PARENT, N.ID
      FROM "NAVIGATION"
      UNION ALL
      SELECT NULL, NULL
     ) D
     ON D.PARENT = C.ID
WHERE "A"."ID" = CHAR_TO_UUID('00000000-0000-0000-0000-000000000000');

for (int a=0;a<count_row;a++)
{
     for(int b=0;b<count_col;b++) 
      {
          obj_ml.append(String.valueOf(table[a][b]));
      }
     // add to obj_ml new line character '\n'
     obj_ml.append("\n");
}

RENAME TABLE car TO temp_car;
RENAME TABLE new_car TO car;
TRUNCATE TABLE temp_car;
RENAME TABLE temp_car TO new_car;

SELECT
  AVG("distance[m]") AS avg_distance
FROM
  distance_table

SELECT TABLE_NAME, COLUMN_NAME
FROM sysindexes AS i 
INNER JOIN sysobjects AS o 
ON i.id=o.id 
INNER JOIN INFORMATION_SCHEMA.COLUMNS 
ON o.NAME=TABLE_NAME 
WHERE(indid=0 or indid=1) 
and DATA_TYPE like '%varchar' 
and(CHARACTER_MAXIMUM_LENGTH=-1 or CHARACTER_MAXIMUM_LENGTH=2147483647);

select t1.id, t1.name, t2.name
from yourTable t1
join (select * from yourTable
where name = 'Laguna') t2
on t1.id = t2.id
where t1.name = 'José'

select  site_id
,       max(count) as TopCount
from    tags 
where   match (tag) against ('statistici' in boolean mode) 
group by 
        site_id 
order by
        TopCount DESC

   --Set output size
   SET serveroutput ON size 1000000

   DECLARE
      -- var table Name for cursor loop.
      t_c1_tname      user_tab_columns.table_name%TYPE;
      -- var column name for dynamic sql statement.
      t_c1_cname      user_tab_columns.column_name%TYPE;
      -- var string for dynamic sql statement.
      t_command       VARCHAR2(200);
      -- var for your search key word.
      l_str varchar2(20) := '%test%';
      -- var for dynamic cursor.
      t_cid           INTEGER;
      -- var for total row counts.
      t_total_records NUMBER(10);
      -- var for stat of executing dynamic sql statement.
      stat            INTEGER;
      --var for each loop row counts.
      row_count       INTEGER;
      -- var for minimum search result, here I set value = 0;
      t_limit         INTEGER := 0;    -- Only show tables with more rows

      -- cursor gets all table name, column name.
      CURSOR c1 IS select table_name, column_name
        from user_tab_columns
        where data_type in ( 'VARCHAR2' , 'VARCHAR', 'CHAR' );
    BEGIN
      t_limit := 0;
      OPEN c1;
      LOOP
      FETCH c1 INTO t_c1_tname,t_c1_cname;
      EXIT WHEN c1%NOTFOUND;
      -- Here create dynamic sql statement. 
      t_command := 'SELECT COUNT(0) FROM '||t_c1_tname || ' where ' || t_c1_cname ||' like '''|| l_str||'''';
      t_cid := DBMS_SQL.OPEN_CURSOR;
      DBMS_SQL.PARSE(t_cid,t_command,DBMS_SQL.native);
      DBMS_SQL.DEFINE_COLUMN(t_cid,1,t_total_records);
      -- Here execute dynamic sql statement. 
      stat := DBMS_SQL.EXECUTE(t_cid);
      row_count := DBMS_SQL.FETCH_ROWS(t_cid);
      -- Here get total row counts for each loop.
      DBMS_SQL.COLUMN_VALUE(t_cid,1,t_total_records);
      IF t_total_records > t_limit THEN
         --Here output results
         DBMS_OUTPUT.PUT_LINE(RPAD(t_c1_tname,55,' ')||RPAD(t_c1_cname,55,' ')||
                        TO_CHAR(t_total_records,'99999999')||' record(s)');
         -- here you can insert results into your table.
         --INSERT INTO search_db_results VALUES (t_c1_tname,t_c1_cname,t_total_records);
      END IF;
      DBMS_SQL.CLOSE_CURSOR(t_cid);
      END LOOP;
      CLOSE c1;

     -- COMMIT if you have any insert statement.
     -- COMMIT;
    END;
    /

tmpCol.query(Tablename, columns, "WHERE Clause LIMIT xx OFFSET yy",
                                selectionArgs[], having, orderBy);

INSERT INTO dbo.tbl_waredetails
        (wd_id, wd_mt_code, wd_wa_Id, wd_supply, wd_description, wd_status)
   SELECT    
       (SELECT ISNULL(MAX(wd.wd_id), 0)  
        FROM dbo.tbl_waredetails AS wd)+ (row_number() over (order by wd.wd_id)), 
       dbo.tbl_material.mat_code, @id,    
       dbo.fun_CompRem(mat_code, -1, @user_id) AS supply,
       NULL, 0
   FROM                 
       tbl_material 
   INNER JOIN
       dbo.tbl_MatUnit ON dbo.tbl_material.mat_MatUnt_Code = dbo.tbl_MatUnit.Matunt_code 
   INNER JOIN
       dbo.tbl_MatGroup ON dbo.tbl_material.mat_MatGrp_Code = dbo.tbl_MatGroup.MatGrp_Code

 SELECT (fistnameField + "" + LastnameField) AS Name FROM Customer WHERE Customer_Id IN (SELECT Customer_Review_Id FROM Review);

if (cursor.moveToFirst()){
   do{
      String data = cursor.getString(cursor.getColumnIndex("text"));
      //do stuff... 
   }while(cursor.moveToNext());
}
cursor.close();

WITH SAMPLE (ID,GRP_ID,SCORE,RANK) AS (
SELECT 1,1,100,NULL FROM DUAL UNION
SELECT 2,1,90,NULL FROM DUAL UNION
SELECT 3,1,70,NULL FROM DUAL UNION
SELECT 4,2,95,NULL FROM DUAL UNION
SELECT 5,2,70,NULL FROM DUAL UNION
SELECT 6,2,60,NULL FROM DUAL)
SELECT ID,GRP_ID,SCORE,RANK FROM SAMPLE
MODEL
DIMENSION BY (ID,GRP_ID)
MEASURES (SCORE,0 RANK,0 LAST_RANKED_GRP,0 ITEM_COUNT,0 HAS_RANK)
RULES
ITERATE (1000) UNTIL (ITERATION_NUMBER = ITEM_COUNT[1,1]) --ITERATE ONCE FOR EACH ITEM TO BE RANKED
(
RANK[ANY,ANY] = CASE WHEN SCORE[CV(),CV()] = MAX(SCORE) OVER (PARTITION BY HAS_RANK) THEN RANK() OVER (ORDER BY SCORE DESC,ID) ELSE RANK[CV(),CV()] END, --IF THE CURRENT ITEM SCORE IS EQUAL TO THE MAX SCORE OF UNRANKED, ASSIGN A RANK
LAST_RANKED_GRP[ANY,ANY] = FIRST_VALUE(GRP_ID) OVER (ORDER BY RANK DESC),
SCORE[ANY,ANY] = CASE WHEN RANK[CV(),CV()] = 0 AND CV(GRP_ID) = LAST_RANKED_GRP[CV(),CV()] THEN SCORE[CV(),CV()]+10 ELSE SCORE[CV(),CV()] END,
ITEM_COUNT[ANY,ANY] = COUNT(*) OVER (),
HAS_RANK[ANY,ANY] = CASE WHEN RANK[CV(),CV()] <> 0 THEN 1 ELSE 0 END --TO SEPARATE RANKED/UNRANKED ITEMS
)
ORDER BY RANK;

select firstname,lastname 
from table1 (nolock) 
left outer join table2 on table1.ID=table2.ID
where isnull(billingaddress, shippingaddress) like 'Lake street'

BEGIN TRANSACTION
BEGIN TRY
    DELETE FROM dbo.MYTABLE WHERE ID=@ID;

    INSERT INTO dbo.MYTABLE (ID, NAME)
       SELECT @ID, NAME

    -- COMMIT only if both DELETE and INSERT worked ....
    COMMIT TRANSACTION
END TRY
BEGIN CATCH
    SELECT 
        ERROR_NUMBER() AS ErrorNumber,
        ERROR_SEVERITY() AS ErrorSeverity,
        ERROR_STATE() AS ErrorState,
        ERROR_PROCEDURE() AS ErrorProcedure,
        ERROR_LINE() AS ErrorLine,
        ERROR_MESSAGE() AS ErrorMessage

    -- ROLLBACK if either DELETE and INSERT failed ....
    ROLLBACK TRANSACTION
END CATCH

SELECT * 
FROM (
    SELECT tpl.*, a.MidParentAId as 'MidParentId', 1 as 'IsMidParentA' 
    FROM TopLevelParent tpl 
    INNER JOIN MidParentA  a ON a.TopLevelParentId = tpl.TopLevelParentID
UNION
    SELECT tpl.*, b.MidParentBId as 'MidParentId', 0 as 'IsMidParentA'  
    FROM TopLevelParent tpl 
    INNER JOIN MidParentB b ON b.TopLevelParentId = tpl.TopLevelParentID
UNION
    SELECT tpl.*, 0 as 'MidParentId', 0 as 'IsMidParentA'  
    FROM TopLevelParent tpl 
    WHERE tpl.TopLevelParentID NOT IN (
       SELECT pa.TopLevelParentID 
       FROM TopLevelParent tpl
       INNER JOIN MidParentA  a ON a.TopLevelParentId = tpl.TopLevelParentID
    UNION
       SELECT pa.TopLevelParentID 
       FROM TopLevelParent tpl
       INNER JOIN MidParentB b ON h.TopLevelParentId = tpl.TopLevelParentID
    )
) tpl
LEFT JOIN MidParentA a ON a.TopLevelParentId = tpl.TopLevelParentID
LEFT JOIN MidParentB b ON b.TopLevelParentId = tpl.TopLevelParentID
LEFT JOIN 
(
        SELECT  [ChildId]
                ,[MidParentAId] as 'MidParentId'
                ,1 as 'IsMidParentA'
        FROM Child c
        WHERE c.MidParentAId IS NOT NULL
   UNION
        SELECT [ChildId]
               ,[MidParentBId] as 'MidParentId'
               ,0 as 'IsMidParentA'
        FROM Child c
        WHERE c.MidParentBId IS NOT NULL
) AS c
ON c.MidParentId = tpl.MidParentId  AND c.IsMidParentA = tpl.IsMidParentA

select col2
from yourtable
group by col2 
having sum(col3=1) > 0 
  and sum(col3=2) > 0
  and sum(col3 not in (1,2)) = 0 

SELECT DISTINCT A.user_id
FROM jos_user_usergroup_map A 
LEFT OUTER JOIN jos_user_usergroup_map B ON A.user_id = B.user_id AND B.group_id = 12 
WHERE B.user_id IS NULL;

select x 
from (
  select x ,
  case when x = 'a' then 'z' else x end as y
  from 
    (select 'a' as x),
    (select 'b' as x),
    (select 'c' as x),
    (select 'd' as x)
  )
order by y desc

SELECT t1.id_user, t1.username
FROM user t1
LEFT JOIN block_user t2
ON 
   (t2.user_request = <current user id> AND t2.user_banned = t1.id_user)
   OR
   (t2.user_request = t1.id_user AND t2.user_banned = <current user id>)
WHERE t2.id_block IS NULL;

update MainTable set active = b'0' where lastprocessdate < '2011-05-21';

SELECT @BaseProductId, Id, Row_Number() OVER (ORDER BY ....),
@UserId, GETUTCDATE(), @UserID, GETUTCDATE() FROM @ImageIDs;

INSERT INTO school_entries (`date`,`secondfield`,...)
SELECT 
    `date` + 7 AS `date`,
    `secondfield`,
    ...
    /** 
     * YOU HAVE TO MANNUALLY SELECT ALL REQUIRED FIELDS
     * EXCEPT PRIMARY KEY, OR IF THERE IS ANY UNIQUE FIELDS
     * OTHERISE YOU'LL GET DUPLICATE ENTRY ERROR 
     */
FROM school_entries   
WHERE `date` BETWEEN DATE('$date') AND DATE_ADD(DATE('$date'), INTERVAL 6 DAY) 

    BEGIN TRANSACTION

    DECLARE @tmpTablesToDelete TABLE ( 
                                        RowNumber INT PRIMARY KEY
                                       ,Query NVARCHAR(MAX)
                                     )

    INSERT INTO
            @tmpTablesToDelete 
    SELECT 
         RowNumber = ROW_NUMBER() OVER (ORDER BY (SELECT (0)))
        ,'DROP TABLE '+schemas.name+'.'+objects.name AS Query
    FROM 
        sys.objects 
    INNER JOIN
        sys.schemas
    ON
        schemas.schema_id = objects.schema_id
    WHERE 
        type = 'U' AND objects.name like 'g_str%'

    DECLARE @Counter INT
    SELECT @Counter = MAX(RowNumber) FROM @tmpTablesToDelete

    WHILE(@Counter > 0) BEGIN

        DECLARE @Query NVARCHAR(MAX)

        SELECT @Query = Query FROM @tmpTablesToDelete WHERE RowNumber = @Counter

        PRINT @Query

        EXEC sp_executesql @statement = @Query

        SET @Counter = @Counter - 1

    END

    COMMIT TRANSACTION

SELECT * FROM [INDEX] AS i 
WHERE
        i.area = Forms![SearchForm]![txtArea]
    AND i.[project year] = Forms![SearchForm]![txtProjectYear]

select t2.Id,
       t2.Name, 
       t2.ExternalId,
       t2.DeviceName, 
       t2.DeviceLocation, 
       t2.Version, 
       t1.AdditionalColumn1,
       t1.AdditionalColumn2
from 
(select ExternalID, max(Version) as Version from Table2 group by ExternalID) tmp
join Table2 t2 on tmp.ExternalID = t2.ExternalID and tmp.Version = t2.Version
join Table1 t1 on t1.DeviceName = t2.DeviceName and t1.DeviceLocation = t2.DeviceLocation

order by decode(?, 'colA', colA, 'colB', colB)

CREATE TABLE Games(
    GameID int IDENTITY(1,1),
    ...Other Columns,
    CONSTRAINT PK_Games PRIMARY KEY CLUSTERED(GameID))

    SELECT
        ProductID, 
        SUM(Case When IsCreditor = 1 then TotalQty else 0 end) AS [TotalPurchase],
        SUM(Case When IsCreditor = 0 then TotalQty else 0 end) AS [TotalSale]
    FROM
        TestTable
    GROUP BY
        ProductID

select *
from event
order by abs(datediff(event_date, now()))
limit 4

@TableId int
As

Declare @nameoftable varchar(50)
select @nameoftable = Nameoftable from tablelist where id = @tableid

-- returning on selected table

declare @sql nvarchar(1000)
set @sql = 'Select somestuff from ' + Quotename(@nameoftable)
exec(@sql)

 SELECT entries.*
      , categories.name      AS name_cat
      , areas.name           AS name_area
      , sub_categories.name  AS name_sub
   FROM entries
   LEFT
   JOIN areas
     ON areas.id = entries.area
   LEFT
   JOIN sub_categories
     ON sub_categories.id= entries.id_sub
   LEFT
   JOIN categories
     ON categories.id = entries.id_cat
  WHERE 1=1
  ORDER BY entries.id DESC

SQL> create trigger this_wont_work
  2  after insert on emp
  3  begin
  4    commit;
  5  end;
  6  /

Trigger created.

SQL> insert into emp (empno) values (123)
  2  /
insert into emp (empno) values (123)
            *
ERROR at line 1:
ORA-04092: cannot COMMIT in a trigger
ORA-06512: at "TONY.THIS_WONT_WORK", line 2
ORA-04088: error during execution of trigger 'TONY.THIS_WONT_WORK'

SELECT * FROM DATABASE_TABLE
    WHERE strftime('%Y-%m-%d',DATE) >= date('now','-6 days') AND 
    strftime('%Y-%m-%d',DATE)<=date('now') order by DATE

SELECT * FROM
(
  SELECT Period, [Returns], value
  FROM MyTable
  CROSS APPLY
  (
    SELECT 'Portofolio', CAST(Portofolio as varchar(10)) 
    UNION ALL
    SELECT 'Benchmark', CAST(Benchmark as varchar(10)) 
  ) c([Returns], value)
) d
PIVOT
(
    MAX(value)
    FOR Period IN (Pre0Month, Pre1Month, Pre2Month)
) piv;

select winner,loser,date,cnt from (select winner, loser, date, date - lag(date,3) over ( order by date) as cnt  from playday) where cnt >=3

SELECT
    CASE
        WHEN A IS NOT NULL THEN 'A'
        WHEN B IS NOT NULL THEN 'B'
        WHEN C IS NOT NULL THEN 'C'
        WHEN D IS NOT NULL THEN 'D'
    END
FROM
    MyTable

SELECT  *
FROM    Patients p
        CROSS APPLY ( SELECT    MAX(ModifiedAt) AS ModifiedAt
                      FROM      ResultsStored rs
                      WHERE     p.RowId = rs.RowId
                    ) a
WHERE   a.ModifiedAt > p.ModifiedAt

let date = fromGregorian 2014 1 1
    time = timeOfDayToTime $ TimeOfDay 0 0 0
posts <- runDB $ selectList [PostDate >. UTCTime date time] [Desc PostDate]

 SELECT  'Column2' as ColumnName, COUNT(column1) AS Expr1
    FROM     Table1

SELECT 
     c.MemeberID
     , m.MemberName
     , m.ContactNumber
FROM 
     class c
     INNER JOIN members m ON
         c.MemberID = m.MemberID 
WHERE c.classID = @classID

(DATEPART(hour, sja.stop_execution_date) = 4 and (DATEPART(minute, sja.stop_execution_date) > 10)
OR DATEPART(hour, sja.stop_execution_date) > 4

UPDATE bank_account acct
   SET balance = balance + (SELECT SUM(th.value)
                              FROM transaction_history th
                             WHERE th.bankID = acct.bankID)
 WHERE EXISTS( SELECT 1
                 FROM transaction_history th
                WHERE th.bankID = acct.bankID )

UPDATE TableOne SET TABLE_TWO_ID = null;
DELETE FROM TableTwo;
DELETE FROM TableOne;

SELECT id, lead(timestampstart) OVER (ORDER BY timestampstart) -
           timestampend AS timetonext
FROM routes;

SELECT 
    SUBSTRING(col, PATINDEX('%[a-zA-Z][a-zA-Z][0-9][0-9][0-9][0-9][0-9]%', '' + col), 7)
FROM TEST
WHERE PATINDEX('%[a-zA-Z][a-zA-Z][0-9][0-9][0-9][0-9][0-9]%', '' + col) <> 0

regexp_replace(:P14_search_text, '[[:space:]]*', '');

select * from table where timestamp > now() - interval '1 month'

subdate(currentDate, 1)

MAC_ADDRESSES_TABLE 
MAC_ID (PK)     MAC_ADDRESS
1               00-B0-D0-86-BB-F7
2               00-B1-D0-86-BC-F8
3               00-B2-D0-86-BD-F9
4               00-B3-D0-86-BE-A7
5               00-B4-D0-86-BF-A9
…                …


MAC_ACTIVITIES_TABLE                    
MAC_ACTIVITY_ID (PK)    MAC_ID (FK)     REF_NUM         DATETIME      LONG          LAT
1                              1           A1       1/20/2013 13:40   40.689060   74.044636
2                              1           B2       1/21/2013 13:40   40.689061   74.044636
3                              3           C3       1/22/2013 13:40   40.689062   74.044636
4                              4           A5       1/23/2013 13:40   40.689063   74.044636
5                              4           D9       1/24/2013 13:40   40.689064   74.044636
…                              …           …         …                 …          …

SELECT ROUND(0.1428571428571428571428571428571428571429 * 10, 1)

ourDatabase.execSQL("delete from <TableName>");

function (doc, req) {

    var body = JSON.parse(req.body || '{}') || {};

    if (doc == null) doc = {
        _id: req.id,
        type: 'user'
    };

    doc.name = body.name;
    doc.roles = body.roles;
    doc.salt = req.uuid;
    doc.password_scheme = 'simple';
    doc.password_sha = hex_sha1(body.password + doc.salt);

    return [doc, { json: doc }];
}

select distinct col1 from test where 
    col1 not in (select col1 from test where col2 = 0)

;WITH PartitionedComponents AS
(
   SELECT 
       CollectionID = c.ID, 
       c.Name, 
       c.Description,
       MediaObjectId = m.ID,
       ROW_NUMBER() OVER(PARTITION BY c.ID ORDER BY m.ID DESC) AS 'RowNum'
   FROM 
       dbo.BB_Collection c
   INNER JOIN
       dbo.BB_MEDIAOBJECT_COLLECTION mc ON mc.CollectionId = c.ID
   INNER JOIN
       dbo.BB_MEDIAOBJECT m ON mc.MediaObjectId = m.Id
   WHERE
       ......
)
SELECT 
   CollectionID, 
   Name, 
   Description,
   MediaObjectId
FROM 
   PartitionedComponents
WHERE
   RowNum <= 10

CREATE OR REPLACE FUNCTION reencode(string IN VARCHAR2) RETURN VARCHAR2
AS
    encoded VARCHAR2(32767);
    type  array_t IS varray(3) OF VARCHAR2(15);
    array array_t := array_t('AL32UTF8', 'WE8MSWIN1252', 'WE8ISO8859P1');
BEGIN
    FOR I IN 1..array.count LOOP
        encoded := CASE array(i)
            WHEN 'AL32UTF8' THEN string
            ELSE CONVERT(string, 'AL32UTF8', array(i))
        END;
        IF instr(
            rawtohex(
                utl_raw.cast_to_raw(
                    utl_i18n.raw_to_char(utl_raw.cast_to_raw(encoded), 'utf8')
                )
            ),
            'EFBFBD'
        ) = 0 THEN
            RETURN encoded;
        END IF;
    END LOOP;
    RAISE VALUE_ERROR;
END;

select
  t1.*,
  t2.*,
  t1.GeoLoc.STDistance(t2.GeoLoc) as DistanceApart
from table1 t1
join table2 t2
on (t1.GeoLoc.STDistance(t2.GeoLoc) <= @distanceX)

 ddply(tab, .(time, id), summarise, product = paste(product, collapse="&"))

update items i
    set baseunitid = ut.baseunitid
    from units u join
         unittypes ut
         on ut.unittypeid = u.unittypeid
    where i.unitid = u.unitid;

select count(distinct SAMPNAME),
       (select sum(ss)
        from (select distinct SAMPNAME,
                              SAMPSIZE as ss
              from TEST_TABLE as T2
              where T2.TC_ID = T1.TC_ID)
       ),
       TC_ID
from TEST_TABLE as T1
group by TC_ID

SELECT     tmp5.SerialNumber, tmp5.StationID, tmp4.ParamCount, tmp4.ParamName, tmp5.ParamValue, tmp5.LSL, tmp5.USL, tmp5.ParamUnits, 
                  tmp5.TestDate
FROM         (SELECT     COUNT(ParamName) AS ParamCount, ParamName
                   FROM          (SELECT     Tests.T_Idx, Products.SerialNumber, Products.StationID, Tests.ParamName, Tests.ParamValue, Tests.LSL, Tests.USL, 
                                                                  Tests.ParamUnits, Products.TestDate
                                           FROM          Tests INNER JOIN
                                                                  Products ON Tests.P_Idx = Products.P_idx
                                           WHERE      (Products.ProductID = @ProductID) AND (Products.TestID = 1) AND (Tests.ParamState = 0) AND 
                                                                  (Tests.ParamName <> 'UUT Test State') AND (Tests.ParamName <> 'Total Test Time') AND (Products.TestDate BETWEEN 
                                                                  @StartDate AND DATEADD(second, - 1, DATEADD(day, 1, @EndDate))) AND (Tests.T_Idx IN
                                                                      (SELECT     MIN(Tests_3.T_Idx) AS TestIdx
                                                                        FROM          Tests AS Tests_3 INNER JOIN
                                                                                               Products AS Products_3 ON Tests_3.P_Idx = Products_3.P_idx
                                                                        WHERE      (Products_3.ProductID = @ProductID) AND (Products_3.TestID = 1) AND (Tests_3.ParamState = 0) AND 
                                                                                               (Tests_3.ParamName <> 'UUT Test State') AND (Tests_3.ParamName <> 'Total Test Time') AND 
                                                                                               (Products_3.TestDate BETWEEN @StartDate AND DATEADD(second, - 1, DATEADD(day, 1, @EndDate)))
                                                                        GROUP BY Products_3.SerialNumber))) AS tmp3
                   GROUP BY ParamName) AS tmp4 LEFT OUTER JOIN
                      (SELECT     MIN(Tests_2.T_Idx) AS TestIdx, Products_2.SerialNumber, Products_2.StationID, Tests_2.ParamName, Tests_2.ParamValue, 
                                               Tests_2.LSL, Tests_2.USL, Tests_2.ParamUnits, Products_2.TestDate
                        FROM          Tests AS Tests_2 INNER JOIN
                                               Products AS Products_2 ON Tests_2.P_Idx = Products_2.P_idx
                        WHERE      (Products_2.ProductID = @ProductID) AND (Products_2.TestID = 1) AND (Tests_2.ParamState = 0) AND 
                                               (Tests_2.ParamName <> 'UUT Test State') AND (Tests_2.ParamName <> 'Total Test Time') AND (Products_2.TestDate BETWEEN 
                                               @StartDate AND DATEADD(second, - 1, DATEADD(day, 1, @EndDate))) AND (Tests_2.T_Idx IN
                                                   (SELECT     MIN(Tests_1.T_Idx) AS TestIdx
                                                     FROM          Tests AS Tests_1 INNER JOIN
                                                                            Products AS Products_1 ON Tests_1.P_Idx = Products_1.P_idx
                                                     WHERE      (Products_1.ProductID = @ProductID) AND (Products_1.TestID = 1) AND (Tests_1.ParamState = 0) AND 
                                                                            (Tests_1.ParamName <> 'UUT Test State') AND (Tests_1.ParamName <> 'Total Test Time') AND 
                                                                            (Products_1.TestDate BETWEEN @StartDate AND DATEADD(second, - 1, DATEADD(day, 1, @EndDate)))
                                                     GROUP BY Products_1.SerialNumber))
                        GROUP BY Products_2.SerialNumber, Products_2.StationID, Tests_2.ParamName, Tests_2.ParamValue, Tests_2.LSL, Tests_2.USL, 
                                               Tests_2.ParamUnits, Products_2.TestDate) AS tmp5 ON tmp4.ParamName = tmp5.ParamName
ORDER BY tmp4.ParamCount DESC

select
  t4.Value
from
  [Table 1] as t1
  inner join [Table 2] as t2 on t2.Tb1GID = t1.GID
  inner join [Table 4] as t4 on t4.Tb2GID = t2.GID
  inner join [Table 3] as t3 on t3.GID = t4.Tb3GID
where
  t1.Info1 = @Info1 and
  t2.Info2 = @Info2 and
  t3.Info3 = @Info3

select r.rule_id, count(*)
from alarms a join
     rules r
     on ',' || a.rule_ids || ',' like '%,' || r.rule_id || ',%'
group by r.rule_id;

UPDATE table1
SET table1.column1 = table2.column1
FROM table1 JOIN
     table2 on table1.column2 = table2.column2

SELECT SUM(OD.quantityOrdered)
 FROM OrderDetails OD JOIN Offices O 
 ON OD.somecol=O.someothercol

SELECT * FROM
(
    (SELECT * FROM table WHERE something = 1) a,
    (SELECT * FROM table WHERE something = 2) b,
    (SELECT * FROM table WHERE something = 3) c
)

SELECT  SUM( CASE WHEN w.invoiceDate < DATE_SUB(curdate(), INTERVAL 10 DAY) THEN 1 ELSE 0 END) AS '10 Days',
        SUM( CASE WHEN w.invoiceDate < DATE_SUB(curdate(), INTERVAL 20 DAY) THEN 1 ELSE 0 END) AS '20 Days'
FROM    tbl_Invoice w 
WHERE   w.invoiceId NOT IN( 
                            SELECT  inv.invoiceId 
                            FROM    tbl_InvoiceAllocation inv) 
AND     w.invoiceDate < DATE_SUB(curdate(), INTERVAL 20 DAY)

R:\>tnsping someconnection

TNS Ping Utility for 32-bit Windows: Version 9.0.1.3.1 - Production on 27-AUG-20
08 10:38:07

Copyright (c) 1997 Oracle Corporation.  All rights reserved.

Used parameter files:
C:\Oracle92\network\ADMIN\sqlnet.ora
C:\Oracle92\network\ADMIN\tnsnames.ora

TNS-03505: Failed to resolve name

R:\>


R:\>tnsping entpr01

TNS Ping Utility for 32-bit Windows: Version 9.0.1.3.1 - Production on 27-AUG-20
08 10:39:22

Copyright (c) 1997 Oracle Corporation.  All rights reserved.

Used parameter files:
C:\Oracle92\network\ADMIN\sqlnet.ora
C:\Oracle92\network\ADMIN\tnsnames.ora

Used TNSNAMES adapter to resolve the alias
Attempting to contact (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (COMMUNITY = **)
 (PROTOCOL = TCP) (Host = ****) (Port = 1521))) (CONNECT_DATA = (SID = ENTPR0
1)))
OK (40 msec)

R:\>

SELECT to_number(e.ID) AS "CODE-AFD",
       e.DESCRIPCION AS "DESCRIPTION-AFD",
       t.CODERRORGENESIS AS "CODE-GEN",
       t.DESCRIPCIONERROR AS "DESCRIPTION-GEN"
  FROM errores e
  INNER JOIN TRADUCTORAGENESISAFD t
    ON t.CODERRORAFD = e.ID
  WHERE e.ID = NVL(p_CodAFDm e.ID)
  order by t.CODERRORAFD DESC

select decode(kpi_def_id,NULL,'N',
       case when instr(ini||curr||downtime||manual,'N',1) = 0 
       then status else 'N' end)
from ex_6

SELECT SUM(
 GREATEST(0, 
  DATEDIFF(
   LEAST('2013-01-01', vacation_end_date),
   GREATEST('2012-01-01', vacation_start_date)
))) 'VACATION_DAYS'
FROM vacation;

;WITH CTE AS
(
   SELECT 
      Column1, Column2, Column3,
      (your list of additional columns - if needed),
      RN = ROW_NUMBER() OVER (ORDER BY InsertionDate)
)
SELECT 
    FirstValue = (SELECT Column1 FROM CTE WHERE RN = N),
    SecondValue = (SELECT Column2 FROM CTE WHERE RN = M),
    ThirdValue = (SELECT Column3 FROM CTE WHERE RN = K)

select t.*,
       (select min(ReturnDate) from t t2 where t.bookid = t2.bookid and t2.id > t.id and t2.type = 0) as ReturnDate
from t
where type = 1

SELECT owner, table_name
  FROM dba_tables
 WHERE table_name = 'PLAN_TABLE'

CREATE TABLE tableC AS
SELECT tableA.*
FROM tableA LEFT SEMI JOIN tableB on (tableA.id = tableB.id);

DECLARE @tbl TABLE(UPRN VARCHAR(100),ProductType FLOAT);
INSERT INTO @tbl VALUES('valid Float',123.45)
                      ,('Float is zero',0.0)
                      ,('Float is missing',NULL);
SELECT *
FROM @tbl AS tbl
FOR XML PATH('XML_DATA'),ROOT('SURVEYDATA');

/* Result
<SURVEYDATA>
  <XML_DATA>
    <UPRN>valid Float</UPRN>
    <ProductType>1.234500000000000e+002</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is zero</UPRN>
    <ProductType>0.000000000000000e+000</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is missing</UPRN>
  </XML_DATA>
</SURVEYDATA>
*/

SELECT tbl.UPRN 
      ,CAST(tbl.ProductType AS DECIMAL(12,4)) AS ProductType
FROM @tbl AS tbl
FOR XML PATH('XML_DATA'),ROOT('SURVEYDATA');

/* Result with "nicer" numbers, but the empty one is missing...
<SURVEYDATA>
  <XML_DATA>
    <UPRN>valid Float</UPRN>
    <ProductType>123.4500</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is zero</UPRN>
    <ProductType>0.0000</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is missing</UPRN>
  </XML_DATA>
</SURVEYDATA>
*/

SELECT tbl.UPRN 
      ,CAST(tbl.ProductType AS DECIMAL(12,4)) AS ProductType,'' AS ProductType
FROM @tbl AS tbl
FOR XML PATH('XML_DATA'),ROOT('SURVEYDATA');

/* Result, "nicer" numbers and the empty one appears as empty tag.
The trick: There are two elements with the same name and they are concatenated implicitly... 
Nothing plus an empty string is: the empty string!
<SURVEYDATA>
  <XML_DATA>
    <UPRN>valid Float</UPRN>
    <ProductType>123.4500</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is zero</UPRN>
    <ProductType>0.0000</ProductType>
  </XML_DATA>
  <XML_DATA>
    <UPRN>Float is missing</UPRN>
    <ProductType></ProductType>
  </XML_DATA>
</SURVEYDATA>
*/

DELETE  a
FROM    table1 a
        INNER JOIN table2 b
            ON  a.Stall = b.Stall AND
                a.Fruit = b.Fruit

Select T1.ID1, T1.ID2, T1.ID3, T21.Translation as Name1, T22.Translation  as Name2, T23.Translation  as Name3,
from Table1 T1 left join Table2 T21 on T1.Id1 = T21.Table1_ID
   left join Table2 T22 on T1.Id2 = T22.Table1_ID
   left join Table2 T23 on T1.Id3 = T23.Table1_ID

update yourTable t1, yourTable t2 set 
t1.tx_latitude = t2.tx_latitude,
t1.tx_longitude = t2.tx_longitude
where t1.class = 'R' and t2.class = 'T' and t1.callsign = t2.callsign

CREATE TABLE contacts(
  name CHAR(10) NOT NULL,
  address INTEGER,
  phone INTEGER NOT NULL,
  song VARCHAR(255),
  PRIMARY KEY (name, phone)
)

select
  student.id, student.student, language.language
from
  student left join language
      on student.languageid = language.languageid

UPDATE data_tab tab1
   SET value = (SELECT tab2.value
                FROM data_tab tab2
                WHERE tab1.id = tab2.id AND
                      tab2.sub_id = 3
              )
   WHERE tab1.id in (select id from ids_table) and
         tab1.sub_id = 2;

SELECT Doc_Name, 
       CASE WHEN 
              COUNT(CASE WHEN Doc_Owner <> Doc_Run_by THEN 1 END) > 0 THEN 'Y'
            ELSE 'N'
       END AS Share_Status
FROM Log_Table 
GROUP BY Doc_Name

;WITH Firsts AS (
    SELECT t1.dt
        ,MIN(t2.dt) AS Prevdt
    FROM t AS t1
    INNER JOIN t AS t2
        ON t1.dt < t2.dt
        AND t2.cyclestate <> t1.cyclestate
    GROUP BY t1.dt
)
SELECT MIN(t1.dt) AS dt_start
    ,t2.dt AS dt_end
FROM t AS t1
INNER JOIN Firsts
    ON t1.dt = Firsts.dt
INNER JOIN t AS t2
    ON t2.dt = Firsts.Prevdt
    AND t1.cyclestate <> t2.cyclestate
GROUP BY t2.dt
    ,t2.cyclestate
HAVING MIN(t1.cyclestate) = 0

function load_listbox(hObject,handles) 

    conn = database('antoine_db','','');
    setdbprefs('datareturnformat','structure'); %sets the db preferences to a structure
    query = 'SELECT ID,"Compound Name" FROM antoine_data ORDER BY ID';

    result = fetch(conn,query);

    %%The following creates a structure containing the names and ID's
    %%of everything in the database
    data = struct([]);
    for i=1:length(result.ID)
        data(i).id =   result.ID(i);
        data(i).name = (result.CompoundName(i));        %this is a cell
        names(i) = data(i).name;
    end



    handles.compounds = names;
    set(handles.listbox1,'String',handles.compounds,'Value',1);

handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

end

select id,
       max(case when seqnum = 1 then value end) as value1,
       max(case when seqnum = 2 then value end) as value2,
       max(case when seqnum = 3 then value end) as value3
from (select t.*,
             row_number() over (partition by id order by (select null)) as seqnum
      from t
     ) t
group by id;

DECLARE @ID int

SET @ID = 1;

WITH CTE_Table_1
(
  ID,
  Name,
  ParentID,
  TreeLevel
)
AS(
 SELECT 
  ID,
  Name,
  ParentID,
  0 AS TreeLevel
 FROM Table_1
 WHERE ID = @ID

UNION ALL

 SELECT 
  T.ID,
  T.Name,
  T.ParentID,
  TreeLevel + 1
 FROM Table_1 T
 INNER JOIN CTE_Table_1 ON CTE_Table_1.ID = T.ParentID
)

SELECT * FROM CTE_Table_1

With 
    Member X As 
       ( 
          [Measures].[Circulation Count] , 
          (
              [Circulation Kind].[Circulation Code].&[1]
          ) 
       )

Select 
    X On Columns
From <>

insert into table (columns_names_here)
select    
   col.table_name, .... 
   case when col.is_nullable = 'YES' then 1 else 0 end as enabled, 
   col.data_type
from 
 ....

select
 a.*
from Album as a
where a.Album_Id not in 
(
    select
     at.Album_Id
    from AlbumTrack as at
        join Track as t
        on t.Track_Id = at.Track_Id
    where t.TrackName ='SomeTrack1'
)

SELECT * from dat a, dat b 
WHERE a.id < b.id 
    AND a.s < b.e 
    AND a.e > b.s

SELECT 
id, 
name, 
city, 
state, 
country, 
date,
MATCH(name, city, state, country) AGAINST ('$str') AS relevancy 
FROM 
events_search 
WHERE 
MATCH(name, city, state, country) AGAINST ('$str')
ORDER BY relevancy DESC

  SELECT t.name,
         MAX(CASE WHEN t.stat = 'stat1' THEN t.value ELSE NULL END) AS stat1,
         MAX(CASE WHEN t.stat = 'stat2' THEN t.value ELSE NULL END) AS stat2,
         MAX(CASE WHEN t.stat = 'stat3' THEN t.value ELSE NULL END) AS stat3,
         MAX(CASE WHEN t.stat = 'stat4' THEN t.value ELSE NULL END) AS stat4
    FROM TABLE t
GROUP BY t.name

    try
    {
        var bindingSource1 = new BindingSource();

        // Automatically generate the DataGridView columns.
        dataGridView1.AutoGenerateColumns = true;

        // Set up the data source.
        bindingSource1.DataSource = GetData("Select * From UsersTable Inner Join ActivitiesTable"));
        dataGridView1.DataSource = bindingSource1;

        // Automatically resize the visible rows.
        dataGridView1.AutoSizeRowsMode = 
DataGridViewAutoSizeRowsMode.DisplayedCellsExceptHeaders;
    }
    catch (SqlException)
    {
        // TODO manage errors
    }
}

private static DataTable GetData(string sqlCommand)
{
    var connectionString = "%your connection string%";
    var northwindConnection = new SqlConnection(connectionString);
    var command = new SqlCommand(sqlCommand, northwindConnection);
    var adapter = new SqlDataAdapter();

    adapter.SelectCommand = command;

    var table = new DataTable();
    table.Locale = System.Globalization.CultureInfo.InvariantCulture;
    adapter.Fill(table);

    return table;
}

SELECT cl.*, c.*, s.*, o.*, p.*, count(r.rating)
FROM COMPANY_LOCATION__K cl
INNER JOIN COMPANY__K c on c.COMPANY_ID__K = cl.COMPANY_ID__K
INNER JOIN SOCIAL_MEDIA__K s on cl.COMPANY_ID__K = s.COMPANY_ID__K
INNER JOIN OPERATIONAL_HOURS__K o on cl.LOCATION_ID__K = o.LOCATION_ID__K
INNER JOIN PERMISSIONS__K p on cl.LOCATION_ID__K = p.LOCATION_ID__K
LEFT OUTER JOIN REVIEW__K r on cl.LOCATION_ID__K = r.LOCATION_ID__K
GROUP BY cl.LOCATION_ID
ORDER BY DISTANCE__K
LIMIT 100;

SELECT
  pl_scores.*
FROM
  pl_scores
INNER JOIN
  (SELECT MAX(updatedAt) AS maxUpdatedAt FROM pl_scores GROUP BY DATE(updatedAt)) as Lookup
    ON Lookup.MaxUpdatedAt = pl_scores.updatedAt

select ASIN
from aboProducts
    left join lowestprices
        on aboProducts.asin = lowestprices.productAsin
        and lowestprices.pricedate > (GETDATE()-1)
where lowestprices.productAsin is null
and aboProducts.amzlive=1

SELECT *
FROM table1, table2,
(SELECT user_id AS lUserid, MAX(season) AS lSeason FROM table2 GROUP BY user_id) AS lTable2
WHERE table1.user_id = table2.user_id
AND table2.user_id = lTable2.lUserid
AND table2.season = lTablle2.lSeason

SELECT username  
FROM 
  (SELECT username  
   FROM table  
   ORDER BY userid DESC)
WHERE rownum <= 50

select city
  from vwpersonprimaryaddress
 where state in ( 
           select regexp_substr(v_province,'[^'',]+', 1, level) 
             from dual
          connect by regexp_substr(v_province, '[^'',]+', 1, level) is not null
                  )

Id(x => x.Id).Column("ID").GeneratedBy.SequenceIdentity("Your_Sequence_Name")

select left(path, length('5'||'/') + position('/' in split_part(path||'/', '5'||'/', 2)) - 1) as child,
       count(*) - 1 as numdescendants
from items
where path like '5' || '/' || '%'
group by child;

SELECT CASE WHEN strpos(name,', ') > 0 
            THEN substr(name,strpos(name,', ') + 2)  ||' ' || substr(name,0, strpos(name,', '))
            ELSE NULL END
    FROM person

select 
    m.mstr_list_item_desc,
    p.last_name,
    p.first_name,
    AVG(
        (
        ISNULL(l.percentage_1, 0.0) + 
        ISNULL(l.percentage_2, 0.0) + 
        ISNULL(l.percentage_3, 0.0) + 
        ISNULL(l.percentage_4, 0.0) + 
        ISNULL(l.percentage_5, 0.0) + 
        ISNULL(l.percentage_6, 0.0) +
        ISNULL(l.percentage_7, 0.0) + 
        ISNULL(l.percentage_8, 0.0) + 
        ISNULL(l.percentage_9, 0.0) + 
        ISNULL(l.percentage_10, 0.0) + 
        ISNULL(l.percentage_11, 0.0) + 
        ISNULL(l.percentage_12, 0.0) + 
        ISNULL(l.percentage_13, 0.0)
        )
        /13.0) as Total_average
from 
    LMA_ob_compliance_ as l
    INNER JOIN patient_encounter as pe on l.enc_id=pe.enc_id
    INNER JOIN provider_mstr as p on p.provider_id=pe.rendering_provider_id
    INNER JOIN mstr_lists as m on m.mstr_list_item_id=p.provider_subgrouping1_id
group by 
    m.mstr_list_item_desc, 
    p.last_name, 
    p.first_name
order by 
    p.last_name asc

SELECT top 1 *
FROM CensusFacility_Records
WHERE Division_Program = 'Division 1' 
AND cast(JMS_UpdateDateTime as datetime) = @dateParam

SELECT * FROM
(
    SELECT  LEFT(RSTab1.EventstartDate,6) MONTHtab1
       ,LEFT(RSTab2.EventstartDate,6) MONTHtab2
       ,RSTab1.TigoMainNumber
       ,(SUM(RSTab2.RevenueRWF)+SUM(RSTab1.Revenue)) as Total_RevenueSUM
       ,COUNT(*) as countRevenue



    FROM DWHAUX1.[SubscriberBase].[dbo].[CDRSubscriber_Revenue]AS RSTab1 WITH(NOLOCK) 
    INNER JOIN DWHAUX1.CDRNOrmal.dbo.nrmMSC RSTab2 WITH(NOLOCK) 
    ON  RSTab1.TigoMainNumber= RSTab2.CalledPartyNumber
    WHERE LEFT(RSTab1.EventstartDate,6) BETWEEN 201310 AND 201403 
    OR LEFT(RSTab2.EventstartDate,6) BETWEEN 201310 AND 201403 
    GROUP BY LEFT(RSTab1.EventstartDate,6)
            ,LEFT(RSTab2.EventstartDate,6)
            ,RSTab1.TigoMainNumber
) as Z
WHERE Total_RevenueSUM >680
ORDER BY countRevenue DESC

select TRIM(LEADING '.' from REGEXP_REPLACE(col_name,'^.*((\.[^.]+){3})$', '\1')) AS fixed_dn from table_name;

   WITH TotalTime AS (
        SELECT  
            CAST(DateCreated AS DATE) as [date] 
            ,DATEPART(hour,DateCreated) AS [hour]
            ,SUM(DATEDIFF(second,TimeIn,TimeOut)) AS Total
            ,UserReference 
            ,locationid
        FROM    TimeTable
        GROUP BY UserReference,locationid,CAST(DateCreated AS DATE),DATEPART(hour,DateCreated) 
        HAVING DATEPART(hh,DateCreated) >= 7 and DATEPART(hh,DateCreated) <= 18
    )
    , rn AS (
        SELECT *, ROW_NUMBER() OVER (PARTITION BY [date],[hour],locationid ORDER BY Total DESC) AS row_num
        FROM TotalTime
    )
    SELECT *
    FROM rn 
    WHERE row_num = 1

select CNT,   PATID,     DATE,      PATName, 
row_number() over (partition by PATName order by PATID) as VISIT
from table

Select Title, 
       (SELECT GROUP_CONCAT(Comment) FROM Comments
         WHERE
         Comments.postid=posts.posts) as comments
FROM posts

WITH data (POSITIVEVALUE, NEGATIVEVALUE) AS (
    SELECT  100, NULL FROM DUAL UNION ALL
    SELECT NULL,   50 FROM DUAL UNION ALL
    SELECT   70, NULL FROM DUAL UNION ALL
    SELECT NULL,   80 FROM DUAL UNION ALL
    SELECT  100,   30 FROM DUAL
)
SELECT
    ROWTOTAL,
    SUM(ROWTOTAL) OVER (ORDER BY RN) SUCCESSIVESUM
FROM (
    SELECT
        ROWNUM RN,
        NVL(POSITIVEVALUE, 0) - NVL(NEGATIVEVALUE, 0) ROWTOTAL
    FROM
        data)

Entity (ID (PK), {common fields})
Customer (ID (PK), EntityID (FK), {other fields})
Supplier (ID (PK), EntityID (FK), {other fields})
Telephone (ID (PK), EntityID (FK), Value)

select firstGUID, secondGUID, name, datecreated
from (select t.*, 
             rank() over (partition by secondGUID order by datecreated desc) r
      from TestTable t) ilv
where r=1

ALTER TABLE `product` ADD INDEX `product_category` (`product_category`);
ALTER TABLE `category` ADD PRIMARY KEY(category_id);

select PhoneNo,
count(*) as TotalNumberOfRecords, 
sum(DurationInMinutes) as TotalDurationOfCalls,
count(distinct location) as TotalOfLocations from yourtablename
group by PhoneNo

DECLARE @Words xml
SELECT @Words = '
<word A="al"   B="h"   C="Ps" />
<word A="has"  B="es"  C="Pf" />
<word A="mom"  B="es"  C="Ph" />'

SET @Words.modify('replace value of(/word[@A = "al"]/@B)[1] with "B1"')
SET @Words.modify('replace value of(/word[@A = "al"]/@C)[1] with "C1"')
SET @Words.modify('replace value of(/word[@A = "has"]/@B)[1] with "B2"')
SET @Words.modify('replace value of(/word[@A = "has"]/@C)[1] with "C1"')
SET @Words.modify('replace value of(/word[@A = "mom"]/@B)[1] with "B2"')
SET @Words.modify('replace value of(/word[@A = "mom"]/@C)[1] with "C2"')

SELECT @Words

select '1700' as "LOCATION", round(avg(e.salary),2) AS "AVG SALARY", count(d.LOCATION_ID) as "COUNT"
from departments d
join employees e on e.DEPARTMENT_ID = d.DEPARTMENT_ID
where d.location_id = 1700

union

select '<>1700' as "LOCATION", round(avg(e.salary),2) AS "AVG SALARY", count(d.LOCATION_ID) as "COUNT"
from departments d
join employees e on e.DEPARTMENT_ID = d.DEPARTMENT_ID
where d.location_id <> 1700

select UName from AllData
where id= (select id from SearchTable where LatinNames ="Ahmad")

SELECT  p1.*
FROM    prod_prices p1
        INNER JOIN
        (   SELECT  ID, MAX(Date) AS Date
            FROM    prod_prices
            GROUP BY ID
        ) AS p2
            ON p1.ID = p2.ID 
            AND p1.Date = p2.Date

alter table test add index idx1(site, area, expired, endtime);

declare @a Table (ID varchar(10),Parent Varchar(10))
Insert into @a Values ('A',NULL) ,('B' , 'A'),('C','A'),('E',NULL) ,('F','E')
Select a.ID,b.ID  as GroupMember
from @a a
JOIN @a b ON ISNULL(a.Parent,a.ID)=ISNULL(b.Parent,b.ID) 

SELECT
    GROUP_CONCAT(t.name) AS SubOrganizations
FROM
    tableX AS t
  JOIN
    tableX AS p
      ON  t.treePath LIKE CONCAT( p.treePath, '%') 
      AND t.organizationId <> p.organizationId 
WHERE
    p.organizationId = 10707 ;

db.collection.find({ "field" : { $gt: value1, $lt: value2 } } );    // value1 < field < value

 FROM DI_Intervention_Schedule S
    WHERE
    (S.[ID] = @ID OR @ID IS NULL)
    AND (( S.[StartDateTime] >= @StartDate   AND S.[EndDateTime] <= @EndDate)  OR @StartDate IS NULL )

-- insert into tableA (Date, Id, Name, Zone, hour, observationvalue)
select Date,
  Id,
  Name,
  Zone,
  replace(hour, 'hour', '') hour,
  observationvalue
from tableB
unpivot
(
  observationvalue
  for hour in (Hour1, Hour2, Hour3, Hour4, Hour5...)
) unpiv;

SELECT
    FL.id AS FirstLevelId
    ,FL.active AS FirstLevelActive
    ,SL.id AS SecondLevelId
    -- If First Level is Active, ignore it by passing it as NULL to coalesce, and take the value of Second_Level.active
    -- If First Level is not active, take its value as the "active" value for this level. 
    ,COALESCE(NULLIF(FL.active, 1), SL.active) AS SecondLevelActive
    ,TL.id AS ThirdLevelId
    -- Same as above, but with one more level involved
    ,COALESCE(NULLIF(FL.active, 1), NULLIF(SL.active, 1), TL.active) AS ThirdLevelActive
FROM
    First_Level FL
    LEFT JOIN
    Second_Level SL ON
        (SL.first_level_id = FL.id)
    LEFT JOIN
    Third_Level TL ON
        (TL.second_level_id = SL.id)

$cfg['MaxTableList'] = 250;

ALTER TABLE tableA ADD UNIQUE INDEX idxColAB (columnA, columnB)

SELECT  status, COUNT(*) totalCount
FROM    tableName
GROUP   BY status

SELECT '2015-01-28T17:41:52Z'::timestamptz

SELECT l.id, l.foo, r.id, r.foo
FROM   storyevents l 
         INNER JOIN storyevents r 
               ON l.id = r.id
         RIGHT JOIN 
         (
               SELECT distinct extid, foo 
               FROM storyevents
         ) tmp on l.foo = tmp.foo AND
                  tmp.extid = l.id
where l.foo = 12345

select mdr.invoiceno, mdr.invoicedate, mdr.customerid, mdr.netamount, cus.name,
    max(case when pt.Name = 'Cash' then pay.amount end) CashAmt,
    max(case when pt.Name = 'Cheque' then pay.amount end) ChequeAmt
from customer cus
    ....
group by mdr.invoiceno, mdr.invoicedate, mdr.customerid, mdr.netamount, cus.name
order by mdr.invoiceno

    SELECT
     ROW_NUMBER() OVER(ORDER BY object_id, column_id) as RowNum
    , COUNT(*) OVER(PARTITION BY 1) as TotalRows
    , * 
    FROM master.sys.columns

SELECT cur.car,
    cur.[service date],
    cur.findings
FROM tablename cur
WHERE cur.[service date] = @mydate
    AND EXISTS (
        SELECT 1
        FROM tablename past
        WHERE past.car = cur.car
           AND past.[service date] < cur.[service date]
           AND past.findings = 'oil change'
    )

SELECT *
  FROM (SELECT i.*
          FROM ITEM i
         WHERE i.categoryid = 1
         LIMIT 1),
       (SELECT i.*
          FROM ITEM i
         WHERE i.categoryid = 2
         LIMIT 2),
       (SELECT i.*
          FROM ITEM i
         WHERE i.categoryid = 3
         LIMIT 2)

SELECT table_name
FROM dictionary 
WHERE table_name LIKE 'V$\_%' ESCAPE '\'
  OR table_name LIKE 'ALL\_%' ESCAPE '\'
  OR table_name LIKE 'USER\_%' ESCAPE '\';

// custom CursorAdapter ...

    @Override
    public View newView(Context context, Cursor cursor, ViewGroup parent) {
        View rowView = ((LayoutInflater) context
                .getSystemService("layout_inflater")).inflate(
                R.layout.row_layout, parent, false);
        ViewHolder holder = new ViewHolder();
        holder.v1 = rowView.findViewById(R.id.v1);
        holder.v2 = rowView.findViewById(R.id.v2);
        rowView.setTag(holder);
        return rowView;
    }

    @Override
    public void bindView(View view, Context context, Cursor cursor) {
        ViewHolder holder = (ViewHolder) view.getTag();
        // use the holder filled with views
        // hlder.v1.setSomething
    }

    class ViewHolder {
        View v1, v2;
    }
// ...

select campus,
(
    select avg(wage)
    from 
    (
        select ssn, campus, wage, row_number() over(partition by SSN order by wage) as RN
        from #thetable as inside
        where (inside.campus=outside.campus or outside.campus is null) 
    ) as middle
    where RN=1
)
from #thetable outside
group by cube(campus);

DECLARE @d AS datetime
SET @d = '1/15/2009'
PRINT @d
PRINT DATEADD(day, 8 - DATEPART(weekday, @d), @d)
SET @d = '1/18/2009'
PRINT @d
PRINT DATEADD(day, 8 - DATEPART(weekday, @d), @d)

-- So it should be able to be used inline pretty efficiently:
DATEADD(day, 8 - DATEPART(weekday, datecolumn), datecolumn)

-- If you want to change the first day for a different convention, simply use SET DATEFIRST before performing the operation
-- e.g. for Monday: SET DATEFIRST 1
-- e.g. for Saturday: SET DATEFIRST 6

DECLARE @restore AS int
SET @restore = @@DATEFIRST
SET DATEFIRST 1

DECLARE @d AS datetime
SET @d = '1/15/2009'
PRINT @d
PRINT DATEADD(day, 8 - DATEPART(weekday, @d), @d)
SET @d = '1/19/2009'
PRINT @d

PRINT DATEADD(day, 8 - DATEPART(weekday, @d), @d)
SET DATEFIRST @restore

SELECT Title FROM TableA
UNION ALL
SELECT Title FROM TableB

select * from
( 
SELECT complex_expression() ce
FROM t
)
where ce != '';

---- Create the variables for the random number generation
DECLARE @Random INT;
DECLARE @Upper INT;
DECLARE @Lower INT;
DECLARE @Index integer

---- This will create a random number between 1 and 999
SET @Lower = 1 ---- The lowest random number
SET @Upper = 999 ---- The highest random number
SET @Index = 0 --- A while loop counter

--- Loop from 0 to 10
WHILE @Index < 10
BEGIN
  SELECT 'loop counter = ', @index
  SELECT @Random = ROUND(((@Upper - @Lower -1) * RAND() + @Lower), 0)
  --Insert @Random here.
  SET @index = @index + 1
END

WITH recency_cte --(SalesPersonID, SalesOrderID, SalesYear)
AS
-- Define the CTE query.
(
    SELECT Customer_ID, Customer_class, purchase_day, ROW_NUMBER() OVER (PARTITION BY Customer_ID ORDER BY purchase_day) AS RowNumber
    FROM transactions_table b join customer_table a on customer_id=b.customer_id
     -- (
        --SELECT 1 Customer_ID, 'a' Customer_Class, '6/01/2014' Purchase_Day
        --UNION 
        --SELECT 2 Customer_ID, 'b' Customer_Class, '6/03/2014' Purchase_Day
        --UNION 
        --SELECT 2 Customer_ID, 'b' Customer_Class, '6/04/2014' Purchase_Day
        --UNION 
        --SELECT 2 Customer_ID, 'b' Customer_Class, '6/05/2014' Purchase_Day
        --UNION 
        --SELECT 2 Customer_ID, 'b' Customer_Class, '6/08/2014' Purchase_Day
        --UNION 
        --SELECT 2 Customer_ID, 'b' Customer_Class, '6/12/2014' Purchase_Day
        --UNION 
        --SELECT 1 Customer_ID, 'a' Customer_Class, '6/12/2014' Purchase_Day
     -- )s
    GROUP BY Customer_ID, Customer_class, purchase_day
)
-- Define the outer query referencing the CTE name.
SELECT Day1.customer_class, avg(datediff(day, Day1.Purchase_Day, Day2.Purchase_Day)) AverageDaysBetweenPurchases
FROM 
    recency_cte Day1
     INNER JOIN 
    recency_cte Day2 ON 
        Day1.Customer_ID = Day2.Customer_ID AND 
        Day1.RowNumber + 1 = Day2.RowNumber
group by Day1.Customer_Class

SELECT systimestamp AT TIME ZONE 'GMT'
  FROM dual

UPDATE TBL_RESULTS
SET COST_CENTRE = (SELECT H.COST_CENTRE
                   FROM TBL_HEADER H 
                   WHERE H.HEADER_ID = TBL_RESULTS.HEADER_ID_FK
                  )

SELECT 
    name,
    create_date,
    modify_date
FROM sys.procedures
WHERE create_date = '20120927'  

=Sum(Fields!numOfStudents.Value * Fields!avgGpa.Value)
  / Sum(Fields!numOfStudents.Value)

SELECT COUNT(DISTINCT user_id) AS uniq, SUM(count) AS total
----------------------^
FROM my_table;

(SELECT name, pic0, bio,site
FROM ".$table."
WHERE ( (name LIKE '%john%' OR name LIKE '%smith%') AND site LIKE ('%site1%') )
ORDER BY ( (name LIKE '%john%' OR name LIKE '%smith%') AND site LIKE ('%site1%') ) DESC)
UNION
(SELECT name, pic0, bio,site
FROM ".$table."
WHERE ( name IS NOT NULL AND category IN ('drivers', 'construction') AND site LIKE ('%site1%') )
ORDER BY ( (name LIKE '%john%' OR name LIKE '%smith%') AND site LIKE ('%site1%') ) DESC)  

SELECT * FROM [Employee]
WHERE lname + ', ' + fname in 
(SELECT lname + ', ' + fname as fullname FROM [Employee]
WHERE lname != ' ' AND fname != ' '
GROUP BY lname + ', ' + fname
HAVING COUNT(*) > 1)

WITH    cte
          AS ( SELECT   R.Code ,
                        R.Name ,
                        R.[Department Code] ,
                        R.[Line Role]
               FROM     [Employment Role] R
             )
    SELECT  emp.[First Name] ,
            emp.[Last Name] ,
            f.Name AS [Employee Job Title] ,
            f.[Department          Code] AS [Employee Department] ,
            s.Name AS [Manager Job Title] ,
            s.[Department Code] AS [Manager Department] ,
            snr.Name AS [Senior Manager Job Title] ,
            snr.[Department Code] AS [Senior Manager Department]
    FROM    cte f
            INNER JOIN cte s ON f.[Line Role] = s.Code
            INNER JOIN cte snr ON s.[Line Role] = snr.Code
            INNER JOIN [Employee] Emp ON Emp.[Role Name] = f.Name

SELECT a.table_name
     , a.column_name
     , a.constraint_name
     , c.owner
     , c.r_owner
     , c_pk.table_name      r_table_name
     , c_pk.constraint_name r_pk
     , cc_pk.column_name    r_column_name
  FROM all_cons_columns a
  JOIN all_constraints  c       ON (a.owner                 = c.owner                   AND a.constraint_name   = c.constraint_name     )
  JOIN all_constraints  c_pk    ON (c.r_owner               = c_pk.owner                AND c.r_constraint_name = c_pk.constraint_name  )
  JOIN all_cons_columns cc_pk   on (cc_pk.constraint_name   = c_pk.constraint_name      AND cc_pk.owner         = c_pk.owner            )
 WHERE a.owner = 'BRANCH_DEV'
   AND a.table_name IN ( 'table1','table2' )
     ;

declare @tbl_test table(
    first_name nvarchar(255),
    last_name nvarchar(255),
    [address] nvarchar(255)
);

insert @tbl_test values ('Andrei','Corovei','str Meteor');
insert @tbl_test values ('Pop','Ionut','str Meteor');
insert @tbl_test values ('Whitehead','John','str Lunii');
insert @tbl_test values ('Grisham','Robert','str Corcoduselor');
insert @tbl_test values ('Eugen','Johnesco','str Prunelor');

select
        *
    from
        (select
                row_number() over (partition by r%2 order by first_name) as batch,
                *
            from 
                (select
                        row_number() over (order by first_name) as r,
                        *
                    from
                        @tbl_test
                ) as t
        ) as b
    where
        batch = 2
    order by
        batch, r
;

CREATE TABLE test2(A NUMBER, B NUMBER);

INSERT INTO TEST2 VALUES(1,2);

UPDATE TEST2 SET A=B,B=0;

SELECT *,
    CASE 
        WHEN Active <> 0 AND 
             ISNULL(LAG(Active) OVER (PARTITION BY LocationCode ORDER BY YearMonth), 0) = 0 THEN 1 
        ELSE 0 
    END As New
FROM yourTable;

SELECT COALESCE(email, number)
FROM   tableName

SELECT *, 
       SUM(Sales) OVER (ORDER BY sales DESC, id) as running_sales 
FROM   t
ORDER  BY sales DESC, id;

;WITH Ages AS 
(
  SELECT YEAR(getdate()) - Birthyear AS Age
  FROM people
)
SELECT SUM(CASE WHEN Age BETWEEN 0 AND 20 THEN 1 ELSE 0 END) AS [0-20],
    SUM(CASE WHEN Age BETWEEN 21 AND 40 THEN 1 ELSE 0 END) AS [21-40],
    SUM(CASE WHEN Age BETWEEN 41 AND 60 THEN 1 ELSE 0 END) AS [41-60],
    SUM(CASE WHEN Age BETWEEN 61 AND 100 THEN 1 ELSE 0 END) AS [61-100]
FROM Ages

declare
    tab apex_application_global.vc_arr2;
begin
    tab := apex_util.string_to_table (:p1_multiple_item);
    ...
end;

with maxdate as (
select student_id, max(date_entered) as mxdate 
from student_history
group by student_id)
select s.* 
from student_history s 
join maxdate m on s.student_id = m.student_id and s.date_entered = m.mxdate
where s.section_id in (1,2)

CREATE TABLE ranks
SELECT 0 rank, 20 count
    UNION ALL
SELECT 1 rank, 15 count
    UNION ALL
SELECT 2 rank, 9 count
    UNION ALL
SELECT 6 rank, 3 count
    UNION ALL
SELECT 9 rank, 2 count;

SET @VCounter := -1;

SELECT A.rank, B.count FROM
    (SELECT @VCounter := @VCounter + 1 rank FROM anyTable WHERE @VCounter < 10) A
LEFT JOIN
    ranks B
ON A.rank = B.rank
ORDER BY A.rank;

$mySiteURL = Get-SPSite -Limit 1  -ContentDatabase WSS_Content_DBNAME | select-object -expandproperty url

select b.col1, b.col2, a.col1, a.col2
from a left outer join
     b 
     on a.key = b.key;

SELECT `e`.*, (datediff(e.start, 'someValue')) AS `offset`
FROM `event` AS `e`
HAVING `offset` % someInterval = 0

SELECT bus_name
FROM buses
WHERE id in
(SELECT b.bid
FROM bus_route b
JOIN bus_route _b  
ON b.bid = _b.bid  
WHERE b.rid = 1 AND _b.rid = 2)

select a.*,b.* from testing a, testing b
where a.aid = b.aid(+) 
and a.bid < b.bid(+)
order by a.aid, b.bid;

SELECT  a.*
FROM    tableName a
WHERE   EXISTS
        (
            SELECT  1
            FROM    tableName b
            WHERE   a.ID = b.ID AND
                    a.SubjectID = b.subjectID
            GROUP   BY Id, SubjectId
            HAVING  COUNT(*) > 1
        )

SELECT i.item_id
FROM sale_detail sd
    INNER JOIN item i ON sd.items_id = i.item_ID
    INNER JOIN sale s ON sd.sale_id = s.sale_id
GROUP BY i.item_id HAVING COUNT(s.sale_id) > 2

SELECT d.DeviceName, d.DeviceManufactur, d.AttributeName, d.AttributeValue
FROM aDevice d
WHERE d.DeviceName IN (
    SELECT dd.DeviceName
    FROM aDevice dd
    WHERE EXISTS (SELECT 1 FROM aDevice ddd WHERE AttributeName='Cost' AND AttributeValue='480' AND ddd.DeviceName = dd.DeviceName)
    AND EXISTS (SELECT 1 FROM aDevice ddd WHERE AttributeName ='MappedName' AND AttributeValue = 'DummyString' AND ddd.DeviceName = dd.DeviceName))

select COLUMN_NAME from ALL_TAB_COLUMNS 

MakeChannel = function(dbName){
  system(paste("REG ADD HKEY_CURRENT_USER\\Software\\ODBC\\ODBC.INI\\MyODBClink /f /v \"Database\" /t REG_SZ /d ", "\"", dbName ,"\"", sep=""),intern=T)
  return(odbcConnect("MyODBClink"))
}

"DELETE FROM comments WHERE comment_id='$comment' AND p_id='$pid' AND for_w = '$z'"

DECLARE
   TYPE t_SeatNo is TABLE OF SEATING_PLAN.SeatNo%TYPE INDEX BY BINARY_INTEGER;
   seats t_SeatNo;
BEGIN
   SELECT SeatNo
   BULK COLLECT INTO seats
   FROM SEATING_PLAN
   WHERE Block = 1;

   -- Do what you need with the data

END;

SELECT FLOOR(t1.confidence), AVG(t2.predicted_label)
FROM Table t1
    JOIN Table t2 ON t2.confidence <= t1.Confidence
GROUP BY FLOOR(t1.confidence)

=DATEADD("d", 1 - DATEPART(DateInterval.WeekDay, Today(),FirstDayOfWeek.Monday), Today())

 WITH Tbl AS(
            SELECT  *,STUFF((SELECT ',' + struktur_bolmesi
    FROM tb_Structure WHERE  concat(',',bolmeler,',')  LIKE concat('%,',struktur_id,',%')
    FOR XML PATH('') ), 1, 1, '') 
            as new_column from tb_Customers
    )
    SELECT  *
    FROM    Tbl
    WHERE   new_column LIKE '%text%' 

SELECT data.content,item.value
FROM contents 
 AS data 
JOIN items 
 AS item 
WHERE data.id=item.content_id 
ORDER BY data.release_date DESC
LIMIT 50

ALTER PROCEDURE [dbo].[spFormula1_Save]
    @Formula1Xml xml--Formula1 as xml
AS
BEGIN 
    -- SET NOCOUNT ON added to prevent extra result sets from
    -- interfering with SELECT statements.
    SET NOCOUNT, XACT_ABORT ON;

    IF DATALENGTH(@Formula1Xml) = 0
        RETURN 0

------------------------
--Xml shredding
------------------------
-- I prefer using the new XML methods (nodes, value, exist) instead of sp_xml_preparedocument + OPENXML 
-- because you may get memory leaks if we don't use sp_xml_removedocument
DECLARE @Formula1_Table TABLE
(
    M_iFormula1Id bigint,
    Rnk bigint primary key, -- It's used to unique identify the old and the new rows
    M_bDataInUse bit,
    M_bActive bit
);
INSERT  @Formula1_Table (M_iFormula1Id, Rnk, M_bDataInUse, M_bActive)
SELECT  x.XmlCol.value('(M_iFormula1Id)[1]', 'BIGINT') AS M_iFormula1Id,
        ROW_NUMBER() OVER(ORDER BY x.XmlCol) AS Rnk, -- It's used to unique identify the old and the new rows
        x.XmlCol.value('(M_bDataInUse)[1]', 'BIT') AS M_bDataInUse,
        x.XmlCol.value('(M_bActive)[1]', 'BIT') AS M_bActive
FROM    @Formula1Xml.nodes('/root/Formula1') x(XmlCol);

DECLARE @Formula1_M_lstItem_Table TABLE
(
    M_iFormula1Id bigint,
    Rnk bigint, -- It's used to unique identify new "Formula1" rows (those rows having M_iFormula1Id=0)
    M_iItemId bigint,
    M_iItemTypeId bit,
    M_sItemValue varchar(1000),
    M_iRaceId int,
    M_iDriverId int
);
INSERT  @Formula1_M_lstItem_Table 
(
    M_iFormula1Id,
    Rnk, 
    M_iItemId,
    M_iItemTypeId,
    M_sItemValue,
    M_iRaceId,
    M_iDriverId
)
SELECT  /*x.XmlCol.value('(M_iFormula1Id)[1]', 'BIGINT')*/ 
        -- At this moment we insert only nulls
        NULL AS M_iFormula1Id,
        DENSE_RANK() OVER(ORDER BY x.XmlCol) AS Rnk, -- It's used to unique identify new and old "Formula1" rows
        y.XmlCol.value('(M_iItemId)[1]', 'BIGINT') AS M_iItemId,
        y.XmlCol.value('(M_iItemTypeId)[1]', 'BIT') AS M_iItemTypeId,
        y.XmlCol.value('(M_sItemValue)[1]', 'VARCHAR(1000)') AS M_sItemValue,
        y.XmlCol.value('(M_iRaceId)[1]', 'INT') AS M_iRaceId,
        y.XmlCol.value('(M_iDriverId)[1]', 'INT') AS M_iDriverId
FROM    @Formula1Xml.nodes('/root/Formula1') x(XmlCol)
CROSS APPLY x.XmlCol.nodes('M_lstItem') y(XmlCol);
------------------------
--End of Xml shredding
------------------------


BEGIN TRANSACTION
BEGIN TRY

-------------------
--Formula1 Table
-------------------
DECLARE @Merged_Rows TABLE
(
    Merge_Action nvarchar(10) not null,
    Rnk bigint not null,
    M_iFormula1Id bigint -- The old id's and the new inserted id's.
);
DECLARE @Formula1Id bigint = 0;

    MERGE INTO Formula1 WITH(HOLDLOCK) AS tab -- To prevent race condition. http://weblogs.sqlteam.com/dang/archive/2009/01/31/UPSERT-Race-Condition-With-MERGE.aspx
    USING @Formula1_Table AS [xml]
    ON (tab.Formula1Id = [xml].[M_iFormula1Id])
    WHEN MATCHED THEN UPDATE SET tab.DataInUse = [xml].M_bDataInUse,
                                 tab.Active = [xml].M_bActive
                                 -- We no more need this line because of OUTPUT clause
                                 -- @Formula1Id = [xml].M_iFormula1Id 
    WHEN NOT MATCHED THEN INSERT (DataInUse,
                                  Active)
                                 VALUES([xml].M_bDataInUse,
                                        [xml].M_bActive
                                        )
    -- This OUTPUT clause will insert into @Merged_Rows the Rnk and the new M_iFormula1Id for every /root/Formula1 element  
    -- http://msdn.microsoft.com/en-us/library/ms177564.aspx
    OUTPUT $action, [xml].Rnk, inserted.M_iFormula1Id INTO @Merged_Rows (Merge_Action, Rnk, M_iFormula1Id);

-- This is replaced by previous OUTPUT clause
/*
IF(@Formula1Id = 0)--then we haven''t updated so get inserted rowid
BEGIN
 SET @Formula1Id = SCOPE_IDENTITY();--get the inserted identity
END
*/

-- At this moment we replace all previously inserted NULLs with the real (old and new) id's
UPDATE  x
SET     M_iFormula1Id = y.M_iFormula1Id
FROM    @Formula1_M_lstItem_Table x
JOIN    @Merged_Rows y ON x.Rnk = y.Rnk;

-------------------
--Formula1Item Table
-------------------
    MERGE INTO Formula1Item AS tab
    USING @Formula1_M_lstItem_Table AS [xml]
    ON (tab.ItemId = [xml].M_iItemId) 
    -- Maybe you should need also this join predicate (tab.M_iFormula1Id = [xml].M_iFormula1Id)
    WHEN MATCHED THEN UPDATE SET tab.ItemTypeId = [xml].M_iItemTypeId,
                                 tab.ItemValue = [xml].M_sItemValue,
                                 tab.RaceId = [xml].M_iRaceId,
                                 tab.DriverId = [xml].M_iDriverId
    WHEN NOT MATCHED THEN INSERT (Formula1Id,
                                  ItemTypeId,
                                  ItemValue,
                                  RaceId,
                                  DriverId)
                                 VALUES([xml].M_iFormula1Id,
                                        [xml].M_iItemTypeId,
                                        [xml].M_sItemValue,
                                        [xml].M_iRaceId,
                                        [xml].M_iDriverId
                                        );   
 COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    ROLLBACK TRANSACTION;
    -- The caller should be informed when an error / exception is catched
    -- THROW
END CATCH;  

END

WITH T as (
  SELECT
    id,
    owner,
    lag(id) over w AS previous_id,
    lead(id) over w AS next_id
  FROM
    mytable
  WINDOW w AS (
    ORDER BY order_field_1 DESC, 
    order_field_2 DESC
  )
)
  SELECT * FROM T
  WHERE
    owner = 'someuser' AND id = 3
  ORDER BY 
    order_field_1 DESC, 
    order_field_2 DESC

BEGIN TRAN
-- sql operations here
COMMIT

-- send email
EXEC msdb.dbo.sp_send_dbmail
@profile_name = 'DB Alerts',
@recipients = 'you@yourdomain.com',
@body = 'Commit completed for ...',
@subject = 'SQL Commit/Rollback event';

SELECT DATE_FORMAT(datetime, '%a') AS field1, 
round(SUM(price_paid)/ COUNT(DISTINCT(date(datetime))) ) AS field2 
FROM Bills 
WHERE date(datetime) BETWEEN '2012-01-02' AND '2012-01-09' 
GROUP BY weekday(datetime)

SELECT
 producttemp.*,
 GROUP_CONCAT(DISTINCT colors.id) as color,
 GROUP_CONCAT(DISTINCT upc.UPC) as upc
FROM producttemp
INNER JOIN productcolor
 ON productcolor.productid=producttemp.id
INNER JOIN upc
 ON upc.productid=producttemp.id
INNER JOIN colors
 ON colors.id=productcolor.colorid
INNER JOIN categorie
 ON categorie.id = producttemp.productcategorie
GROUP BY producttemp.id
LIMIT 5

select num as "number",
       name as "name"
  from my_table_name 
 where number = '12345'
   and rownum = 1; -- just gets the first row.

AND [table6].LOG_CREATE_TIME between convert(date, getdate() -1) and convert(date, getdate())

Select Book_Name,Client_Name, max(date)
From table A
Group By Book_Name,Client_Name
HAVING max(date) < any (select..


                      ...)

SELECT
   O.*,
   S.*
FROM
   dbo.Object O
   OUTER APPLY (
      SELECT TOP 1 *
      FROM dbo.ObjectStatus S
      WHERE O.ObjectID = S.ObjectID
      ORDER BY DateChanged DESC
   ) S

   SELECT c.name AS customer,
          s.name AS shipper,
          b.name AS buyer
     FROM PEOPLE p
LEFT JOIN USER c ON c.id = p.customer
LEFT JOIN USER s ON s.id = p.shipper
LEFT JOIN USER b ON b.id = p.buyer

select id,name--,COUNT(*)
from(
select id,name from table1 
union all 
select id,name from table2
) x
group by id,name
having COUNT(*)=1

ORDER BY CASE Priority 
    WHEN 'urgent' THEN 1
    WHEN 'high' THEN 2
    WHEN 'medium' THEN 3
    WHEN 'low' THEN 4
    END

select 
  l.* from table l
inner join (
  select category, sum(price) as total from table group by category
) r
on l.category = r.category
order by r.total, <some_other_column>

with
cte as  (   select      t1.Year,
                        t1.Month,
                        t1.State,
                        Weight      =   MAX(case
                                                when t1.State = t2.State and t1.Month = t2.Month
                                                then t2.Weight
                                                else t1.Weight
                                            end),
                        StateWeight =   MAX(case
                                            when t1.State = t2.State and t1.Month = t2.Month
                                            then t2.StateWeight
                                            else t1.StateWeight
                                        end),
                        Overweight  =   MAX(t2.Overweight)
            from        Table1  as  t1
            inner join  Table2  as  t2  on  t1.Year = t2.Year
            group by    t1.Year, t1.Month, t1.State)
update      t1
set         Weight  =   tv.Weight,
            StateWeight =   tv.StateWeight,
            Overweight = tv.Overweight
from        Table1  as  t1
inner join  cte     as  tv  on  t1.Year = tv.Year
                            and t1.Month = tv.Month
                            and t1.State = tv.State;

SELECT p.partner_id,
       SUM(CASE WHEN pa.currency_id = 1 THEN amount ELSE 0 END) AS curUsdAmount,
       SUM(CASE WHEN pa.currency_id = 2 THEN amount ELSE 0 END) AS curRubAmount,
       SUM(CASE WHEN pa.currency_id = 3 THEN amount ELSE 0 END) AS curUahAmount
FROM public.player_account pa JOIN
     player p
     ON p.id = pa.player_id
WHERE p.partner_id IN (819)
GROUP BY p.partner_id;

SELECT DoctorUsername FROM TABLE_NAME GROUP BY DoctorUsername HAVING AVG(Rating) = 4

ALTER TABLE matches
    ADD m_winner as (CASE WHEN M_HomeScore > M_AwayScore
                          THEN M_HomeTeam
                          WHEN M_AwayScore > M_HomeScore
                          THEN M_AwayTeam
                     END)

select Item, sum(Quantity) as TotalQuantity
from {tablename}
group by Item;

SELECT (score_end - score_start) delta, name_start
FROM
( SELECT date date_start, score score_start, name name_start
  FROM t t
  WHERE NOT EXISTS
  ( SELECT 1
    FROM t x
    WHERE x.date < t.date
     AND x.name = t.name
   )
 ) AS start_date_t
JOIN
( SELECT date date_end, score score_end, name name_end
  FROM t t
  WHERE NOT EXISTS
  ( SELECT 1
    FROM t x
    WHERE x.date > t.date
      AND x.name = t.name
   )
 ) end_date_t ON start_date_t.name_start = end_date_t.name_end
 WHERE score_end-score_start  < 0  

storeDb.Albums.Where(a => a.Genre.Name == genre).OrerBy(a => a.Artist.Name)

(
SELECT MyField1, MyField2 FROM A
INNER JOIN B ON A.Id = B.Id
AND A.MyField = 1
)
UNION
(
SELECT MyField1, MyField2 FROM A
INNER JOIN C ON A.Id = C.Id
AND A.MyField = 2
)

COUNT(case when Recordings_Sum >= 60 AND Recordings_Sum < 100 then 1 end) AS DaysAbove60
COUNT(case when Recordings_Sum >= 100 AND Recordings_Sum < 140 then 1 end) AS DaysAbove100
COUNT(case when Recordings_Sum >= 140 then 1 end) AS DaysAbove140

WITH valid_date_range(valid_date) AS (
   SELECT x.range_start + LEVEL - 1
     FROM (SELECT TO_DATE('2015-06-07', 'YYYY-MM-DD') AS range_start,
                  TO_DATE('2015-06-09', 'YYYY-MM-DD') AS range_end
             FROM dual) x
  CONNECT BY x.range_start + LEVEL - 1 <= x.range_end),
message_count_by_user_and_date(message_date, userid, num_messages) AS (
  SELECT d.valid_date, iu.userid, COUNT(me.message_id)
    FROM interesting_userid iu
    JOIN valid_date_range d ON 1 = 1
    LEFT JOIN message_table me
      ON me.userid = iu.userid
     AND me.timestamp >= d.valid_date
     AND me.timestamp < d.valid_date + 1
   GROUP BY d.valid_date, iu.userid)
SELECT some_date_interval_function(m.message_date) AS DayOfWeek,
       m.userid,
       m.num_messages
  FROM message_count_by_user_and_date m
 ORDER BY m.message_date, m.userid;

SELECT t.FinYearVal, t.Category, ISNULL(ttb.AMOUNT,0)
FROM (
    SELECT tta.FinYearVal, d.Category
    FROM @TempTableA tta
    CROSS JOIN (SELECT DISTINCT ttb.Category FROM @TempTableB ttb) AS d
) AS t
LEFT OUTER JOIN @TempTableB ttb ON t.FinYearVal = ttb.FinYear AND ttb.Category = t.Category
ORDER BY t.Category, t.FinYearVal

DISPLAY SQL('SELECT sys, COUNT(memno) as memCount, Memno, userName, address FROM QTEMP/addrchg2 GROUP BY memno, sys, userName, address HAVING COUNT(memno)>2 ORDER BY sys')

select 
  transaction, 
  "'BBK'",
  "'SBK'",
  "'OBK'",
  "'IBK'"
from (
  select 
  regexp_substr("col_a", '[^~]+', 1, 1) as transaction,
  regexp_substr("col_a", '[^~]+', 1, 2) as code,
  regexp_substr("col_a", '[^~]+', 1, 3) as country
  from Table1 t)
pivot 
( 
  MAX(country) for code in ('BBK','SBK','OBK','IBK')
);

with cte as
(
select holiday_id, 
       id, 
       holiday_name, 
       date_start, 
       date_end, 
       row_number() over (partition by holiday_id order by holiday_id) as [Index]
from Action
)
select holiday_id, id, holiday_name, date_start, date_end,
       (select count(*) from Action 
        where holiday_id = cte.holiday_id and delete_date is null) as [Count]
from cte
where [Index] = 1

EVENT
------
event_id
start_tm
end_tm
description

EVENT_SERVICE
-------------
event_id
service_id
employee_id 
start_tm
end_tm
(other info as needed)

SERVICE
---------
service_id
description

CAUSE
-------
cause_id
description

EVENT_CAUSE
-----------
event_id
cause_id

SELECT YEAR(o.orderdate) AS YEAR,
       c.Categoryname,
       SUM(o.netamount) AS Totsales
FROM orders o
INNER JOIN orderlines ol ON ol.orderid = o.orderid
INNER JOIN Products p ON p.ProdID = ol.Prodid
INNER JOIN categories c ON c.Category = p.Category
WHERE c.Categoryname LIKE 'A%'
GROUP BY c.Categoryname, YEAR(o.orderdate);

 SELECT
    yt1.[timestamp] AS StartTime,
    MIN(yt2.[timestamp]) AS EndTime,
    DATEDIFF(MINUTE, yt1.[timestamp], MIN(yt2.[timestamp])) AS DifferenceInMinutes
    into #tmp1
    FROM
    Sheet1$ yt1
    LEFT JOIN Sheet1$ yt2 ON yt1.[timestamp] < yt2.[timestamp]
    WHERE
    yt1.TWSPD IS NULL
    GROUP BY yt1.[timestamp]


Select t1.* 
into #tmp2
from #tmp1 t1
left join #tmp1 t2 on t1.Starttime=t2.Endtime
where t2.Endtime is null

Declare @rcn int
Select @rcn=1
While @rcn>0
    begin
       Update #tmp2 set #tmp2.Endtime=t.endTime,#tmp2.DifferenceInMinutes=#tmp2.DifferenceInMinutes+t.DifferenceInMinutes
       from #tmp1 t
       where t.Starttime=#tmp2.Endtime
       select @rcn=@@Rowcount
    end


select * from #tmp2

Drop Table #tmp1
Drop Table #tmp2

^(\d{9}[a-zA-Z][a-zA-Z0-9]?|[a-zA-Z][a-zA-Z0-9]{6,11})$

select m.month, s.status, coalesce(i.cnt, 0) as cnt
from (select distinct strftime('%m', date) as month from item) m cross join
     (select id, status from status) s left outer join
     (select strftime('%m', date) as month, status_id, count(*) as cnt
      from item i
      group by strftime('%m', date), status_id
     ) i
     on i.month = m.month and i.status_id = s.id;

SELECT SUBSTR(NameColumn, 1, INSTR(NameColumn,' ',1)) AS firstName,
SUBSTR(NameColumn, INSTR(NameColumn,' ',1)+1) FROM tablName

MERGE
INTO    dsms d
USING   (
        SELECT  :DSM AS dsm, :SURNAME AS surname, :FIRSTNAME AS firstname, :VALID AS valud
        FROM    dual
        ) v
ON      (d.dsm = q.dsm)
WHEN MATCHED THEN
UPDATE
SET     SURNAME = v.SURNAME, FIRSTNAME = v.FIRSTNAME, VALID = v.VALID
WHERE   d.surname <> v.surname
        OR d.firstname <> v.firstname
        OR d.valid <> v.valid
WHEN NOT MATCHED THEN
INSERT
INTO    (SURNAME, FIRSTNAME, VALID)
VALUES  (SURNAME, FIRSTNAME, VALID)

select date(datetime), count(*)
from t
where userid = 1 and datetime between DATE1 and DATE2
group by date(datetime)

 xs:dateTime($doc/root/date_value) eq fn:dateTime(xs:date('2015-09-11'), xs:time(xs:dateTime($doc/root/date_value)))

select productid, type,
       sum(case when adjust_type = 'ADD' then reorder_qty
                when adjust_type = 'DEDUCT' then - reorder_qty
                else 0
           end) as total_balance
from atable
group by productid, type;

SELECT o.id, o.name, t1.name as name1, t2.name as name2
from objects o LEFT OUTER JOIN
     types t1
     ON o.type1 = t1._id LEFT OUTER JOIN
     types t2
     on o.type2 = t2._id;

select 
    Location_ID 
from CategoryLocations
where Category_ID in (2,3)
group by Location_ID
having COUNT(distinct Category_ID) = 2  -- this 2 is the number of items in the IN list above

public void store(int[] params1, int[] params2) {
   Connection con = session.connection();
   boolean initialAutocommitSetting = connection con.getAutoCommit();
   //disable autocommit
   con.setAutoCommit(false);
   //you only need one statement object:
   CallableStatement stmt = con.prepareCall("{ call changesalary(?,?) }");

   for (int i = 0; i < params1.length; i++) {       
       stmt.setInt(1, params1[i]);
       stmt.setInt(2, params2[i]);  
       //for each call, add the set of parameters as needed and call addBatch();
       stmt.addBatch();
    }
    //when you're done, execute your (batch) statement and see how many updates you got
    int [] updatesCount=stmt.executeBatch(); 

    //manually commit
    con.commit();

    if(updatesCount!=i) {
        //some updates didn't work
    }

    //return connection to initial autocommit setting:
    connection.setAutoCommit(initialAutocommitSetting );
}

select * from tbl_point where point%100=0 and point>0

var sqlite3 = require('sqlite3').verbose();

var stmt = db.prepare(query);

doQuery();

function doQuery(){

    stmt.get(function(error, data){
        if(data){
            if(error){
                console.log(error);
            } else {
                // do something with data here.
            }
            setImmediate(function(){
                doQuery();
            });
        }
    });

}

select Name+isnull(','+Address1,'')+isnull(','+Address2,'') as compDeatils 
from tableCompany where ID = 4

 SimpleDateFormat currentDate = new SimpleDateFormat("yyyy-MM-dd kk:mm:ss");

 Calendar c = Calendar.getInstance();
 c.setTime(currentDate.parse(data)); // your date value
 c.add(Calendar.MINUTE,10);
 newDate = c.getTime()

DECLARE
  v_row NUMBER;
 CURSOR cur IS
    select * from (SELECT COUNT(transaction_id) counter, book_id 
    FROM transaction_master 
    GROUP BY book_id) order by counter desc;

BEGIN
  -- truncate table
  execute immediate 'truncate table top_books';
  --insert fresh data
  FOR rec IN cur LOOP
    v_row := cur%rowcount;
   insert into top_books (rank_id,book_id,ciybt_issue) values(v_row,rec.book_id,rec.counter);
  END LOOP;
  commit;
END;

CREATE TABLE SomeTable
(
P_Id int PRIMARY KEY IDENTITY,
CompoundKeyPrefix varchar(255) NOT NULL,
CompoundKey AS CompoundKeyPrefix + CAST(P_Id AS VARCHAR(10))
)

SELECT t.SessionId, COUNT(tc.Action)
    FROM YourTable t
        LEFT JOIN YourTable tc
            ON t.SessionId = tc.SessionId
                AND tc.Action <> 'LOGIN'
    WHERE t.Action = 'LOGIN'
    GROUP BY t.SessionId;

..

CREATE TABLE #foo  (..)

INSERT #foo
exec sp_Membership @id

SELECT * FROM #foo

...

CREATE VIEW dbo.CompanyServices
WITH SCHEMABINDING
AS
SELECT
  c.COMPANY_ID,
  s.SERVICE_CODE
FROM       dbo.COMPANY c
INNER JOIN dbo.LSP     l ON c.COMPANY_ID = l.COMPANY_ID
INNER JOIN dbo.SERVICE s ON l.LSP_ID     = s.LSP_ID
GO

CREATE UNIQUE CLUSTERED INDEX UQ_CompanyServices
ON dbo.CompanyServices (COMPANY_ID, SERVICE_CODE);

WITH daily_charges AS (
  SELECT
    sum(total_amount) AS daily_total,
    user_id,
    date_trunc('day', created_at) AS charge_date
  FROM charges
  GROUP BY user_id, created_at
  )
SELECT
  d.charge_date,
  date_trunc('day', u.created_at) AS layer,
  avg(d.daily_total) AS avg_amount
FROM
  daily_charges d
  JOIN users u ON
    (d.user_id=u.id)
GROUP BY charge_date, layer;

CREATE ROLE students
GRANT EXECUTE TO students

EXEC sp_addrolemember 'students', 'Bob'
EXEC sp_addrolemember 'students', 'Jill'
EXEC sp_addrolemember 'students', 'Steve'

declare @AllPhones table (id int, phones varchar(max))

insert into @AllPhones select 0, '1234; 5897;'
insert into @AllPhones select 1, '0121; 7875; 5455;'
insert into @AllPhones select 2, '0121; 5455; 7875;'
insert into @AllPhones select 3, '999;'
insert into @AllPhones select 4, '0121;'
insert into @AllPhones select 5, '5455; 0121;'
insert into @AllPhones select 6, '222;'
insert into @AllPhones select 7, '888;'
insert into @AllPhones select 8, '222; 888;'
insert into @AllPhones select 9, '888; 222;'


select * from @AllPhones

declare @IdPhone table (id int, done bit)
declare @Phone table (id int, phone varchar(max), insertOrder int)

insert into @IdPhone
select id, 0
from   @AllPhones

declare @Id int
declare @ConcatPhone varchar(max)

declare @idx int       
declare @slice varchar(max)
declare @insertOrder int

while exists(select * from @IdPhone where done=0)
begin
    select top 1 @Id = ap.id
               , @ConcatPhone = ap.phones
    from @IdPhone ip inner join @AllPhones ap on ip.id = ap.id
    where done=0 

    select @idx = 1
    select @insertOrder = 1       
    if len(@ConcatPhone)> 0 and @ConcatPhone is not null
    begin
        while @idx!= 0       
        begin       
            set @idx = charindex(';',@ConcatPhone)       
            if @idx!=0       
                set @slice = left(@ConcatPhone,@idx - 1)       
            else       
                set @slice = @ConcatPhone       

            if(len(@slice)>0)
                insert into @Phone(Id, phone,insertOrder) values(@Id, rtrim(ltrim(@slice)),@insertOrder)       

            set @ConcatPhone = right(@ConcatPhone,len(@ConcatPhone) - @idx)       
            if len(@ConcatPhone) = 0 break       

            select @insertOrder = @insertOrder+1 
        end   
    end

    update @IdPhone 
    set done=1 
    where Id = @Id
end

declare @UniquePhone table (id int, c int, phone varchar(max),insertOrder int, done int)

insert into @UniquePhone
    select p.id
         , (select top 1 count(pCount.id) from @phone pCount where pCount.id=p.id) as t
         , p.phone
         ,p.insertOrder
         ,0
    from @phone p
    group by p.id, p.phone, p.insertOrder

while exists(select * from @UniquePhone where done=0)
begin
    select top 1 @Id = up.id
    from @UniquePhone up 
    where done=0 
    order by c desc
           , id desc

    delete from @UniquePhone 
    where id <> @id and phone in (select phone from @UniquePhone pp where pp.id=@id)

    print @id

    update @UniquePhone 
    set done=1 
    where Id = @Id
end

select FinalTable.id,
       ltrim(rtrim(FinalTable.Phones)) As Phones
from(select distinct up2.id, 
           (select up1.phone + '; ' as [text()]
            from @UniquePhone up1
            where up1.id = up2.id
            order by up1.id, insertOrder
            for XML PATH ('')) Phones
     from @UniquePhone up2) [FinalTable]

public $virtualFields = array(
 'projectTypeName' => 'SELECT name FROM project_types where id = Project.project_type_id'
);    

when "Ticket Number" LIKE 'INC%' AND "Support Person" IS NULL

SELECT Col1
FROM table
UNION
SELECT Col2
FROM table
UNION
SELECT Col3
FROM table

select tabl1.* from table1
inner join table2
on table1.id=table2.id and table1.name=table2.name

SQL> select to_char( 4, '9.0' )
  2    from dual;

TO_C
----
 4.0

SQL> ed
Wrote file afiedt.buf

  1  select to_char( 4.1, '9.0' )
  2*   from dual
SQL> /

TO_C
----
 4.1

SELECT t, name, extra, extra2, extra3 FROM newEvent
EXCEPT
SELECT t, name, extra, extra2, extra3 FROM event

SELECT locations.id, locations.location, COALESCE(COUNT( DISTINCT article.id), 0) AS Number 
FROM ar.locations 
JOIN ar.articleLocation 
     ON articleLocation.locationId = locations.id 
LEFT JOIN 
(SELECT article.* FROM ar.article 
JOIN ar.articleProfile 
     ON article.id = articleProfile.articleId 
WHERE article.createDate >= '2013-11-30' 
AND article.startDate <= '2014-05-30' 
AND articleProfile.profileId 
     IN ('1000000410','1000000408','1000000393') 
) article
ON article.id=articleLocation.articleId 
WHERE articleLocation.locationId IN ('250','194','195','204','281') 
GROUP BY locations.id, locations.location 
ORDER BY locations.location;

create or replace function getDoctor(
    p_dbNumber IN NUMBER,
    p_code IN VARCHAR2(10),
    p_doccode IN VARCHAR2(10)
) return varchar2
is
  l_DOCID VARCHAR2(10);
begin
  begin
    select MDOCID
      into l_DOCID 
      from NEW_PROVIDERS NP 
     where p_dbNumber=NP.dbNumber 
       and p_code=NP.code 
       and p_doccode=NP.doccode
    ;
  exception
    when no_data_found then
      select MDOCID 
        into l_DOCID
        from ProvidersProxy P 
       where P.originalDB=p_dbNumber 
         and p_cpcode=P.originalGroup 
         and p_doccode=P.originalDocCode
      ;
  end;
  return l_DOCID;
end getDoctor;

SELECT TOP(1000) UserId, [Key], Value 
FROM
 (SELECT *, RN = ROW_NUMBER() OVER (PARTITION BY UserId order by TimeStamp)
  FROM MyTable 
  WHERE Processed = 'false') X
WHERE RN=1
ORDER BY TimeStamp;

select t.p,
       max(case when c = 3 then a end) as a3,
       max(case when c = 3 then b end) as b3,
       max(case when c = 4 then a end) as a4,
       max(case when c = 4 then b end) as b4
from atable t
group by t.p;

select `Hostess Code`, DATE_FORMAT(`Datum Bezoek 1`, '%e %M'), count(PA), count(PB), count(PG), GoedkeuringDoorNew, Blanco,... where ... group by DATE_FORMAT(`Datum Bezoek 1`, '%e %M') order by DATE_FORMAT(`Datum Bezoek 1`, '%e %M')

SELECT
    COUNT(*) as nbr,
    CASE mc_owner WHEN 'Element1' THEN 'Element1' ELSE `Others` END as Owner
FROM [dbo].[full] 
WHERE (date_reception > '01-01-2015')
GROUP BY CASE mc_owner WHEN 'Element1' THEN 'Element1' ELSE `Others` END
ORDER BY COUNT(*) DESC


BEGIN TRAN

SELECT *
INTO o
FROM sys.objects

CREATE UNIQUE NONCLUSTERED INDEX sjhfg ON o (object_ID)
CREATE UNIQUE CLUSTERED INDEX sjhfg ON o (object_ID) WITH (DROP_EXISTING = ON)

SELECT * FROM sys.indexes WHERE object_id = OBJECT_ID('o')

ROLLBACK

SELECT ID, First, Last FROM tbl_1 t1
JOIN tbl_1 t2 
  ON (t1.Last = t2.Last AND t1.ID = YOUR_ID);

SELECT yt.qty,
       x.cat_avg,
       yt.sales/yt.qty AS avg_price,
       NULL AS weighted_average 
  FROM YOUR_TABLE yt
  JOIN (SELECT t.category,
               AVG(t.qty) AS cat_avg
          FROM YOUR_TABLE t
      GROUP BY t.category) x ON x.category = yt.category
 WHERE yt.seller = 'Ash'

INSERT INTO B (supplier_id, supplier_name)
SELECT supplier_id, supplier_name FROM A
WHERE abc > 10;

select *
from
(
  select 
    ticker, 
    date, 
    price, 
    lag(price) over (partition by ticker order by date) as price_before
  from prices
) both_prices
where price > price_before * 1.5 or price < price_before * 0.5;

CREATE TABLE #a(code VARCHAR(32));

INSERT #a SELECT 'abc'
UNION ALL SELECT 'abc'
UNION ALL SELECT 'abc'
UNION ALL SELECT 'def'
UNION ALL SELECT 'def'
UNION ALL SELECT 'ghi';
GO

SELECT x.code, id = y.number FROM 
(
  SELECT code, maxid = COUNT(*) FROM #a GROUP BY code
) AS x
CROSS JOIN 
(
  SELECT DISTINCT number FROM master..spt_values
  WHERE number BETWEEN 1 AND 256
) AS y
WHERE x.maxid >= y.number;

DROP TABLE #a;

SELECT  SUBNO, 
        SUBJECT, 
        CE_TotalMarks, 
        TotalMarksObt_C, 
        TE_TotalMarks, 
        TotalMarksObt,
        MAXMARKS, 
        OverAllMark
FROM (  SELECT  AISECTRESULT_Schemes.SUBNO, 
                AISECTRESULT_Schemes.SUBJECT, 
                AISECTRESULT_Schemes.CE_TotalMarks, 
                AISECTRESULT_ExamMarksData.TotalMarksObt_C, 
                AISECTRESULT_Schemes.TE_TotalMarks, 
                AISECTRESULT_ExamMarksData.TotalMarksObt,
                MAXMARKS, 
                AISECTRESULT_ExamMarksData.OverAllMarks,
                1 ColOrder
        FROM AISECTRESULT_Schemes 
        INNER JOIN AISECTRESULT_ExamMarksData 
        ON AISECTRESULT_Schemes.[EXAMSCHEME ID] = AISECTRESULT_ExamMarksData.EXAMSCHEMEID
        WHERE AISECTRESULT_ExamMarksData.REGISTRATIONID = '201192145'

        UNION

        SELECT  ''AS SUBNO,''AS SUBJECT,
                SUM(AISECTRESULT_Schemes.CE_TotalMarks)CE_TotalMarks, 
                SUM(AISECTRESULT_ExamMarksData.TotalMarksObt_C)TotalMarksObt_C,
                SUM(AISECTRESULT_Schemes.TE_TotalMarks)TE_TotalMarks, 
                SUM(AISECTRESULT_ExamMarksData.TotalMarksObt)TotalMarksObt,
                SUM(AISECTRESULT_Schemes.MAXMARKS)MAXMARKS,
                SUM(AISECTRESULT_Exa![enter image description here][1]mMarksData.OverAllMarks)OverAllMarks,
                2
        FROM AISECTRESULT_Schemes 
        INNER JOIN AISECTRESULT_ExamMarksData 
        ON AISECTRESULT_Schemes.[EXAMSCHEME ID] = AISECTRESULT_ExamMarksData.EXAMSCHEMEID 
        WHERE AISECTRESULT_ExamMarksData.REGISTRATIONID = '201192145') AS Data
ORDER BY ColOrder

select distinct on (user_id, name)
    user_id, name, w.id as workout_id,
    difficulty_level, rounds_count
from
    workouts w
    inner join
    trainings t on t.workout_id = w.id
order by user_id, name, difficulty_level desc, rounds_count desc

SELECT x.* 
  FROM messages x
  JOIN 
     ( SELECT sender_id
            , receiver_id
            , MAX(date) max_date 
         FROM messages 
        GROUP 
           BY receiver_id
            , sender_id
     ) y 
    ON y.sender_id = x.sender_id 
   AND y.receiver_id = x.receiver_id 
   AND y.max_date = x.date
 WHERE x.belong_to = x.receiver_id;

select 
  id, 
  case 
     when count(case mark when 'C' then 1 else null end) = 0 
     then 
        sum(amount)
     else 
        sum(case when mark <> 'A' then amount else 0 end)
  end
from sampletable
group by id

 DECLARE @Item TABLE
(
    Id int,
    Price decimal,
    PricePer decimal
)

DECLARE @OrderItem TABLE
(
    Id int,
    ItemId int,
    ChargedPrice nvarchar(10),
    QtyRequired int,
    QtyLeftToDespatch int
)

INSERT INTO @Item (Id,Price,PricePer) VALUES (1,1.00, 1)
INSERT INTO @Item (Id,Price,PricePer) VALUES (2,2.00, 1)
INSERT INTO @Item (Id,Price,PricePer) VALUES (3,3.00, 1)
INSERT INTO @Item (Id,Price,PricePer) VALUES (4,4.00, 1)

INSERT INTO @OrderItem (Id, ItemId,ChargedPrice,QtyRequired,QtyLeftToDespatch) VALUES ( 1,1,100,100,50 )
INSERT INTO @OrderItem (Id, ItemId,ChargedPrice,QtyRequired,QtyLeftToDespatch) VALUES ( 2,1,200,300,50)
INSERT INTO @OrderItem (Id, ItemId,ChargedPrice,QtyRequired,QtyLeftToDespatch) VALUES ( 3,1,300,300,50 )

DECLARE @ItemIdTest int 
SET @ItemIdTest = 4

SELECT COALESCE(SUM((price/priceper)*QtyRequired),0) as total_value,
       COALESCE(SUM((price/priceper)*QtyRequired),0) as outstanding_value
FROM @Item i
LEFT OUTER JOIN @OrderItem o ON i.Id = o.ItemId
WHERE i.Id = @ItemIdTest
group by itemId

select distinct CAST( w.work_area AS CHAR(4) ) || s.code_id as WATT
from sys_code s, work_area_master w
where s.code_type = '590' 
and (CAST( w.work_area AS CHAR(4)) || s.code_id) in (
select substr(coalesce(misc_flags,"    "), 1,6)
from sys_code
where code_type = 'STA'
);

configuration.getTypeHandlerRegistry().register(HashMap.class, new MyPLSQLTypeHandler());

left(Address, (CHARINDEX(CHAR(13) + CHAR(10), Address, CHARINDEX(CHAR(13) + CHAR(10), Address)))) as 'Address1'

SELECT text FROM (SELECT commentid, SUM(IF(vote > 0, 1, 0)) AS pos_votes,
SUM(IF(vote < 0, 1, 0)) AS neg_votes FROM votes GROUP BY commentid) AS vote_count
INNER JOIN comments ON comments.id = vote_count.commentid WHERE
(neg_votes * 100 / (neg_votes + pos_votes)) <= 25

$query = $this->db->query('SELECT val FROM table')->result_array();

$array = array();

foreach ( $query as $key => $val )
{
    $temp = array_values($val);
    $array[] = $temp[0];
}

select
    region.id,
    count(*) as total_jobs,
    count(job = 'Janitor' or null) as "Janitor"
    count(job = 'Repair' or null) as "Repair"
from
    region_center
    inner join
    region on st_dwithin(region_center.geom, region.geom, 2640)
group by region.id;

select t1.personid
  , t1.monthyear
  , datetimevalue = prev.datetimevalue
from t1
  outer apply
  (
    select top 1 datetimevalue
      , personid
      , monthyear
    from t1 prev
    where prev.monthyear <= t1.monthyear
      and prev.datetimevalue is not null
    order by monthyear desc
) prev
order by t1.personid
  , t1.monthyear

select t.user_id, m.min_result, min(t.id) id
from results t
inner join (select user_id, min(result) min_result
            from results
            group by user_id) m
        on t.user_id = m.user_id
       and t.result = m.min_result
group by t.user_id, m.min_result

--Approach 2: Closer to Hubert's Examples
--Advantage: Easy to read - intuitive, doesn't rely on a primary key
--Disadvantage: Creates temp junk in the db 
--      which means reusing in same session you must drop
--  and using in nested subquery results may be unpredictable

CREATE TEMP sequence temp_seq;
SELECT nextval('temp_seq') As row_number, oldtable.*
FROM (SELECT * FROM beta) As oldtable;

SELECT * 
  FROM [Users]
 WHERE LastName LIKE 'S%'

SQLCMD -d database -i filename.sql

$db_link->multi_query("update prodb set buyer = buyer+1 where userId = 1; update prodb set seller = seller+1 where userId = 2;");

SELECT driver.customer, driver.fulldate, o.amount 
FROM   (select d.fulldate, customer
        from datetable d cross join
             (select customer
              from orders
              where year(orderdate) in (2012)
             ) o
        where d.calendaryear IN ( 2012 )
       ) driver LEFT OUTER JOIN
       orders o 
       ON driver.fulldate = o.orderdate and
          driver.customer = o.customer;

UPDATE customers
SET postal_code = (
  SELECT postal_codes.postal_code 
  FROM postal_codes
  WHERE postal_codes.city_name = customers.city_name 
)
WHERE EXISTS (
  SELECT *
  FROM postal_codes
  WHERE postal_codes.city_name = customers.city_name
    AND postal_codes.postal_code <> customers.postal_code
);

select p.*
from products p
left join span_products s on s.part_no = p.part_no
where s.part_no is null

order by (case when state = 'NY' then 0 else 1 end),
         state

select verb, count(relation) count, relation
from
    (select vp.verb, group_concat(label.name) relation 
    from 
        vp, label, vp_terminal, terminal 
    where 
        label.idlabel==terminal.label_id 
        and vp_terminal.vp_id==vp.idvp
        and vp_terminal.terminal_id==terminal.idterminal
    group by vp.verb, vp.idvp 
    order by verb, relation)
group by relation, verb 
order by verb asc, count desc;

FROM   invoice i2 
       LEFT outer JOIN invoice_refnum ir16 
              ON i2.invoice_gid = ir16.invoice_gid and ir16.invoice_refnum_qual_gid like 'GL CODE%'
       LEFT outer JOIN invoice_refnum ir15 
              ON i2.invoice_gid = ir15.invoice_gid and ir15.invoice_refnum_qual_gid like 'GL AMOUNT%'
       LEFT outer JOIN invoice_refnum ir17 
              ON i2.invoice_gid = ir17.invoice_gid and ir17.invoice_refnum_qual_gid like 'GL RECEIVING BU%'
       LEFT outer JOIN invoice_refnum ir18 
              ON i2.invoice_gid = ir18.invoice_gid and ir18.invoice_refnum_qual_gid like 'GL SHIPPING BU%'
       LEFT outer JOIN invoice_refnum ir19 
              ON i2.invoice_gid = ir19.invoice_gid and ir19.invoice_refnum_qual_gid like 'GL SALES ORDER NUMBER%' and
                 regexp_substr(ir16.invoice_refnum_qual_gid,'\d+$') = regexp_substr( ir15.invoice_refnum_qual_gid,'\d+$') and
                 regexp_substr(ir16.invoice_refnum_qual_gid,'\d+$') = regexp_substr( ir17.invoice_refnum_qual_gid,'\d+$') and
                 regexp_substr(ir16.invoice_refnum_qual_gid,'\d+$') = regexp_substr( ir18.invoice_refnum_qual_gid,'\d+$') and
                 regexp_substr(ir16.invoice_refnum_qual_gid,'\d+$') = regexp_substr( ir19.invoice_refnum_qual_gid,'\d+$')
WHERE i2.invoice_gid = 'TEST' 

select dates 
  from table t 
 group by dates having count(dates) < k ;

UPDATE  Categories a
        INNER JOIN Vocabulary b
            ON a.sid = b.sid
SET     a.Name = b.value
WHERE   b.langID = 1

mysql> SELECT code,version,data_version FROM core_resource;

adminnotification_setup     1.0.0   1.0.0
admin_setup                 0.7.2   0.7.2
amazonpayments_setup        0.1.2   0.1.2
api_setup                   0.8.1   0.8.1
backup_setup                0.7.0   0.7.0
bundle_setup                0.1.11  0.1.11
...

SELECT column2
FROM mytable
WHERE column1 IN ('a', 'b')
GROUP BY column2
HAVING COUNT(DISTINCT column1) = 2

select 'John'
union all
select 'Rupert'
union all
select 'Cassandra'
union all
select 'Amy'
except
select name from mytable;

select a, sum(b)
from (select t.*,
             (row_number() over (order by c) -
              row_number() over (partition by a order by c)
             ) as grp
      from table t
     ) t
group by grp, a
order by min(c);

SELECT 
      CASE WHEN Count(Account)=0 THEN (Sum(Amount))/(Count(Account)) END AS New_field
FROM TableName

final String week = "whatever";
final Integer myPoint = 1337;
Condition weekCondition = new Condition()
        .withComparisonOperator(ComparisonOperator.EQ)
        .withAttributeValueList(new AttributeValue().withS(week));
Condition myPointCondition = new Condition()
        .withComparisonOperator(ComparisonOperator.GE)
        .withAttributeValueList(new AttributeValue().withN(myPoint.toString()))

Map<String, Condition> keyConditions = new HashMap<>();
keyConditions.put("week", weekCondition);
keyConditions.put("point", myPointCondition);

QueryRequest request = new QueryRequest("game_table");
request.setIndexName("week-point-index");
request.setSelect(Select.COUNT);
request.setKeyConditions(keyConditions);

QueryResult result = dynamoDBClient.query(request);
Integer count = result.getCount();

select 
  t1.id_invoice_in, t1.paymentcode, t1.personname, t1.amount,
  t2.id_invoice_out, t2.paymentcode, t2.personname, t2.amount  
from (
  select     
    id_invoice_in, paymentcode, personname, amount,
    (@r1 := @r1 + 1) as r1
  from invoice_in 
  join paymenttype pt on pt.id = paymenttype_id 
  join persons p on p.id = person_id
  ,(select @r1 := 0) r
) t1 left join (
  select 
    id_invoice_out, paymentcode, personname, amount,
    (@r2 := @r2 + 1) as r2
  from invoice_out 
  join paymenttype pt on pt.id = paymenttype_id 
  join persons p on p.id = person_id
  ,(select @r2 := 0) r
) t2 on t1.r1 = t2.r2;

SELECT  fc.BM_Unit_Name
        , fc.RunDate
        , fc.Period
        , CASE 
          WHEN AVG(bc.PN_Level) IS NULL THEN AVG(fc.PN_Level)             -- No BOA Value, use the FPN Value
          WHEN MIN(bc.PN_Level) < AVG(fc.PN_Level) THEN MIN(bc.PN_Level) -- BOA Value is less than the FPN, use the BOA Value
          ELSE MAX(bc.PN_Level)                                          -- BOA Value is greater than the FPN, use the BOA Value
          END 
FROM    dbo.BMReports_FPN_Curves fc
        LEFT JOIN dbo.BMReports_BOA_Curves bc ON fc.RunDate = bc.RunDate        
                                                 AND fc.BM_Unit_Name = bc.BM_Unit_Name
WHERE   fc.BM_Unit_Name ='T_DRAXX-1'
GROUP BY
        fc.BM_Unit_Name
        , fc.RunDate
        , fc.Period

create table #temp (id int, val varchar(100))
insert into #temp
exec sp_My_Other_SP @value, @value, @value, @count OUTPUT

select cast(dt as date) + cast(tm as datetime)
from yourtable

Select * from ShipsTable where  ShipType = "Barge" into Barges
Run Menu Command 311

    --Create temp tbl for the name/org code search
        CREATE TABLE #OrgCodesHier
        (
            OrgCodeID int, 
            OrgCode_Level int,
            OrgName varchar(255),
            OrgCode varchar(50),
            ParentOrgCodeID varchar(50)

            PRIMARY KEY (OrgCode) 
        )

    ;WITH orgCode_hierarchy (ParentOrgCodeID, OrgCodeID, OrgCode, OrgName, OrgCodeSortOrder, LEVEL) AS
    (
    -- Initializing:
          SELECT h_base.ParentOrgCodeID, h_base.OrgCodeID, h_base.OrgCode, h_base.OrgName, cast('::' + h_base.OrgCode  + '::' AS VARCHAR (200)) AS OrgCodeSortOrder, 0 AS LEVEL
          FROM L_OrgCode h_base
          WHERE h_base.OrgCode is not null

          UNION all

    -- Executing recursive: 
          SELECT h_child.ParentOrgCodeID, h_child.OrgCodeID, h_child.OrgCode, h_child.OrgName,  cast (ho.OrgCodeSortOrder + CASE WHEN left(h_child.OrgCode, 2) = '::' THEN '::' ELSE '' END  + h_child.OrgCode + '::' AS VARCHAR (200)) AS OrgCodeSortOrder, LEVEL + 1 AS LEVEL
          FROM L_OrgCode h_child
          inner join orgCode_hierarchy ho on h_child.ParentOrgCodeID = ho.OrgCodeID
    )     

    -- CTE:
INSERT INTO #OrgCodesHier (ParentOrgCodeID,OrgCodeID,OrgCode,OrgName,OrgCode_Level)
    SELECT DISTINCT ParentOrgCodeID, OrgCodeID, OrgCode, OrgName, LEVEL
    FROM orgCode_hierarchy
    WHERE OrgCode LIKE '2.2.1.1%'  
    -- ORDER BY 1  
    ORDER BY OrgCode, 1 


    SELECT * FROM #OrgCodesHier

SELECT angajati.Nume 
FROM angajati 
JOIN angajari  ON angajati.AngajatID = angajari.AngajatID
JOIN distribuire ON angajari.distribuireid = distribuire.distribuireid
WHERE distribuire.locatie = 'california'

SELECT PersonID, LogonDate, LoggedOnTime
       LEAD(LoggedOnTime, 1, 0) OVER (PARTITION BY PersonID ORDER BY LogonDate, LoggedOnTime)
FROM Agent_Logout

INSERT
INTO sae_scenario_type
  (
    id,
    name,
    description,
    locked
  )
  VALUES
  (
    SEQ_SAE_SCENARIO_TYPE.nextVAL,
    'Direct_SQL_Insertion_1',
    'Direct SQL Insertion from RfoAdmin 1',
    'N'
  );

COMMIT;  --> you are missing this

 DECLARE @uidSecurity NVARCHAR(25), 
     @sql NVARCHAR(500), 
     @sql1 NVARCHAR(500), 
     @SecurityGroup nvarchar(10) = 'NEWGROUP'

 DECLARE @Winlogon TABLE (
     uidFileNumber nvarchar(25))

 SET @sql = N'SELECT uidFileNumber 
    FROM ' + QUOTENAME(@DBName) + '.dbo.SERCURE 
    WHERE code = ' + QUOTENAME(@SecurityGroup, '''')

 INSERT INTO @Winlogon(uidFileNumber)
 EXEC(@sql)

select key1, key2, key3, emailSent_Date,
       row_number() over (partition by key2, key3 order by key1) as "Count"
from "table";

sqlite> SELECT count(*) FROM contacts, people, states WHERE contacts.person1_id=people.id AND people.state_id=states.id AND states.name='Kansas';
31665994
sqlite> SELECT count(*) FROM contacts, people, states WHERE contacts.person2_id=people.id AND people.state_id=states.id AND states.name='Missouri';
69436970

db.demo.aggregate([
    { $match: { score: { $gt: 0 }, person: { $in: ["bob", "jake"] } } },
    { $group: { _id: "$person", scoreSum: { $sum: "$score" }, scoreAvg: { $avg: "$score" }, scoreMin: { $min: "$score" }, scoreMax: { $max: "$score" }, count: { $sum: 1 } } }
])

select order_id, delivery_id, delivery_date, to_char(delivery_time,'hh24:mi:ss') 
from delivery

select i.id_item_order, i.id_order,
        o.no_order || chr(rownum + 64) as no_order
from item_order i
inner join "order" o on o.id_order = i.id_order;

INSERT INTO table
  (name, col1, col2)
SELECT t.name, t.col1, 'a'
  FROM TABLE t
 WHERE t.col2 IS NULL

SELECT DISTINCT countries.name as name_from_countries
FROM countries
INNER JOIN views ON countries.code = views.code
WHERE
    views.page_id = 34

SELECT status, COUNT(*)
FROM yourtable
GROUP BY status

SELECT
    @var1 = col1
    ,@var2 = col2
FROM
    Inserted;

SELECT * FROM tableOne 
WHERE (SELECT COUNT(*) FROM tableTwo WHERE tableTwo.data_id = tableOne.data_id) = 0
ORDER BY RAND()
LIMIT 1

SELECT child.Id FROM theTable current LEFT JOIN theTable child ON child.ParentId = current.Id;

SELECT
    *
FROM
    Table1 t1
    LEFT JOIN Table2 t2 ON t1.id_12 = t2.id_12 AND t2.fieldX = ...
    LEFT JOIN Table3 t3 ON t2.id_23 = t3.id_23
WHERE
    t1.fieldY = ...

select * 
 from Evrak 
Where Evrak.Product_Date  = TO_TIMESTAMP ('25.04.2012:12:00:00','DD.MM.YYYY:HH24:MI:SS')

  Select StudentId, Count(*) DupCount
  From Table
  Group By StudentId
  Having Count(*) > 1
  Order By Count(*) desc, 

SELECT SUM( case when column_name > 0 
                 then column_name
                 else 0
              end ) sum_of_non_negative
  FROM table_name

select xyz
from theTable
where not regexp_like(mycolumn,pattern)

alter table PORTAL_ROLE add constraint pk_portalroles primary key('ROLE_NAME');

SELECT *, 
    `tee`.`id` as id, `tee`.`created` as created, `users`.`id` as user_id, `users`.`created` as user_created 
FROM `tee`
    JOIN `users` ON `users`.`id` = `tee`.`user_id` 
    JOIN `user_follow` ON `tee`.`user_id` = `user_follow`.`user_followed_id` 
WHERE `tee`.`id` NOT IN (41,11,13,20,14,35,31,36) 
    AND `user_follow`.`user_follower_id` = '2' 
ORDER BY `tee`.`created` desc 
LIMIT 8

create or replace procedure tmp_split_job as
  TYPE wtype IS TABLE OF NUMBER INDEX BY VARCHAR2(40);
  uwords wtype;
  w varchar2(40);
  i pls_integer;
  n pls_integer;
  p pls_integer;
  cursor c_fetch is select PersonID, Department, JobDescription from Persons where JobDescription is not null;
begin
  for v_row in c_fetch loop
    n := length(v_row.JobDescription);
    i := 1;
    while i <= n loop
      p := instr(v_row.JobDescription, ' ', i);
      if p > 1 then
        w := substr(v_row.JobDescription, i, p-i);
        i := p + 1;
      else
        w := substr(v_row.JobDescription, i);
        i := n + 1;
      end if;
      uwords(w) := 1;
    end loop;
    w := uwords.FIRST;
    while w is not null loop
      insert into words (PersonID, Department, Word) values (v_row.PersonID, v_row.Department, w);
      w := uwords.next(w);
    end loop;
    uwords.DELETE;
  end loop;
end;
/

exec tmp_split_job;
drop procedure tmp_split_job;

SELECT name, SUM(v) AS sum FROM table GROUP BY name ORDER BY SUM(v) DESC

ORDER BY cast(replace(regexp_substr(b||' ', '[0-9]+ ', 1, 1), ' ', '') as int) NULLS FIRST,
         cast(replace(regexp_substr(b||' ', '[0-9]+ ', 1, 2), ' ', '') as int)

SELECT
  login_time
FROM
  tablename
ORDER BY
  STR_TO_DATE(login_time, '%l:%i %p')

SELECT DATE(a.tarih),
       SUM(CASE WHEN s.durum_id IN (4, 26, 27, 28, 29) THEN s.stoplam ELSE 0 END) as iptal,
       SUM(CASE WHEN s.durum_id NOT IN (4, 26, 27, 28, 29) THEN s.stoplam ELSE 0 END) as Ciro,
       (SELECT SUM(d.stoplam)
        FROM siparis d
        WHERE d.durum_id NOT IN (4, 26, 27, 28, 29) AND
              DATE(d.tarih) = DATE_ADD(DATE(a.tarih), INTERVAL - 30 DAY)
       ) AS GCiro
FROM siparis a
WHERE DATE(a.tarih) > DATE_ADD(CURDATE(), INTERVAL - 30 DAY)
GROUP BY DATE(a.tarih);

SELECT * FROM table
WHERE EXTRACT(YEAR_MONTH FROM timestamp_field) = EXTRACT(YEAR_MONTH FROM NOW())

declare
  cust customertype;
begin
  cust := new customertype('111111', 'Mr. Burns', '42 Mil,ky Way', '+41 75 000');
  insert into customertable values cust;
end;
/


INSERT INTO OrderTable
  SELECT OrderType (REF(c), '1234567890', '02-Nov-2009', 99)
      FROM CustomerTable c
          WHERE c.customerId = '111111';

--

select * from ordertable;

select o.customer.name from ordertable o where o.orderid = '1234567890';

SELECT  ScanCode as ItemID,
        ReceiptAlias,
        MAX(CASE WHEN StoreFK = 1 THEN Retail ELSE NULL END) Store_1,
        MAX(CASE WHEN StoreFK = 2 THEN Retail ELSE NULL END) Store_2,
        MAX(CASE WHEN StoreFK = 3 THEN Retail ELSE NULL END) Store_3
FROM    ItemData
GROUP   BY ScanCode, ReceiptAlias
HAVING  COUNT(DISTINCT Retail) > 1

declare @dir varchar(4000) 

exec master.dbo.xp_regread 
    N'HKEY_LOCAL_MACHINE',
    N'SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName','ComputerName',
    @dir output
select @dir

DECLARE @parentChild TABLE (Id INT NOT NULL, ParentId INT NULL);
INSERT INTO @parentChild VALUES (1, NULL);
INSERT INTO @parentChild VALUES (2, 1);
INSERT INTO @parentChild VALUES (3, 1);
INSERT INTO @parentChild VALUES (4, 2);
INSERT INTO @parentChild VALUES (5, 2);
INSERT INTO @parentChild VALUES (6, 3);
INSERT INTO @parentChild VALUES (7, 3);
INSERT INTO @parentChild VALUES (8, 7);

DECLARE @ids TABLE (Id INT NOT NULL);
INSERT INTO @ids VALUES (6);
INSERT INTO @ids VALUES (7);
INSERT INTO @ids VALUES (8);

DECLARE @count INT;
SELECT @count = COUNT(1) FROM @ids;

WITH Nodes(Id, ParentId, Depth) AS
(
    -- Start from every node in the @ids collection.
    SELECT pc.Id , pc.ParentId , 0 AS DEPTH
    FROM @parentChild pc
    JOIN @ids i ON pc.Id = i.Id

    UNION ALL

    -- Recursively find parent nodes for each starting node.
    SELECT pc.Id , pc.ParentId , n.Depth - 1
    FROM @parentChild pc
    JOIN Nodes n ON pc.Id = n.ParentId
)
SELECT n.Id
FROM Nodes n
GROUP BY n.Id
HAVING COUNT(n.Id) = @count
ORDER BY MIN(n.Depth) DESC

SELECT bl.bline, a.*, ROUND(((a.avg-b.avg)/b.avg)*100,2) pct_change
FROM
  ( 
     SELECT x.*, COUNT(*) rank
     FROM blavg x 
         JOIN blavg y 
             ON y.bline_id = x.bline_id 
            AND y.id >= x.id 
     GROUP BY x.id
) a
JOIN
( 
     SELECT x.*, COUNT(*) rank
     FROM blavg x 
         JOIN blavg y 
             ON y.bline_id = x.bline_id 
            AND y.id >= x.id 
     GROUP BY x.id
 ) b
     ON b.bline_id = a.bline_id
     AND b.rank = a.rank+1
     LEFT OUTER JOIN bl
         ON bl.bl_id = a.bline_id
WHERE a.rank = 1;

CREATE TABLE `posts` (
`pID` bigint(20) NOT NULL auto_increment,
`content` text NOT NULL,
`time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
`uID` bigint(20) NOT NULL,
`wikiptr` bigint(20) default NULL,
`cID` bigint(20) NOT NULL,
PRIMARY KEY  (`pID`),
Foreign Key(`cID`) references categories(`cID`),
Foreign Key(`uID`) references users(`uID`)
) ENGINE=InnoDB;

UPDATE glossary
SET link=REPLACE(link,'.com//','.com/')

UPDATE ITinventory
SET location = 'disposed'
WHERE status = 'disposed'

select t1.eid
  from t t1
 where t1.fid  = 'B'
   and not exists
       (select 1
          from t t2
         where t2.eid = t1.eid
           and t2.fid  = 'A')

SELECT * FROM messages WHERE YEAR(date_sent) < 2013

update table set column  = REPLACE(column,'\n','\\n') 

SELECT TO_CHAR(Registered_on, "YYYY-MM-DD HH24") AS TimeSlot,
       COUNT(*) AS Registrations
    FROM EmployeeReg
    GROUP BY 1
    ORDER BY 1;

SELECT L1.`date`, SUM(L1.`pages`) `pages`
FROM `log` L1
JOIN
(
  SELECT `website_id`, MAX(`created_at`) as `created_at`
  FROM `log`
  GROUP BY `website_id`, `date`
) L2
ON L1.`website_id` = L2.`website_id`
  AND L1.`created_at` = L2.`created_at`
GROUP BY `date`

Select ID, A.PersonID, A.StoreID, Data1, Data2, A.EntryDate
From ExampleTable As A
Inner Join
    (select PersonID, StoreID, max(EntryDate) As EntryDate
    from ExampleTable
    group by PersonID, StoreID, dbo.dayof(EntryDate)) As B
  On ExampleTable.PersonID = B.PersonID 
    And ExampleTable.StoreID = B.StoreID 
    And ExampleTable.EntryDate = B.EntryDate

SELECT company_id
      ,name
      ,uuid
      ,company_type
      ,overview
      ,practice_area_id
      ,practice_area_name
      ,created_at
      ,created_by
      ,updated_by
      ,vetting_id
      ,vetting_name
      ,vetting_event_status
      ,vetting_event_id
      ,vetting_event_type_position
FROM (
     SELECT
    companies.id as company_id,
    companies.name as name,
    companies.uuid as uuid,
    companies.company_type as company_type,
    companies.description as overview,
    practice_areas.id as practice_area_id,
    practice_areas.name as practice_area_name,
    companies.created_at as created_at,
    companies.updated_at as updated_at,
    companies.created_by as created_by,
    companies.updated_by as updated_by,
    vettings.id as vetting_id,
    vettings.name as vetting_name,
    vetting_event_types.name as vetting_event_status,
    vetting_events.id as vetting_event_id,
    vetting_event_types.position as vetting_event_type_position,
    ROW_NUMBER() OVER (PARTITION BY companies.id ORDER BY vetting_event_types.position DESC) rn

    FROM vettings
        LEFT OUTER JOIN vetting_events ON (vettings.id = vetting_events.vetting_id)
        LEFT OUTER JOIN vetting_event_types ON (vetting_events.vetting_event_type_id = vetting_event_types.id)
        RIGHT OUTER JOIN companies ON (companies.id = vettings.company_id)
        LEFT OUTER JOIN practice_areas ON (companies.practice_area_id = practice_areas.id)
        LEFT OUTER JOIN dispositions ON (companies.disposition_id = dispositions.id)
     ) A
WHERE A.rn = 1
ORDER BY name, vetting_name, vetting_event_type_position

@notifications = current_user.notifications.
  joins("INNER JOIN activities ON notifications.activity_id = activities.id").
  joins("INNER JOIN comments ON activities.trackable_id = comments.id")

SELECT *
FROM   some_table
JOIN   (SELECT 11 as val FROM dual
        UNION ALL
        SELECT 12 as val FROM dual
        UNION ALL
        SELECT 24 as val FROM dual
        UNION ALL
        SELECT 141 as val FROM dual)
ON     val IN (code_01, code_02, ... code_20);

console.log('This is executed first');

MySqlSpService.spGetAllUsers(function(err, result){
    console.log('This is executed when the result of the database query is received');
    if(err) return res.serverError(err);
    users = result[1];
    /**
     * Here you can access to the "users" data
     * and execute code depending on it
     */
});

console.log('This is executed in second and it is not possible to know the result of the query yet');

DECLARE @t TABLE (oID int, nID int);

MERGE T s
USING (
        SELECT TID, name, address
        FROM T [s]
      ) d on 0 = 1
WHEN NOT MATCHED
THEN INSERT (name, address)
    VALUES (name, address)
OUTPUT d.TID as oID, Inserted.TID as nID
INTO @t;

SELECT e.employee_number, e.nme, l.leavedate, la.days
FROM employee e
INNER JOIN
(
   SELECT Max(date) leavedate, employee_id
   FROM leave_allocation
   GROUP BY employee_id
) l
   ON e.employee_id = l.employee_id
INNER JOIN leave_allocation la
   ON l.employee_id = la.employee_id
   AND l.leavedate = la.date

SELECT project.project, 
SEC_TO_TIME(AVG(IF( approved.dep1_date != '0000-00-00 00:00:00', TIME_TO_SEC(TIMEDIFF(approved.dep1_date,file.uploaded_datetime), NULL))) as dep1_avg
SEC_TO_TIME(AVG(IF( approved.dep2_date != '0000-00-00 00:00:00', TIME_TO_SEC(TIMEDIFF(approved.dep2_date,file.uploaded_datetime), NULL))) as dep2_avg
SEC_TO_TIME(AVG(IF( approved.dep3_date != '0000-00-00 00:00:00', TIME_TO_SEC(TIMEDIFF(approved.dep3_date,file.uploaded_datetime), NULL))) as dep3_avg
FROM APPROVED
LEFT JOIN file on file.id = approved.file_id
LEFT JOIN project on project.id=file.project_id
GROUP BY project.project

DECLARE @TABLENAME VARCHAR(100), @TABLENAME2 VARCHAR(100), @COMMIT_CHANGES BIT, @SSERVERNAME VARCHAR(100)

SET @TABLENAME='database.dbo.ITEMS' --local
SET @TABLENAME2='database.dbo.ITEMS_WEB' --remote
SET @SSERVERNAME = 'WEBSERV' --remote server
SET @COMMIT_CHANGES=0 -- set to 1, and it WILL change your remote table

    SET NOCOUNT ON

    DECLARE @SQL VARCHAR(MAX)
    DECLARE @DB1 SYSNAME, @OWNER1 SYSNAME, @TABLE1 SYSNAME
    DECLARE @DB2 SYSNAME, @OWNER2 SYSNAME, @TABLE2 SYSNAME
    DECLARE @RECIPIENTS VARCHAR(500), @ENABLEEMAIL BIT

    IF @COMMIT_CHANGES = 0 PRINT 'TEST MODE ONLY, CHANGES WILL NOT BE MADE'

    -- PARSE TABLE NAME INTO 3 PARTS
    SELECT @TABLE1 = PARSENAME(@TABLENAME, 1)
    SELECT @OWNER1 = PARSENAME(@TABLENAME, 2)
    IF @OWNER1 IS NULL SELECT @OWNER1 = 'DBO'
    SELECT @DB1 = PARSENAME(@TABLENAME, 3) 
    IF @DB1 IS NULL SELECT @DB1 = DB_NAME()

    -- PARSE ARCHIVE TABLE NAME INTO 3 PARTS
    SELECT @TABLE2 = PARSENAME(@TABLENAME2, 1)
    SELECT @OWNER2 = PARSENAME(@TABLENAME2, 2)
    IF @OWNER2 IS NULL SELECT @OWNER2 = 'DBO'
    SELECT @DB2 = PARSENAME(@TABLENAME2, 3) 
    IF @DB2 IS NULL SELECT @DB2 = DB_NAME()

    -- IF OUR TEMP TABLES EXIST, DROP THEM
    IF EXISTS (SELECT * FROM TEMPDB.INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '##T1_MAIN') DROP TABLE ##T1_MAIN
    IF EXISTS (SELECT * FROM TEMPDB.INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '##T2_ARCHIVE') DROP TABLE ##T2_ARCHIVE

    -- GATHER SCHEMA INFO FOR LIVE TABLE
    SET @SQL = 'SELECT TABLE_NAME, 
                COLUMN_NAME, 
                DATA_TYPE, 
                ISNULL(CHARACTER_MAXIMUM_LENGTH,0) AS CHARACTER_MAXIMUM_LENGTH,
                ISNULL(NUMERIC_PRECISION,0) AS NUMERIC_PRECISION,
                ISNULL(NUMERIC_SCALE,0) AS NUMERIC_SCALE,
                IS_NULLABLE,
                CAST(0 AS BIT) AS ADD_COLUMN,
                CAST(0 AS BIT) AS ALTER_COLUMN
                INTO ##T1_MAIN
                FROM ' + @DB1 + '.INFORMATION_SCHEMA.COLUMNS 
                WHERE TABLE_NAME = ''' + @TABLE1 + '''
                AND TABLE_SCHEMA = ''' + @OWNER1 + ''' '
    --PRINT @SQL
    EXEC(@SQL)

    -- CHECK IF TABLES EXIST, ELSE SKIP ALL WORK
    IF NOT EXISTS (SELECT * FROM TEMPDB.INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '##T1_MAIN')
    BEGIN
        PRINT @TABLENAME + ' DOES NOT EXIST, EXITING PROC'
        GOTO SKIPWORK
    END

    -- GATHER SCHEMA INFO FOR ARCHIVE TABLE
    SET @SQL = 'SELECT TABLE_NAME, 
                COLUMN_NAME, 
                DATA_TYPE, 
                ISNULL(CHARACTER_MAXIMUM_LENGTH,0) AS CHARACTER_MAXIMUM_LENGTH,
                ISNULL(NUMERIC_PRECISION,0) AS NUMERIC_PRECISION,
                ISNULL(NUMERIC_SCALE,0) AS NUMERIC_SCALE,  
                IS_NULLABLE,         
                CAST(0 AS BIT) AS DROP_COLUMN
                INTO ##T2_ARCHIVE
                FROM ['+@SSERVERNAME+'].' + @DB2 + '.INFORMATION_SCHEMA.COLUMNS 
                WHERE TABLE_NAME = ''' + @TABLE2 + ''' 
                AND TABLE_SCHEMA = ''' + @OWNER2 + ''' '
    --PRINT @SQL
    EXEC(@SQL)

    -- CHECK IF TABLES EXIST, ELSE SKIP ALL WORK
    IF NOT EXISTS (SELECT * FROM TEMPDB.INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '##T2_ARCHIVE')
    BEGIN
        PRINT @TABLENAME2 + ' DOES NOT EXIST, EXITING PROC'
        GOTO SKIPWORK
    END

    -- FLAG NEW COLUMNS
    -- COLUMN IN T1 (LIVE) BUT NOT IN T2 (ARCHIVE)
    UPDATE T1 SET ADD_COLUMN = 1
    FROM ##T1_MAIN T1
    LEFT OUTER JOIN ##T2_ARCHIVE T2
       ON T1.COLUMN_NAME = T2.COLUMN_NAME
    WHERE T2.COLUMN_NAME IS NULL

    -- FLAG REMOVED COLUMNS
    -- COLUMN IN T2 (ARCHIVE) BUT NOT IN T1 (LIVE)
    -- ** NOT DOING ANYTHING WITH THIS **
    UPDATE T2 SET DROP_COLUMN = 1
    FROM ##T2_ARCHIVE T2
    LEFT OUTER JOIN ##T1_MAIN T1
       ON T2.COLUMN_NAME = T1.COLUMN_NAME
    WHERE T1.COLUMN_NAME IS NULL

    -- FLAG ALTERED COLUMNS     
    -- ONLY NEED WHERE LIVE DATA LENGTH IS > THAN ARCHIVE DATA LENGTH
    -- WE WOULDN'T WANT TO SHRINK A COLUMN AND TRUNCATE A VALUE           
    UPDATE T1 SET ALTER_COLUMN = 1
    FROM ##T1_MAIN T1
    JOIN ##T2_ARCHIVE T2
       ON T1.COLUMN_NAME = T2.COLUMN_NAME
       AND (T1.DATA_TYPE <> T2.DATA_TYPE
            OR T1.CHARACTER_MAXIMUM_LENGTH > T2.CHARACTER_MAXIMUM_LENGTH
            OR T1.NUMERIC_PRECISION > T2.NUMERIC_PRECISION
            OR T1.NUMERIC_SCALE > T2.NUMERIC_SCALE
            OR (T1.IS_NULLABLE = 'YES' AND T2.IS_NULLABLE = 'NO'))

    DECLARE @COLUMN_NAME VARCHAR(100),
            @DATA_TYPE VARCHAR(100),
            @CHARACTER_MAXIMUM_LENGTH INT,
            @NUMERIC_PRECISION INT,
            @NUMERIC_SCALE INT,
            @IS_NULLABLE VARCHAR(3)

    -- CREATE A TEMP TABLE TO HOLD OUR COMMANDS FOR EMAIL
    IF EXISTS (SELECT * FROM TEMPDB.INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = '##COMMANDLIST') DROP TABLE ##COMMANDLIST

    CREATE TABLE ##COMMANDLIST (sText VARCHAR(1000))

    DECLARE ALTER_COLUMN CURSOR LOCAL
    FOR
       SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, IS_NULLABLE
       FROM ##T1_MAIN
       WHERE ALTER_COLUMN=1

       OPEN ALTER_COLUMN

       FETCH NEXT FROM ALTER_COLUMN INTO @COLUMN_NAME, @DATA_TYPE, @CHARACTER_MAXIMUM_LENGTH, @NUMERIC_PRECISION, @NUMERIC_SCALE, @IS_NULLABLE

       WHILE @@FETCH_STATUS = 0
       BEGIN
          SET @SQL = 'ALTER TABLE ' + @DB2 + '.' + @OWNER2 + '.' + @TABLE2 + ' ALTER COLUMN ' + @COLUMN_NAME + ' ' + CASE 
                                                                                                                        WHEN @DATA_TYPE IN ('NCHAR','NVARCHAR','CHAR','VARCHAR') THEN @DATA_TYPE + ' (' + CAST(@CHARACTER_MAXIMUM_LENGTH AS VARCHAR(15)) + ')'
                                                                                                                        WHEN @DATA_TYPE IN ('TINYINT','SMALLINT','INT','BIGINT','BIT','UNIQUEIDENTIFIER') THEN @DATA_TYPE
                                                                                                                        WHEN @DATA_TYPE IN ('DECIMAL','MONEY','FLOAT','NUMERIC') THEN @DATA_TYPE + ' (' + CAST(@NUMERIC_PRECISION AS VARCHAR(15)) + ',' + CAST(@NUMERIC_SCALE AS VARCHAR(15)) + ')'
                                                                                                                     END
                                                                                                                     + ' ' +
                                                                                                                     CASE
                                                                                                                        WHEN @IS_NULLABLE = 'YES' THEN 'NULL'
                                                                                                                        ELSE 'NULL'
                                                                                                                     END
          PRINT @SQL
          IF @COMMIT_CHANGES = 1 
          BEGIN
             IF(@@SERVERNAME <> @sServerName) SET @SQL = 'EXEC(''' + REPLACE(@SQL,'''','''''') + ''') AT ' + QUOTENAME(@sServerName)   
             EXEC(@SQL)
          END

          IF @SQL IS NOT NULL INSERT INTO ##COMMANDLIST (sText) SELECT @SQL

          FETCH NEXT FROM ALTER_COLUMN INTO @COLUMN_NAME, @DATA_TYPE, @CHARACTER_MAXIMUM_LENGTH, @NUMERIC_PRECISION, @NUMERIC_SCALE, @IS_NULLABLE
       END
       CLOSE ALTER_COLUMN
    DEALLOCATE ALTER_COLUMN

    DECLARE ADD_COLUMN CURSOR LOCAL
    FOR
       SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, NUMERIC_PRECISION, NUMERIC_SCALE, IS_NULLABLE
       FROM ##T1_MAIN
       WHERE ADD_COLUMN=1

       OPEN ADD_COLUMN

       FETCH NEXT FROM ADD_COLUMN INTO @COLUMN_NAME, @DATA_TYPE, @CHARACTER_MAXIMUM_LENGTH, @NUMERIC_PRECISION, @NUMERIC_SCALE, @IS_NULLABLE

       WHILE @@FETCH_STATUS = 0
       BEGIN
          SET @SQL = 'ALTER TABLE ' + @DB2 + '.' + @OWNER2 + '.' + @TABLE2 + ' ADD ' + @COLUMN_NAME + ' ' + CASE 
                                                                                                               WHEN @DATA_TYPE IN ('NCHAR','NVARCHAR','CHAR','VARCHAR') THEN @DATA_TYPE + ' (' + CAST(@CHARACTER_MAXIMUM_LENGTH AS VARCHAR(15)) + ')'
                                                                                                               WHEN @DATA_TYPE IN ('TINYINT','SMALLINT','INT','BIGINT','BIT','UNIQUEIDENTIFIER') THEN @DATA_TYPE
                                                                                                               WHEN @DATA_TYPE IN ('DECIMAL','MONEY','FLOAT','NUMERIC') THEN @DATA_TYPE + ' (' + CAST(@NUMERIC_PRECISION AS VARCHAR(15)) + ',' + CAST(@NUMERIC_SCALE AS VARCHAR(15)) + ')'
                                                                                                            END
                                                                                                            + ' ' +
                                                                                                            CASE
                                                                                                               WHEN @IS_NULLABLE = 'YES' THEN 'NULL'
                                                                                                               ELSE 'NOT NULL'
                                                                                                            END
          PRINT @SQL
          IF @COMMIT_CHANGES = 1 
          BEGIN
             IF(@@SERVERNAME <> @sServerName) SET @SQL = 'EXEC(''' + REPLACE(@SQL,'''','''''') + ''') AT ' + QUOTENAME(@sServerName)   
             -- uncomment this EXEC to make the commit changes flag work...
             --EXEC(@SQL)
          END

          IF @SQL IS NOT NULL INSERT INTO ##COMMANDLIST (sText) SELECT @SQL

          FETCH NEXT FROM ADD_COLUMN INTO @COLUMN_NAME, @DATA_TYPE, @CHARACTER_MAXIMUM_LENGTH, @NUMERIC_PRECISION, @NUMERIC_SCALE, @IS_NULLABLE
       END
       CLOSE ADD_COLUMN
    DEALLOCATE ADD_COLUMN

    SKIPWORK:

create table t (product_id number, quantity number);
insert into t values (1,3);
insert into t values (2,5);

select t.* 
  from t 
    join (select rownum rn from dual connect by level < 15) a 
                                 on a.rn <= t.quantity
order by 1;

SELECT firstname, 
       middlename, 
       lastname 
FROM   people 
WHERE  ( Upper(firstname) LIKE token1 
          OR Upper(middlename) LIKE token1 
          OR Upper(lastname) LIKE token1 ) 
INTERSECT 
SELECT firstname, 
       middlename, 
       lastname 
FROM   people 
WHERE  ( Upper(firstname) LIKE token2 
          OR Upper(middlename) LIKE token2 
          OR Upper(lastname) LIKE token2 ); 

SELECT
AVG(var1) AS var1,
AVG(var2) AS var2,
AVG(var3) AS var3,
(
 SUM(ifnull(var1,0))+
 SUM(ifnull(var2,0))+
 SUM(ifnull(var3,0))
) / (COUNT(var1)+COUNT(var2)+COUNT(var3))
 AS metric_total
FROM test

SELECT sa.ShipperState  --, other columns surely
FROM dbo.Customers AS c
LEFT OUTER JOIN dbo.Orders AS o 
ON o.Customer_FK = c.Customer_PK
LEFT OUTER JOIN dbo.OrdersTypeA AS oa
  ON oa.OrdersTypeA_PK = o.OrdersTypeA_FK
LEFT OUTER JOIN dbo.OrdersTypeB AS ob
  ON ob.OrdersTypeB_PK = o.OrdersTypeB_FK
LEFT OUTER JOIN dbo.OrdersTypeC AS oc
  ON oc.OrdersTypeC_PK = o.OrdersTypeC_FK
LEFT OUTER JOIN dbo.Shippers AS s
  ON s.Shipper_PK = COALESCE(oa.Shipper_FK, ob.Shipper_FK, oc.Shipper_FK)
LEFT OUTER JOIN dbo.ShipperAddress AS sa
  ON s.ShipperAddress_FK = sa.ShipperAddress_PK;

SELECT
MAX(id)
FROM
Table1 t
GROUP BY another_id
HAVING SUM(`condition`) = 0

SELECT m.name, COUNT(c.actor) AS 'ActorsCount' 
FROM Movies m INNER JOIN [Cast] c ON m.id = c.idmovie
GROUP BY m.name HAVING COUNT(c.actor) > 10;

select p.name,
       sum(case when [date] < cast(getdate() as date) then quantity end) as PreviewTotal,
       sum(case when [date] = cast(getdate() as date) and quantity > 0
                then quantity end) as TodayTotalPos,
       sum(case when [date] = cast(getdate() as date) and
                quantity < 0 then quantity end) as TodayTotNeg
from products p join
     quantity q
     on q.id_product = p.id
group by p.name
order by p.name;

DateAdd ( "m", 6, yourDateVariable )

SELECT item_id, item_name, catid FROM 
  (SELECT t1.*, COUNT(*) cnt FROM items t1
    LEFT JOIN items t2
      ON t2.catid = t1.catid AND t2.item_id <= t1.item_id 
  GROUP BY
    t1.catid, t1.item_id
  ) t
WHERE
  cnt < 6
-- LIMIT 20

Select Id, Stuff((Select ','+Response from TableName B where B.Id=A.Id for Xml Path('')),1,1,'') as Response from TableName A
group By Id;

INSERT
INTO    table
SELECT  a.id, a.data, b.id, b.data, c.id, c.data,
        a_seq.nextval, b_seq.nextval, c_seq.nextval,
        SYSDATE
FROM    a
LEFT JOIN
        b
ON      b.id = a.id
LEFT JOIN
        c
ON      c.id = b.id

select
    u.id,
    sum(s.xxx)
from
    users u
left join stats s
    on s.user_id = u.id
where u.id in (100, 200, 300)
group by
    u.id

CREATE TABLE user_rating (
    rated_user_id INTEGER NOT NULL,
    rater_user_id INTEGER NOT NULL,
    value FLOAT,
    time TIMESTAMP,
    PRIMARY KEY (rated_user_id, rater_user_id));

SELECT ID, COALESCE(A.dn, B.dn), COALESCE(A.pn, B.pn), COALESCE(A.sp,B.sp)
FROM dn A
    LEFT OUTER JOIN sp B
         ON A.id = B.id 

DBCC IND('myDatabase','myTable',2)

SELECT a.*, pending + wrong_number + yes + no AS 'total'
FROM (
    SELECT 
        CONCAT(u.firstname,' ',u.lastname) AS 'agent',
        COUNT(CASE WHEN pa.answer_text LIKE '%yes%' THEN pa.answer_id END) AS yes,
        COUNT(CASE WHEN pa.answer_text LIKE '%no%' THEN pa.answer_id END) AS NO,
        COUNT(CASE WHEN l2u.lead_status_id IN (4,5,8,39) THEN l2u.lead_id END) AS pending,
        COUNT(CASE WHEN l2u.lead_status_id IN (7,14,43) THEN l2u.lead_id END) AS wrong_number,
    FROM USER u
    JOIN poll_votes pv
      ON u.user_id = pv.user_id
    JOIN poll_answers pa
      ON pv.answer_id = pa.answer_id
    JOIN lead_to_user_original l2u
      ON l2u.lead_id = pv.vote_lead_id
    WHERE (pa.answer_client_one = '869' OR pa.answer_client_two = '869')
      AND pv.vote_date BETWEEN '2013-07-01 00:00:01' AND '2013-07-17 23:59:59'
    GROUP BY u.user_id
) AS a

DECLARE
    v_sql_statement VARCHAR2(2000);
    n_null_count    NUMBER;
BEGIN
    FOR cn IN (SELECT column_name
               FROM   user_tab_cols
               WHERE  table_name = 'EMPLOYEE') LOOP
        v_sql_statement := 'SELECT COUNT(1) FROM EMPLOYEE where '
                           || cn.column_name
                           || ' IS null';

        EXECUTE IMMEDIATE v_sql_statement INTO n_null_count;

        dbms_output.Put_line('Count of nulls for column: '
                             || cn.column_name
                             || ' is: '
                             || n_null_count);
    END LOOP;
END; 

UPDATE tableA
SET B = 'abcd',
    C = CASE
        WHEN C = 'abc' THEN 'abcd'
                       ELSE C
        END
WHERE column = 1;

... 
and bonus is null

OPEN myREF 
     FOR SELECT * 
         FROM MYTABLE 
         WHERE MYID IN (select * from table(:Values)) 
     USING myPassedInValList;

SELECT cpp.page_id 
    FROM cmsplugin_text AS cpt 
    LEFT JOIN cms_cmsplugin AS ccp ON cpt.cmsplugin_ptr_id = ccp.id 
    LEFT JOIN cms_page_placeholders AS cpp ON ccp.placeholder_id = cpp.placeholder_id  
    WHERE cpt.body like '%userfiles%';

mysql -D example_database -o < dump.sql

#print c.fetchall() 
row = c.fetchall()
for r in row: print r

uses DBTables;

procedure LoadAliases();
var
  CurrentAliases: TStringList;
begin
  CurrentAliases := TStringList.Create;
  try
    Session.GetAliasNames(CurrentAliases);
    ComboBox1.Items:= CurrentAliases;
  finally
    CurrentAliases.Free;
  end;
end;

SELECT USER, Manager, Amount FROM employees CONNECT BY PRIOR USER = Manager;

SELECT user.uid as uid, user.name as username, account.name as accountname
FROM user LEFT JOIN account ON user.uid=accountid.uid

select * from [order]

SELECT tt.TOKENTYPE_NAME, t.TOKEN_NAME 
FROM TOKENS AS t
JOIN TOKENTYPES AS tt
    ON tt.TOKENTYPE_ID = t.TOKENTYPE_ID

SELECT dep,
       count(*) totalrows,
       SUM(n_of_cust > n_of_employees) many_cust_rows,
       SUM(n_of_cust = n_of_employees) equal_cust_rows
  FROM My_table
  GROUP BY dep

select sum(case when raw1 = 'a' then qty1 else 0 end + 
    case when raw2 = 'a' then qty2 else 0 end +
    case when raw3 = 'a' then qty3 else 0 end +
    case when raw4 = 'a' then qty4 else 0 end) as sumqty
from jtjobfil

order by case 
    when Symbol = 'urgent' then 1
    when Symbol like '%fast' then 2
    when Symbol like '%late' then 3
    else 4 
end

select * from [table] where [column] like '%'||chr(10)||'%'

SELECT *, round(hit::numeric / at_bat, 2) AS rate
FROM  (
   SELECT input_ts
        , count(*) FILTER (WHERE event_cd = ANY ('{20,21,22,23}'::int[]))
                   OVER (ORDER BY input_ts) AS hit
        , count(*) FILTER (WHERE NOT (event_cd = ANY ('{11,14,15,16,17}'::int[]))) 
                   OVER (ORDER BY input_ts) AS at_bat
   FROM   events
   WHERE  bat_id = 'ortid001'
   ) sub
ORDER  BY input_ts;

SELECT  1 as num, 'TITLE1' as tt, [DATE], CURRENCY, 
        SUM(CASE WHEN GROUP_ID IN (1700) THEN AMOUNT END) as assets, 
        SUM(CASE WHEN GROUP_ID IN (2700, 2770) THEN AMOUNT END) as liabilities
FROM    [MYTABLE] T1  
WHERE   GROUP_ID IN (1700, 2700, 2770) 
AND     [DATE] = '2014-01-20' 
GROUP BY CURRENCY, [DATE]

create table country(id serial primary key, name text);
create table athlete(id serial primary key, name text, primary_country int references country(id));
create table athlete_country(athlete_id int references athlete(id), country_id int references country(id), primary key (athlete_id, country_id));

=SUMIF(Sheet1!$A:$A;Sheet2!$A2;Sheet1!B:B)

select U1.*, C2.*, U3.*
from URL_CATEGORIES U1 inner join
      CATEGORY C2
      on U1.CAT_ID = C2.ID inner join
      URL U3
      on U1.URL_ID = U3.ID

SELECT * FROM sys.master_files

SELECT LEFT( FORMAT_UTC_USEC(UTC_USEC_TO_DAY(timestamp*1000000)),10) as date_day,
AVG (download_speed)avg_download,
AVG (upload_speed)avg_upload,
GROUP_CONCAT(real_address)as real_address_list
FROM [xxxxxxx:xxxxx.xxxxx]
GROUP BY date_day
ORDER BY date_day ASC

select  *
from    staffdetails sd
where   not exists
        (
        select  *
        from    worklog w
        where   sd.stafid = w.stfid
                and starttime is not null
                and finishtime is null
        )

alter user FOO identified by 'BAR'; -- Broken
alter user FOO identified by BAR;   -- Works
alter user FOO identified by "BAR"; -- Works

CREATE OR REPLACE TRIGGER check_movie_parent_rating
BEFORE INSERT OR UPDATE OF DateOfBirth ON Person
REFERENCING NEW AS n                 
FOR EACH ROW
DECLARE
   v_allowed VARCHAR2(1);
BEGIN
   BEGIN
        SELECT CASE WHEN (Movie.Date - person.DateOfBirth  >= Movie.MinAge)
                    THEN 'Y'
                    ELSE 'N'
                END As Allowed
        INTO v_allowed 
        FROM Movie , Person
        WHERE Movie.id = :n.movieId
        AND Person.movieId = Movie.id
        AND Person.id = :n.id;
   EXCEPTION
   WHEN NO_DATA_FOUND THEN
      v_allowed := NULL;
   END;

   IF v_allowed IS NULL THEN
      Raise_application_error(-20202, 'Movie Detail not available in parent');
   ELSIF v_allowed = 'N' THEN
      Raise_application_error(-20201, 'Movie Restricted for User');
   END IF;
END;
/

SET @v1=112, @v2=113;

SELECT *
FROM   sizes
WHERE  (
       cm_min BETWEEN @v1 and @v2
       AND
       cm_max BETWEEN @v1 and @v2
       )
OR
       cm_min = (
         SELECT MIN(cm_min)
         FROM   sizes
         WHERE  (@v1+@v2) <= (cm_min + cm_max)
         )
UNION
SELECT *
FROM   sizes
WHERE  (
       cm_min BETWEEN @v1 and @v2
       OR
       cm_max BETWEEN @v1 and @v2
        )
OR
       cm_max = (
         SELECT MAX(cm_max)
         FROM   sizes
         WHERE  (@v1+@v2) >= (cm_min + cm_max)
         )
ORDER BY cm_max ASC;
;

select t2.*
from t1 cross join t2
where patindex('%' + t1.StringCol + '%', t2.StringCol) > 0

  SELECT x.movieid,
         x.score,
         COUNT(x.userid) / y.score_count  AS percentage
    FROM YOUR_TABLE x
    JOIN (SELECT t.movieid,
                 COUNT(t.score) AS score_count
            FROM YOUR_TABLE t
        GROUP BY t.movieid) y ON y.movieid = x.movieid
GROUP BY x.movieid, x.score

SELECT count(distinct code) as total_codes,
       count(distinct case when redeemed='TRUE' then code end) as reserved
FROM "tablename"

select r.id, r.add, r.jid, r.sid, r.cocode, o.tid, o.date, o.cid
from (select r.*, row_number() over (partition by id order by jid desc) as seqnum
      from r
     ) r join
     o
     on r.id = o.pkey and seqnum = 1;

SELECT type, 
       name, 
       MAX(color) color, 
       MAX(description) description
  FROM table_name
 GROUP BY type, name;

SELECT t1.ticketId, t1.submittedBy,
  COALESCE(t2.priority, t1.priority),
  COALESCE(t2.ticket_description, t1.ticket_description),
  t1.current_status
FROM table1 t1
LEFT JOIN table2 t2 ON t1.ticketId = t2.ticketId

Product as p join fetch p.inventories as i join fetch i.inventoryUser as iu join fetch iu.user as u where u.name=:name

SELECT users.id, users.country, count(artist_id) as match_count
FROM users
LEFT JOIN favourite_artists ON user_id = users.id AND artist_id IN (1,3,4,9)
WHERE users.country = 'gb'
GROUP BY 1, 2
ORDER BY 3 DESC;

SELECT Status, count(distinct T1.AccountNo)
FROM Orders (nolock), Accounts (NOLOCK)
WHERE Orders.AccountNo = Accounts .AccountNo  
AND date between '1 Oct 2011' and '31 Oct 2011'
AND ((HOST_NAME() <> 'ClientA') OR (Accounts.Role IN ('User') AND Accounts.Active= 'Y'))
GROUP BY Status

SELECT * FROM (
    SELECT 
        'tblC1' as tbl, tblC1.*
     FROM   tblC1 
      UNION SELECT 'tblC2', tblC2.* FROM tblC2  
      UNION SELECT 'tblC3', tblC3.* FROM tblC3 
) t
where t.nname = "new5"

SELECT s.id, user_id, body, read, s.created_at, username, name
FROM (
    SELECT DISTINCT ON (user_id) *
    FROM (
        SELECT DISTINCT ON (user_id) id, recipient_id AS user_id, created_at
            FROM messages
            WHERE sender_id = 1
        UNION ALL
        SELECT DISTINCT ON (user_id) id, sender_id AS user_id, created_at
            FROM messages
            WHERE recipient_id = 1
        ) s
    ORDER BY user_id, created_at DESC
    LIMIT 20
    ) s
JOIN users u ON (u.id = s.user_id)
JOIN messages m ON (m.id = s.id)

CREATE SCHEMA cdbo AUTHORIZATION dbo;

select top 1 * from sysobjects
WHILE @@ROWCOUNT > 0
BEGIN
    UPDATE TOP 1 Keys SET Key = (SELECT MAX(Key) from Keys)+1 WHERE Key is null
END

-- add 'loopback' linkedserver 
if exists (select * from master..sysservers where srvname = 'loopback')
    exec sp_dropserver 'loopback'
go
exec sp_addlinkedserver @server = N'loopback',
    @srvproduct = N'',
    @provider = N'SQLOLEDB', 
    @datasrc = @@servername
go

declare @myDynamicSQL varchar(max)
select @myDynamicSQL = 'exec sp_who'
exec('
    select * into #t from openquery(loopback, ''' + @myDynamicSQL + ''');
    select * from #t
    ')

select i.id, t.half_month, t.month, t.year, coalesce(sum(nbr_ord), 0)
from (select distinct id from orders) i cross join
     (select distinct half_month, month, year
      from orders
      where month = 7 and year = 2015
     ) t left join
     orders o
     on o.id = i.id and o.half_month = t.half_month and
        o.month = t.month and o.year = t.year
group by i.id, t.half_month, t.month, t.year;

WITH ins AS (
   INSERT INTO animals (name) VALUES ('pig')
   RETURNING animal_id  -- return generated ID immediately
   )
INSERT INTO animal_food (food_id, animal_id)  -- m:m link table
SELECT food_id, animal_id  -- food_id passed as 2nd param
FROM   ins;

select
  split_part(account_url, '/', 3)
from exp_logs;

SELECT foo.idProject
FROM Delivery AS foo
LEFT JOIN Delivery AS bar
  ON foo.idProject = bar.idProject
    AND bar.idProvider <> 1
WHERE foo.idProvider = 1
  AND bar.idProject IS NULL;

SELECT code, count(code) as dup, GROUP_CONCAT(DISTINCT email_address)
from tg_user group by code having dup>1 order by dup;

SELECT (DATEDIFF(WEEK,StartDate,EndDate)-1) * 2 +
        CASE DATEPART(dw,StartDate)
            WHEN 4 THEN 2
            WHEN 5 THEN 1
            ELSE 0
        END

select tradername,convert(varchar,recdate,103)as recdate,Recamount,chequeno,
remark,updatedby from (
SELECT  name as tradername,Receiveddate as recdate,Recamount,Chequeno,
Remark,Updatedby FROM K_HM_ChicksaleDueReport  
where Receiveddate between @fromdate and @todate 
and name like '%'+@name+'%'
union all
Select name as tradername,chicksplaceddate as recdate,Recamount,''as chequeno,'Direct' as Remark,Updatedby from K_HM_ChickSales 
where Recamount>0 and  chicksplaceddate between @fromdate and @todate and name like '%'+@name+'%')a   order by a.recdate  desc

end

else
select tradername,convert(varchar,recdate,103)as recdate,Recamount,chequeno,remark,updatedby from(
SELECT name as tradername,Receiveddate as recdate,Recamount, Chequeno,
Remark,Updatedby 
FROM K_HM_ChicksaleDueReport  where Receiveddate between @fromdate 
and @todate and name=@name
union all
Select name as tradername,chicksplaceddate as recdate,Recamount,''as chequeno,
'Direct' as Remark,Updatedby from K_HM_ChickSales 
where Recamount>0 and  chicksplaceddate between @fromdate and @todate 
and name=@name)a order by a.recdate  desc

SELECT *, a.id as `tag_id`, a.tag, a.type
FROM items LEFT OUTER JOIN
     (SELECT id, item_id, tag, type from itemtags ORDER BY 1,2,3) a
     ON items.id = a.item_id
ORDER BY items.id;

select item, 
       price
from (
  select item,
         price, 
         dense_rank() over (order by price desc) as rnk
  from the_table
) t 
where rnk = 1;

firstsheetname = "Sheet1"

strSQL = "SELECT [" & firstsheetname & "$].ID FROM [" _
           & firstsheetname & "$] WHERE [" & firstsheetname & "$].ID IS NULL

rs.Open strSQL, cn, adOpenKeyset, adLockReadOnly

SELECT * FROM sample ORDER BY RIGHT(Id, 3);

SELECT ROLE.RoleTitle
FROM Role AS ROLE
  LEFT JOIN StaffRole AS STAFFROLE ON ROLE.RoleID = STAFFROLE.RoleID
WHERE STAFFROLE.StaffID = '12345' AND ROLE.Primary = 'True'

CREATE PROCEDURE [dbo].[usp_]

    @customerId VARCHAR(6),
    @isType BIT

AS BEGIN 

    DECLARE 
        @permit VARCHAR(6),
        @fPSVersion VARCHAR(2)

    SELECT 
          @fPSVersion = CASE WHEN t.DynamicDirs = 0 THEN '=' ELSE '>' END
        , @permit = 'FAX'
    FROM dbo.CM t
    WHERE t.CustID = @customerId 
        AND @isType = 1

    DECLARE @SQL NVARCHAR(MAX)
    SELECT @SQL = '
    SELECT * 
    FROM dbo.MM 
    WHERE Permit = ''' + @permit + '''
        AND FPSVersion ''' + @fPSVersion + ''' 1'

    EXEC sys.sp_executesql @SQL

END 

CREATE TABLE player (
    id INT PRIMARY KEY,
    -- other player details
);

CREATE TABLE match (
    id INT PRIMARY KEY,
    -- other match details
);

CREATE TABLE player_matches (
    player_id INT,
    match_id INT,
    minute_on INT NOT NULL DEFAULT 0,
    minute_off INT,
    CONSTRAINT player_matches_pk PRIMARY KEY (player_id, match_id),
    CONSTRAINT fk_player FOREIGN KEY (player_id) REFERENCES player(id),
    CONSTRAINT fk_match FOREIGN KEY (match_id) REFERENCES match(id)
);

SELECT `Word`, 12 AS MatchID FROM `Words` WHERE `Word` like 'a%'
UNION
SELECT `Word`, 13 AS MatchID FROM `Words` WHERE `Word` like 'b%'
UNION
SELECT `Word`, 14 AS MatchID FROM `Words` WHERE `Word` like 'a%'

select 
   Items.itemId,
   count(MyTbl.itemId) as count
from Items
   left join MyTbl on (MyTbl.ItemID = Items.ItemID)
group by Items.itemId
order by Items.itemId

SELECT s.final_item, p.article
    FROM  `structure` s INNER JOIN products p ON s.item = p.article
    WHERE s.article IN ('200101','200102')
    ORDER BY s.level DESC 
    LIMIT 1

SELECT time, orderValue
FROM orders
ORDER BY CONVERT (DATETIME, '01 ' + time, 104)

SELECT T.RealName, Q.acnt, Q.bcnt
FROM
(select a.CodeName, a.cnt as acnt, b.cnt as bcnt from

  (select tableA.CodeName, count(*) cnt
   from aaaa..AAAA tableA inner join bbbb..BBBB tableB 
   on tableA.CodeName = tableB.CodeName
   where XXXXXXX
   group by tableA.CodeName) a

   JOIN

  (select tableA.CodeName, count(*) cnt
   from aaaa..AAAA tableA inner join bbbb..BBBB tableB 
   on tableA.CodeName = tableB.CodeName
   where XXXXXXX
   group by tableA.CodeName,tableA.INAMALOCK) b

ON a.CodeName = b.CodeName) Q
INNER JOIN TableCodeReal T ON Q.CodeName = T.CodeName

select ItemCode1, ItemCode2, Value 
from tablename t1
where Value = (select max(Value)
               from tablename t2
               where t1.ItemCode2 = t2.ItemCode2)

Update TableB
Set IsValid = 0
From TableA as A INNER JOIN TableB as B
                      ON A.TableBNo = B.TableBNo And IsGood = 1
                 INNER JOIN TableBChild as BC
                       ON B.TableBID = BC.TableBID
AND BC.MEMBERID NOT IN ( SELECT MemberID from Member Where MemberNo = A.MemberNo )

create table schema_version (
  version integer not null
);

Function LinkTables()
    Dim DB As Database, tDef As TableDef
    Set DB = CurrentDb
    Set tDef = DB.CreateTableDef("YourAccessLinkedTableNameHere")
    tDef.Connect = "ODBC;Driver={SQL Server};Server=srvname;Database=dbname;UID=sqluserid;PWD=sqlpwd"
    tDef.SourceTableName = "dbo.YourSourceTableNameHere"
    DB.TableDefs.Append tDef
End Function

   Select ( case when seq=1 then name else '' end ) as name,
       job_id,
       Change_date
   From (
      Select p.name,
          j.job_id,
          j.change_date,
         Row_number() over ( partition by p.person_id order by job_id desc) as seq
      from   people p
      Join jobs j
     On j.person_id = p.person_id) T

UPDATE phone_calls SET owner_id = 5 WHERE status = 1 AND owner_id <> 5 LIMIT 15000

SELECT
    people.lastname,
    people.firstname,
    people.title,
    people.phone,

    room.roomnumber,
    room.name AS roomname,

    department.name AS departmentname

FROM
    room JOIN peopleroom ON room.id = peopleroom.roomid
    JOIN people ON peopleroom.peopleid = people.id
    JOIN department ON people.departmentid = department.id

ORDER BY
    people.lastname

select 
    page_session_id, event_name
from tbl 
where event_name = 'started'
group by page_session_id, event_name
having count(*) >= 2

; WITH CTE
AS 
(
   SELECT field1, field2, field3, startDate, lastUpdate,
       ROW_NUMBER() OVER (PARTITION BY field1, field2, field3 
                          ORDER BY lastUpdate DESC) AS RN
   FROM Table_Name 
   WHERE startDate IS NOT NULL
) 
SELECT  field1, field2, field3, startDate, lastUpdate
FROM CTE 
WHERE RN = 1

update table
    set priority = priority + 200
    where RecordId in (<list provided by user>);

ALTER TABLE <TABLE_NAME> DROP CONSTRAINT <FOREIGN_KEY_NAME>

SELECT *
FROM Employee
WHERE DOJ <= '2015-02-15'
  AND (DOR IS NULL OR DOR > '2015-02-15')

"Update Table1 SET SortNum =...;Update Table1 SET SortNum =...;Update...;"

SELECT * 
FROM tbl 
WHERE col NOT LIKE 'Y*' 
AND col NOT LIKE 'A*' 
AND col NOT LIKE 'B*'

IF isnull((select AnInt from ATable where Cond), expectedInt) = expectedInt

SELECT  p.*
FROM    Products p
        JOIN Products p1 ON p1.`Product Name` = 'Phone1'
                            AND (p1.`Code 1` IN (p.`Code 1`,p.`Code 2`,p.`Code 3`)
                                 OR p1.`Code 2` IN (p.`Code 1`,p.`Code 2`,p.`Code 3`)
                                 OR p1.`Code 3` IN (p.`Code 1`,p.`Code 2`,p.`Code 3`))
WHERE   p.`Product Name` <> 'Phone1'

SELECT product_id,
       category_id,
       category_name 
FROM
( select product_id,
         c2.id category_id,
         c2.name category_name,
         row_number() OVER (PARTITION BY c2.id ORDER BY random()) as rn
  FROM categories_products cp
  JOIN categories c3 ON (cp.category_id=c3.id)
  JOIN categories c2 ON (c3.parent_id=c2.id) 
) T 
WHERE rn =1 

CREATE OR REPLACE TRIGGER A_TRG
BEFORE INSERT
ON A REFERENCING NEW AS New OLD AS Old
FOR EACH ROW
WHEN (New.IDS is null) -- (1)
BEGIN
  :new.IDS := A_SEQ.nextval;
END A_TRG;
/

INSERT INTO entries(author_name) 
SELECT meta_value 
FROM wp_postmeta
JOIN entries on wp_postmeta.post_id = entries.post_id
WHERE meta_key = "user_submit_name" AND post_id = entries.post_id;

SELECT USER_ID,FIRST_NAME,LAST_NAME
FROM m_user_info
WHERE USER_ID IN 
(select m_groups.GROUP_CREATOR_ID as GROUP_ADMIN 
from m_groups where m_groups.GROUP_ID='6'  
union
select m_group_admin.GROUP_ADMIN from m_group_admin 
where m_group_admin .GROUP_ID='6';)

SELECT t.* FROM (
  SELECT
    TITLE.name, 
    (TITLE.value-TITLE.msp) AS Lower, 
    (TITLE.value+TITLE.msp) AS Upper,
    (TITLE.value) AS Value
  FROM TITLE 
) t
WHERE 98 BETWEEN t.Lower AND t.Upper
ORDER BY ABS(98 - t.Value) ASC
LIMIT 5

UPDATE TableA
SET columnA = ''
FROM
    TableA 
    LEFT JOIN TableB ON TableA.columnA = TableB.columnB
WHERE
    TableA.columnA IS NOT NULL AND TableA.columnA <> '' AND
    TableB.columnB IS NULL;

SELECT DepositNo, SubmitDate  
FROM (  
     SELECT DepositNo, SubmitDate  
     FROM OutgoingDocs  
     WHERE DepositNo = 1 --Or a variable @MyDepositNo  
     UNION ALL --this will preserve duplicate rows if there are any between the two tables  
     SELECT DepositNo, SubmitDate  
     FROM IncomingDocs  
     WHERE DepositNo = 1 --as above  
) TT  
ORDER BY TT.SubmitDate  

SELECT AVG(q1.Entry1) as AvgPerWeek
FROM (SELECT COUNT(TestID) as Entry1, Year(TestDate),
      CASE WHEN DATEPART(month, TestDate) between 1 AND 6 
       THEN 'first half' ELSE 'second half' END as term
      FROM Table1
      GROUP BY Year(TestDate), 
               CASE WHEN DATEPART(month, TestDate) between 1 AND 6 
                    THEN 'first half' ELSE 'second half' 
               END
     ) q1

SELECT * FROM employee WHERE NAME LIKE '%k\_p%';

SELECT * FROM mytable WHERE mytext REGEXP '[[:<:]]car[[:>:]]';

update people set ID = regexp_replace(ID, '[[:cntrl:]]','');
commit;

select t1.value as name, t2.value as Age, t3.value as Score
from (select userid, value from DataTable where field_id = 1) as t1
join (select userid, value from DataTable where field_id = 2) as t2 ON t1.userid = t2.userid
join (select userid, value from DataTable where field_id = 3) as t3 ON t1.userid = t3.userid

select 
  ID,
  Sum(CASE When Year = 2009 then Revenue ELSE 0 END) as Y2009,
  Sum(CASE When Year = 2010 then Revenue ELSE 0 END) as Y2010
From
  YourTable
Group by ID

SELECT *
FROM People P
WHERE EXISTS(
        SELECT 1
        FROM Properties T
        WHERE T.PEOPLE= P.ID
)
AND NOT EXISTS(
        SELECT 1
        FROM Properties T
        WHERE T.PEOPLE= P.ID
        AND NOT EXISTS(
                SELECT 1
                FROM Accessories A
                WHERE A.Properties = T.ID
        )
);

select user_id,
  sum(case when gender = 'M' then sent else 0 end) male_sent,
  sum(case when gender = 'F' then sent else 0 end) female_sent,
  sum(sent) total_sent
from yourtable
group by user_id

IDlist <- c(23, 232, 434, 35445)
paste("WHERE idname IN (", paste(IDlist, collapse = ", "), ")")
#[1] "WHERE idname IN ( 23, 232, 434, 35445 )"

SQL OUTPUT parameters - return multiple records
--SQL returning multiple records
CREATE OR REPLACE FUNCTION fn_sqltestmulti(param_subject varchar, 
  OUT test_id integer, OUT test_stuff text) RETURNS SETOF record
AS $$
  SELECT test_id, test_stuff 
    FROM testtable where test_stuff LIKE $1;
$$
LANGUAGE 'sql' VOLATILE;

--example
SELECT * FROM fn_sqltestmulti('%stuff%');

 --OUTPUT--
 test_id |     test_stuff
---------+--------------------
       1 | this is more stuff
       2 | this is new stuff

UPDATE A
SET A.SOME_COLUMN = D.ANOTHER_COLUMN
FROM MY_TABLE AS A
JOIN inserted AS B ON A.ID = B.ID -- Point 1.
JOIN deleted AS C ON A.ID = C.ID
JOIN (SELECT MAX(ID) AS OTHER_ID, GROUP_ID AS OTHER_GROUP_ID -- Point 2.
      FROM MY_TABLE AS E
      WHERE E.SOME_STRING_COLUMN LIKE '%SomeString%'
      GROUP BY E.GROUP_ID) AS D ON A.GROUP_ID = D.OTHER_GROUP_ID
WHERE C.SOME_BOOL_COLUMN != B.SOME_BOOL_COLUMN -- Point 3.
      AND C.SOME_STRING_COLUMN NOT LIKE '%SomeString%'

 SELECT x.bin_type_name,
  x.bin_level floor,
  x.empty_locations EMPTY,
  ( ( b.total total - x.empty_locations ) / y.total total ) * 100  perc_available,
  y.total total,
  TO_CHAR ( sysdate, 'MM-DD-YYYY ' ) AS DAY,
  TO_CHAR ( sysdate, 'hh:mi:ssam' )  AS TIME
   FROM
  (
     SELECT bin_type_name,
      COUNT ( b.bin_id ) empty_locations,
      bin_level
       FROM bins b
    LEFT JOIN bin_items bi
         ON bi.bin_id = b.bin_id
      WHERE quantity IS NULL
      AND USAGE       = '1024'
   GROUP BY bin_type_name,
      bin_level,
      quantity
  )
  x
INNER JOIN
  (
     SELECT bin_type_name,
      bin_level,
      COUNT ( bin_type_name ) AS total
       FROM bins
      WHERE USAGE = '1024'
   GROUP BY bin_type_name,
      bin_level
  )
  y
     ON x.bin_type_name = y.bin_type_name
  AND x.bin_level       = y.bin_level
order by 2  ;

SELECT arr.PersonSK, MIN(arr.ArrivalDttm) as StartDttm,
(SELECT MIN(p2.ArrivalDttm)
 FROM person_dttm p2 
 WHERE p2.PersonSK=arr.PersonSK AND p2.ArrivalDttm > arr.ArrivalDttm AND p2.Room <> arr.Room) as EndDttm
FROM person_dttm arr
GROUP BY arr.PersonSK, arr.Room
ORDER BY arr.PersonSK, arr.ArrivalDttm

    SELECT  SUM(IF(type ='like',1,0) )as Likes, 
            SUM(IF(type='comment',1,0)) comments, 
            DAY(DATE) 'day'
    FROM `test_types`
    GROUP BY  DAY(DATE)

update tbraccd 
    set tbraccd_effective_date = '01-JAN-2014', 
        tbraccd_entry_date = '01-JAN-2014'
where tbraccd_detail_code = 'VPMT' 
and tbraccd_effective_date = '31-DEC-2013' 
and (tbraccd_entry_date > '31-DEC-2013' 
and tbraccd_entry_date < '01-JAN-2014')
and tbraccd_term_code = '201410'
and exists
    (select 'X' from ttbtaxn  
       where tbraccd.pidm = ttbtaxn.pidm
        and  ttbtaxn_stud_notif_status = 'E'
        and  ttbtaxn_tax_year = '2013')

DELETE FROM PLAYER WHERE playerId = any( SELECT playerId FROM Game G
WHERE G.levelId=1
AND
G.time>=ALL(SELECT time FROM GAME WHERE G.levelId=levelId));

select t1.SKU SKU, concat(t1.SerialNo, "  ", t1.grade) SerialGrade from yourTable t1
    join tempTable t2 on t2.SerialNo = t1.SerialNo
    orderby t1.SerialNo ASC

SELECT Price_€, COUNT(Price_€) FROM `sales20102015` 
WHERE Date_of_Sale LIKE '%2010%' AND County = 'Monaghan'
GROUP BY Price_€
ORDER BY COUNT(Price_€) DESC
LIMIT 1;

Public Class Form1

    ' Here we declare some class level variables. 
    'These are visible to all members of the class

    Dim dvSection As DataView
    Dim tableAdapter As New DataSet1TableAdapters.CustomersTableAdapter()
    Dim ds As New DataSet1()


    Public Sub New()

        ' This call is required by the designer.
        InitializeComponent()

       ' We fill our dataset - in this case using a table adapter
        tableAdapter.Fill(ds.Customers)
        dvSection = ds.Customers.DefaultView

        DataGridView1.DataSource = dvSection

    End Sub

    ' Here is the code to filter.
    ' Note how I refer to the class level variable dvSection
    Private Sub ComboBox1_SelectedIndexChanged(sender As System.Object, e As System.EventArgs) Handles ComboBox1.SelectedIndexChanged

        Dim filter As String 

        lblDepartmentId.Text =   ds.Tables("department").Rows(cmbDepartment.SelectedIndex)(0) 

        filter = "dprtId = " & lblDepartmentId.Text 
        dvSection.RowFilter = filter 

        dvSection.RowFilter = filter

    End Sub

    ' And here is the update code referring to the class level table adapter
    Private Sub Button1_Click(sender As System.Object, e As System.EventArgs) Handles Button1.Click
        tableAdapter.Update(ds.Customers)
    End Sub
End Class

id | type | text
1  | foo  | A
2  | foo  | B
3  | foo  | C
4  | bar  | D

public static string CreateCopyTableDataSQLServer(DataTable dt, string tableName, string connectionString)
{
    //Create the Destination Table based upon the structure of the DataTable
    string sql = string.Empty;
    string retValue = string.Empty;
    StringBuilder sbu;

    try
    {
        if (dt.Rows.Count == 0)
        {
            retValue += "The table " + tableName + " was NOT created because the source table contained zero (0) rows of data";
        }
        else
        {
            sbu = new StringBuilder(string.Format("IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[dbo].[{0}]') AND type in (N'U')) DROP TABLE [dbo].[{0}] ", tableName));
            sbu.Append("Create Table " + tableName + " (");

            string dataType = string.Empty;

            foreach (DataColumn column in dt.Columns)
            {
                switch (column.DataType.Name)
                {
                    case "String":
                        dataType = " nvarchar(MAX) ";
                        break;
                    case "DateTime":
                        dataType = " nvarchar(MAX) ";
                        break;
                    case "Boolean":
                        dataType = " nvarchar(MAX) ";
                        break;
                    case "Int32":
                        dataType = " int ";
                        break;
                    case "Byte[]":
                        dataType = " varbinary(8000) ";
                        break;
                    default:
                        dataType = " nvarchar(MAX) ";
                        break;
                }
                string columnName = column.ColumnName.ToString();
                columnName = columnName.FormatProperNameCase();
                columnName = column.ColumnName.ToString().Replace(" ", "_").Replace("-", "_").Replace("#", "_").FormatRemoveNonLettersNumbers();
                sbu.Append("[" + columnName + "]" + dataType + " null, ");
            }

            sbu.Remove(sbu.Length - 2, 2);
            sbu.Append(")");
            sql = sbu.ToString();
            sql = sql.Replace("/", "_").Replace("\\", "_");

            //Copy the Data From the Data Table into the destination Table that was created above
            bool errorRetValue = SQLServerBulkCopy(dt, sql, tableName, connectionString);

            if (!errorRetValue)
            {
                retValue += " \r\n";
                retValue += "There was an error!";
            }
        }
        return retValue;
    }
    catch (Exception ex)
    {
        retValue = string.Format("Error - There was a problem with table {0} and thus it's data has NOT been transferred - {1}", tableName, ex.Message);
        return retValue;
    }
}

public static bool SQLServerBulkCopy(DataTable dt, string Sql, string TableName, string connectionString, bool connectionTypeSQL = true)
{
    try
    {
        if (connectionTypeSQL)
        {
            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                conn.Open();
                using (SqlBulkCopy sqlcpy = new SqlBulkCopy(conn))
                {
                    using (SqlCommand cmd = new SqlCommand(Sql, conn))
                    {
                        cmd.ExecuteNonQuery();
                        sqlcpy.DestinationTableName = TableName;  //copy the datatable to the sql table
                        sqlcpy.WriteToServer(dt);
                    }
                }
            }
            return true;
        }
        else
        {
            throw new ArgumentOutOfRangeException("This method is only for SQL Server Engines");
        }
    }
    catch (Exception ex)
    {
        return false;
    }
}

Sub sample()

    Dim str_Val As String
    Dim start As Long
    str_Val = "Donkeys are <a href=""#"">also</a> humans <br /> hello hello hello <br /> hey hey hey"
    start = InStr(1, str_Val, "<br />", vbTextCompare) + Len("<br />")
    MsgBox Right(str_Val, Len(str_Val) - start)
End Sub

update @tempTable
set userName =  u.userName, 
badgeId = b.badgeId
FROM @Users as u
INNER JOIN @Badges as b
ON b.userId = u.UserId

SELECT * FROM TABLE Base base
LEFT JOIN A a ON a.a = base.a
LEFT JOIN C c ON c.c = a.c
LEFT JOIN B b ON b.b = c.b

from django.db import models, connection

class MyManager(models.Manager):

    def create_in_bulk(self, values):
        base_sql = "INSERT INTO tbl_name (a,b,c) VALUES "
        values_sql = []
        values_data = []

        for value_list in values:
            placeholders = ['%s' for i in range(len(value_list))]
            values_sql.append("(%s)" % ','.join(placeholders))
            values_data.extend(value_list)

        sql = '%s%s' % (base_sql, ', '.join(values_sql))

        curs = connection.cursor()
        curs.execute(sql, values_data)

class MyObject(models.Model):
    # model definition as usual... assume:
    foo = models.CharField(max_length=128)

    # custom manager
    objects = MyManager()

MyObject.objects.create_in_bulk( [('hello',), ('bye',), ('c', )] )

   FROM 
   ( 
     select * from seasons 
     union
     select '' as [sname],'1/1/1980' as [sStart],DateAdd(dd,-1,MIN([sStart])) as [send]
     from Seasons
     union
     select '' as [sname],DateAdd(dd,+1,MAX([send])) as [sstart],'12/31/2021' as [Send]
     from Seasons
    ) Seasons         

SELECT m.month_first, COUNT(x.date_of_car_sale) as sales
FROM months m
LEFT JOIN (
  SELECT date_of_car_sale
  FROM sales
) x ON m.month_first <= x.date_of_car_sale 
    AND m.month_last >= x.date_of_car_sale
GROUP BY m.month_first
ORDER BY m.month_first

SQL> select * from v$version;

BANNER                                                                               
-------------------------------------------------------------------------------- 
Oracle Database 12c Enterprise Edition Release 12.1.0.1.0 - 64bit Production     
....


SQL> create table t1(
  2    col1 number,
  3    col2 number invisible
  4  )
  5  ;

Table created

select date, station, sum(imp) / count(distinct dem)
from mytable
group by date, station

UPDATE posts SET post_modified = post_date;

WITH summary AS (
   SELECT t.employee,
          t.task,
          t.iscurrent,
          ROW_NUMBER() OVER (PARTITION BY t.employee
                                 ORDER BY t.task) AS rank
     FROM TABLE t)
   SELECT a.employee,
          a.task AS current_task,
          COALESCE(b.task, y.min_task) AS next_task,
          COALESCE(c.task, y.min_task) AS next_task2
     FROM summary a
     JOIN (SELECT x.employee,
                  MIN(x.task) AS min_task
             FROM TABLE x
         GROUP BY x.employee) y ON y.employee = a.employee
LEFT JOIN summary b ON b.employee = a.employee
                   AND b.rank = a.rank + 1
LEFT JOIN summary c ON c.employee = a.employee
                   AND c.rank = a.rank + 2                   
    WHERE a.iscurrent = 'yes'

select dateadd(s,-1*datepart(s, votetime),votetime) ,
sum(case when vote='Y' then 1 else 0 end) as 'Yes',
sum(case when vote='N' then 1 else 0 end) as 'No'

from votes
group by dateadd(s,-1*datepart(s, votetime),votetime)

select
    t1.*,
    case when t2.user is not null then 1 else 0 end is_mutual
from test as t1
    left outer join test as t2 on t2.user = t1.friend and t2.friend = t1.user

SELECT * FROM crosstab(
       'SELECT cola, EXTRACT(HOUR from colb) AS h, count(*) AS ct
        FROM   fooo
        GROUP  BY 1, 2
        ORDER  BY 1, 2'

       ,'SELECT g::float8 FROM generate_series(0,23) g'
   ) AS ct (cola text
      , h00 int, h01 int, h02 int, h03 int, h04 int, h05 int
      , h06 int, h07 int, h08 int, h09 int, h10 int, h11 int
      , h12 int, h13 int, h14 int, h15 int, h16 int, h17 int
      , h18 int, h19 int, h20 int, h21 int, h22 int, h23 int);

SELECT *
FROM   messages
WHERE  (sender_id, receiver_id, date) IN (
          SELECT   sender_id, receiver_id, MAX(date)
          FROM     messages
          WHERE    receiver_id=7
          GROUP BY sender_id, receiver_id)

SELECT 
  CASE 
    WHEN RIGHT(`name`,LENGTH(`name`)-INSTR(`name`,'-')) = `name` THEN ''
    ELSE RIGHT(`name`,LENGTH(`name`)-INSTR(`name`,'-')) 
  END AS `suffix`,
  `name`
FROM 
  `table1`
ORDER BY
  `suffix`, `name`

DELETE FROM map_table where mapid LIKE 'h%';

SELECT `email`,`listid` 
FROM   `table` t
WHERE  `emailaddress` LIKE '%@email%' AND 
       `listid` = 1 AND
       NOT EXISTS (SELECT *
                   FROM   `table` t2
                   WHERE  t1.`emailaddress` = t2.`emailaddress` AND
                          t2.`listid = 5)

SELECT
      t1.day,
      t2.day as OtherDay,
      t1.quality,
      t1.anotherColumn,
      t2.OtherAnotherColumn,
      t1.thirdColumn,
      t2.OtherThirdColumn
   FROM 
      my_table t1
         join my_table t2
            on t1.quality = t2.quality
           AND t2.day = '2015-01-09'
   where
      t1.day = '2015-01-08' 

DECLARE @ReportAlarmOverride TABLE
(
ReportAlarmOverrideId INT IDENTITY(1,1),
ChartId INT,
Active BIT,
StartTime DATETIME,
EndTime DATETIME,
LastModifiedTime DATETIME DEFAULT GETDATE()
)
INSERT INTO @ReportAlarmOverride
SELECT 1, 1, GETDATE() - 1, NULL, NULL UNION
SELECT 3, 1, GETDATE() - 1, GETDATE(), NULL UNION
SELECT 5, 1, GETDATE() - 3, NULL, NULL UNION
SELECT 7, 1, GETDATE() - 1, NULL, GETDATE() --UNION 
--SELECT 3, 1, '2012-11-12 16:09:20', '2012-11-12 16:09:21', NULL --Adding this row makes SELECT below stop working

SELECT  Alarm.AlarmTime, *
FROM dbo.AlarmLogSummary Alarm
    JOIN dbo.AlarmConfiguration AlarmConfig ON Alarm.AlarmConfigurationId = AlarmConfig.AlarmConfigurationId
WHERE Alarm.AlarmTime > GETDATE() - 2
  AND NOT EXISTS(SELECT 1 FROM @ReportAlarmOverride Override
                    WHERE Override.ChartId = AlarmConfig.ChartId
                      AND Override.Active = 1
                      AND Alarm.AlarmTime BETWEEN Override.StartTime AND ISNULL(Override.EndTime, GETDATE())

;WITH todaydate as
(
  SELECT max(date) as date, ticker
  FROM tblndx
  group by ticker
),  yesterdaydate as
(
  SELECT max(time) as time, ticker
  FROM tblndx
  group by ticker
  having  DATEDIFF(Day, date, getdate()) = 1
)
SELECT ticker
    , date
    , time
    , [open]
    , high
    , low
    , [close]
    , volume
    , change
    , yeserdaydate.time as [yeserday time]
from tblndx
inner join todaydate on tblndx.ticker = todaydate.ticker and tblndx.date = todaydate.date
left join yesterdaydate on tblndx.ticker = yeserdaydate.ticker

data tableName type tabname.  
if <some condition>.   
   tableName='PA0001'.   
else.   
   tableName='PA0002'.   
endif.   
select * from (tableName) where ...

SELECT     (SELECT COUNT (tab.someColumnName)
           FROM TableName tab
           WHERE tab.experience = 1 AND tab.bl = 1) AS 'Regular',

           (SELECT COUNT (tab.someColumnName)
           FROM TableName tab               
           WHERE tab.experience = 1 AND tab.bl = 0) AS 'rptmm',

           (SELECT COUNT (tab.someColumnName)
           FROM TableName tab
           WHERE tab.experience = 0 AND tab.bl = 0) AS 'New',

           (SELECT COUNT (tab.someColumnName)
           FROM TableName tab
           WHERE tab.experience = 0 AND tab.bl = 1) AS 'rptss'

IF @CurrentStatus IN (1, 4) AND @RoleID IN ('ADMN', 'PMGR', 'SMGR', 'DMGR', 'DESI', 'DERO')
    BEGIN
            -- SELECT query...
    END

Else IF @CurrentStatus = 2 AND @RoleID IN('ADMN')
    BEGIN
            -- SELECT query...
    END

Else
    BEGIN
       -- Default query
    END

SELECT person_id
FROM interest
WHERE interest_category IN ( 'music', 'movie', 'sport');
GROUP BY person_id
HAVING COUNT(*) = 3;

select
    nvl(
        (select (aa + bb) from table_x where cc = 'on' and id = t2.id)
    , 0) + t2.b as sum
from
    table_y t2

select *
from table a
    join table b
        on a.month = b.month
           and a.average between b.rangestart and isnull(b.rangeend,10000) -- 100000 = greater than max value

   SELECT MAX(ltrim(sys_connect_by_path(flow_run_id, ','), ','))
   FROM
   (
    select flow_run_id, rownum rn
    from table
    where CREATED_DATE < sysdate - 32
    and rownum < 10
    order by 1 desc
   )
   START WITH rn = 1
   CONNECT BY PRIOR rn = rn - 1

set @myDate = isnull(@myDate, dateadd(year, -2, getdate()))

 Select * from [Members]
 where [Expire] >= #" & Me.Text168 & "# 
 And [MembType] IN ('A' , 'B', 'C' , 'D') And  [MembType] <> 'E'

Select * from Customer 
where CustNo IN
(
  SELECT CustNo
  FROM Rental
  GROUP BY CustNo
  HAVING COUNT(*) > 1
)

select * into new_table from table where 1 = 0

with res as(
select "Id" , "Row" , "Description" ,  "Type" , "Answer", "Code", "ClientId" from A

union all

select B."Id" as "Id" , B."Row" as "Row" , B."Desc" as "Description",
 B."Type" as "Type", null as "Answer", B."Code" as "Code", A1."ClientId" as "ClientId"
 from B inner join (select distinct "ClientId", "Code" from A) A1 ON B."Code"= A1."Code"
 ) 
select * from res order by "Code", "ClientId", "Answer"

SELECT [Time sub].CLIENT_ID, 
       [Time sub].Code, 
       [Time sub].Minutes, 
       FirstDay.MinEntry

FROM [Time sub] 
     INNER JOIN [
        SELECT
         [Time sub].CLIENT_ID,
         MIN([Time sub].[Date_Entered]) AS MinEntry

        FROM
         [Time sub]

        WHERE
          [Time sub].Code NOT IN ("T", "L")

       GROUP BY
          [Time sub].CLIENT_ID,
          DateValue([Time sub].[Date_Entered])

 ].AS FirstDay 

 ON FirstDay.MinEntry = [Time sub].[Date_Entered]

 ORDER BY FirstDay.MinEntry, [Time sub].CLIENT_ID;

with data as(
select date_check, type, total from (
      select date_check, type || ' ' || decode(id_type, 1, '- new', 2, '- old', 3, '- xpto') as type, total from history
))
select * from data
pivot(
  max(total) for type in ('abc - new', 'abc33 - new', 'bbb - new',
                          'bbb33 - xpto', 'ddd - old', 'ddd33 - old')
)
order by date_check;

;WITH CTE AS (
  SELECT SessionID, LineNumber, LineContents,
         Row_Number() OVER(PARTITION BY SessionID ORDER BY LineNumber) Rn
  FROM Table1 
)
UPDATE CTE
SET LineNumber = Rn
WHERE SessionID = 74666;

select *
from
father 
inner join mother on father.IDNO = mother.IDNO
inner join parents on mother.IDNO = parents.IDNO
where
father.IDNO = '03a45'

IF NOT EXISTS ( select * 
                  from sys.objects 
                 where parent_object_id = object_id('MyTable') 
                   and type = 'PK' )

do <create index for rec_index>

=IIF(First(Fields!string.Value) = Last(Fields!string.Value), First(Fields!string.Value), First(Fields!string.Value)+","+ Last(Fields!string.Value))

ORDER BY status,
        CASE WHEN status IN (0, 10) THEN Datetime END ASC,
        CASE WHEN status IN (20, 100) THEN Datetime END DESC

> select 643/109;
5
> select round(643/109, 0);
5.0
> select 643/109.0;
5.89908256880734
> select round(643/109.0, 0);
6.0

places := []Place{}
err := db.Select(&places, "SELECT * FROM place ORDER BY telcode ASC")
if err != nil {
    fmt.Printf(err)
    return
}

SELECT REGEXP_REPLACE('aa      b     cc     d  e f ', '( ){2,}', ' ')
FROM DUAL;

select UserID from Friends
where FriendID = 1001
Union All
select FriendID from Friends
where UserID = 1001

DECLARE col_names CURSOR FOR
SELECT column_name, table_name
FROM INFORMATION_SCHEMA.COLUMNS

<%@ page import="com.day.commons.datasource.poolservice.DataSourcePool" %>
<%@ page import="javax.sql.DataSource" %>

DataSourcePool dbService = sling.getService(DataSourcePool.class);
DataSource ds = (DataSource) dbService.getDataSource("yourDataSourceName");

if(ds != null) {
   try {
      %><sql:query var="result" sql="SELECT now()" dataSource="<%=ds%>" /><%
   } catch (Exception e) { } 
}
select f.food, min(p.person)
from food f
    left join linktable l on f.id = l.food_id
    left join people p on p.id = l.person_id
group by f.food

/// <summary>
/// MS SQL 2005 Compatible DateDiff() function.
/// </summary>
/// <remarks>
/// ms-help://MS.VSCC.v80/MS.MSDN.v80/MS.SQL.v2005.en/tsqlref9/html/eba979f2-1a8d-4cce-9d75-b74f9b519b37.htm
/// 
/// 
/// </remarks>
[SQLiteFunction(Name = "DateDiff", Arguments = 3, FuncType = FunctionType.Scalar)]
public class DateDiff : SQLiteFunction
{
    public override object Invoke(object[] args)
    {
        if (args[0] == DBNull.Value || 
            args[1] == DBNull.Value ||
            args[2] == DBNull.Value)
        {
            return null;
        }
        string part = Convert.ToString(args[0]);
        DateTime startTime = ToDateTime(args[1]);
        DateTime endTime = ToDateTime(args[2]);

        switch(part)
        {
            case "year":
            case "yy":
            case "yyyy":
                return endTime.Year - startTime.Year;

            case "quarter":
            case "qq":
            case "q":
                return (endTime.Year - startTime.Year) * 4 + ((endTime.Month - 1) / 3) - ((startTime.Month - 1) / 3);

            case "month":
            case "mm":
            case "m":
                return (endTime.Year - startTime.Year) * 12 + endTime.Month - startTime.Month;

            case "dayofyear":
            case "dy":
            case "y":
            case "day":
            case "dd":
            case "d":
                return (endTime - startTime).TotalDays;

            case "week":
            case "wk":
            case "ww":
                return (endTime - startTime).TotalDays / 7.0;

            case "Hour":
            case "hh":
            case "h":
                return (endTime - startTime).TotalHours;

            case "minute":
            case "mi":
            case "n":
                return (endTime - startTime).TotalMinutes;

            case "second":
            case "ss":
            case "s":
                return (endTime - startTime).TotalSeconds;

            case "millisecond":
            case "ms":
                return (endTime - startTime).TotalMilliseconds;

            default:
                throw new ArgumentException(String.Format("Date part '{0}' is not recognized.", part));
        }

    }

    private static DateTime ToDateTime(object source)
    {
        try
        {
            return Convert.ToDateTime(source);              
        } 
        catch (Exception ex)
        {
            throw new ArgumentException(String.Format("DateDiff Input value '{0}' can not be converted to a DateTime.", source), ex);
        }
    }
}

WITH T(A, B, C, D, RowNum) AS 
(
    SELECT A, B, C, D, ROW_NUMBER() OVER (PARTITION BY A ORDER BY A)
    FROM MyTable
)
SELECT * FROM T
WHERE 
    RowNum = 1

WITH t1 AS (
    SELECT 'T18564' AS f_number, '20140702' AS act_date
         , 10 AS amount, '700102180211' AS range_start
         , '700102195210' AS range_end
      FROM dual
     UNION ALL
    SELECT 'T18564', '20140702', 10, '700104371331', '700104376330'
      FROM dual
     UNION ALL
    SELECT 'T18564', '20140702', 20, '700250037215', '700250077214'
      FROM dual
     UNION ALL
    SELECT 'T18564', '20140702', 30, '600311039928', '600311044927'
      FROM dual
)
SELECT f_number, act_date, amount, range_start - 1 + LEVEL
  FROM (
    SELECT f_number, act_date, amount
         , TO_NUMBER(range_start) AS range_start
         , TO_NUMBER(range_end) AS range_end
         , ROW_NUMBER() OVER ( ORDER BY NULL ) AS rn
      FROM t1
) CONNECT BY range_start - 1 + LEVEL <= range_end
      AND PRIOR rn = rn
      AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;

WHERE ad.AdvertisementID IN (SELECT AdvertisementID FROM UDF_GetAdvertisements)

AND [GROUP] NOT IN 
(SELECT [GROUP] FROM mytable WHERE FILTER1 = '22337755' OR FILTER2 = '22337755') 

SELECT
    "Parent_id",
    SUM("Count"),
    bool_and("Read")
FROM
    tablename
GROUP BY
    "Parent_id";

select c.efforts_id, 
  c.cycle_name,
  listagg(r.release_name, ', ') within group (order by c.efforts_id) as release_name
from
(
  select efforts_id,
    listagg(cycle_name, ', ') within group (order by efforts_id) as cycle_name
  from yourtable
  group by efforts_id
) c
inner join
(
  select distinct efforts_id, release_name
  from yourtable
) r
  on c.efforts_id = r.efforts_id
group by c.efforts_id, c.cycle_name

    Select tab1.Name,tab2.Name 
From table1 
INNER JOIN table2 
    ON table2.ID=table1.ID
WHERE (@Val=0 AND table1.ID>5) OR (@Val!=0 AND table2.ID>5)

ALTER TABLE lists_has_users DROP FOREIGN KEY `key_symbol`;
ALTER TABLE lists_has_users ADD FOREIGN KEY (lists_id_lists) REFERENCES lists (id_lists) ON DELETE CASCADE

     P1                 P2
 ---------------------------------
  BEGIN TRANS
                     BEGIN TRANS
  WRITE (success)
                     WRITE (blocked)
  do work            |
  .                  |
  .                  | 
  COMMIT     ->      block released, WRITE finishes

                     do work
                     . 
                     .
                     COMMIT

DECLARE @COMMASEPSTR NVARCHAR(200), @SQL nvarchar(max), @STR  nvarchar(100) = 'a,b,c'
 SET @COMMASEPSTR= '''' + REPLACE(@STR,',',''',''') + ''''

SET @SQL = 'select columnA,columnB from 
test where columnA IN ( ' + @COMMASEPSTR + ')'
EXEC sp_executesql @SQL

CREATE TABLE #FeeRate (Expression VARCHAR(20) DEFAULT '', Price NUMERIC(10,2) DEFAULT 0, Description VARCHAR(50) DEFAULT '',Priority int)

INSERT INTO #FeeRate VALUES ('001%',  10.0, 'International call',5)
INSERT INTO #FeeRate VALUES ('0[^0]%', 5.0, 'National call',4)
INSERT INTO #FeeRate VALUES ('800%',   0.0, 'Free call',3)
INSERT INTO #FeeRate VALUES ('400%',   0.8,  '800 like, but caller need pay for local part',2)
INSERT INTO #FeeRate VALUES ('%',  0.2, 'Others/Local call',1)

SELECT * FROM #Detail d
    inner JOIN #FeeRate f ON d.TelNO LIKE f.Expression
    left join #FeeRate f_anti on d.TelNo LIKE f_anti.Expression and f_anti.Priority > f.Priority
where
    f_anti.Price is null

SELECT
    t.Date,
    t.Visits,
    t.Purchases,
    SUM(r.Visits) AS CumVisits,
    SUM(r.Purchases) AS CumPurchases,
    SUM(r.Purchases)*1.0/SUM(r.Visits) AS Ratio
FROM t
JOIN t AS r ON r.Date BETWEEN SUBSTR(t.DATE, 1, 4) AND t.Date
GROUP BY t.Date

select pid, trim(user_name), starttime, query
from stv_recents
where status = 'Running'
order by starttime ASC; 

SELECT * FROM StatsVehicle WHERE 
( 
    -- Removed the following, as it's not clear if this is beneficial
    -- (@referenceModeleId IS NOT NULL) AND 
    (ReferenceModelId = @referenceModeleId)
) OR
(@referenceModeleId IS NULL AND 
 (
    (ReferenceMakeId = @referenceMakeId) OR
    (@referenceMakeId IS NULL)
 )
)

adb shell

  SELECT * 
  FROM tablename
  WHERE IFNULL(colname, 0) <=0;

SELECT st.Id, st.Name, GROUP_CONCAT(ct.ClassId) AS ClassList
    FROM StudentTable st
        INNER JOIN ClassTable ct
            ON st.Id = ct.Id
    GROUP BY st.Id, st.Name

SELECT Id_car, count(DISTINCT Id_Color) AS CountColors FROM SoldCars GROUP BY Id_car

For cn As Integer = 1 To Datagridview1.RowCount 
    Dim StartTime As Date = Datagridview1.Rows(cn-1).Cells(1).Value
    Try
        Using conn1 As New SqlConnection(connstring)
            conn1.Open()
            Using comm1 As New SqlCommand("INSERT INTO table1 (col1, col2, col3, col4, col5) VALUES (@col1, @col2, getdate(), 5, @col5)", conn1)
                With comm1.Parameters
                    .AddWithValue("@col1", StartTime)
                    .AddWithValue("@Col2", Combobox1.selectedvalue)
                    .AddWithValue("@Col5", (cn * 2) - 1)
                End With
                comm1.ExecuteReader()
            End Using
        End Using
    Catch ex As Exception
        MsgBox(ex.ToString)
    End Try
Next

    SELECT COUNT(DATE(`joinedDate`)) AS `no_of_members_on_this_day`,
                                         DATE(`joinedDate`) AS `date_of_signup` 
                            FROM   tableName 
                            JOIN (
                                    SELECT 100 / COUNT(*) AS factor
                                    FROM tableName
                                  ) AS t
                            GROUP BY 
                                DATE(`joinedDate`)

SELECT *
FROM 
( 
   SELECT [YourColumn] AS YourAlias, etc...
   FROM Whatever
) YourSubquery
WHERE YourAlias > 2

SELECT post.ID,max(post.Title),max(post.Author),min(post.CreateDate),
min(comment.CreateDate),
datediff(mi,min(post.CreateDate),min(comment.CreateDate)) as 'first comment in minutes'
FROM Posts as post
INNER JOIN Comments as comments on post.ID = comment.PostID
where  comment.Type != 'initial'
group by post.id

SELECT IFNULL(T1.summary,0) as summary,
       rangeDescription.`range`
  FROM (      SELECT '1-15' as `range`, 1 as rowOrder
        UNION SELECT '16-30'        , 2
        UNION SELECT '31-45'        , 3
        UNION SELECT '46-60'        , 4
        UNION SELECT '61-75'        , 5
        UNION SELECT '76-90'        , 6
        UNION SELECT '90+'          , 7
        )rangeDescription
  LEFT JOIN
        (SELECT count(minute) as summary, 
          CASE WHEN minute >= 1  AND minute <= 15 THEN  '1-15'
               WHEN minute >= 16 AND minute <= 30 THEN '16-30' 
               WHEN minute >= 31 AND minute <= 45 THEN '31-45' 
               WHEN minute >= 46 AND minute <= 60 THEN '46-60' 
               WHEN minute >= 61 AND minute <= 75 THEN '61-75'
               WHEN minute >= 76 AND minute <= 90 THEN '76-90'
               WHEN minute > 90   THEN '90+'
               ELSE 'no goals' 
          END as `range` 
        FROM
        teamgoals
        WHERE clubId = 1
         GROUP BY `range`
        )T1
   ON rangeDescription.`range` = T1.`range`
ORDER BY rangeDescription.rowOrder asc

ALTER TABLE dbo.Person ADD job_Id INT NULL;
ALTER TABLE dbo.Person ADD CONSTRAINT FL_JOB 
FOREIGN KEY (job_Id) REFERENCES dbo.Job(job_Id);

SELECT pm1.meta_value _EventVenueID
     , p1.post_title event_type
     , p2.post_title organiser
     , pm2.meta_value _EventStartDate
     , pm3.meta_value _EventEndDate
     , pm4.meta_value _EventOrganizerID
  FROM wp_posts p1 
  JOIN wp_postmeta pm1 
    ON p1.ID = pm1.post_id 
   AND pm1.meta_key = '_EventVenueID'
  LEFT 
  JOIN wp_postmeta pm2 
    ON p1.ID = pm2.post_id 
   AND pm2.meta_key = '_EventStartDate'
  LEFT 
  JOIN wp_postmeta pm3 
    ON p1.ID = pm3.post_id 
   AND pm3.meta_key = '_EventEndDate'
  LEFT 
  JOIN wp_postmeta pm4 
    ON p1.ID = pm4.post_id 
   AND pm4.meta_key = '_EventOrganizerID'

  LEFT
  JOIN wp_posts p2
    ON p2.id = pm4.meta_value 

 WHERE p1.post_type = 'tribe_events' 
   AND p1.post_status = 'publish'
   AND pm1.meta_value = 333;

      Product-Enquiries
=============================
P_ID-E_ID  PK, int, AUTO_INCR 
P_ID       FK, int
E_ID       FK, int

SELECT 
  SUM(vote = 1) AS upvotes,
  SUM(vote = -1) AS downvotes
FROM votes WHERE link = <linkid>

select c.*
from copies c
where not exists (select 1
                  from booking b
                  where b.copy_id = c.id and
                        b.rent_until >= @PeriodStart and b.rent_from <= @PeriodEnd
                 );

SELECT  COUNT(CourseCount) AS CourseCount
FROM    (
    SELECT  StudentID, COUNT(CourseID) AS CourseCount
            FROM enrollment
            GROUP BY StudentID
            HAVING  (COUNT(CourseID) >= 4)) AS T

MERGE INTO scv_client_details d
USING (SELECT NVL(c.paxus_client_id, c.client_id),
              UPPER(NVL(NVL2(c.paxus_client_id, 
                             pc.clt_mar_stat, 
                             c.maritial_status_code),
                        decode(c.client_type_id, '2000001702', 'C', 'U'))) 
              AS NewMarStatus,
              scd.ROWID rid
         FROM scv_client_details scd, client c, paxus_client pc
        WHERE scd.system_client_id = to_char(c.client_id)
          AND c.paxus_client_id = pc.client(+)
          AND (scd.marital_status <> 
               UPPER(NVL(NVL2(c.paxus_client_id, 
                             pc.clt_mar_stat, 
                             c.maritial_status_code),
                        decode(c.client_type_id, '2000001702', 'C', 'U')))
              OR
              scd.marital_status IS NULL)) v
ON (d.ROWID = v.rid)
WHEN MATCHED THEN
   UPDATE SET d.marital_status = newmarstatus;

select
  p.id as projects_id,
  pp.id projectparams_id,
  pp.defaultvalue,
  pp.defaultvaluealias,
  pp.globalvalue,
  pp.globalvaluealias,
  ppp.value,
  ppp.valuealias
from projects p
cross join projectparams pp 
left join projects_projectparams ppp on ppp.projects_id = p.id 
                                     and ppp.projectparams_id = pp.id;

CREATE       PROCEDURE [dbo].[usp_GetOneBatchJobForExec]
@sMachineName NVARCHAR(50)
AS
BEGIN

SET NOCOUNT ON; 
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

with cte as (
    SELECT TOP(1) JD.*, JY.JOB_NAME
    FROM dbo.T_JOB_TYPE AS JY 
        INNER JOIN dbo.T_JOB_TYPE_ON_INST AS JTI 
            ON JY.JOB_TYPE_ID = JTI.JOB_TYPE_ID
        INNER JOIN dbo.T_JOB_DIRECT AS JD WITH (ROWLOCK, READPAST)
            ON JD.JOB_TYPE_ID = JTI.JOB_TYPE_ID
        AND JD.INST_ID = JTI.INST_ID
    WHERE (JD.IN_PROCESS_BY IS NULL OR JD.IN_PROCESS_BY = @sMachineName) AND JD.START_DATETIME < GETDATE()
    ORDER BY JD.IN_PROCESS_BY DESC, JD.START_DATETIME DESC, JTI.PRIORITY DESC
)
UPDATE cte 
SET IN_PROCESS_BY = @sMachineName
OUTPUT inserted.JOB_DIRECT_ID, inserted.JOB_TYPE_ID, inserted.INST_ID, inserted.JOB_QUEUE_ID, inserted.JOB_DATA, inserted.REG_DATETIME, 
        inserted.REG_USER_ID, inserted.JOB_TIME_ID, inserted.IN_PROCESS_BY, inserted.START_DATETIME, deleted.JOB_NAME

END

SELECT COUNT(DISTINCT Project), COUNT(DISTINCT Node) FROM YourTable

; WITH CTE AS 
(
    SELECT *, 
    COUNT(*) OVER (PARTITION BY CustID, DOP) Row_Cnt
    FROM TEST
), CTE2 AS 
(
    SELECT * FROM CTE
    WHERE [dop] BETWEEN '11/05/12' AND '11/20/12'
), CTE3 AS 
(
    SELECT * FROM CTE2 WHERE price > 0
    UNION
    SELECT * FROM CTE2 WHERE price < 0 
    and SKU IN (SELECT SKU FROM CTE2 WHERE Price > 0)
    UNION
    SELECT * FROM CTE
    WHERE row_cnt > 1 and DOP IN (
    SELECT max(A.dop) d FROM CTE A
    INNER JOIN CTE2 B ON A.CustID = B.CustID AND A.SKU = B.SKU
    )
 )
SELECT Custid, max(dop) dateid, sum(price) Price
from cte3
group by custid;

select 
PremiumYTDPrevious=Sum(CASE WHEN AASI.Inv_Acctcur>='200901'
    AND AASI.Inv_Acctcur<= '200904'
THEN (AASI.Inv_Premium)*R.[Percent]
ELSE 0 END),
PremiumYTDCurrent=Sum(CASE WHEN AASI.Inv_Acctcur>='201001'
    AND AASI.Inv_Acctcur<= '201004' 
THEN (AASI.Inv_Premium)*R.[Percent]
ELSE 0 END),
[... the rest of your query ...]

SELECT     SiteProductVariation.ProductVariationID
         , COUNT(CASE WHEN SiteProduct.ProductDisplay = 0 THEN  SiteProduct.SiteProductID END) AS Expr1
         , COUNT(CASE WHEN SiteProduct.ProductDisplay = 1 THEN  SiteProduct.SiteProductID END) AS Expr2
FROM SiteProductVariation 
INNER JOIN SiteProduct ON SiteProduct.SiteProductID = SiteProductVariation.SiteProductID 
WHERE (SiteProductVariation.ProductVariationID = 159868) 
  AND (SiteProduct.ProductDisplay = 0 
       OR 
      SiteProduct.ProductDisplay = 1)
GROUP BY SiteProductVariation.ProductVariationID

 SELECT id, COUNT(id)
 FROM table
 GROUP BY id

UPDATE `client` a,
(SELECT StatementTermsID FROM statementterms WHERE TermsDescription = 'NET 15') b
SET a.StatementTermsID = b.StatementTermsID
WHERE a.StatementNote LIKE '%Net 15%';

select p.*
from
  (select code_wildcard
   from second
   where id = 1) s
  join parent p
      on p.office_code like s.code_wildcard

