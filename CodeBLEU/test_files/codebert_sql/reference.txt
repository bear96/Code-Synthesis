select max(id), parent from tree group by parent;
CREATE GLOBAL TEMPORARY TABLE comments ON COMMIT PRESERVE ROWS AS SELECT * FROM test@db; SELECT INTO TEST(ID, NAME,DESCRIPTION, COMMENT) SELECT ID, NAME, dbms_lob.substr(description, 4000, 1), dbms_lob.substr(description, 4000, 1) FROM comments;
UPDATE categories SET code = CONCAT(code, '_standard') WHERE id = 1;
select * from user where id=100 limit 1
var queryUsers = dc.lkUsers.Where(p => p.UserID == userId); var queryLinks = dc.lkDeptLinks.Where(p => queryUsers.ref.Any(x=>x== p)); var queryDept = dc.lkDepts.Where(p => queryLinks.deptid.Any(x=> x == p.deptid)); return queryDept .Select(x=>new {ID = x.deptId, Name = x.deptName, Detail = x.Detail}) .ToList();
IF @dbnum = 1 USE Db1; ELSE USE DefaultDb;
SELECT A.name, A.regionID, b.Name FROM countries A Join regions B on B.id = A.RegionId ORDER BY A.name ASC
SELECT a.* FROM Article AS a JOIN ( SELECT article_id FROM Comment GROUP BY article_id ORDER BY count(*) DESC LIMIT 10 ) AS c ON c.article_id = a.id;
SELECT (SELECT Max(StartDate) FROM myTable WHERE phName = "Name") as MaxDate, id, name , phName , startDate, endDate FROM myTable WHERE phName = "Name"
INSERT INTO match VALUES(1001, TO_DATE('20130515', 'YYYYMMDD'), 90000, 'American Airlines Arena', 001);
- (void)resetDateFilters { self.dateMinSetFilter = [NSDate distantPast]; self.dateMaxSetFilter = [NSDate distantFuture]; // destroy the FRC here, delete cache if necessary }
//Clears learnDataTable: mDb.execSQL("DELETE FROM learnDataTable"); //Insert 5 random rows from dic: mDb.execSQL("INSERT INTO learnDataTable (english, bangla) SELECT english ,bangla FROM dic ORDER BY RANDOM() LIMIT 5");
SET @year := 2013; SELECT SUM(if (CONCAT(@year, '-01') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jan, SUM(if (CONCAT(@year, '-02') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Feb, SUM(if (CONCAT(@year, '-03') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Mar, SUM(if (CONCAT(@year, '-04') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Apr, SUM(if (CONCAT(@year, '-05') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) May, SUM(if (CONCAT(@year, '-06') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jun, SUM(if (CONCAT(@year, '-07') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Jul, SUM(if (CONCAT(@year, '-08') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Aug, SUM(if (CONCAT(@year, '-09') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Sep, SUM(if (CONCAT(@year, '-10') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Oct, SUM(if (CONCAT(@year, '-11') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) Nov, SUM(if (CONCAT(@year, '-12') BETWEEN date_format(date_ini, '%Y-%m') AND date_format(date_expired, '%Y-%m'),i.net_insurance, 0)) `Dec` FROM insurances i INNER JOIN policies p ON p.id = i.policy_id WHERE (i.initial_date >= p.date_ini AND i.final_date <= p.date_expired) ;
CREATE VIEW history_view AS SELECT h.id, h.name, min(CASE WHEN h.code = 1 THEN time_date) AS start_date, min(CASE when h.code = 2 THEN time_date) AS process_date, min(CASE when h.code = 3 THEN time_date) AS finish_date FROM history h group by h.id, h.name;
order by (fruit = 'Melon') desc, rand() limit 3;
Select min(DATEADD(HOUR,DATEDIFF (HOUR,'2011-01-01',CreateOn )/5*5,'2011-01-01')) as Start_time, max(DATEADD(HOUR,(DATEDIFF (HOUR,'2011-01-01',CreateOn )/5+1)*5,'2011-01-01')) as End_Time, DATEDIFF (HOUR,'2011-01-01',CreateOn )/5 as Interval_Number, Count(*) as _Count From Table1 Group By DATEDIFF (HOUR,'2011-01-01',CreateOn )/5
DBMS_OUTPUT.put_line('Some Message');
CREATE TABLE #NEWTABLE ( NEW_CUST_KEY int not null , CUST_ID int not null, CUST_EMAIL nvarchar(100) null ) ------------------------------------ insert into #NEWTABLE (NEW_CUST_KEY,CUST_ID,CUST_EMAIL) SELECT ROW_NUMBER() OVER(ORDER BY CUST_ID, CUST_EMAIL) AS NEW_CUST_KEY, CUST_ID, CUST_EMAIL FROM ( SELECT CUST_ID, CUST_EMAIL FROM OLDTABLE GROUP BY CUST_ID, CUST_EMAIL ) T UPDATE Upd SET NEW_CUST_KEY = T.NEW_CUST_KEY FROM #NEWTABLE Upd join ( SELECT CUST_ID, min(NEW_CUST_KEY) AS NEW_CUST_KEY FROM #NEWTABLE GROUP BY CUST_ID) T on Upd.CUST_ID = T.CUST_ID UPDATE Upd SET NEW_CUST_KEY = T.NEW_CUST_KEY FROM #NEWTABLE Upd join ( SELECT CUST_EMAIL, min(NEW_CUST_KEY) AS NEW_CUST_KEY FROM #NEWTABLE GROUP BY CUST_EMAIL) T on nullif(Upd.CUST_EMAIL,'') = nullif(T.CUST_EMAIL,'') UPDATE Upd SET NEW_CUST_KEY = T.CHANGE_CUST_KEY FROM #NEWTABLE Upd join ( SELECT NEW_CUST_KEY, ROW_NUMBER() OVER(ORDER BY NEW_CUST_KEY) AS CHANGE_CUST_KEY FROM #NEWTABLE GROUP BY NEW_CUST_KEY) T on Upd.NEW_CUST_KEY = T.NEW_CUST_KEY select * from #NEWTABLE
SELECT a.ItemID, a.Name FROM things a WHERE name IN (SELECT name FROM things WHERE itemID = 1)
select * from Publisher where Motor COLLATE Macedonian_BIN like '%" + ed + "%' ";
select user_id, user_login_date, row_number() over( partition by user_id order by user_login_date ) as date_id from users order by user_id, date_id
with xml_source as (select 1 id, 'xyz' val, 'y' flag from dual union all select 2, 'abc', 'y' from dual union all select 3, 'def', 'y' from dual union all select 4, 'ghi', 'y' from dual union all select 5, 'jkl', 'y' from dual union all select 6, 'mno', 'y' from dual) select xmlagg(xmlelement(TABLE_NAME, (xmlelement(TABLE_ROW, XMLATTRIBUTES(x.id AS ID), xmlforest(x.val as Value))))) from xml_source x
SELECT COUNT(sid) FROM ( SELECT sid FROM Labs LIMIT 2, 18446744073709551615 ) T1
SELECT DAY(`date`) AS `date` SUM(CASE WHEN HOUR(`date`) BETWEEN 6 AND 12 THEN value ELSE 0 END) AS `morning`, SUM(CASE WHEN HOUR(`date`) BETWEEN 12 AND 18 THEN value ELSE 0 END) AS `afternoon`, SUM(CASE WHEN HOUR(`date`) < 6 OR HOUR(`date`) > 18 THEN value ELSE 0 END) AS `evening` FROM my_table GROUP BY DAY(`date`)
def cartest(request): cars = list(Car._default_manager.filter(user__username__exact='michael')[:5]) first_car_name = car[0] another_car = car[1] return HttpResponse(len(connection.queries))
WITH recordList AS ( SELECT ID, DATE, Amt, DENSE_RANK() OVER (PARTITION BY ID ORDER BY DATE ASC) rn FROM tableName ) SELECT ID, DATE, Amt FROM recordList WHERE rn <= 2
(DT_WSTR,4)YEAR(DATEADD("dd", - @[User::Days] , GETDATE())) + "-" + RIGHT("0" + (DT_WSTR,2)MONTH(DATEADD("dd", - @[User::Days] , GETDATE())), 2) + "-" + RIGHT("0" + (DT_WSTR,2)DAY(DATEADD("dd", - @[User::Days] , GETDATE())), 2)
SELECT trippin.PostData.Id, trippin.AccountData.username, trippin.PostData.posttext, trippin.CategoryData.categoryname, SUM(CASE WHEN likes.liked = 1 THEN 1 ELSE 0 END) as TimesLiked, SUM(CASE WHEN likes.liked = 0 THEN 1 ELSE 0 END) as TimesDisLiked FROM trippin.PostData INNER JOIN trippin.AccountData ON trippin.PostData.accountid = trippin.AccountData.id INNER JOIN trippin.CategoryData ON trippin.CategoryData.id = trippin.PostData.categoryid LEFT OUTER JOIN trippin.LikesDislikesData likes ON likes.postid = trippin.PostData.id -- remove AND likes.accountid = trippin.AccountData.id GROUP BY trippin.PostData.Id, (trippin.AccountData.username), (trippin.PostData.posttext), (trippin.categorydata.categoryname);
Select Cast(Dep_Gender as Char(6)) as Gender, Count(1) 'Number Counted' From Dependent Group By Cast(Dep_Gender as Char(6))
with src_type_2 as ( select c.target_id, a.name from table_c c join table_a on a.id = c.source_id join table_b on b.id = a.type_id where b.type_name = 'Type 2' ), all_type_1 as ( select a.id, a.name from table_a a join table_b on b.id = a.type_id where b.type_name = 'Type 1' ) select tgt.name, src.name from all_type_1 tgt left join src_type_2 src on src.target_id = tgt.id
SELECT * FROM T WHERE tog = 'yes' and val in (select val from t where tog='no') UNION SELECT * FROM T WHERE tog = 'no' and val in (select val from t where tog='yes')
SELECT table1.FullName , sub1.sum_points , table3.Name , sub2.sum_points FROM table1 JOIN table3 ON table1.ParentCustomerId = table3.AccountId JOIN ( SELECT Asp_SalemadebyId , SUM(Asp_PointsAwarded) sum_points FROM table2 GROUP BY Asp_SalemadebyId ) sub1 ON table1.ContactId = sub1.Asp_SalemadebyId JOIN ( SELECT Asp_PointsAwardedToId , SUM(Asp_PointsAwarded) sum_points FROM table4 GROUP BY Asp_PointsAwardedToId ) sub2 ON table1.ContactId = sub2.Asp_PointsAwardedToId WHERE table3.asp_mimanagerid = '10CACCBD-70A7-DD11-9C65-001EC9B77038')
DECLARE @Sql varchar(50) = 'TEST|00000298398293|EQ5|Patient' SELECT PARSENAME(REPLACE(@sql,'|','.'),4), PARSENAME(REPLACE(@sql,'|','.'),3), PARSENAME(REPLACE(@sql,'|','.'),2), PARSENAME(REPLACE(@sql,'|','.'),1)
SELECT AVG(period) FROM ( SELECT TIME_TO_SEC(TIMEDIFF(@date_posted, date_posted)) AS period, @date_posted := date_posted FROM ( SELECT @date_posted := NULL ) vars, messages ORDER BY date_posted ) q
{% for item in query_results %} <tr> <td>{{ item.name }}</td> <td>{{ item.definition }}</td> <td>{{ item.fundstellen }}</td> <td>{{ item.wissenswertes }}</td> <td> {% for tag in item.tags.all %} {{ tag }} {% endfor %} </td> </tr> {% endfor %}
SELECT fp.id, usr.id as UserID, usr.firstname, usr.lastname, c.id as CourseID, c.fullname, c.idnumber, fd.name, fd.timemodified as DiscussionCreatedOn, fp.created AS TimeofPost, fp.modified, fp.subject, fp.message FROM mdl_forum_posts fp INNER JOIN mdl_forum_discussions fd ON fp.discussion = fd.id INNER JOIN mdl_forum f ON f.id = fd.forum INNER JOIN mdl_course c ON f.course = c.id INNER JOIN mdl_user usr ON fp.userid = usr.id WHERE EXISTS (SELECT 1 FROM mdl_user_enrolments ue INNER JOIN mdl_enrol e ON ue.enrolid = e.id WHERE usr.id = ue.userid AND e.courseid = f.course)
WITH tblB AS ( SELECT 1 CountryID, 'England' Country FROM dual UNION SELECT 2 CountryID, 'Wales' Country FROM dual UNION SELECT 3 CountryID, 'Scotland' Country FROM dual UNION SELECT 4 CountryID, 'Ireland' Country FROM dual ), tblC AS ( SELECT 1 StudentID, 1 CountryID, 'ABC-Student' Student FROM dual UNION SELECT 2 StudentID, 2 CountryID, 'XYZ-Student' Student FROM dual ), tblA AS ( SELECT 1 SchoolID, 3 CountryID, 1 StudentID, 'ABC-School' School FROM dual UNION SELECT 2 SchoolID, 4 CountryID, 2 StudentID, 'XYZ-SChool' School FROM dual ) SELECT a.SchoolID, a.School, b.Country, c.Student, b2.Country Student_Country FROM tblA a JOIN tblB b ON b.CountryID = a.CountryID JOIN tblC c ON c.StudentID = a.StudentID JOIN tblB b2 ON b2.CountryID = c.CountryID
WITH cte AS ( -- Base condition, where do we start the search? SELECT t.* FROM tblPartTable t WHERE t.PartNumber = '100X' UNION ALL -- Continue condition, how do we find the next part from the current one? SELECT t.* FROM tblPartTable t JOIN cte ON t.PartNumber = cte.NextPartNumber ) SELECT partnumber, active FROM cte;
select min(DateAndTime) as minDateAndTime, max(DateAndTime) as maxDateAndTime from (select pt.*, sum(case when datediff(second, prevdt, DateAndTime) <= 1 then 0 else 1 end) over (order by DateAndTime) as grp from (select pt.*, lag(DateAndTime) over (order by DateAndTime) as prevdt from ProductTracker pt where LineFaultStatus = 1 and DateAndTime > '2014-04-07 8:00:00' and DateAndTime < '2014-04-07 17:00:00' ) pt ) pt group by grp order by 1;
SELECT SUM(Qty) as Qty,DATE_FORMAT(Date, '%b') Month from table GROUP BY DATE_FORMAT(Date,'%Y-%m')
select count(distinct author) from ( SELECT author FROM comics WHERE author NOT IN ( SELECT email FROM bans ) UNION ALL SELECT email FROM users WHERE email NOT IN ( SELECT email FROM bans ) ) as SubQueryAlias
SELECT ID, Name, Addr, PhoneNumber, Descr FROM CusInfo i WHERE Type_ID = 'type_01' AND 3 = (select count(distinct case when c.Cri_ID in ('a','b') then 1 when c.Cri_ID in ('c','d') then 2 when c.Cri_ID in ('e','f') then 3 end) from CusCri c WHERE c.Cus_ID = i.ID and c.Cri_ID in ('a','b','c','d','e','f') )
SELECT MONTH([Date]) [Month], YEAR([Date]) [Year], COUNT(*) [Total], COUNT(CASE WHEN Status IN ('Gone', 'Cancelled') THEN 1 END) [Lost], COUNT(CASE WHEN Status= 'Won' THEN 1 END) [Won] FROM MyTable GROUP BY MONTH([Date]), YEAR([Date])
select ic.UserName, ic.primaryconsultantid, ic.starters, ic.[month], ic.[year], ic.totalvalue, cg.threshold as Threshold, cgv.percentage as Percentage from ( select u.username + ' ' + u.surname as UserName, tt.primaryconsultantid, count(tt.invoiceid) as starters, datename(mm, tt.invoiceissueddate) as [month], datepartT(yy, tt.invoiceissueddate) as [year], cast(sum((tt.value / tt.exchangerate) * (tt.primaryconsultantperc / 100)) as numeric(8,2)) as totalvalue, from InvoiceCommissions as tt inner join Users as u on u.userid = tt.primaryconsultantid group by tt.primaryconsultantid, datename(mm, tt.invoiceissueddate), datepart(yy, tt.invoiceissueddate), u.username + ' ' + u.surname ) as ic inner join commissionconsultants as cc on cc.userid = ic.primaryconsultantid inner join commissiongrades as cg on cg.gradeid = cc.gradeid inner join commissiongradevalues as cgv on cgv.gradeid = cc.gradeid and cgv.starters = ic.starters
SELECT k.KUNDENID AS ID, vorname AS Vorname, nachname AS Nachname, LPAD( CONCAT(IFNULL(ROUND(SUM(Betrag), 2), 0), ' Euro') , 13, ' ') AS Gesamt FROM kunde k LEFT JOIN verkauf v ON k.KUNDENID = v.KUNDENID GROUP BY k.KUNDENID;
select r.* from R where R.a = 100
SELECT SQL_CALC_FOUND_ROWS `contact_data`.`id`, `contact_data`.`name`, MAX(CASE WHEN fields.`key` = :field1 THEN fields.`value` END) AS `fields0`, MAX(CASE WHEN fields.`key` = :field2 THEN fields.`value` END) AS `fields1`, MAX(CASE WHEN fields.`key` = :field3 THEN fields.`value` END) AS `fields2`, ...etc... CONTACT_DATA_TAGS( GROUP_CONCAT(DISTINCT `contact_data_tags`.`name`), GROUP_CONCAT(DISTINCT `contact_data_assignment`.`user`), GROUP_CONCAT(DISTINCT `contact_data_read`.`user`) ) AS `tags`, GROUP_CONCAT(DISTINCT `contact_data_assignment`.`user`) AS `assignments`, `contact_data`.`updated`, `contact_data`.`created` FROM `contact_data` LEFT JOIN contact_data_tags ON contact_data.`id` = contact_data_tags.`data` LEFT JOIN contact_data_assignment ON contact_data.`id` = contact_data_assignment.`data` LEFT JOIN contact_data_read ON contact_data.`id` = contact_data_read.`data` LEFT JOIN contact_data_fields AS fields ON contact_data.`id` = fields.`contact_data_id` ...etc... GROUP BY contact_data.`id` ORDER BY `id` DESC
factory.selectFrom(ScoreCard.SCORE_CARD) .orderBy(OloScoreCard.SCORE_CARD_ID.cast(Integer.class).descending()) .limit(0, 1);
select group_concat(sub) from post where cat = 1;
select set_vertica_options('EE','ENABLE_JOIN_SPILL');
SELECT one.id AS id, one.something1 AS something1, one.something2 AS something2, two.name AS name FROM one JOIN two ON one.id = two.id
SELECT MemberId = y.i.value('(./text())[1]', 'nvarchar(1000)'), TokenId = u.j.value('(./text())[1]', 'nvarchar(1000)') FROM ( SELECT m = CONVERT(XML, '<i>' + REPLACE(MemberId, ',' , '</i><i>') + '</i>').query('.'), t= CONVERT(XML, '<j>' + REPLACE(TokenId, ',' , '</j><j>') + '</j>').query('.') FROM member_tokens ) AS a CROSS APPLY m.nodes('i') AS y(i) CROSS APPLY t.nodes('j') AS u(j)
KeyWords ---------- KeyWordId Int Identity(1,1) KeyWord VarChar(200) KeyFieldKeyWords ---------------- Keyfield Int KeyWordId Int
select distinct on (name) id, name, version from metadata where name in ('foo', 'bar') order by name, version desc
SELECT TableA.[Name] AS FirstName, TableB.LastName FROM TableA INNER JOIN TableB ON TableA.LastNameId = TableB.LastNameId
SELECT sfo.entity_id, sfo.increment_id, sfoi.name, sfoi.product_type, sfoi.price, sfoi.original_price, sfo.status, sfi.state FROM sales_flat_order sfo INNER JOIN sales_flat_order_item sfoi ON sfoi.order_id = sfo.entity_id LEFT JOIN sales_flat_invoice sfi ON sfi.order_id = sfo.entity_id ORDER BY sfo.entity_id DESC LIMIT 500
SELECT DISTINCT A.ID, A.SurveyID, A.PersonID, A.Answer, B.QuestionID, B.Question FROM TblAnswers A INNER JOIN TblQuestion B ON A.QuestionID=B.QuestionID
SELECT M.ID, M.Value, D.ID DETAILID, D.Value DetailValue, D.Date FROM TABLE_MASTER M LEFT JOIN ( SELECT * FROM TABLE_DETAIL1 UNION ALL SELECT * FROM TABLE_DETAIL2) D ON M.ID = D.MASTER_ID
select a.Id L,b.id R into #cross from MyTable a inner join mytable b on a.id <= b.id
SELECT cm.* FROM conversations_messages cm JOIN conversations c ON cm.conversation_id = c.id JOIN conversations_users cu ON cu.conversation_id = c.id WHERE cu.user_id = 1 AND NOT EXISTS ( SELECT 'a' FROM conversations_messages cm2 WHERE cm2.conversation_id = cm.conversation_id AND cm2.created_at > cm.created_at ) GROUP BY c.id
SELECT TO_CHAR(TRUNC(scheme.table.reg_date,'dd'),'DD.MM.YYYY') AS "DATE", COUNT(*) FROM scheme.table WHERE scheme.table.reg_date BETWEEN TO_DATE('01.08.2013','dd.mm.yyyy') AND TO_DATE('28.08.2013','dd.mm.yyyy') GROUP BY TRUNC(scheme.table.reg_date,'dd');
DECLARE @input XML = '<root> <log realm="ABC" at="Wed Oct 15 00:00:02 2014.211" lifespan="2279ms"> <receive> <isomsg direction="IN"> <header>6000911384</header> <field id="0" value="0800"/> <field id="3" value="980000"/> <field id="11" value="000852"/> </isomsg> </receive> </log> </root>' SELECT At = xc.value('../../../@at', 'varchar(50)'), Lifespan = xc.value('../../../@lifespan', 'varchar(25)'), Direction = xc.value('../@direction', 'varchar(10)'), ID = XC.value('@id', 'int'), Value = xc.value('@value', 'varchar(25)') FROM @Input.nodes('/root/log/receive/isomsg/field') AS XT(XC)
Private Sub Form_Current Laborer1.RowSource = ReferenceField.Value Laborer1.Requery 'I don't believe you need this, but you might. End Sub
#!/bin/bash result=$(sqlplus64 -S <username>/<password>@<IPADDRESS>/<SERVICENAME> << EOF set serveroutput on; begin dbms_output.put_line('hello '||'$0'); end; / exit; EOF ) echo "result=$result"
delete from your_table where id not in ( select * from ( select id from your_table order by id desc limit 1000 ) x )
SELECT (EXISTS (SELECT 1 FROM test WHERE id = 100))::int;
DECLARE @CounterInitialValue INT DECLARE @NewCounterValue INT SELECT @CounterInitialValue = SELECT counter FROM MyTable WHERE MyID = 1234 -- do stuff with the counter value UPDATE MyTable SET counter = counter + 1 WHERE MyID = 1234 AND counter = @CounterInitialValue -- prevents the update if counter changed. -- the value of counter must not change in this scenario. -- so we rollback if the update affected no rows IF( @@ROWCOUNT = 0 ) ROLLBACK
SELECT * FROM DATA d JOIN USERS u ON u.user_id = d.user_id WHERE NOT EXISTS (SELECT NULL FROM DATA t WHERE t.id = d.id AND CONVERT('10:00:00', TIME) BETWEEN t.start_time AND t.end_time) GROUP BY u.usrID
CREATE TABLE US_Address ( AddressID int, Streetline varchar(80), City varchar(80), State char(2), ZIP char(5), StateName varchar(80), StateTax DECIMAL(5,2) )
INSERT INTO tblSurveyReport(FirstName) SELECT FirstName FROM tblSurveyData where FirstColumn = 'A0' INSERT INTO tblSurveyReport(MiddleName) SELECT MiddleName FROM tblSurveyData where FirstColumn = 'A1'
select max(ID) from [Table]
SELECT LENGTH(TRANSLATE(TO_CHAR(3.0123456789),'1234567890.-','1234567890')) FROM dual
with cte as(select *, ceiling(1.0 * row_number() over(order by Wins, Id) / 2) as rn from Player) select c1.Id, c1.Name, c2.Id, c2.name from cte c1 join cte c2 on c1.rn = c2.rn and c1.Id > c2.Id;
SELECT dept.Name, COUNT(emp.id) as timesOccurring FROM departments dept INNER JOIN employees emp ON emp.dept_id = dept.id GROUP BY dept.Name ORDER BY timesOccurring
select red, green, blue, count(*) from t group by red, green, blue;
SELECT COALESCE(UNIX_TIMESTAMP(Date(p.published_at)),0) as 'day', COALESCE(SUM(case when p.status = 2 then p.value end),0) as 'total_accepted', COALESCE(SUM(case when p.status = 1 then p.value end),0) as 'total_open', COALESCE(SUM(case when p.status = 3 then p.value end),0) as 'total_declined', COALESCE(SUM(case when p.status !=0 then p.value end),0) as 'total_published' FROM posts as p WHERE p.published_at IS NOT NULL GROUP BY DATE(p.published_at);
select * from orders o1 where o1.city = 'Austin' and exists (select ordernumber from orders o2 where o1.ordernumber = o2.ordernumber group by ordernumber having count(distinct city) >1)
20130320 2013-03-20 2013 mar 20 March 20, 2013 2013.03.20
SELECT GROUP_CONCAT(CONCAT('CF', CustomFieldID, ' AS `', CustomFieldName, '`')) INTO fieldNames FROM qcdt_jobs_CustomFields WHERE projectId = 181; PREPARE stmt FROM CONCAT('SELECT JobID, ', fieldNames, ' Etc. FROM qcdt_jobs_customfields_181 where JobID=1'); EXECUTE stmt;
select c.customerID, c.name, a.UAN, a.balance, a.overdraft From customer c join current_acc a on c.customerID = a.customerID and a ='current account'
friend_list = sqlexec "select user2_id from relations where user1_id = " + current_user_id photolist = [] for friend in friend_list: photolist += sqlexec "select user_id, id, date_uploaded from photos" + " where user_id = " + friend.get("user2_id") + " order by date_uploaded desc fetch first 3 rows only" # Now do something with photolist
IF NOT EXISTS(SELECT 1 FROM [MyDB].[dbo].[Accounts] WHERE MyID = @MyID) INSERT INTO [MyDB].[dbo].[Accounts] (MyID, Phone, MyDate, Agent, Charge, Vendor) VALUES (@MyID, @Phone, @MyDATE, @Agent, @Charge, @Vendor)
SELECT * FROM Patients p WHERE DATEDIFF(d, (SELECT MIN(AppointmentDate) FROM Appointments a WHERE a.PatientID = p.PatientID), (SELECT MAX(AppointmentDate) FROM Appointments a WHERE a.PatientID = p.PatientID)) >= 365
select a.col1, a.col2, b.col1, b.col2, c.col1, c.col2 from view a, view b, view c where a.col3 = 1 and b.col3 = 2 and c.col3 = 3
SELECT ID, z.cnt FROM mytable CROSS APPLY (SELECT COUNT(*) AS cnt FROM (VALUES (x1), (x2), (x3), (x4)) x(y) WHERE x.y > 0) z
SELECT COUNT(*) FROM jwemaildb.LogFileRecords WHERE date > = DATEADD(month, DATEDIFF(month, 0, GETDATE())-1, 0) AND date < DATEADD(month, DATEDIFF(month, 0, GETDATE()), 0) AND CAST(RIGHT(eAlertSentDate, 4) + LEFT(eAlertSentDate, 4) AS date) BETWEEN DATEADD(dd , 1 - DAY(GETDATE()), DATEADD(mm, -1 ,GETDATE())) AND DATEADD(dd , 1 - DAY(GETDATE()), GETDATE())
set @isweekday=case when (DATEPART(dw, @tempdate) + @@DATEFIRST) % 7 NOT IN (0, 1) then 1 else 0 end
SELECT TblLoan.LoanID, TblCustomer.LastName, Payment.TotalPaid AS Payments, Nz(TblLoan.FutureValue) - Nz(Payment.TotalPaid) AS Balance FROM TblLoan LEFT JOIN ( SELECT LoanID, sum(TotalAmount) as TotalPaid FROM TblPayment group by LoanID ) AS Payment ON Payment.LoanID = TblLoan.LoanID LEFT JOIN TblCustomer ON TblLoan.CustomerID = TblCustomer.CustID WHERE Nz(TblLoan.FutureValue) - Nz(Payment.TotalPaid) <= 0;
SELECT TOP 1 ID, COUNT(*) AS CountOfRows FROM UnknownTable GROUP BY ID ORDER BY CountOfRows DESC
SELECT `activities`.*, `admins`.`admin_role_id` FROM (`activities`) LEFT JOIN `admins` ON `admins`.`activity_id`=`activities`.`id` AND admins.member_id=27500 JOIN (`transactions_items` JOIN `transactions` ON `transactions`.`id` = `transactions_items`.`id` JOIN `products` ON `products`.`id` = `transactions_items`.`product_id`) ON `activities`.`id`=`products`.`activity_ID` WHERE `transactions`.`member_id` = 27500 AND `activities`.`active` = 1
SELECT FirstName, LastName, Line1, City, State, ZipCode FROM Customers JOIN Addresses ON (Customers.ShippingAddressId = Addresses.AddressID);
select * from session_actions where find_in_set(`action_type`,'login_failed,channel_recorded');
select t1.id,t1.values,t2.values from table1 t1 left outer join table t2 on nvl(t1.id,0)=nvl(t2.id,0)
SELECT 'MYTABLE_A' AS MYTABLENAME, CASE WHEN EXISTS ( SELECT * FROM MYTABLE_A WHERE timestamp = to_char(sysdate-1, 'yyyymmdd') || '0000' ) THEN 0 ELSE 1 END AS FLAG_MYTABLE_A from DUAL UNION ALL SELECT 'MYTABLE_B' AS MYTABLENAME, CASE WHEN EXISTS ( SELECT *, timestamp FROM MYTABLE_B WHERE timestamp = to_char(sysdate-1, 'yyyymmdd') || '0000' ) ) THEN 0 ELSE 1 END AS FLAG_MYTABLE_B from DUAL;
Select Name, sum(case when DayAci = 'Sunday' then 1 else 0 END) as Sunday, sum(case when DayAci = 'Monday' then 1 else 0 END) as Monday, sum(case when DayAci = 'Tuesday' then 1 else 0 END) as Tuesday, sum(case when DayAci = 'Wednesday' then 1 else 0 END) as Wednesday, sum(case when DayAci = 'Thursday' then 1 else 0 END) as Thursday, sum(case when DayAci = 'Friday' then 1 else 0 END) as Friday, sum(case when DayAci = 'Saturday' then 1 else 0 END) as Saturday, count(*) as Total, max(cap.prevTotal) as prevTotal from Caraccident ca left outer join (select cap.name, count(*) as prevTotal from CaraccidentPrev cap where cap.Accident = 'Near-miss' group by cap.name ) cap on cap.name = ca.name where Accident = 'Near-miss' group by Name;
DECLARE @tempString AS varchar(max) SET @tempString ='' ;WITH firstCte AS ( SELECT CAST('<M>' + REPLACE(contactpeopleids, ',','</M><M>') + '</M>' AS XML) AS Names FROM soTable1 -- THIS WHERE CLAUSE MUST MATCH THE FINAL WHERE CLAUSE WHERE name = 'John' AND surname = 'Cobaing' ) ,secondCte AS ( SELECT Split.a.value('.','VARCHAR(100)') AS NameIds FROM firstCte CROSS APPLY Names.nodes('/M') Split(a) ) ,thirdCte AS ( SELECT t2.name + ' ' + t2.lastname AS theContactName FROM secondCte t1 -- NOTE: IF THE IDS YOU EXTRACT FROM TABLE 1 DO NOT HAVE A MATCH IN TABLE 2 YOU WILL GET NO RESULT FOR THAT ID HERE! -- IF YOU WANT NULL RESULTS CHANGE THIS TO A 'LEFT JOIN' INNER JOIN soTable2 t2 ON t1.NameIds = t2.id ) SELECT @tempString = @tempString + ',' + theContactName FROM thirdCte ; -- The select substring is used to remove the leading ',' SELECT name, surname, age, location, SUBSTRING(@tempString,2,LEN(@tempString)) AS contactpeoplenames FROM soTable1 WHERE name = 'John' AND surname = 'Cobaing'
select (select name from table2 where id = ( select top 1 arr_id from table1 group by arr_id order by count(*) desc) ) as most_arrivals, (select name from table2 where id = ( select top 1 dep_id from table1 group by dep_id order by count(*) desc) ) as most_departures
;with pc as ( select p.personid, tc.titleid, count(*) as cnt_pc from person p inner join personcertification pc on p.personid = pc.personid inner join titlecertifications tc on pc.certificationid = tc.certificationid group by p.personid, tc.titleid ), tc as ( select t.titleid, count(*) as cnt_tc from title t inner join titlecertifications tc on t.titleid = tc.titleid group by t.titleid ) select p.firstname, t.shortname from pc inner join tc on pc.titleid = tc.titleid inner join person p on pc.personid = p.personid inner join title t on pc.titleid = t.titleid where cnt_pc = cnt_tc
SELECT userid FROM (SELECT userid, YEARWEEK(TIMESTAMP) AS year_week, COUNT(DISTINCT DAYOFWEEK(TIMESTAMP)) AS check_in_days FROM checkins WHERE 1 = 1 -- This would be your date range filter GROUP BY userid, YEARWEEK(TIMESTAMP) HAVING check_in_days BETWEEN 3 AND 5) AS user_weeks GROUP BY userid HAVING COUNT(year_week) = (SELECT COUNT(*) FROM year_week WHERE 1 = 1 -- This would be your date range filter );
DELIMITER $$ CREATE TRIGGER adresse_trigger_insert_check BEFORE INSERT ON adresse FOR EACH ROW BEGIN IF NEW.land IS NULL THEN SET NEW.land := 'XY'; END IF; END$$ DELIMITER ;
DECLARE @date AS DATETIME SET @date = '2014-01-01' SELECT 'SELECT ''' + OBJECT_NAME(object_id) + ''' AS [Table], COUNT(*) AS [Count] FROM [' + OBJECT_NAME(object_id) + '] WHERE [created] <= ''' + CONVERT(VARCHAR, @date, 20) + '''' FROM sys.columns WHERE name = 'created'
insert /*+ IGNORE_ROW_ON_DUPKEY_INDEX(table_name index_name) */ into table_name select * ...
select sum(row_size) from ( select char_length(column1)+ char_length(column2)+ char_length(column3)+ char_length(column4) ... <-- repeat for all columns as row_size from your_table ) as tbl1;
ALTER PROC [dbo].[SPFetchAllDisActiveUser] ( @StartRowIndex INT, @MaxRows INT ) AS BEGIN SELECT * FROM ( SELECT *, ROW_NUMBER() OVER(ORDER BY [User-ID] ASC) AS RowNum FROM [User-Tbl] WHERE [Gu-Id] IS NULL ) AS DisActiveUser WHERE RowNum BETWEEN @StartRowIndex + 1 AND @MaxRows; END
SELECT t.* FROM comment c LEFT JOIN read_message rm ON c.id-rm.cid WHERE c.author!=2 AND rm.User=2 AND c.tid=17 AND rm.Topic=17 AND (c.Original_Date BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW()) OR (c.last_update BETWEEN DATE_SUB(NOW(), INTERVAL 30 DAY) AND NOW())
UPDATE status SET description = SUBSTRING(description,1,CHARINDEX('abc',description)-1) + 'def' + SUBSTRING(description,CHARINDEX('abc',description)+CHAR_LENGTH('abc'),CHAR_LENGTH(description)-CHARINDEX('abc',description)) WHERE name = 'test'
SELECT * FROM table1 t1 JOIN table2 t2 ON t1.sid = t2.sid JOIN table3 t3 ON t2.referencedid = t3.referencedid WHERE // here you can add your criteria if you have
SELECT DISTINCT name from `Student` WHERE `name` REGEXP '[ae]'
select col_1, col_2 from tbl_a A inner join tbl_b B on A.col_1 = B.col_1 and A.col_2 = B.col_2 left join ( select col_1,col_2 from tbl_c where clo_c_1 <> '1' ) C on C.col_2 = A.col_2
SELECT ( SELECT [customer] ,( SELECT [id] AS [@id], [Item] AS [data()] FROM @OrderDetail od WHERE od.fk_Order = ot.id FOR XML PATH('d'),TYPE ) FROM @OrderTbl ot FOR XML PATH('c'),TYPE ) FOR XML PATH('b'), ROOT('a')
... WHERE MONTH(MD.MD_DOB) > @StartMonth AND MONTH(MD.MD_DOB) < @EndMonth OR (MONTH(MD.MD_DOB) = @StartMonth AND DAY(MD.MD_DOB) >= @Startday) OR (MONTH(MD.MD_DOB) = @EndMonth AND DAY(MD.MD_DOB) <= @Endday)
procedure runproc (p_procname varchar2) is begin execute immediate 'begin ' || p_procname || '; end;'; end;
select t.candidateid , @curRank := @curRank + 1 AS rank, if(@prevote=-1, 0,@prevote-t.num) as sub, @prevote:=t.num as num from ( SELECT candidateid, count(*) as num FROM vote p group by candidateid ORDER BY num desc ) t, (SELECT @curRank := 0, @prevote:=-1) r
SELECT cmsdocument.internaldocid, cmsdocument.documentid, cmsdocument.versionid, cmsdocversion.title, string_agg(cmstag.tagname, ',') FROM public.cmsobjecttag, public.cmstag, public.cmsdocument, public.cmsdocversion, public.cmsuser WHERE cmsobjecttag.tagid = cmstag.tagid AND cmsobjecttag.objectid = cmsdocument.internaldocid AND cmsdocument.internaldocid = cmsdocversion.internaldocid AND cmsdocument.userid = cmsuser.userid AND cmsdocversion.state = 'published' AND cmsobjecttag.objecttype = '102' GROUP BY cmsdocument.internaldocid, cmsdocument.documentid, cmsdocument.versionid, cmsdocversion.title
WITH src AS ( SELECT level id FROM dual CONNECT BY level <= 5) SELECT nvl(ent_id, 'Not Found' ) FROM src LEFT OUTER JOIN tc_logs ON (src.id = tc_logs.ent_id)
WITH cte AS ( SELECT t.TaskID ,t.Title ,t.ParentID ,CONVERT(VARCHAR(MAX),'') AS [Path] FROM tasks.Tasks t WHERE t.ParentID IS NULL AND t.TaskID = @TaskID UNION ALL SELECT sub.TaskID ,sub.Title ,sub.ParentID ,cte.[Path] + '->' + CONVERT(VARCHAR(MAX),sub.TaskID) AS [Path] FROM tasks.Tasks sub INNER JOIN cte ON cte.TaskID = sub.ParentID ) SELECT cte.TaskID ,cte.Title ,cte.ParentID ,CONVERT(VARCHAR(MAX),@TaskID) + cte.[Path] AS [Path] FROM cte
select date_format(Release, '%d.%m.%Y') from movies
WITH RECURSIVE list AS ( SELECT PK, Name FROM A WHERE PK = 1 UNION ALL SELECT A.PK, A.Name FROM list JOIN B ON list.PK = B.FK1 JOIN A ON B.FK2 = A.PK ) SELECT * FROM list;
select m.*, ms.TotalValue from MyTable m inner join ( select [Order], sum(Price * Quantity) as TotalValue from MyTable group by [Order] ) ms on m.[Order] = ms.[Order]
select t1.a, min(t2.a), t1.b from table_1 t1 inner join table_1 t2 on t2.a > t1.a group by t1.a, t1.b
with source as ( SELECT adr.nad_nkt_id id1, firmenadr.nad_nkt_id id2 FROM nav_adressen adr, nav_kontakte kontakt, nav_kontakte firma, nav_adressen firmenadr WHERE kontakt.nkt_id = adr.nad_nkt_id AND firma.nkt_id (+)= kontakt.nkt_nkt_id AND firmenadr.nad_id (+)= firma.nkt_id AND (firmenadr.nad_strasse like '%needle%' OR adr.nad_strasse like '%needle%') ) select decode(x.l, 1, a.id1, 2, a.id2) as id from source a cross join (select level as l from dual connect by level <=2) x
SELECT TOP 10 usr.firstname, usr.lastname, count(doc.modifiedBy) AS modified_items, count(doc.createdDate) AS created_items, (count(doc.modifiedBy)) + (count(doc.createdDate)) AS summed_items FROM document doc WHERE doc.active = 't' GROUP BY usr.firstname, usr.lastname ORDER BY doc.modified_items DESC
FORTUNE_DB(ADMIN)=> select * from so; COL1 -------------------------------------------------------------------------------------------------------------- This is sting one:Y,this is string Two:X,This is string Three:N,This is string four:N,This is string five:X, FORTUNE_DB(ADMIN)=> select regexp_replace(col1,',[^(:N)]+:N','') from so; REGEXP_REPLACE ----------------------------------------------------------------- This is sting one:Y,this is string Two:X,This is string five:X,
merge into tester using ( select 1 id,'0123456785' employee_phone_number from dual union all select 2 id,'0123456786' employee_phone_number from dual) new_values on ( tester.id = new_values.id) when matched then update set employee_phone_number = new_values.employee_phone_number;
SELECT CHR(1) FROM DUAL;
WHERE person.personstatusuid = @StatusUID AND person.forename != '' AND (ISNULL(@Location,'') = '' OR person.Location = @Location)
DECLARE @company_id char(2) SET @company_id = '02' EXEC('CREATE TABLE CUSTOMER' + @company_id + ' (id int PRIMARY KEY)')
SELECT T0.C0, T1.C0, T2.C0, CASE WHEN T1.C0 IS NULL AND T2.C0 IS NULL THEN 1 END, CASE WHEN T2.C0 = 'NM' THEN 'New to PHI' WHEN T1.C0 IS NOT NULL OR T2.C0 IS NOT NULL THEN 'Transferred' ELSE 'New to PHI' END, T0.C1 FROM ( SELECT DISTINCT "Memberships"."MemberNo" AS C0, COUNT("Memberships"."MemberNo") AS C1 FROM "dbo"."Memberships" WHERE ( "Memberships"."IsProspect" = N'N' ) AND ( ( "Memberships"."PaidToDate" > "Memberships"."JoinDate" OR "Memberships"."HealthTermEntryDate" IS NULL ) AND "Memberships"."JoinDate" BETWEEN '20150701 00:00:00.0' AND '20160630 23:59:59.997' ) GROUP BY "Memberships"."MemberNo" ) T0 LEFT OUTER JOIN ( SELECT DISTINCT "MembershipPlans"."PrevFundID" AS C0, "Memberships"."MemberNo" AS C1 FROM "dbo"."Memberships" INNER JOIN "dbo"."MembershipPlans" ON ( "Memberships"."MemberNo" = "MembershipPlans"."MemberNo" ) WHERE ( "Memberships"."IsProspect" = N'N' ) AND ( "MembershipPlans"."IsPrevCover" IN (N'Y') ) ) T1 ON T0.C0 = T1.C1 LEFT OUTER JOIN ( SELECT DISTINCT "MembershipUDPs"."Property" AS C0, "MembershipUDPs"."MemberNo" AS C1 FROM "dbo"."Memberships" LEFT OUTER JOIN "dbo"."MembershipUDPs" ON ( "Memberships"."MemberNo" = "MembershipUDPs"."MemberNo" ) WHERE ( "Memberships"."IsProspect" = N'N' ) AND ( "MembershipUDPs"."PropertyID" IN (N'TF ') AND "Memberships"."JoinDate" >= '20150608 00:00:00.0' ) ) T2 ON T0.C0 = T2.C1
SELECT TO_CHAR(CURRENT_TIMESTAMP, 'DD/MON/YYYY');
Select ..... from .... where (Status = @Status or @Status is null) and (Created=@Created or @Created is null) and (Release = @Release or @Release is null) and (Date = @Date or @Date is null)
$q = "SELECT * FROM football_1314_beacha_standings ORDER BY pct DESC, win DESC";
SELECT * FROM information_schema.columns c with (Nolock)
select Location.Lat, Location.Long from GeographyTable
select users.user_id,l.login,p.points from users inner join (select user_id, count(1) login from login group by login) as l on users.user_id=login.user_id inner join (select user_id, sum(point) as point from point group by user_id ) as p on users.user_id=point.user_id
SELECT a.pname, b.rank, b.score FROM players a INNER JOIN player_stats b ON a.pid = b.pid INNER JOIN ( SELECT pid, MAX(statdate) statdate FROM player_stats GROUP BY pid ) c ON b.pid = c.pid AND b.statdate = c.statdate
CREATE TEMP TABLE mapper (old_val CHAR(5) NOT NULL, new_val CHAR(5) NOT NULL); ...multiple inserts into mapper... INSERT INTO mapper(old_val, new_val) VALUES('a.1', 'a1'); INSERT INTO mapper(old_val, new_val) VALUES('a-1', 'a1'); INSERT INTO mapper(old_val, new_val) VALUES('b.1', 'b1'); INSERT INTO mapper(old_val, new_val) VALUES('b-1', 'b1'); ...etcetera... UPDATE tbl SET title = (SELECT new_val FROM mapper WHERE old_val = tbl.title) WHERE title IN (SELECT old_val FROM mapper);
begin statement_zero; savepoint my_savepoint; begin -- if either of these fail, then exception section will be executed statement_one; statement_two; exception when others then rollback to my_savepoint; end; statement_three; commit; end;
select brand from car group by brand having count(*) = (select count(*) from car where brand = 'Ferrari')
SELECT user, MIN(sn) range_start, MAX(sn) range_end FROM ( SELECT user, sn, @r := IF(@g = user, @r, @r + 1) range_num, @g := user FROM table1 CROSS JOIN (SELECT @r := 0, @g := NULL) i ORDER BY sn ) q GROUP BY user, range_num
import groovy.sql.Sql import oracle.jdbc.driver.OracleDriver def dbServer = context.expand( '${#Project#dbServer}' ) def dbUser = context.expand( '${#Project#dbUser}' ) def dbPass = context.expand( '${#Project#dbPass}' ) def con = Sql.newinstance('dbServer, dbUser, dbPass, "oracle.jdbc.driver.OracleDriver"') def res = con.rows("select * from table1 where message_in = 'Bang'") log.info(res[0]) con.close() assert res[0] != null
SELECT property.property_id, bedrooms.value AS bedrooms, bathrooms.value AS bathrooms FROM property, attribute AS bedrooms_attr, attribute_value AS bedrooms, property_attribute AS bedrooms_prop, attribute AS bathrooms_attr, attribute_value AS bathrooms, property_attribute AS bathrooms_prop WHERE bedrooms_attr.name = 'bedrooms' AND bedrooms.attribute_id = bedrooms_attr.attribute_id AND bedrooms.attribute_value_id = bedrooms_prop.attribute_value_id AND bedrooms_prop.property_id = property.property_id AND bedrooms.value = 2 AND bathrooms_attr.name = 'bathrooms' AND bathrooms.attribute_id = bathrooms_attr.attribute_id AND bathrooms.attribute_value_id = bathrooms_prop.attribute_value_id AND bathrooms_prop.property_id = property.property_id AND bathrooms.value = 2
select pa.appointment_key, p.profile_key as Rep, p2.profile_key as Customer, p.first_name as RepName,p2.first_name as CustomerName from profile_appointment pa join profile_appointment pa2 on pa.appointment_key = pa2.appointment_key join profile p on p.profile_key = pa.profile_key and p.profile_type_key = '4' join profile p2 on p2.profile_key = pa2.profile_key and p2.profile_type_key = '6'
UPDATE Table1 SET f2 = T2.f2, f3 = convert(varchar, T2.f3, 101) FROM Table1 T1 INNER JOIN Server.DB.dbo.Table2 T2 ON T1.f1 = T2.f1 WHERE T2.f3 = (SELECT MAX(f3) FROM Server.DB.dbo.Table2 WHERE f1 = T1.f1)
SELECT fID_a FROM tbl GROUP BY fID_a HAVING MAX(fID_b)=1 AND MIN(fID_b)=1
COUNT(CASE WHEN Bids.Burned=0 THEN 1 END) AS 'ActiveBids', COUNT(CASE WHEN Bids.Burned=1 THEN 1 END) AS 'BurnedBids'
SELECT * FROM Table 1 JOIN Table2 2 on 2.ID = Table1.ID UNION SELECT * FROM Table 1 JOIN Table2 22 on 22.ParentID = Table1.ID
UPDATE PlayerLeague AS l JOIN ( SELECT p.player_id, @i := @i + 1 AS player_position FROM ( SELECT ss.player_id FROM PlayerStat AS ss JOIN PlayerLeague AS ll ON ss.player_id=ll.player_id WHERE ll.league_id=3 ORDER BY ss.score DESC ) AS p, (SELECT @i := 0) AS tmp ) AS s ON s.player_id=l.player_id SET l.player_position = s.player_position
SELECT Category AS 'Category/SubCategory', COUNT(*) AS 'Count' FROM Categories GROUP BY Category UNION SELECT SubCategory AS 'Category/SubCategory', COUNT(*) AS 'Count' FROM Categories GROUP BY SubCategory
declare @Foo as Table ( ColA Int, ColB Int ); insert into @Foo ( ColA, ColB ) values ( 1, 1 ), ( 1, 2 ), ( 2, 1 ); select * from @Foo; select * from @Foo intersect select * from ( values ( 2, 1 ) ) as Bar( ColA, ColB );
def escapeSQLDelimiters(dataToEscape: String) = { dataToEscape flatMap { c => c match { case '\\' => "\\\\" case '\u0000' => "\\0" case '\n' => "\\n" case '\t' => "\\t" case '\r' => "\\r" case '\b' => "\\b" case '\'' => "\\\'" case '\"' => "\\\"" case _ => c.toString } } }
var result = db.tbl_feesCollection.Max(element => element.VarInvoiceNo);
SELECT JobCode, designation, SUM(salaryWithIncrement) FROM table1 GROUP BY JobCode, designation
SELECT distinct on (parent_id) parent_id , version_id FROM items ORDER BY parent_id, version_id DESC
DECLARE @ActionNumber varchar(20)='EHPL-DES-SQ-1021' declare @tmp table ( id int identity(1,1), item varchar(20) ) insert into @tmp (item) select * from dbo.ANOSplit(@ActionNumber,'-') select * from @tmp where id in (2,3)
reportContext.getHttpServletRequest().getSession().getAttribute("db");
IF NOT EXISTS (SELECT * FROM dbo.sysobjects WHERE id = OBJECT_ID(N'[dbo].[SomeStoredProcedure]') AND OBJECTPROPERTY(id,N'IsProcedure') = 1) EXEC sp_executesql N'CREATE PROCEDURE [dbo].[SomeStoredProcedure] AS SELECT ''SPROC Template''' GO SET ANSI_NULLS ON GO SET QUOTED_IDENTIFIER ON GO ALTER PROCEDURE SomeStoredProcedure
SELECT * FROM image WHERE id NOT IN (SELECT image_id FROM user_image WHERE user_id = THE_USER_ID);
INNER JOIN T_CASE CF ON ( A.AWESOME_ID = CF.AWESOME_ID // Several more conditions ) AND ( ( @NEWPARAM = 1 AND cy.SOMEFLAG = 0 AND CF.SOMEDATE IS NOT NULL ) OR ( @NEWPARAM = 1 AND cy.SOMEFLAG = 1 AND CF.CASE_TYPE = 1 AND CF.SOMEDATE IS NOT NULL ) OR ( @NEWPARAM <> 1 AND cy.SOMEFLAG = 0 AND CF.SOMEDATE IS NULL ) OR ( @NEWPARAM <> 1 AND ((cy.SOMEFLAG = 1 AND CF.CASE_TYPE = 0) OR CF.SOMEDATE IS NULL ) ) )
select x from y where (( UPPER(d.Gender) = UPPER(@gender) OR UPPER(d.Gender) ='EITHER') AND @gender IS NOT NULL ) OR (@gender IS NULL AND 1=1)
CREATE TRIGGER trTriggerName ON tblNames AFTER INSERT AS UPDATE tblNames SET UpFileName = replace(UpFileName,'%20','_') FROM tblNames t JOIN INSERTED i ON t.ID = i.ID
EXEC sp_spaceused 'TableName'
DECLARE @x xml DECLARE @strXML varchar(MAX) SET @x=N'<Employee><Name>Luftwaffe</Name></Employee>' set @strXML = '<xml version="1.0" encoding="ISO-8859-1"/>' + CONVERT(varchar(MAX),@x) SELECT @strXML
;With Ordered as ( select UserId,ContactType,ContactDetail,LoadDate, ROW_NUMBER() OVER ( PARTITION BY UserID,ContactType ORDER BY LoadDate DESC) as rn from ContactDetails ) select * from Ordered where rn = 1
SELECT DAYNAME(sip_Date) AS DAY, COUNT(DISTINCT sip_callid) FROM request_line WHERE DAYNAME(sip_Date) = 'Saturday' GROUP BY DAYNAME(sip_Date)
SELECT * FROM Product ORDER BY FIELD(CategoryID, 2, 5) DESC
CREATE TABLE таб1 (id int, name varchar(30)) CHARSET=utf8;
Select Distinct Top 1000000 tblAssets.AssetName, (Select Case When tblRegistry.Value = '2' Then 'Notify Only' When tblRegistry.Value = '3' Then 'Download Notify' When tblRegistry.Value = '4' Then 'Scheduled' When tblRegistry.Value = '5' Then 'Download and Custom' Else tblRegistry.Value End As RegistryValue From tblAssets As TA Left Join tblRegistry On tblRegistry.AssetID = TA.AssetID Where tblRegistry.Valuename = 'AUoptions' And TA.AssetID = tblAssets.AssetID) As AUOption From tblAssets
WHERE datefieldsubquery = Convert(varchar(50),YEAR(GETDATE()))+'-12-31 23:59:00'
user_id T1 T2 T3 T4 ------- --- --- --- --- 1 -2 0 0 0 1 2 0 0 0 2 1 0 0 0 2 2 0 0 0
select sourceIP, sum(sourceBytes) TotalBytes from flows group by sourceIP having sum(SourceBytes) > 50 order by sum(sourceBytes) desc
select foreign_id from your_table where string in ('house', 'window') group by foreign_id having count(distinct string) = 2;
select Distinct Meal from NewTab NT where not exists (select 1 from NewTab where NeededQty>AvailableQty and NT.Meal = Meal);
select post_id, sum(case when ul_key = 'u_like' then ul_value else 0 end) as likes, sum(case when ul_key = 'u_dislike' then ul_value else 0 end) as dislikes from wp_like_dislike_counters group by post_id;
with todelete as ( select t.*, row_number() over (partition by col1, col2, col3, . . . order by newid()) as seqnum from table t ) delete from todelete where seqnum % 2 = 0;
Dim dbs As DAO.Database Dim rsTable As DAO.Recordset Dim rsQuery As DAO.Recordset Set dbs = CurrentDb 'Open a table-type Recordset Set rsTable = dbs.OpenRecordset("tblSupeGenNotes", dbOpenDynaset) 'Open a dynaset-type Recordset using a saved query Set rsQuery = dbs.OpenRecordset("qrySupeGenNotes", dbOpenDynaset) 'update the values vased on the contents of the form controls rsQuery.Edit rsQuery![NoteDate] = Me.tbxNoteDate rsQuery![SupeType] = Me.cbxSupeType rsQuery![SupeAlerts] = alrt rsQuery![Note] = Me.tbxNote rsQuery.Update 'clean up rsQuery.Close rsTable.Close Set rsQuery = Nothing Set rsTable = Nothing
;WITH d AS ( SELECT TOP (366) d = DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY object_id), '20111231') FROM sys.all_objects ) INSERT dbo.[a table]([Date]) SELECT d FROM d WHERE d NOT IN (SELECT [Date] FROM dbo.[a table]) AND d <= DATEADD(DAY, 0-DATEPART(WEEKDAY, GETDATE()), GETDATE());
SELECT i.ItemName, i.CreateDate, (uc.LastName + ', ' + uc.FirstName) as [Created By Name], i.CreatedBy, i.LastChanged, (ucb.LastName + ', ' + ucb.FirstName) as [Last Changed By Name], i.LastChangedBy FROM Items i LEFT JOIN Users uc ON i.CreatedBy = uc.UserID LEFT JOIN Users ucb ON i.LastChangedBy = ucb.UserId WHERE i.LastChangedBy = 0001;
PoolingDataSource derbyDataSource1 = new PoolingDataSource(); derbyDataSource1.setClassName("org.apache.derby.jdbc.EmbeddedXADataSource"); derbyDataSource1.setUniqueName("derby1"); derbyDataSource1.getDriverProperties().setProperty("databaseName", "database1"); derbyDataSource1.init(); PoolingDataSource derbyDataSource2= new PoolingDataSource(); derbyDataSource2.setClassName("org.apache.derby.jdbc.EmbeddedXADataSource"); derbyDataSource2.setUniqueName("derby2"); derbyDataSource2.getDriverProperties().setProperty("databaseName", "database2"); derbyDataSource2.init(); BitronixTransactionManager btm = TransactionManagerServices.getTransactionManager(); btm.begin(); try { Connection c1= derbyDataSource1.getConnection(); Connection c2= derbyDataSource2.getConnection(); /***Use c1 and c2 to execute statements again their corresponding DBs as usual**/ btm.commit(); } catch (SQLException ex) { ex.printStackTrace(); btm.rollback(); }
LOAD DATA LOCAL INFILE 'CategoryData.txt' REPLACE INTO TABLE db.Category(CategoryName) LINES STARTING BY '(' LINES TERMINATED BY ')\n' FIELDS TERMINATED BY ',' SET ID = NULL;
field FILLER, col1 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\1')", col2 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\2')", col3 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\3')", col4 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\4')", col5 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\5')", col6 EXPRESSION "REGEXP_REPLACE(:field,'^([^|]*)\\|([^|]*)\\|(.*)\\|([^|]*)\\|([^|]*)\\|([^|]*)$', '\\6')"
SELECT TOP 1 MAX(e1.StartDate), COUNT(e2.eventID) FROM event e1 INNER JOIN event e2 on e1.StartDate BETWEEN e2.StartDate AND DATEADD(second,e2.Duration,e2.StartDate) GROUP BY e1.EventID ORDER BY COUNT(e2.eventID) DESC
select v1.word as word1, v2.word as word2 from verb v1 join verb v2 on v1.word < v2.word limit 10;
UPDATE [dbo].[ImageDocuments] SET [dbo].[ImageDocuments].[OriginalFileName] = d.FileName, [dbo].[ImageDocuments].[StorageFileName] = d.RealName OUTPUT INSERTED.ImageDocumentId INTO @Ids FROM [dbo].[ImageDocuments] as fu, [dbo].[Documents] as d WHERE fu.DocumentID = d.DocumentID; DELETE FROM Documents WHERE DocumentID IN (SELECT ImageDocumentId FROM @IDs);
SQL> with t1(Name1, LastName, tPoints, aPoints, sPoints, gPoints, type1) as( 2 select 'John' , 'Johnny', 15, 14, 13, 10, 1 from dual union all 3 select 'Joe' , 'P.' , 12, 11, 26, 10, 1 from dual union all 4 select 'Matt' , 'Q.' , 11, 26, 37, 44, 2 from dual union all 5 select 'Sorine', 'P.' , 55, 9 , 8 , 7, 2 from dual union all 6 select 'Ali' , 'Ahmed' , 30, 44, 88, 65, 2 from dual 7 ) 8 select type1 9 , tpoints 10 , apoints 11 , name1 12 , Lastname 13 from t1 14 order by case when type1=1 then tpoints else type1 end desc, 15 case when type1=2 then apoints else type1 end desc; TYPE1 TPOINTS APOINTS NAME1 LASTNAME ---------- ---------- ---------- ------ -------- 1 15 14 John Johnny 1 12 11 Joe P. 2 30 44 Ali Ahmed 2 11 26 Matt Q. 2 55 9 Sorine P.
UPDATE mytable SET [date] = DATEADD(DAY, 7, [date]) WHERE [date] >= '2014-02-20' AND [date] < '2014-02-21'
CREATE TABLE Example ( _id INTEGER PRIMARY KEY, name TEXT, index INTEGER, score INTEGER, UNIQUE (name, index) ON CONFLICT REPLACE )
select T2.id, coalesce((T1.classement=T2.classement),0)+ coalesce((T1.aptitude=T2.aptitude),0)+ coalesce((T1.A=T2.A),0)+ coalesce((T1.B=T2.B),0)+ coalesce((T1.C=T2.C),0) match_count from Temp T1 cross join Temp T2 where T1.id = 1 and T2.id <> 1 order by 2 desc
select * from Users left outer join School on Users.Schoolid = School.Schoolid
SELECT to_char(d.day, 'YYYY/MM/DD" - "') || to_char(d.day + 6, 'YYYY/MM/DD') AS week , count(situation ILIKE '%active%' OR NULL) AS activated , ... FROM ( SELECT day::date FROM generate_series('2014-08-11'::date , '2014-09-14'::date , '1 week'::interval) day ) d LEFT JOIN account_details a ON a.date_opened >= d.day AND a.date_opened < d.day + 7 -- 7, not 6! GROUP BY d.day;
$object_id = 2; Doctrine::getTable('Tagset')->createQuery('t') ->select('t.tag_id, o.id, o.name, COUNT(t.tag_id) AS tag_count') ->innerJoin('t.Object o WITH o.id != ?', $object_id) ->where('t.tag_id IN (SELECT t.tag_id FROM Tagset t WHERE t.object_id = ?)', $object_id) ->groupBy('t.object_id')
select district, sum(case when sex ='M' then 1 else 0 end) M, sum(case when sex ='F' then 1 else 0 end) F, sum(case when sex ='NI' then 1 else 0 end) NI from table1 group by district order by district
SELECT i.equip_pk, i.request_pk, NVL(MY_ALIAS.EQUIP_ALIAS_ID, 'Nothing' FROM tableOne i LEFT OUTER JOIN table2 MY_ALIAS ON (i.EQUIP_PK = MY_ALIAS.EQUIP_PK) WHERE i.request_pk=:requestPk
echo.If @intA ^<^> @intB> "C:\output_file.txt"
SELECT EID, SUM(PCNUM) FROM table1 GROUP BY EID;
DECLARE @path NVARCHAR(500) = 'F:\Fruit Seeds-Category Oil\Quality- Fine Seeds'; DECLARE @i INT = 1; DECLARE @ix INT = 0; WHILE @i > 0 BEGIN SET @ix = @i; SET @i = CHARINDEX('-', @Path, @i + 1); END SELECT LEFT(@path, @ix - 1)
-- assume @dbname has the name of the database where getdetails was created declare @sql nvarchar(4000), @params nvarchar(4000), @dbname sysname set @dbname = 'test' set @sql = @dbname + '..getdetails' set @params = '' exec sp_executesql @sql, @params
select (case when (1 < 2) then 'True' else 'False' end) as one, (case when (1 > 2) then 'True' else 'False' end) as two from table
INSERT INTO software(Name, Type) SELECT (CAST(Name as nvarchar), Type) FROM serials (ProductName, Type)
select round(123.456, 2, 1)
String hqlQuery =" SELECT message FROM p_message pm WHERE pm.message_id in (SELECT a.scene FROM p_config a INNER JOIN p_rec_type b ON a.email_id=b.email_id AND rec_type =:rectype WHERE a.email_type=:emailTYpe)"; query = session.createQuery(hqlQuery); query.setParameter("rectype", 2); query.setParameter("emailTYpe", 1);
select prs.id, prs.name, count(*) from Person prs join(select process_no, id from Responsible res Union all select process_no, id from Linked lin ) a on a.id=prs.id group by prs.id, prs.name
String filter = "hachiko" def hero = Hero.createCriteria().list { familiar { like('name', filter) } }
select cu.cust_id, cu.cust_name, ci.location from cinema ci join booking b on ci.c_id = b.c_id join customer cu on b.cust_id = cu.cust_id where ci.location <> 'Paris'
SELECT car.name, testresults.testname, isnull(testresults.result, 0) FROM cars CROSS JOIN safetytests LEFT JOIN testresults on safetytests.testid = testresults.testid AND car.id = testresults.carid
create or replace view state_city_view as select state_name as name, '' as parent_name from state union all select city_name || ' ' || population name, state_name as parent_name from city;
select a.ID as "Article-Number", a.Name as "Name" from Articles a where (a.ID = '3264')
declare o CURSOR FAST_FORWARD FOR select comments from EVENT declare @comment nvarchar(max) OPEN o FETCH NEXT FROM o into @comment while @@FETCH_STATUS = 0 BEGIN Declare @item nvarchar(750) declare @tbl Table(Category nvarchar(250), Description nvarchar(250), Quantity nvarchar(250), Value DECIMAL(10,2)) declare c CURSOR FAST_FORWARD FOR SELECT items FROM dbo.Split(@comment, Char(10)) OPEN c FETCH NEXT FROM c into @item WHILE @@FETCH_STATUS = 0 BEGIN set @item = @item + ':' insert into @tbl Values (LTRIM(RTRIM(SUBSTRING(@item, 1, CHARINDEX(' - ', @item) - 1))), CASE when @item like '%D:%' Then LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('D:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('D:', @item)+2) - CHARINDEX('D:', @item) - 3))) else '' end, CASE when @item like '%Q:%' Then LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('Q:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('Q:', @item)+2) - CHARINDEX('Q:', @item) - 3))) else '1' end, CASE when @item like '%V:%' Then CONVERT(DECIMAL(10,2),dbo.RemoveNonNumericCharacters(LTRIM(RTRIM(SUBSTRING(@item, CHARINDEX('V:', @item) + 2, CHARINDEX(':', @item, CHARINDEX('V:', @item)+2) - CHARINDEX('V:', @item) - 3))))) else 0 end) FETCH NEXT FROM c into @item END CLOSE c DEALLOCATE c END CLOSE o DEALLOCATE o SELECT * FROM @tbl
WITH RECURSIVE year_table(n) AS ( SELECT 1000 UNION ALL SELECT n+1 FROM year_table ) SELECT Id, To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY') FROM Feasts WHERE To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY') >= Date_From AND To_Date(DAY || ' ' || MONTH || ' ' || YEAR, 'DD MM YYYY') <= Date_To AND YEAR IS NOT NULL UNION SELECT Feasts.Id, To_Date(DAY || ' ' || MONTH || ' ' || Year_Table.n, 'DD MM YYYY') FROM Feasts, Year_Table WHERE n >= To_Char(Date_From, 'YYYY') AND n <= To_Char(Date_To, 'YYYY') AND Feasts.YEAR IS NULL;
select 'text1' text, SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla, SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla, SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba from table1 UNION ALL select 'text2' text, SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla, SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla, SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba from table2 UNION ALL select 'text3' text, SUM(CASE WHEN "XY" LIKE '%XP Pro%' THEN 1 ELSE 0 END) blabla, SUM(CASE WHEN "XYZ" = 1 THEN 1 ELSE 0 END) blablabla, SUM(CASE WHEN "ABS" = 1 THEN 1 ELSE 0 END) blablalasba from table3
select count(*) from BadWords where @userName like '%'+theBadWord+'%'
select * from openquery ( myLinkedServer ,'Select * from mySQLTables where complicated joins/filters')
SET @parentID = parentId;
<WebMethod()> Public Function LookupItem(ByVal strUPC As String) As DataSet Try Dim connUPC As New Data.SqlClient.SqlConnection Dim cmdUPC As New Data.SqlClient.SqlCommand Dim daUPC As New Data.SqlClient.SqlDataAdapter Dim dsUPC As DataSet = New DataSet Dim ConnectionString As String = "Data Source=localhost\db;Initial Catalog=DB_SQL;Persist Security Info=True;User ID=myID;Password=myPass" Dim strSQL As String = "SELECT Inv_Qty.*,PLU.*,PLU.PLU_NUM, PLU.DEPT_NUM From PLU INNER JOIN Inv_Qty ON PLU.PLU_NUM=Inv_Qty.PLU_NUM WHERE ((PLU.PLU_NUM) = '" & strUPC & "');" '// Opening the connection connUPC.Open() cmdUPC.Connection = connUPC cmdUPC.CommandText = strSQL daUPC.SelectCommand = cmdUPC daUPC.Fill(dsUPC) connUPC.Close() connUPC = Nothing Return dsUPC Catch ex As Exception End Try End Function
using ( select 1 as ana_rb, 1 as ana_id, 'da' as ana_kupanje, 'da' as ana_kosa, 'da' as ana_brijanje, 'da' as ana_zubi, 'da' as ana_nokti, 'da' as ana_odjeca, 'da' as ana_koza, 'da' as ana_dek_rizik, 'da' as ana_dek_rizik_gdje, 'da' as ana_dek_postojeci, 'da' as ana_dek_post_gdje, 'da' as ana_pokretnost, 'da' as ana_kolica, 'da' as ana_pomagala, 'veki' as azurirao, getdate() as datumazur ) e
SELECT to_char(o.date_order, 'DD-MM-YYYY') AS date_order , sum(o.amount_total) AS amount FROM public.sale_order o WHERE EXISTS ( SELECT * -- These tables probably have an N:1 relation -- to public.sale_order -- We don't have to sum them; just check existence. FROM public.sale_order_line l JOIN public.product_product pp ON pp.id = l.product_id JOIN public.product_template pt ON pt.id = pp.product_tmpl_id JOIN public.product_category pc ON pc.id = pt.categ_id WHERE pc.name = 'Starchi' AND l.order_id = o.id ) AND o.order_year = '2015' AND o.order_month = 'April' GROUP BY o.date_order ORDER BY o.date_order ASC ;
SELECT * FROM Services WHERE Service IN (1, 3) AND pay_date > '2014-07-01' AND pay_date < '2014-07-30' AND NOT EXISTS ( SELECT 1 FROM services AS s2 WHERE s2.Name = s.Name AND s2.Status = 1 AND s2.Service IN (1, 3) AND s2.pay_date > '2014-07-01' AND s2.pay_date < '2014-07-30' );
SELECT SUM(amount) FROM sales_orders WHERE date BETWEEN '2011-03-06' and '2011-04-06' -- not sure what your date is.
select min(value) from table where value <> ( select min(value) form table );
with t as ( select '12:10:08: Dialing12:10:08: Connecting12:10:08: ABC: abc:9433769781$100.88.77.0:878712:10:08: ABCD: 000012:10:09: Agent Initializing12:10:25: On Call12:10:25: Assigned to operator12:10:25: Waiting for Supervisor12:10:30: Waiting for Manager12:11:30: Call Ended12:11:30: Call Not connected.. ' as col ), cte as ( select left(t.col, 9 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(t.col, 11, 1000))) as val, substring(t.col, 10 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(t.col, 11, 1000)), 1000) as rest from t where t.col like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %' union all select (case when rest like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %' then left(rest, 9 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(rest, 11, 1000))) else rest end) as val, substring(rest, 10 + patindex('%[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %', substring(rest, 11, 1000)), 1000) as rest from cte where rest like '[0-9][0-9]:[0-9][0-9]:[0-9][0-9]: %' ) select val from cte;
ALTER PROCEDURE [dbo].[GetSimilarIssues] ( @InputSearch varchar(255) ) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @SearchText varchar(500); SELECT @SearchText = '"' + @InputSearch + '*"' SELECT PostId, Summary, [Description], Created FROM Issue WHERE FREETEXT (Summary, @SearchText); END
select AC.category_id, count(*) as num_articles from categories C join articles_categories AC on C.id = AC.category_id join ( select id from articles where match(name, teaser, plaintext_contents) against ('some text' in boolean mode) ) A_IDS ON A_IDS.id=AC.article_id group by AC.category_id;
//Your query $queryliste = "SELECT id, nom, prenom FROM table"; //Initialize pdo connection use your $name, $host, $username and $password $pdoLink = new PDO("mysql:dbname={$name};host={$host};charset=utf8", $username, $password); //Prepare statement $statement = $pdoLink-> prepare($queryliste); //Execute query $statement -> execute(); //(1) Fetch rows using PDO::FETCH_ASSOC $rows = $statement -> fetchAll(PDO::FETCH_ASSOC); $statement -> closeCursor(); foreach($rows as $row) { echo $row['id']; echo $row['nom']; echo $row['prenom']; } //(2) or you can use PDO::FETCH_NUM $rows = $statement -> fetchAll(PDO::FETCH_NUM); $statement -> closeCursor(); foreach($rows as list($x, $y, $z)) { echo $x; echo $y; echo $z; } //(3) or you can rewrite the last in the same form you are using as while((list($x, $y, $z) = $statement->fetch(PDO::FETCH_NUM))) { echo $x; echo $y; echo $z; } $statement -> closeCursor();
DECLARE @i int = 1019 SELECT c.id FROM Users c LEFT JOIN offers o ON c.id = o.UserId AND o.ProductId IN (@i) WHERE o.UserId IS NULL ORDER BY c.id
SELECT * FROM (SELECT SUM(pur.purchase_net_invoice_value), par.party_desc FROM purchase pur JOIN party par ON par.party_id = pur.party_id GROUP BY par.party_desc ORDER BY 1 DESC) WHERE rownum <= 5;
select Project.MEDIA_F('tv', '06-05-13', 'n') from dual;
select passenger_no, hr from ride_txn rt, ( select 0 hr union all select 1 union all select 2 union all select 3 union all select 4 union all select 5 union all select 6 union all select 7 union all select 8 union all select 9 union all select 10 union all select 11 union all select 12 union all select 13 union all select 14 union all select 15 union all select 16 union all select 17 union all select 18 union all select 19 union all select 20 union all select 21 union all select 22 union all select 23 ) hrs where action = 'Board' and hrs.hr between hour(txn_time) /* could add 3599 seconds to only count top of the hour */ and ( select min(txt_time) from ride_txn rt2 where rt2.passenger_no = rt.passenger_no and rt2.txt_time > rt.txt_time and action = 'Deboard' )
SELECT [Users], [Stars] FROM [Table] WHERE [Users] != 'Admin' OR [Stars] > 3
select Convert(date, BookedDateTime) as Date, AVG(datediff(minute, BookedDateTime, PickupDateTime)) as AverageTime from tablename group by Convert(date, BookedDateTime) order by Convert(date, BookedDateTime)
SELECT * FROM (your_UNION_query) AS p WHERE NOT ( colX = 'TERMINATED' AND EXISTS ( SELECT * FROM (your_UNION_query) AS q WHERE q.id = p.id AND q.colY = 'ACTIVE' ) )
CREATE PROCEDURE Find_Text_In_SP @StringToSearch varchar(100) AS SET @StringToSearch = '%' +@StringToSearch + '%' SELECT Distinct SO.Name FROM sysobjects SO (NOLOCK) INNER JOIN syscomments SC (NOLOCK) on SO.Id = SC.ID AND SO.Type = 'P' AND SC.Text LIKE @stringtosearch ORDER BY SO.Name GO
Create or Replace procedure Main SAVEPOINT sp_1; Call procedure_1(); Call procedure_2(); IF X = true THEN ROLLBACK TO sp_1; END IF; END Procedure Main;
BEGIN FOR c IN ( SELECT table_name FROM user_tables WHERE table_name LIKE 'EXT_%' ) LOOP EXECUTE IMMEDIATE 'DROP TABLE ' || c.table_name; END LOOP; END;
c.site_gb LIKE 'A%' c.up_dept_cd='A001'
with x as ( select 'Černický' name from dual union all select 'Marián' from dual ) select convert(name, 'US7ASCII') from x;
conn = database('databasename','username','password'); dbpath = 'C:\Users\______.mdb'; %insert database path tableName = 'datetime'; %insert tablename here in MSAccess colname = {'column1'} %column of your tables in MsAccess date = datestr(now); %the string of date and time coldata = {date} insert(conn,tableName,colname,coldata); %will insert the data to the database. close(conn);
update your_table set column1 = column1 || column2
SELECT st_category AS cat, st_gender, COUNT(studentPK) FROM es_preadmission WHERE st_category IN ('GEN','SC','ST',....,'SGC') GROUP BY st_category, st_gender UNION ALL SELECT st_handi AS cat, st_gender, COUNT(studentPK) FROM es_preadmission WHERE st_handi = 'PH' GROUP BY st_handi, st_gender
exec sp_depends 'view name'
select p.*, (select count(*) from users u where u.uid not in (select o.uid from orders o where o.productid = p.productid) and u.gender = 'Male' ) as NumMales, (select count(*) from users u where u.uid not in (select o.uid from orders o where o.productid = p.productid) and u.gender = 'Female' ) as NumFemales from products p ;
SELECT group.id,COUNT(users.username) FROM groups INNER JOIN users ON users.group_id=groups.id GROUP BY groups.id
SELECT name, address FROM customer WHERE status = 'active' and zip = ?
SELECT * FROM A INNER JOIN B ON B.AID = A.AID INNER JOIN C ON C.BID = B.BID INNER JOIN D ON D.AID = A.AID INNER JOIN E ON E.DID = D.DID INNER JOIN F ON F.EID = E.EID WHERE C.Field = F.Field
SQL> create or replace type numbers_nt as table of number 2 / Type created. SQL> SQL> declare 2 l_array numbers_nt; 3 begin 4 l_array := numbers_nt (7521,7566,7654); 5 for r in ( select ename 6 from emp 7 where empno in ( select * 8 from table (l_array) 9 ) 10 ) 11 loop 12 dbms_output.put_line ( 'employee name = '||r.ename); 13 end loop; 14 end; 15 / employee name = PADFIELD employee name = ROBERTSON employee name = BILLINGTON PL/SQL procedure successfully completed. SQL>
BEGIN IF(CONDITION)THEN htp.init; owa_util.redirect_url('f?p=&APP_ID.:10:&APP_SESSION.'); /*Replace 10 with actual Page Number*/ apex_application.stop_apex_engine; ELSE htp.init; owa_util.redirect_url('f?p=&APP_ID.:20:&APP_SESSION.'); /*Replace 20 with actual Page Number*/ apex_application.stop_apex_engine; END IF; END;
select t.id4id Id, n1.Name Name, group_concat(n2.name) Groups from (select t1.actid id4id, t1.postedby id4name, t2.postedby id4groups from Activity t1 join Activity t2 on t1.actid = t2.parentid) t join "user" n1 on t.id4name = n1.userid join "User" n2 on t.id4groups = n2.userid group by id4id
var unAssociatedPages = from p in db.Pages join mm in db.MainMenus on p.PageID equals mm.MainMenuPageFK into mms where !mms.Any() select p;
ID Data Comes_after_ID -- ----- -------------- 27 Blahh NULL 54 Blahh 27 57 Blahh 54 1 Blahh 57
select * from user u inner join hierarchyset h on h.clientid = u.clientid left outer join linktable l on l.hierarchsetid = h.hierarchsetid and u.userId = l.userId) where l.hierarchsetid is null and l.userId isnull
select dbms_utility.port_string from dual;
SELECT grp.GroupID, grp.GroupNumber, grp.Name, grp.Location, grp.GroupTypeID, grp.DivisionID, grp.MasterGroupID, grp.EffectiveDate, grp.TerminationDate, crt.[ContractNumber], pln.[PBPNumber], div.SiteName, src.Name as SourceName FROM [Group] grp INNER JOIN [IndividualPlanDemographic] idp ON grp.GroupID = idp.IndividualPlanDemographicID INNER JOIN [Plan] pln ON idp.PlanID = pln.PlanID INNER JOIN [Contract] crt ON pln.ContractID = crt.ContractID --THE GROUP IS NOT REQUIRED TO BE IN A DIVISION RELATIONSHIP LEFT OUTER JOIN [Division] div ON grp.DivisionID = div.DivisionID LEFT OUTER JOIN [SourceSystem] src ON div.SourceSystemID = src.SourceSystemID WHERE 1 = 1 AND grp.EffectiveDate = '1/1/2015 12:00:00 AM' AND grp.GroupTypeID = '2' ORDER BY ContractNumber
SELECT * FROM TABLE IF(mytime is null, [sometime],mytime) ORDER BY ...
With Shifts As ( Select 1 As Num , Cast('2012-05-01 6:00 AM' As datetime) As ShiftStart , DateAdd(hh,12,Cast('2012-05-01 6:00 AM' As datetime)) As ShiftEnd Union All Select Num + 1, ShiftEnd, DateAdd(hh,12,ShiftEnd) From Shifts Where ShiftEnd < '2012-05-30' ) , Segments As ( Select event_id , Case When Shifts.ShiftStart > event_start Then Shifts.ShiftStart Else event_start End As start_split_segment , Case When Shifts.ShiftEnd < event_end Then Shifts.ShiftEnd Else event_end End As end_split_segment , Count(*) Over ( Partition By E.event_id ) As SegmentCount From events As E Join Shifts On E.event_start <= ShiftEnd And E.event_end > ShiftStart ) Select E.event_id, E.description, E.event_start, E.event_end , S.start_split_segment, S.end_split_segment , Case When SegmentCount > 1 Then 1 Else 0 End As is_split , NullIf(SegmentCount,1) As split_segments From Segments As S Join events As E On E.event_id = S.event_id
SELECT Quote FROM Quote q, Users u, Followers f WHERE q.user_id = u.id AND q.user_id = f.follower UNION SELECT Quote FROM Quote q, Users u, Followers f WHERE q.user_id = u.id AND q.user_id <> f.follower
WHERE t.something = 'something' AND (t.lastname = 'smith' or t.name <> 'john')
DELETE FROM cities WHERE city_id NOT IN (SELECT city_id FROM events)
update students set highestmark = 5 -- insert new value here where id = 42-- insert id and highestmark < 5 -- insert new value here
select sum(case when ts_homepage is not null then 1 else 0 end) as homepage_count, sum(case when ts_productpage > ts_homepage then 1 else 0 end) as productpage_count, sum(case when ts_checkout > ts.productpage and ts.productpage > ts.homepage then 1 else 0 end) as checkout_count from (select userid, min(case when action = 'homepage' then timestamp end) as ts_homepage, min(case when action = 'product page' then timestamp end) as ts_productpage, min(case when action = 'checkout' then timestamp end) as ts_checkout from table t group by userid ) t
SELECT listagg (''''||PARAMETER||'''', ',') WITHIN GROUP (ORDER BY RowNumber) AS PARAMETER, FROM (SELECT trunc((rownum - 1) / 8) as grp, t.*, rownum as RowNumber FROM SR0_CRTL_SL_OL_PSM_PARAMETER t ) t GROUP BY grp;
^.*\/.*\.[a-zA-Z]{3}$
SELECT SUM (AMOUNT), [Customer No_] FROM ( select Amount [Fluids Management$Cust_ Ledger Entry].[Customer No_] FROM [Fluids Management$Detailed Cust_ Ledg_ Entry] UNION ALL select [Debit Amount] as 'Less then 30 days', [Fluids Management$Cust_ Ledger Entry].[Customer No_] FROM [Fluids Management$Detailed Cust_ Ledg_ Entry] ) GROUP BY [Customer No_]
SQL> SELECT * FROM t_data; PK START_DATE END_DATE ---------- ----------- ----------- 1 20/01/2010 20/01/2010 2 21/01/2010 23/01/2010 3 24/01/2010 27/01/2010 SQL> SELECT pk, start_date, end_date FROM t_data 2 MODEL 3 PARTITION BY (pk) 4 DIMENSION BY (0 AS i) 5 MEASURES(start_date, end_date) 6 RULES 7 ( start_date[FOR i 8 FROM 1 TO end_date[0]-start_date[0] 9 INCREMENT 1] = start_date[0] + cv(i), 10 end_date[ANY] = start_date[CV()] + 1 11 ) 12 ORDER BY 1,2; PK START_DATE END_DATE ---------- ----------- ----------- 1 20/01/2010 21/01/2010 2 21/01/2010 22/01/2010 2 22/01/2010 23/01/2010 2 23/01/2010 24/01/2010 3 24/01/2010 25/01/2010 3 25/01/2010 26/01/2010 3 26/01/2010 27/01/2010 3 27/01/2010 28/01/2010
SELECT SUM(C1) AS C1, CASE WHEN C1 = 1 THEN 'other' ELSE device_type END as device_type FROM ( SELECT COUNT(*) AS C1, device_type FROM stat WHERE stat_date = '2012-02-08' GROUP BY device_type) A GROUP BY CASE WHEN C1 = 1 THEN 'other' ELSE device_type END
UPDATE TimeRequestedTable INNER JOIN BlockTimesTable ON BlockTimesTable.EmpID = TimeRequestedTable.EmpID SET AppointTime = "inputed by user" WHERE AppointTime BETWEEN startTime and EndTime
select count(distinct UnitId) as Units, count(*) as Pieces from Piece where Category = 'A'
set serveroutput on;
UPDATE `table` SET `foo` = 'bar' ORDER BY `timestamp` DESC LIMIT 1;
WHERE EntryDate BETWEEN CASE WHEN Product = 'LTD' THEN @FirstDatetc ELSE DateAdd(blah) END AND GetDate()-1
CREATE TRIGGER [dbo].[DIENSTLEISTUNG_Update] ON [dbo].[DIENSTLEISTUNG] FOR UPDATE AS IF UPDATE(PRICE) ... (do what you need to do if PRICE is updated)... IF UPDATE(DESCRIPTION) ... (do what you need to do if DESCRIPTION is updated)... IF UPDATE(PRIORITY) ... (do what you need to do if PRIORITY is updated)...
UPDATE PS_Z_TREND_NOW_TBL a SET STATUS = ( CASE WHEN COUNT(SEC.IS_AW_AUTH_NAME) > 0 then 'M' ELSE null END ) FROM PS_IS_AW_SECURITY sec WHERE sec.IS_AW_AUTH_NAME LIKE '%Manager%'
UPDATE #Table SET name = 'Winn-Dixie -' + RIGHT(Name, LEN(NAME) - CHARINDEX('-',Name)) WHERE name LIKE 'Sweetbay%'
with test_data as ( SELECT 184 ID, 'Halifax' text, 'Bnk' tag, 1 ord from dual union all SELECT 184 ID, 'RBS' text, 'Bnk' tag, 2 ord from dual union all SELECT 184 ID, 'Natwest' text, 'Bnk' tag, 3 ord from dual union all SELECT 184 ID, '32.16' text, 'Amt' tag, 1 ord from dual union all SELECT 184 ID, '80.15' text, 'Amt' tag, 2 ord from dual union all SELECT 184 ID, '62.54' text, 'Amt' tag, 3 ord from dual ) select bank_name, amount from test_data pivot ( max(text) for tag in ('Bnk' as bank_name, 'Amt' as amount) ) order by ord
UPDATE table SET column = REPLACE(column, 'Street', 'St');
select <...> from A, B, C, (select ID from ...) as e where A.FK_1 = B.PK and A.FK_2 = C.PK and A.ID = e.id union select <...> from A, B, C, (select ID from ...) as e where A.FK_1 = B.PK and A.FK_2 = C.PK and A.ID = e.ID
count(distinct dlr.id)
SELECT startTime, SUM(duration) as sum FROM myTable WHERE startTime = endTime GROUP BY startTime
INSERT INTO PATIENT_DETAIL SELECT PATIENT_NAME, 'DISEASE D', dbms_random.value(1,1000), sysdate, sysdate FROM PATIENT_DETAIL
select p.*, min(ps.price) from products p left join (select ps.product_id, ps.store_id, max(created_at) as maxca from product_store ps group by ps.product_id, ps.store_id ) pssum on pssum.product_id = p.id left join product_store ps on ps.product_id = pssum.product_id and ps.store_id = pssum.store_id and ps.created_at = pssum.maxca group by p.id;
Me.ComboBox.DataBindings.Add(New Binding("SelectedItem", _ Me.TblBindingSource, "ColumnName", True))
CREATE TRIGGER z_LOGIN2 AFTER UPDATE OF lastsignondttm ON SYSADM.PSOPRDEFN FOR EACH ROW BEGIN IF (SELECT COUNT(1) FROM SYSADM.psroleuser b WHERE b.roleuser = NEW.oprid AND (b.rolename = 'FAS Change Admin' OR b.rolename = 'PeopleSoft Administrator')) > 0 THEN INSERT INTO z_LOGIN VALUES (NEW.oprid,NEW.oprdefndesc,NEW.lastlogondttm); END IF; END;
UPDATE t_b SET a_id_fk = COALESCE( (SELECT MIN(a_id) FROM t_a WHERE a_id > t_b.a_id_fk), (SELECT MIN(a_id) FROM t_a)) WHERE b_id = :b_id
WITH ovrdValXML AS ( select xov.id, xmlforest(ID as "valueID", S_VAL as "sValue", U_VAL as "uplValue", O_VAL as "oValue", O_IND as "oIndicator", F_VAL as "finalValue", O_RSN as "reason") AS XMLChunk from ovrd_val xov) SELECT xmlelement("genInf", xmlelement("ID", vt.ID), xmlelement("vID", vt.V_ID), xmlelement("vNum", vt.V_NUM), xmlelement("terrDataCode", TERR_CODE.column_value), --data is based on reference table xmlelement("ABValCode", AB_VAL_CD.column_value), --data is based on reference table ... FROM V_TAB vt JOIN ovrdValXML terr_code ON terr_code = vt.? AND terr_code.id = vt.terr_cd_id JOIN ovrdValXML ab_val_cd ON ab_val_cd = vt.? AND ab_val_cd.id = vt.ab_val_cd WHERE vt.id = IN_VID;
SELECT T1.* FROM TABLE1 AS T1 INNER JOIN TABLE2 AS T2 ON T1.MATERIAL = T2.MATERIAL
;WITH data AS ( SELECT 1 as [value],'2012-03-07' as date UNION ALL SELECT 1,'2012-03-06' UNION ALL SELECT 1,'2012-03-05' UNION ALL SELECT 3,'2012-03-04' UNION ALL SELECT 4,'2012-03-03' UNION ALL SELECT 1,'2012-03-02' ) ,data2 AS ( SELECT [Value] ,date ,row_number() OVER (ORDER BY (SELECT NULL)) as row1 FROM data ) ,data3 AS ( SELECT * , row1 - row_number() OVER (ORDER BY [Value]) as row2 from data2 ) SELECT MIN([Value]) AS [Value] ,MIN(Date) as Date FROM data3 GROUP BY [Value] - row2 ORDER BY MIN(row1)
var query = db.Customers; if (selectID.HasValue) { query = query.Where( c => c.ID > selectID.Value ); } if (!string.IsNullOrEmpty( nameFilter )) { query = query.Where( c => c.Name.Contains( nameFilter ) ); } foreach (var customer in query) // now the query is performed { ... }
SELECT Form_ID, Product_ID, Date, Indicator = Count(*) Over (Partition by Product_ID) FROM my_database.inv_table ORDER BY Indicator DESC
USE AdventureWorksLT2012 -- First query using UNION SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 716 UNION SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 727 UNION SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 770 -- Second query using UNION ALL SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 716 UNION ALL SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 727 UNION ALL SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID = 770 -- Third query using IN SELECT ProductID, Name FROM SalesLT.Product WHERE ProductID IN(716, 727, 770)
SELECT a.* FROM Table1 a LEFT JOIN Table2 b ON a.EmployeeID = b.EmployeeID WHERE b.EmployeeID IS NULL
SELECT T2.org_id, T.item_id FROM table AS T2 JOIN (SELECT item_id, SUM(spend) AS total_spend FROM table AS T GROUP BY T.item_id HAVING COUNT(DISTINCT org_id) < 4) AS T ON T.item_id = T2.item_id ORDER BY T.total_spend DESC
sql = "SELECT CONVERT(VARCHAR(19), date, 120) as date FROM sales WHERE userid=1"
SELECT Count(*) FROM ( SELECT ID FROM dbo.YourTable GROUP BY ID HAVING Count(*) >= 2 ) X ;
--populate tables with sample data DECLARE @totalRecords int SET @totalRecords = 0 DECLARE @currentKey int WHILE @totalRecords < 500 BEGIN SET @totalRecords = @totalRecords + 1 INSERT INTO dbo.submissions (submissionName, dateSubmitted) VALUES ('submission record ' + cast(@totalRecords AS varchar(3)), SYSDATETIME()) Set @currentKey = Scope_Identity() INSERT INTO dbo.submissionItems (fk_submission_id, item) VALUES (@currentKey, 'a new record item for submission '+ cast(@totalRecords AS varchar(3))) END
$query = $_GET['query']; //id I get from the specified item echo 'the id is: ' . $query; //test purposes $mysql_handle = mysqli_connect($dbhost, $dbuser, $dbpass) or die("Error connecting to database server"); $sql1 = "SELECT item_stock FROM chat-db.Item WHERE id = '".$query."'"; $results = mysqli_query($mysql_handle, $sql1); if (!empty($results) && mysqli_num_rows($results) > 0) { while($rec = mysqli_fetch_array($results)) { echo $rec['item_stock']; } }
select jobid, jobtitle, pay, name from ( select j.jobid, j.jobtitle, e.pay, e.name, row_number() over (partition by j.jobid order by e.pay desc) as rn from employees e join jobs j on j.jobid = e.job_id ) where rn <= 3 order by jobid, jobtitle, pay desc;
select f.friend_userid as userId from friends f where f.userid = 1 UNION select f.userid as userId from friends f where f.friend_userid = 1;
;WITH cte AS ( SELECT *, ROW_NUMBER() OVER (PARTITION BY DocumentID ORDER BY DateCreated DESC) AS rn FROM DocumentStatusLogs ) SELECT * FROM cte WHERE rn = 1
CREATE TABLE t1 (username varchar2(4)) ; CREATE INDEX t1_idx ON t1(lower(username));
SELECT ll.ip_address, ll.when, cbi.country FROM last_login ll LEFT JOIN `country_by_ip` cbi on ll.ip_address > cbi.ip_from WHERE ll.ip_address < cbi.ip_to
SELECT t.* FROM t INNER JOIN ( SELECT ID = MAX(ID) FROM t GROUP BY key ) tm ON tm.ID = t.ID
pR.projectRelationId IN ('$id[ 0 ]', '$id[ 1 ]', '$id[ 2 ]')
SELECT @trans_id=transaction_id FROM sys.dm_tran_current_transaction
UPDATE OrderGroupNew SET SavedTotal = ( SELECT SUM(UnitPrice * Quantity) FROM OrderItemNew WHERE OrderNumber = OrderGroupNew.OrderNumber )
declare @maxcount1 float declare @maxcount0 float select @maxcount1 = max(count1), @maxcount0 = max(count0) from (SELECT TeamName,Count(DISTINCT CASE WHEN WorkInfo = 1 THEN SlNo end) AS Count1 , Count(DISTINCT CASE WHEN WorkInfo = 0 THEN SlNo end) AS Count0 FROM tableA WHERE (SubmitDate BETWEEN @start AND @end) GROUP BY TeamName) as s select teamname, count1, count0, round((cast((count1 * 100) as float)/@maxcount1),2) as percentage1, round((cast((count0 * 100) as float)/@maxcount0),2) as percentage0 from (SELECT TeamName,Count(DISTINCT CASE WHEN WorkInfo = 1 THEN SlNo end) AS Count1 , Count(DISTINCT CASE WHEN WorkInfo = 0 THEN SlNo end) AS Count0 FROM tableA WHERE (SubmitDate BETWEEN @start AND @end) GROUP BY TeamName) as s
SET @i:=0; SET @j:=0; UPDATE t1 RIGHT JOIN ( SELECT id ,IF(@j = 0 ,@j:=1, @j:=@j+1) ,IF((@j-1) % 12 = 0, @i:= @i+1, @i) as i FROM t1 WHERE hDate IS NULL ) idx on idx.id = t1.id SET t1.hDate = CURDATE() + INTERVAL (idx.i) DAY
SELECT mobilenumber, COUNT(*) FROM ( SELECT DISTINCT mobilenumber, firstname, lastname FROM YourTable ) AS q GROUP BY mobilenumber HAVING COUNT(*) > 1
DECLARE @DateFrom DATETIME SET @DateFrom = '2011-01-01' DECLARE @DateTo DATETIME SET @DateTo = '2011-01-10' ;WITH DateRanges AS ( SELECT @DateFrom AS 'DateValue' UNION ALL SELECT DATEADD(DAY, 1, DateValue) FROM DateRanges WHERE DateValue < @DateTo ) SELECT * FROM DateRanges
string.Replace(";", "CHAR(59)");
select column_name, count(column_name) from table group by column_name having count (column_name) > 1;
select t1.Name state_name, t2.Name Country_name from State_m t1,Country_m t2 where t1.CountryId=t2.CountryId;
USE intranet ;WITH A AS ( SELECT ROW_NUMBER() OVER (ORDER BY id) AS tab_ranking , id FROM dbo.tabs WHERE cms_initials = @user ), B AS ( SELECT DENSE_RANK() OVER (ORDER BY tabs_id) AS tab_sequence , tabs_id, widgets_id, sort_column, sort_row FROM dbo.columns WHERE tabs_id IN (SELECT t.id FROM dbo.tabs t WHERE t.is_default = 1) ) INSERT INTO dbo.columns (tabs_id, widgets_id, sort_column, sort_row) SELECT a.id, b.widgets_id, b.sort_column, b.sort_row FROM A INNER JOIN B ON B.tab_ranking = A.tab_ranking
SELECT u.* FROM cpnc_User u JOIN ( SELECT firstName, lastName FROM cpnc_User GROUP BY firstName, lastName HAVING COUNT(*) > 1 ) X on X.firstName = u.firstName AND x.lastName = u.lastName ORDER BY u.firstName, u.lastName
update table_name set action=replace(action,'consultation','display');
UPDATE tbl_profile SET year_level='3rd' WHERE users_id IN ( SELECT users_id FROM tbl_usersinfo WHERE full_name = 'captain america');
select replace(col, '$', '') from <whatever>;
select * from master..spt_values where 1=1 or (select count(*) from master..sysobjects) > 0
select concat(d.FirstName, ' ', d.LastName) as 'Donor' , sum(a.amount) as 'Total Paid' , sum(case when a.CompanyId is null then a.amount else 0 end) as 'Pocket' from Donor d join Pledge p on d.DonorId = p.DonorId join Payment a on p.pledgeId = a.pledgeId group by d.donorid
create table your_table_name ( one_row integer not null unique default 1 check (one_row = 1), version varchar(5) not null unique ); insert into your_table_name values (1, '0.0.0');
SELECT col, COUNT(dupe_col) AS dupe_cnt FROM TABLE GROUP BY col HAVING COUNT(dupe_col) > 1 ORDER BY COUNT(dupe_col) DESC
SELECT name FROM `product` WHERE BINARY `name` like 'product%'
select a.* from activities a JOIN (select distinct type FROM activities where type='X' or flag=1) t ON a.type=t.type; select a.* from activities a where type='X' or EXISTS(SELECT * FROM activities WHERE type=a.type AND flag=1); select a.* from activities a where type='X' or type IN (SELECT type FROM activities WHERE flag=1)
coalesce((select 'exists' from veryyugetable vyt where vyt.somenumber = someOtherTable.someNumber and rownum = 1), 'doesn''t exist') somecolumn
SELECT SUM(AMOUNT) SUM_AMOUNT FROM <table> WHERE VoucherDt >= DATEADD(MONTH, DATEDIFF(MONTH, 0, CURRENT_TIMESTAMP), 0) AND VoucherDt < DATEADD(DAY, DATEDIFF(DAY, 0, CURRENT_TIMESTAMP), 1)
$this->getField('id')->calculated(true); function calculate_id(){ return 'id_material'; }
SELECT REPLACE(REPLACE(REPLACE(col, CHAR(10), ' '), CHAR(13), ' '), CHAR(9), ' ') AS Col FROM Table
select * from ( select row_number() over ( partition by p_id order by year desc, month desc) as rn , * from YourTable ) as SubQueryAlias where rn = 1
CREATE TABLE ResultSet (Directory varchar(200)) INSERT INTO ResultSet EXEC master.dbo.xp_subdirs 'c:\' Select * FROM ResultSet where Directory = 'testing'
DECLARE @LastName NVARCHAR(50) = 'John' DECLARE @FirstName NVARCHAR(50) = NULL; DECLARE @ID INT = 1; UPDATE dbo.UpdateExample SET LastName = COALESCE(@LastName, LastName), FirstName = COALESCE(@FirstName, FirstName), WHERE ID = @ID
UPDATE STOCKA a JOIN STOCKB b ON a.P = b.P SET a.U = a.U - ABS(b.U)
select REGEXP_SUBSTR(' EG SUZ SG SIN blabla ', '([A-Z]{2} [A-Z]{3}(\s|$))', 1, 2) from dual;
DECLARE @Location … DECLARE @SQL varchar(max) If (@InputVariable = 1) BEGIN @Location = '[DatabaseA].dbo.MyTable' END ELSE BEGIN @Location = '[DatabaseB].dbo.MyTable' END BEGIN SET @SQL = 'UPDATE '+@Location+ ' WHERE … ' END EXECUTE (@SQL)
insert into dbo.calculationtable (ID, Server, Datetime, UptimeStatus) Select ID, SERVER, CheckTime, ResultType From dbo.sample Where CheckTime > (Select max(DateTime) From dbo.calculationtable) GO
SELECT * FROM child WHERE id NOT IN (SELECT child_id FROM par1) AND id NOT IN (SELECT child_id FROM par2)
select key, max(decode(id_col,1,id_col)) as id_1,max(decode(id_col,1,val)) as val_1, max(decode(id_col,2,id_col)) as id_2,max(decode(id_col,2,val)) as val_2, max(decode(id_col,3,id_col)) as id_3,max(decode(id_col,3,val)) as val_3 from ( select key, row_number() over (partition by key order by id) as id_col,id,val from your_table ) group by key
SELECT start, start + game_duration * INTERVAL '1 SECONDS' AS finish_time FROM "GAME_PLAYED" WHERE id = 123;
select i.[INV ITEM Ext ID], i.[INV ITEM Description], sum(d.[ar orderd qty]) as 'Total Units Sold', sum(case when d.[ar orderd date] >= '2013-09-16' and d.[ar orderd date] < '2013-09-23' then d.[ar orderd qty] else 0 end) as 'total Units sold 9/16-9/22', sum(case when d.[ar orderd date] >= '2013-09-23' and d.[ar orderd date] < '2013-09-30' then d.[ar orderd qty] else 0 end) as 'total Units sold 9/23-9/29' from [inv items] i inner join [ar order detail] d on d.[ar orderd item id] = i.[INV ITEM Ext ID] inner join [ar order] o on o.[AR ORDER Document #] = d.[AR ORDERD Document #] where o.[AR ORDER Document #] not like '%Ret%' and d.[ar orderd date] > '9/16/2013' and d.[AR ORDERD Qty] >= '0' group by i.[INV ITEM Ext ID], i.[INV ITEM Description] order by i.[INV ITEM Ext ID];
select city_name from city order by (case when city_name=upper(city_name) then 2 else 1 end), city_name;
Update table_name set col1='some_value' output inserted.*
SELECT Age,COUNT(user_id) AS "Number of Users" FROM ( SELECT userid, YEAR(CURDATE()) - YEAR(STR_TO_DATE(birth_date, '%m/%d/%Y')) - (RIGHT(CURDATE(), 5) < RIGHT(STR_TO_DATE(birth_date, '%m/%d/%Y'), 5)) AS Age FROM user ) as Z GROUP BY Age
INSERT INTO Movies (Title, Director, Cost, Profits) SELECT 'Star Wars', name, 50000, 1000000 FROM Directors WHERE name = 'Lucas'
SELECT acc.* FROM accounts acc JOIN addresses addr ON acc.id = addr.account_id JOIN alternate_ids ids ON acc.id = ids.account_id WHERE LOWER(acc.firstname) = LOWER('Sam') AND LOWER(addr.name) = LOWER('Street1') AND ids.alternate_id_glbl = '5';
Cursor c = ourDbase.query(MyTABLE, columns , null, null, null, null, KEY_SCORE + " DESC");
select distinct on (transponder, country, system) * from some_table order by transponder, country, system, time desc
SELECT show_table.program, show_table.timebegin FROM show_table INNER JOIN ( SELECT program, MIN(timebegin) AS firsttime FROM show_table GROUP BY program ) AS groups ON (show_table.program = groups.program) ORDER BY groups.firsttime, show_table.program, show_table.timebegin;
SELECT Doc, code, Sum(Qty), ConcatRelated("[Next]","TableName",,,"-") as [Next] FROM TableName GROUP BY Doc, code
select COUNT(EmailID) as Count_Mails, CAST(Createddate as DATE) GROUP BY cast(createdDate as date)
create view v_table as select t.*, (startdate <= curdate() then 1 else 0 end) as has_started from table t;
SQL> VARIABLE return_code NUMBER SQL> BEGIN 2 :return_code := 5; 3 END; 4 / PL/SQL procedure successfully completed. SQL> EXIT :return_code Disconnected from Oracle Database 10g Release 10.2.0.4.0 - Production > echo $? 5
with Permissions as (select Id from Surge.Permission where Name in ('Web.Orders:Enable', 'App.Orders:Enable', 'Web.Orders:View', 'App.Orders:View', 'Web.Orders:Modify', 'App.Orders:Modify', 'Web.Orders:View.All', 'App.Orders:View.All' ) ) INSERT INTO Surge.[RolePermission] (DataPartitionId, PermissionId, RoleId) SELECT DP.Id, p.Id, 2 FROM Surge.DataPartition as DP CROSS JOIN Permissions p
select max(case when `rn` = 2 then `value` end) as `Id`, max(case when `rn` = 1 then `value` end) as `Name`, max(case when `rn` = 3 then `value` end) as `Price` from ( select *, @rn:=if(@rn>2,1,@rn+1) rn, @row:=if(@rn=1,@row+1,@row) `row` from `yourmesseduptable` cross join (select @rn:=0, @row:=0) t ) t group by `row`
DELETE tableA FROM tableA LEFT JOIN tableB B ON A.id = B.a_id WHERE B.a_id IS NULL;
<dataSource driver="net.sourceforge.jtds.jdbc.Driver" url="jdbc:jtds:sqlserver://server/database;useLOBs=false" user="user" password="password" />
SELECT (YEAR(CURDATE())-YEAR(birth)) AS age FROM TABLE_NAME;
UPDATE t JOIN ( SELECT MAX(t.id) AS maxid, lat, lon FROM t JOIN t AS duplicates USING (lat, lon) GROUP BY lat, lon HAVING COUNT(*) > 1 ) AS maxima USING (lat, lon) SET flag = IF(id = maxid, 1, 2);
SELECT * FROM MyTable ORDER BY inet(IP_Address)
SELECT label, MAX(eventdate) AS maxeventdate FROM ( SELECT parentid, eventdate FROM TABLE1 UNION ALL SELECT parentid, eventdate FROM TABLE2) JOIN PARENT ON (id = parentid) GROUP BY label
SELECT to_char(trunc(request_date),'YYYY-MM-DD HH24:MI:SS') date_time
foreach (var myrow in (from x in that_table select x)) { var myChartObject = new ChartObject(); // populate myChartObject fields from myrow // add myChartObject to the actual chart }
select parent_id from your_table group by parent_id having count(distinct child_gender) = 2
SELECT TO_CHAR(dt,'Mon') FROM tb ORDER BY dt
declare @fromDate date = null declare @toDate date = null select * from Mytable where date between coalesce(@fromDate,date) and coalesce(@toDate,date)
with cte as ( select customer_name, min( id ) as id from #table1 group by customer_name having count(*) > 1 ) update #table1 set oldID = cte.id from cte where #table1.customer_name = cte.customer_name and #table1.id != cte.id
SELECT user_id, max(timestamp) FROM `log` GROUP BY user_id ORDER BY max(timestamp) desc;
DELETE FT, ST FROM first_table AS FT JOIN second_table AS ST ON FT.status = ST.status AND ST.final_result = '3'
where phone = replicate(left(phone,1), len(phone)) and phone is not null
select op.Productid , sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate then 1 else 0 end) FirstQty , sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 then 1 else 0 end) SecondQty, , Round(Sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate then op.Price*op.Quantity else 0 end),0) as FirstProductRevenue , Round(Sum( case when Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 then op.Price*op.Quantity else 0 end),0) as SecondProductRevenue from Orderdetails od inner join (select Distinct Orderid,productid,Price,Quantity from Orderproducts) op on op.Orderid=od.Orderid inner JOIN City ct ON od.RecipientCityName = ct.CityName INNER JOIN Associates ass ON Ct.AssociateId = ass.AssociateId Inner join HomepageRowWiseProducts hr on op.ProductId=hr.Productid where ( Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate and @EndDate Or Convert(datetime,Convert(Varchar(50),od.DeliveryDate,101)) between @StartDate1 and @EndDate1 ) and (od.TransactionId IS NOT NULL or ltrim(od.TransactionId) != '') and @Rowname=hr.HomepageRow_name and hr.status=1 Group by op.Productid
;WITH cte(name, Startdate,Enddate) AS ( SELECT name, Startdate,Enddate FROM your_table UNION ALL SELECT name, DATEADD(dd, 1,Startdate),Enddate FROM CTE WHERE Startdate < Enddate ) SELECT * FROM cte ORDER BY name
mysql> create table t (a int not null unique) engine=innodb; Query OK, 0 rows affected (0.05 sec) mysql> insert into t (a) values (0) on duplicate key update a=1; Query OK, 1 row affected (0.00 sec) mysql> select row_count(); +-------------+ | row_count() | +-------------+ | 1 | +-------------+ 1 row in set (0.00 sec) mysql> insert into t (a) values (0) on duplicate key update a=1; Query OK, 2 rows affected (0.00 sec) mysql> select row_count(); +-------------+ | row_count() | +-------------+ | 2 | +-------------+ 1 row in set (0.00 sec)
SELECT Table1.*, something1Table.setting AS something1, something2Table.setting AS something2, something3Table.setting AS something3 FROM Table1 JOIN Table2 AS something1Table ON something1Table.table_1_id = Table1.id AND something1Table.value = 'something' JOIN Table2 AS something2Table ON something2Table.table_1_id = Table1.id AND something2Table.value = 'something2' JOIN Table2 AS something3Table ON something3Table.table_1_id = Table1.id AND something3Table.value = 'something3'
public IQueryable<Timeline> GetHighlights() { var self = from x in Database.Timelines where User.Id == x.UserId || User.Id == x.SenderId select x; var friends = from x in Database.FriendItems.Include("Friend.Timeline") where (User.Id == x.UserId) select x.Friend.Timeline; List<Timeline> highlights = new List<Timeline>(); highlights.AddRange(self); friends.ForEach(x => x.ForEach(y => highlights.Add(y))); return highlights.AsQueryable().OrderByDescending(s => s.Id); }
select * from Table where ReportNumber in (select max(ReportNumber) from Table)
Declare @t table(Groups int,Color varchar(50),ColorDesc varchar(50)) insert into @t select 1 ,'Red', 'The cool name of Red Color' union all select 1,'Green', 'The cool name of Green Color' union all select 2,'Blue', 'The cool name of Blue Color' union all select 2,'Yellow', 'The cool name of Yellow Color' union all select 2,'Purple', 'The cool name of Purple Color' union all select 3,'Pink', 'The cool name of Pink Color' ;with cte as ( select groups,count(*) cnt from @t group by groups ) select distinct b.groups,case when cnt=1 then a.ColorDesc else stuff((select ',' + color from @t c where c.groups=b.Groups for xml path('') ),1,1,'') end from cte b inner join @t a on a.Groups=b.Groups Without distinct(Test both with lot of data) Select * from (select ROW_NUMBER() over(partition by b.groups order by b.groups) rn, b.groups,case when cnt=1 then a.ColorDesc else stuff((select ',' + color from @t c where c.groups=b.Groups for xml path('') ),1,1,'') end colorDesc from cte b inner join @t a on a.Groups=b.Groups )t4 where rn=1
select @rownum:=@rownum+1 'rank', r1.* FROM (SELECT pgid, picfile from pages, (SELECT @rownum:=0) AS r2 where pos= 23 order by Rand() limit 5 ) AS r1 ORDER BY rank
UPDATE A SET A.sequene = B.sequence FROM tableA A INNER JOIN (SELECT text, ROW_NUMBER() OVER (ORDER BY text) sequence FROM tableA ) AS B ON A.text = B.text
DECLARE @searchParam Datatype BEGIN SET @searchParam ='Value to be searched' IF EXISTS (SELECT * FROM [TABLENAME] WHERE [SEARCHPARAM]=@searchParam) SELECT * FROM [TABLENAME] WHERE [SEARCHPARAM]=@searchParam ELSE SELECT * FROM [TABLENAME] END GO
UPDATE tbl2 t INNER JOIN tbl1 s ON(t.transaction_id = s.id) set t.transaction_id = s.id_trans
select cast(collect(b.column_value) as vector) from table(table_of_vector( vector(23, 4, 2222, 22222222), vector(2, 1, 766, 2), vector(2, 1, 5))) a, table(a.column_value) b;
create table SOxx1 ( col1 char(4), col2 char(20) not null ) create table SOxx2 ( col1 char(4), col2 char(20) not null ) Go insert into SOxx1 (col1, col2) VALUES ('ARR ', 'abc') insert into SOxx2 (col1, col2) VALUES ('ARR ', 'abc') go SELECT (ISNULL(a.col1,'') + ISNULL(b.col1,'')) AS WhatEver FROM SOxx1 a left join SOxx2 b on a.Col2 = b.Col2 -- OUTPUT is 'ARR ARR '
select count(*) as counts from myTable where datediff(yyyy,dob,admitdate) between 5 and 10
SELECT * FROM sampletable s1 INNER JOIN (SELECT count(type) AS iCount,type FROM sampletable GROUP BY type) s2 ON s2.type = s1.type ORDER BY s2.iCount DESC, s1.type ASC
select Lastname,count(CASE item WHEN '' THEN NULL ELSE item END) item from info group by Lastname;
SELECT a.title, a.lat, a.lon, a.alert_content_id, a.date_added, count(r.alert_id) as countRep ,count(i.alert_id) AS countInt FROM `alerts` a LEFT JOIN `reply` r ON r.alert_id = a.alerts LEFT JOIN `interactions` i ON i.alert_id = a.alerts GROUP BY a.title, a.lat, a.lon, a.alert_content_id, a.date_added
UPDATE reports_attributes Set ConID='78', CheckServices='Execute Summary', Attribute1='criminality', Attribute2='color1', Attribute3='education', Attribute4='color5', Attribute5='employment_check_2', Attribute6='color7', Attribute7='report_status', Attribute8='color9' WHERE ConID=78 AND ReportType='interim_report'
DECLARE @MyTableVar table( NewScrapReasonID smallint, Name varchar(50), ModifiedDate datetime); INSERT Production.ScrapReason (Name, ModifiedDate) OUTPUT INSERTED.ScrapReasonID, INSERTED.Name, INSERTED.ModifiedDate INTO @MyTableVar VALUES (N'Operator error', GETDATE());
UPDATE tableA a INNER JOIN ( SELECT ID, MAX(Value) max_val FROM tableB WHERE SUB_GROUP IN ('Category 2','Category 3') GROUP BY ID ) b ON a.ID = b.ID SET a.VALUE = b.Max_Val
select string_agg(nm,'+') from( select st.name as nm from building-step bs inner join step st on bs.step_id=st.id where bs.construction_id=1 order by bs ASC ); --done by hand, may have small errors
START TRANSACTION; INSERT INTO player (facebook_id, first_name, last_name, gold_balance) VALUES ('$userid', '$userfirst_name', '$userlast_name', “100”) INSERT INTO BALANCE (facebook_id, first_name, last_name, gold_balance) VALUES ('$userid', '$userfirst_name', '$userlast_name', “100”)" commit;
ALTER TABLE PerformanceData ADD CreatedBy VARCHAR(50) NULL UPDATE PerformanceData SET CreatedBy = 'NA' ALTER TABLE PerformanceData ALTER COLUMN CreatedBy VARCHAR(50) NOT NULL
# Read in the data my @data; while (<>) { chomp; push @data, [ split(/\t/, $_, -1) ]; } # Sort it @data = sort { $a->[0] cmp $b->[0] # By name || $a->[1] <=> $b->[1] # By quantity } @data; # Generate the ids and output the data. my %counts; for my $row (@data) { my $id = join('.', $row->[0], ++$counts{ $row->[0] }); push @$row, $id; print(join("\t", @$row), "\n"); }
select t21.name, t22.name from Table1 t1 inner join Table2 t21 on t1.id_1 = t21.id inner join Table2 t22 on t1.id_2 = t22.id
INSERT INTO clients_products (client_id, product_id) SELECT c.ID, p.ID FROM Clients c CROSS JOIN Products p LEFT JOIN clients_products cp on c.client_id and p.product_id WHERE cp.client_id is null and p.product_id is null
SELECT Location, Size, Quantity FROM ( SELECT Location, 'Small' as Size, Small as Quantity FROM [table] ), ( SELECT Location, 'Medium' as Size, Medium as Quantity FROM [table] ), ( SELECT Location, 'Large' as Size, Large as Quantity FROM [table] )
** ** REPLACE VALUES IN CPANEL.PW_STAT WITHOUT REBUILDING THE ENTIRE TABLE. *; data cpanel.pw_stat; set redirect_updates; modify cpanel.pw_stat key=primary; select(_iorc_); when(%sysrc(_sok)) do; * MATCHED TRANSACTION DATASET TO MASTER DATASET. REPLACE THE VALUE; if date_redirected ne tmp_date_redirected then do; date_redirected = tmp_date_redirected; replace; end; end; when(%sysrc(_dsenom)) do; * NO MATCH. DO NOT ADD OBS OR REPLACE OBS OR DELETE OBS. RESET ERR AND DO NOTHING.; _error_ = 0; end; otherwise do; put 'ERROR: Unexpected value for _IORC_= ' _iorc_; put 'Program terminating. DATA step iteration # ' _n_; put _all_; stop; end; end; run;
select sdo_geom.sdo_distance (a.spatial_data, b.spatial_data, 0.05, 'unit=km') from st_country_postal_code a, st_country_postal_code b where a.country_id = '124' and a.postal_code = UPPER ('V3G1M2') and b.country_id = '124' and b.postal_code = UPPER ('V2R0N3');
cri.Add(Restrictions.Like( Projections.SqlFunction("concat", NHibernateUtil.String, Projections.Constant(","), Projections.Property("ServiceCodes"), Projections.Constant(",")), "%,33,%"));
CASE WHEN status = 'N' THEN 'Export to WMS' ELSE ' ' END AS "Export to WMS"
SELECT case when UserName=lag(UserName) OVER (ORDER BY UserName) then null else UserName end UserName, UserEmail, BoardName FROM YourTable;
WITH TransactionCounts as ( SELECT CustID, COUNT(*) AS TransactionCount FROM [dbo].[TRANSACTION] GROUP BY CustID ) SELECT TOP 1 CUSTOMER.*, TransactionCount FROM TransactionCounts INNER JOIN CUSTOMER ON CUSTOMER.CustID = TransactionCounts.CustId ORDER BY TransactionCount DESC -- alternate to select all if multiple customers are tied for highest count --WHERE TransactionCount = (SELECT MAX(TransactionCount) FROM TransactionCounts)
SELECT *, GROUP_CONCAT( grade_id ) AS gradeid FROM employee_details_table t1 LEFT JOIN department_table t2 USING ( dept_no ) LEFT JOIN relation_table t3 USING ( emp_no ) LEFT JOIN grade_table t4 USING ( grade_id ) WHERE grade_id IN ('1','2','3') GROUP BY t1.emp_no HAVING COUNT(DISTINCT grade_id) = 3;
<?php $first_loop = 0; ?> @foreach($links as $link) @if($first_loop == 0) <?php $first_loop = 1; $current_year = $link->year; ?> <h3 class="text-uppercase"><a href="{{ url('blog/'.$link->year) }}">{{ $link->year }}</a></h3> <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p> @else @if($current_year == $link->year) <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p> <?php $current_year = $link->year; ?> @else <h3 class="text-uppercase"><a href="{{ url('blog/'.$link->year) }}">{{ $link->year }}</a></h3> <p><small class="blog_date"><a href="{{ url('blog/'.$link->year.'/'.$link->month) }}">{{ $link->month_name }} ({{ $link->id }}) </a></small></p> <?php $current_year = $link->year; ?> @endif @endif @endforeach
SELECT @SearchFilter.value('(/KeywordSearch/SelfEmployed/text())[1]', 'varchar(100)')
SELECT SUBSTRING([description],CHARINDEX('BuildNumber:',[description])+12, CHARINDEX(']',[description], CHARINDEX('BuildNumber:',[description])) -(CHARINDEX('BuildNumber:',[description])+12)) FROM YOURTABLE
SQL> alter session set nls_timestamp_format = 'YYYY-MM-DD HH24:MI:SSXFF'; Session altered. SQL> with t as ( 2 select 'Podlaski Oddział Straży Granicznej 3 Informacja dobowa o zdarzeniach na terenie województwa podlaskiego 4 w dniu 15.04.2013 r.' 5 as original_string 6 from dual) 7 select to_timestamp(regexp_substr(original_string, '\d\d\.\d\d\.\d\d\d\d'), 'DD.MM.YYYY') as the_timestamp 8 from t; THE_TIMESTAMP --------------------------------------------------------------------------- 2013-04-15 00:00:00,000000000 1 row selected.
UPDATE MyTable SET [Result]= ISNULL([Result],'') + '<Cat>' WHERE ID IN (3,4); UPDATE MyTable SET [Result]= ISNULL([Result],'') + '<Dog>' WHERE ID IN (4,5);
DELETE FROM WRITTEN_BY WHERE Pub_ID IN ( SELECT Pub_ID FROM PUBLICATION WHERE Pub_Title = 'Introduciton to Database system' ) INSERT INTO WRITTEN_BY SELECT Re_Id,Pub_Id FROM RESEARCHER CROSS JOIN PUBLICATION WHERE Re_Name = 'Henry Gordon' OR Re_Name = 'Sarah Paker' AND Pub_Title like 'Introduciton to Database system' SELECT * FROM WRITTEN_BY
SELECT userId, SUM(case when TYPE='fine' then amount else 0 end) as totalFine, SUM(amount) AS totalDeposite FROM trx GROUP BY userId
SELECT c.value FROM tblhosting a INNER JOIN tblcustomfields b ON b.relid = a.packageid INNER JOIN tblcustomfieldsvalues c ON c.fieldid = b.id WHERE a.id = '$id' AND a.userid = '$userid' AND b.fieldname = 'foo'
SELECT * FROM Table1 ORDER BY Id LIMIT 4,1 -- here you provide which row you want to retrieve -- 4 indicates from which row start selecting (offset) -- 1 - how many rows you want to retrieve -- you can change It as you like
SELECT * FROM ( select *, ROW_NUMBER() over ( partition by projectId order by classType) as seq FROM ( Select projectID, classType, sum(Amount) as Total, sum(case when Classyear = 2014 then Amount else 0 end) as CurrentYear, sum(case when ClassYear <2014 then Amount else 0 end) as PriorYear, sum( case when ClassYear > 2014 then Amount else 0 end) as PostYear from myTable group by ProjectID, classType ) T Where (T.Total >0 and classType <> 'C') or classType ='C' ) C where seq =1
SELECT sum(case when Frequency = 'Monthly' then Amount else 0 end) + sum(case when Frequency = '4 Weekly' then Amount / 2 else 0 end) + sum(case when Frequency = 'Fortnightly' then Amount / 3 else 0 end) + sum(case when Frequency = 'Weekly' then Amount,0.0) / 5 else 0 end) FROM Table WHERE Id = 1;
SELECT ft.FileNo, pt.Amount, 'True' IsPayment FROM FileTable ft JOIN PaymentTable pt ON pt.FK_FileID = ft.FileId UNION ALL SELECT ft.FileNo, et.Amount, 'False' IsPayment FROM FileTable ft JOIN ExpenseTable et ON et.FK_FileID = ft.FileId
select AH_NAME1 COLLATE DATABASE_DEFAULT from GGIMAIN.SYSADM.BW_AUFTR_KOPF union select AH_NAME1 COLLATE DATABASE_DEFAULT from GGI2014.SYSADM.BW_AUFTR_KOPF
Update Backup set ImageURL =replace(ImageURL,'/s/','/I/')
select attname, format_type(atttypid, atttypmod) from pg_type join pg_class on pg_class.oid = pg_type.typrelid join pg_attribute on pg_attribute.attrelid = pg_class.oid where typname = 'mytype' order by attnum
"SELECT id FROM MUSIC WHERE id IN ($files)"
SELECT MONTH(DateColumn) AS MonthNumber, COUNT(1) AS Occurances FROM schema.TableName GROUP BY MONTH(DateColumn)
CREATE PROCEDURE OntoNewVersion @new_title NVARCHAR(100) AS BEGIN BEGIN TRY BEGIN TRANSACTION T1 DECLARE @versid INT INSERT INTO Versions (title) VALUES (@new_title) SET @versid = SCOPE_IDENTITY() INSERT INTO Questions (qtext,subsection_id,version_id,viewtype) SELECT qtext, subsection_id,@versid,viewtype FROM Questions COMMIT TRANSACTION T1 END TRY BEGIN CATCH IF(@@TRANCOUNT>0) BEGIN ROLLBACK TRANSACTION T1 END ;THROW END CATCH END
select a.id, a.name, ga.earned_epoch, ga.offline from achievement a LEFT OUTER JOIN gamer_achievement ga ON a.id = ga.achievement_id AND a.game_id = ga.game_id AND ga.gamer_id = 'fba8fcaa-f57b-44c6-9431-4ab78605b024' where a.game_id = '1480656849' order by convert (a.id, unsigned)
select top 1 userid, count(certificatename) total from certificates group by userid -- but not certificatename order by 2 desc --you can use total or count(certificatname) here
$ db2 connect to sample Database Connection Information Database server = DB2/LINUX 9.1.9 SQL authorization ID = IDBJORH Local database alias = SAMPLE $ db2 values current server 1 ------------------ SAMPLE 1 record(s) selected.
select m, pid, s from (select r.m, r.pid, sum(s) as s, row_number() over (partition by m order by sum(s) desc) as seqnum from report r group by r.m, r.pid ) r where seqnum <= 3 order by m, s desc;
SELECT b.[CUSIP NUMBER], b.[ORIGINAL BALANCE], b.[ORIGINAL WA MATURITY], b. [PASS THRU RATE], Monthlypayment, Monthlypayment2 FROM DBO.mbs012013 a JOIN dbo.mbs022013 b ON a.[CUSIP NUMBER] = b.[CUSIP NUMBER] CROSS APPLY (SELECT b.[ORIGINAL BALANCE] * ( ( b.[PASS THRU RATE] / 12 ) * ( 1 + power (( b.[PASS THRU RATE] / 12 ), b.[ORIGINAL WA MATURITY]) ) / ( 1 + ( power (( b.[PASS THRU RATE] / 12 ), b.[ORIGINAL WA MATURITY]) ) ) )) CA(Monthlypayment) CROSS APPLY(SELECT 1 + Monthlypayment) CA2(Monthlypayment2)
SELECT * FROM SetA LEFT INNER JOIN SetB ON 1 = 1 -- Voila, instant cross join
update test_table set column1=123 where column2 IN(100,200,300)
SELECT * FROM (SELECT ParentID, Caption, Name FROM #table) AS t PIVOT ( MAX(t.Name) FOR Caption IN ([Plan], [Content], [Accuracy]) ) AS pvt
CREATE TABLE dbo.foo (ID int IDENTITY(1,1) PRIMARY KEY, Other1 int, Other2 char(10) DEFAULT 'abcdefghij', Other3 varchar(52) DEFAULT 'abcdefghijklmnopqrstuvwxyz'); GO INSERT dbo.foo (Other1) VALUES (1); GO INSERT dbo.foo (Other1) SELECT Other1 FROM dbo.foo; GO 20 SELECT COUNT(*) FROM dbo.foo; GO -- now enable viewing of execution plans SELECT * FROM dbo.foo WHERE id = 456789 -- Table 'foo'. Scan count 0, logical reads 3, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. GO -- double up rows INSERT dbo.foo (Other1) SELECT Other1 FROM dbo.foo; GO SELECT * FROM dbo.foo WHERE id = 456789 -- Table 'foo'. Scan count 0, logical reads 3, physical reads 0, read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob read-ahead reads 0. GO
SELECT a.Column1 AS 'Col1', a.Column2 AS 'Col2', null AS 'Col3', a.Column4 AS 'Col4' FROM TableA AS a UNION ALL SELECT b.Column1 AS 'Col1', b.Column2 AS 'Col2', b.Column3 AS 'Col3', null AS 'Col4' FROM TableB AS b
UPDATE MyTable SET Col1 = CASE WHEN b.Foo = "Bar" THEN LOWER(b.Baz) ELSE "" END, Col2 = ISNULL(c.Bling, 0) * 100 / Col3 FROM MyTable INNER JOIN MySecondTable AS b ON b.Id = MyTable.SecondId LEFT JOIN ##MyTempTable AS c ON c.Id = b.ThirdId WHERE MyTabe.Col3 > 0 AND b.Foo NOT IS NULL AND MyTable.TheDate > GETDATE() - 10
select uc.id as creator, uu.id as updater, uo.id as owner, a.[name] from asset a JOIN user uc ON uc.user_pk = a.created_by JOIN user uu ON uu.user_pk = a.updated_by JOIN user uo ON uo.user_pk = a.owned_by
CREATE VIEW friends AS SELECT actor, director, film, num_together FROM( SELECT a.aid AS actor, b.aid AS director, a.fid AS film, COUNT(*) OVER (PARTITION BY a.aid, b.aid) AS num_together FROM involved_in a INNER JOIN involved_in b ON a.fid = b.fid WHERE a.job IN ('actor', 'actress') AND b.job = 'director' ) foo WHERE num_together < 'x' -- placeholder for your "limit the rows that appear with count less than x"
WITH AdjustedAdjustments AS ( select PersonID, Date, SubtractAmount/ EXP( SUM(LOG(COALESCE(DivideAmount,1))) OVER ( PARTITION BY PersonID ORDER BY Date ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING ) ) AS AdjustedSubtract, DivideAmount FROM TblAdj ) SELECT p.PersonID, p.Value/COALESCE(EXP(SUM(LOG(COALESCE(DivideAmount,1)))),1) -COALESCE(SUM(a.AdjustedSubtract),0) AS AmountAdjusted FROM TblVal AS p LEFT OUTER JOIN AdjustedAdjustments AS a ON a.PersonID = p.PersonID AND a.Date >= p.Date GROUP BY p.PersonID, p.Value, p.Date;
SELECT id, title FROM ts_Gallary WHERE (title LIKE '%%%@%%' OR location LIKE '%%%@%%' OR tags LIKE '%%%@%%') AND imageExistStatus = 1;
SELECT bc.id, bc.title, bc.estimateCurrent, SUM(TIME_TO_SEC(TIMEDIFF(dateEnding, dateBeginning))) FROM cases bc JOIN timesheet ts on ts.`#case` = bc.id GROUP BY bc.id, bc.title, bc.estimateCurrent
Sub FilterByParameter() Dim wb As Workbook Dim dataSheet As Worksheet Dim parameterSheet As Worksheet Dim rng As Range Dim filterColumn As Long Dim filterValue As String Set wb = ThisWorkbook ' sheet that contains your table Set dataSheet = wb.Sheets("Sheet1") ' sheet that contains your parameters Set parameterSheet = wb.Sheets("Sheet2") ' range that contains your table, hard-coded here ' but can easily be set dynamically Set rng = dataSheet.Range("A1:F78") ' get the column you are searching filterColumn = parameterSheet.Range("G1").Value ' get the value you want to filter on filterValue = parameterSheet.Range("G2").Value ' turn off autofilters if set dataSheet.AutoFilterMode = False ' autofilter using your column and filter rng.AutoFilter field:=filterColumn, Criteria1:=filterValue ' now you can do whatever you want to with the rows ' that remain after the autofilter was applied End Sub
SELECT film.film_id, film.title, rental.return_date FROM film INNER JOIN inventory ON inventory.film_id = film.film_id INNER JOIN rental ON rental.inventory_id = inventory.inventory_id WHERE rental.return_date BETWEEN '2005-05-29' AND '2005-05-30' ORDER BY rental.return_date
UPDATE assoc SET cachedData = NULL WHERE EXISTS (SELECT * FROM otherTable WHERE otherTable.Col1 = assoc.Col1 AND otherTable.Col2 = assoc.Col1)
with t as (select Emp_num, substr(date_key,1,4) as year, avg(salary) over (partition by Emp_num order by Date_key rows unbounded preceding) as avg_sal, avg(bonus) over (partition by Emp_num order by Date_key rows unbounded preceding) as avg_bon, row_number() over (partition by Emp_num, substr(date_key,1,4) order by Date_key desc) as R from Table1) select EMP_NUM, YEAR, AVG_SAL, AVG_BON from t where R = 1; EMP_NUM YEAR AVG_SAL AVG_BON ------------------------------------------- 54343 2010 498 50 54343 2011 553.5 62.5 54343 2012 598.2 70
WHERE coalesce(MainTable.RowVersion,'00000000-0000-0000-0000-000000000000') <> coalesce(CloneOfMainTable.RowVersion,'00000000-0000-0000-0000-000000000000')
UPDATE Table_a a SET qty = qty + b.rn FROM ( SELECT id,ROW_NUMBER() OVER (ORDER BY id) rn FROM Table_a ) b WHERE a.id = b.id
SELECT itemcode, count(itemcode) 'times purchased', sum(quantity) 'amount purchased' FROM `temp_trans` WHERE `trans_date` >= '2012-01-08' AND `trans_date` <= '2012-03-23' GROUP BY itemcode
var subquery = QueryOver.Of<WorkItem>().Where(w => w.State == state) .AndRestrictionOn(w => w.Type).IsLike(type, MatchMode.Exact) .SelectList(list => list.SelectGroup(w => w.UserId)) .OrderBy(Projections.Count<WorkItem>(x => x.UserId)) .Desc().Take(1); var query = CurrentSession.QueryOver<WorkItem>() .WithSubquery .WhereProperty(p => p.UserId) .Eq(subquery);
DECLARE @test DATETIME SET @test = GETDATE() -- or any other date SELECT DATEADD(month, ((YEAR(@test) - 1900) * 12) + MONTH(@test), -1)
Declare @Week Int = 1 While @Week <= 52 Begin select count(distinct user_id) as count from tracking where datepart(wk,login_dt_tm) >= 0 and datepart(wk,login_dt_tm) <= @Week Set @Week += 1 End
SELECT InWarehouse.expiry_date, t1.active_substance, drugs.strength, drugs.strength_type, drugs.dosage_form, drugs.minimum_quantity, InWarehouse.quantity + InPharmacy.quantity, InPharmacy.expiry_date FROM (SELECT InWarehouse.expiry_date, drugs.active_substance, drugs.strength, drugs.strength_type, drugs.dosage_form, drugs.minimum_quantity, NZ(SUM(InWarehouse.quantity),0) AS quant FROM drugs LEFT JOIN (SELECT drug_id, expiry_date, SUM(in_quant - out_quant) AS quantity FROM warehouse GROUP BY drug_id, expiry_date) AS InWarehouse ON InWarehouse.drug_id = drugs.id GROUP BY InWarehouse.expiry_date, drugs.active_substance, drugs.strength, drugs.strength_type, drugs.dosage_form, drugs.minimum_quantity ) t1 JOIN ( SELECT InPharmacy.expiry_date, drugs.active_substance, drugs.strength, drugs.strength_type, drugs.dosage_form, drugs.minimum_quantity, NZ(SUM(InPharmacy.quantity), 0) as quant FROM (drugs LEFT JOIN (SELECT drug_id, expiry_date, SUM(in_quant - out_quant) as quantity FROM pharmacy GROUP BY drug_id, expiry_date) as InPharmacy ON InPharmacy.drug_id = drugs.id) GROUP BY InPharmacy.expiry_date, drugs.active_substance, drugs.strength, drugs.strength_type, drugs.dosage_form, drugs.minimum_quantity ) t2 ON t1.active_substance = t2.active_substance
CREATE TABLE Anonymous ( ID_Column SERIAL NOT NULL PRIMARY KEY, field1 BOOLEAN NOT NULL, field2 BOOLEAN NOT NULL, field3 BOOLEAN NOT NULL, field4 BOOLEAN NOT NULL, field5 CHAR(50), CHECK((field4 = 't' AND field5 IS NOT NULL) OR (field4 = 'f' AND field5 IS NULL)) );
SELECT start_dsgn, COUNT(CASE WHEN min_cost_1 <= @cost_1 OR min_cost_2 <= @cost_2 THEN end_dsng END) as Cnt FROM table GROUP BY start_dsgn
DECLARE @id INT DECLARE id_cursor CURSOR FOR SELECT id from mytable where color = 'red' OPEN id_cursor FETCH NEXT FROM id_cursor INTO @id WHILE @@FETCH_STATUS = 0 BEGIN PRINT @id FETCH NEXT FROM id_cursor INTO @id END CLOSE id_cursor; DEALLOCATE id_cursor;
--Generic example: SELECT * FROM MY_TABLE WHERE SOME_FIELD IS NULL; --Instead of SELECT * FROM MY_TABLE WHERE SOME_FIELD = NULL;
update tblToUpdate set columnToUpdate = '0000-0000-0000-' + right(columnToUpdate , 4)
SELECT NAME, LISTAGG(STRUCTURE_CODE||'.'||AGE_LIMIT , ',') WITHIN GROUP (ORDER BY STRUCTURE_CODE) AS AGE_LIMIT , LISTAGG(STRUCTURE_CODE||'.'||BIRTHPLACE_LIMIT , ',') WITHIN GROUP (ORDER BY STRUCTURE_CODE) AS BIRTHPLACE_LIMIT FROM "TABLE" GROUP BY NAME
SELECT message_type, COUNT(message_type) AS message_type_count, SUM(Unread = 1) AS unread_count FROM Messages GROUP BY message_type
EXECUTE IMMEDIATE 'DELETE FROM dept WHERE deptno = :num' USING dept_id;
SELECT o.NAME, o.STATE, o.ITEM, case when i.RATE is NULL then ( select rate from item_desc where item = o.item and coalesce(state,'') ='' ) else i.RATE end as RATE FROM ORDERS o LEFT JOIN ITEM_DESC i ON o.ITEM = i.ITEM AND o.STATE = i.STATE
declare @d1 varchar(10) = CAST(DATEADD(dd,-1,CAST(GETDATE() as Date)) as varchar(10)) declare @d2 varchar(10) = CAST(DATEADD(dd,-2,CAST(GETDATE() as Date)) as varchar(10)) declare @d3 varchar(10) = CAST(DATEADD(dd,-3,CAST(GETDATE() as Date)) as varchar(10)) declare @d4 varchar(10) = CAST(DATEADD(dd,-4,CAST(GETDATE() as Date)) as varchar(10)) declare @d5 varchar(10) = CAST(DATEADD(dd,-5,CAST(GETDATE() as Date)) as varchar(10)) declare @d6 varchar(10) = CAST(DATEADD(dd,-6,CAST(GETDATE() as Date)) as varchar(10)) declare @d7 varchar(10) = CAST(DATEADD(dd,-7,CAST(GETDATE() as Date)) as varchar(10)) declare @SQL varchar(8000) SET @SQL = 'Select * From ( Select unpvt.[Table] ,unpvt.value ,unpvt.Date From ORIGINAL_TABLE unpivot ( value for [Table] in (Table_1 ,Table_2 ,Table_3 ,... ,Table_35 ) ) unpvt Where Date > cast(dateadd(dd,-8,getdate()) as date) ) ref pivot (sum(ref.value) for ref.Date in ( [' + @d1 + '] ,[' + @d2 + '] ,[' + @d3 + '] ,[' + @d4 + '] ,[' + @d5 + '] ,[' + @d6 + '] ,[' + @d7 + '] ) ) as pvt' EXEC(@SQL)
namespace MyApplication { public class myWebService : System.Web.Services.WebService { private classEmployee _emp = new classEmployee(); [HttpGet] public string GetEmployees() { string EmployeeData = string.Empty; EmployeeData = _emp.GetEmployees(); return EmployeeData; } } }
UPDATE Table1 t1 JOIN ( SELECT id, @n := @n + 1 rnum FROM Table1 CROSS JOIN (SELECT @n := 0) i WHERE date IS NULL ORDER BY id ) t2 ON t1.id = t2.id CROSS JOIN ( SELECT MAX(date) date FROM Table1 ) q SET t1.date = q.date + INTERVAL t2.rnum DAY
SELECT id,name,LENGTH(TRIM(name)) AS namelength FROM table1 GROUP BY id,name HAVING LENGTH(TRIM(name)) > 3
>sqlcmd -i C:\panels_QA28July11.sql -o C:\PanelsImportResult.txt
select t.* from (select t.*, row_number() over (partition by name, course order by lastupdate desc) as seqnum from t ) t where seqnum = 1;
CREATE OR REPLACE FUNCTION to_char(timestamptz) RETURNS text AS $$ SELECT to_char($1,'YYYY/MM/DD~HH24:Mi:SS'); -- here your default setting $$ LANGUAGE SQL;
declare @tab table( code int, amount int) insert into @tab values (1,100), (1,100), (1,100), (2,500), (2,500), (3,1000); select code, case when rn=1 then amount else 0 end amount from (select *, row_number()Over(partition by code Order by amount) RN from @tab)t
INSERT INTO final_table (a,b) SELECT a, b FROM scratch_table EXCEPT SELECT a, b FROM final_table
DATEADD(DD, DATEDIFF(DD, 0, STARTTIME), 0) BETWEEN DATEADD(DD, DATEDIFF(DD, 0, <DATE_TIME_PARAMETER>), 0) AND DATEADD(DD, DATEDIFF(DD, 0, <DATE_TIME_PARAMETER>), 0)
select grp, ind, val from ( select grp, ind, val, lag(val,1,0::numeric) over (partition by grp order by ind) - val as diff from test_table ) t where diff <> 0;
SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(t.keywords, ',', n.n), ',', -1) value , count(*) as counts FROM table1 t CROSS JOIN ( SELECT a.N + b.N * 10 + 1 n FROM (SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) a ,(SELECT 0 AS N UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5 UNION ALL SELECT 6 UNION ALL SELECT 7 UNION ALL SELECT 8 UNION ALL SELECT 9) b ORDER BY n ) n WHERE n.n <= 1 + (LENGTH(t.keywords) - LENGTH(REPLACE(t.keywords, ',', ''))) group by value
DECLARE @start DATETIME DECLARE @end DATETIME SET @start = DATEADD(dd, 0, DATEDIFF(dd, 0, GETUTCDATE())) SET @end = DATEADD(dd, 1, DATEADD(ms, -3, @start))
SELECT [ID], Country, MIN(Address), SUM(Price) As TotalPrice FROM tblYourTableName GROUP BY [ID], Country ORDER BY [ID]
insert into Customers( Cust_id, Date, Rate, Type) select Cust_id, Date, -- TODO:Generate required Date from given one Rate, -- TODO:Generate required Rate from given one Type -- TODO:Generate required Type from given one from Customers where Type = 'm'
select t1.*, t2.*, ((case when t1.id = t2.id then 1 else 0 end) + (case when t1.foo = t2.foo then 1 else 0 end) + (case when t1.bar = t2.bar then 1 else 0 end) + . . . ) as NumMatches from table t1 join table t2 on t1.id = t2.id or t1.foo = t2.foo or t1.bar = t2.bar or . . . order by NumMatches desc;
INSERT INTO mytable (id, name) VALUES (NULL, :name1), (NULL, :name2)
insert into tbl_users select x.y.value('(account_id)[1]', 'nvarchar(150)') as account_id ,x.y.value('(account_name)[1]', 'nvarchar(350)') as account_name ,x.y.value('(account_name_abbr)[1]', 'nvarchar(150)') as account_name_abbr ,x.y.value('(location/id)[1]', 'int') as location_id ,x.y.value('(cpu)[1]', 'int') as cpu_amount ,x.y.value('(ram)[1]', 'int') as ram_amount ,x.y.value('(disk)[1]', 'int') as disk_amount from @xml.nodes('//install/client/vlans') as x(y) declare @tbl_users_id int = scope_identity() insert tbl_users_vlans([user_id],[vlan]) select @tbl_users_id, x.y.value('data(.)', 'nvarchar(150)') from @xml.nodes('//install/client/vlans/item') as x(y)
SELECT country_code , COUNT(emission_class) AS total , SUM(CASE WHEN emission_class = 'E0' THEN 1 ELSE 0 END) AS EURO0 , SUM(CASE WHEN emission_class = 'E?' THEN 1 ELSE 0 END) AS EURO? , ... FROM DB.CUSTOMER_VEHICLE GROUP BY country_code;
select MyColumn from MyTable order by case IsNumeric(MyColumn) when 1 then Replicate('0', 100 - Len(MyColumn)) + MyColumn else MyColumn end
SELECT T.ID, T.SEQ, MAX(T.AMOUNT) AMOUNT, D.DS FROM tbl T CROSS APPLY ( SELECT [DESCRIPTION] + ' ' FROM tbl B WHERE T.ID = B.ID AND T.SEQ = B.SEQ AND [DESCRIPTION] IS NOT NULL FOR XML PATH('') ) D(DS) GROUP BY ID, SEQ, DS
SELECT LEFT(`delivery_postcode`, 2) as `postcode` , count(`delivery_postcode`) as `count` , pc.placeCount FROM `customer_cards` cc LEFT JOIN ( SELECT LEFT(`placePostcode`, 2) as `postcode`, count(`placePostcode`) as `placeCount` FROM `RestaurantsForGoogleMaps` WHERE `placePostcode` IS NOT NULL AND `placePostcode` <> '' GROUP BY `postcode` ) pc on pc.postcode = LEFT(cc.delivery_postcode, 2) WHERE `delivery_postcode` IS NOT NULL AND `delivery_postcode` <> '' GROUP BY `postcode` ORDER BY `count` DESC
UPDATE yourTable SET yourTextColumn = CONCAT(yourTextColumn, '<br/>signature blabla<br/>') WHERE catid IN (778, 779, 780);
select @max := max( RandomId ) from Products; update Products set RandomId = @max := @max + Rand() + 1;
SELECT t1.name AS name, t1.car AS car, t1.price AS max_price FROM table1 t1 ORDER BY max_price DESC LIMIT 1;
select max(total.id) as id, sum(total.product_qty) as product_qty, total.location_id as location_id, total.date as "date", total.year as year, total.month as month, total.day as day, total.product_id as product_id from ( -- From Consumer back to location select -max(id) as id, -sum(product_qty) as product_qty, location_dest_id as location_id, "date", year, month, day, product_id from report_stock_move where location_id in ( select id from stock_location where "name" = 'Consumers' ) and "state" = 'done' group by location_dest_id, "date", year, month, day, product_id union all -- From Location to Consumer select max(id) as id, sum(product_qty) as product_qty, location_id, "date", year, month, day, product_id from report_stock_move where location_id not in ( select id from stock_location where "name" = 'Consumers' ) and "state" = 'done' and location_dest_id in ( select id from stock_location where "name" = 'Consumers' ) group by location_id, "date", year, month, day, product_id ) as total group by location_id, "date", year, month, day, product_id
using System.Data.Objects; EntityFunctions.AsNonUnicode( myUnicodeParam)
WITH RECURSIVE tree(product_id, name, parentlist) AS ( SELECT product_id, name, ARRAY[ row_number() OVER (ORDER BY product_id) ] FROM tree_products WHERE parent_id IS NULL UNION SELECT tp.product_id, tp.name, array_append(parentlist, row_number() OVER (ORDER BY tp.product_id)) FROM tree_products tp INNER JOIN tree t ON (tp.parent_id = t.product_id) ) SELECT * FROM tree ORDER BY parentlist;
DECLARE @str VARCHAR(MAX)='team_name:Brighton|stadium:American Express Community Stadium|max_attendance:30750'; SELECT LEN(@str)-LEN(REPLACE(@str,'|','')) + 1;
SELECT t.line, MIN(t.START), MAX(t.END), t.typ, t.color FROM dbo.tablename t GROUP BY t.line, t.typ, t.color
delete from tbl_test t where t.sta in ('F', 'R') and exists ( select 1 from tbl_test b where b.ser_no = t.ser_no and (sta='L' or (sta<>'L' and b.id<t.id)) )
C+ = C C+ = CD (by using the third dependency) C+ = CDB (by using the fourth dependency)
select * from [My_Table] t where [Order] > 0 and ([Date] between '20150201' and '20150228') and not exists ( select * from [My_Table] where [Order] > 0 and [User] = t.[User] and [Date] between '20150301' and '20150331')
update item set quantity = (select sum(value) from quantities where item.id = quantities.item_id);
select sid from your_table group by sid where (cid=2 and data='john_email') or (cid=4 and data='ok') having sum(cid=2)=1 and sum(data='john_email')=1 and sum(cid=4)=1 and sum(data='ok')=1
declare @UNIX_TIME int select @UNIX_TIME = 1111111111 -- Using dateadd to add seconds to 1970-01-01 select [Datetime from UNIX Time] = dateadd(ss,@UNIX_TIME,'1970-01-01')
SELECT x.* FROM things x JOIN ( SELECT brand , model , MAX(effective_from) max_effective_from FROM things WHERE effective_from <= UNIX_TIMESTAMP() GROUP BY brand , model ) y ON y.brand = x.brand AND y.model = x.model AND y.max_effective_from = x.effective_from; +------+-------+-------+----------------+-------+ | id | brand | model | effective_from | price | +------+-------+-------+----------------+-------+ | 1 | a | red | 1402351200 | 100 | | 2 | b | red | 1402351200 | 110 | | 3 | a | green | 1402391200 | 120 | | 7 | b | green | 1402358200 | 135 | +------+-------+-------+----------------+-------+ SELECT UNIX_TIMESTAMP(); +------------------+ | UNIX_TIMESTAMP() | +------------------+ | 1402404432 | +------------------+
declare @tmp table(driverid nvarchar(10),createddate datetime) --insert a sample record first insert into @tmp select '7x123','2015-6-20' declare @incomingvalue nvarchar(10) = '7x123'; declare @now datetime = getdate(); declare @threshold datetime = @now - 90; if exists(select * from @tmp where driverid = @incomingvalue and createddate >= @threshold) begin print 'Already a record on file within 90 days, no action taken'; end else begin insert into @tmp select @incomingvalue, @now print 'Nothing on file in last 90 days, record inserted'; end select * from @tmp
select * from MDSYS.SDO_COORD_REF_SYS sample(1);
SELECT t.id, t.title FROM task AS t LEFT JOIN activity AS a ON t.id=a.task_id GROUP BY t.id ORDER BY COALESCE(MAX(a.createdat), t.createdat) DESC
SELECT Row_Number() Over (order by (select null)) ID, COALESCE(t1.Name,t2.Name) Name, COALESCE(t1.Value,0) T1Value, COALESCE(t2.Value,0) T2Value FROM databasename.schemaname.table1 t1 FULL OUTER JOIN databasename.schemaname.table2 t2 ON t1.Name = t2.Name
$dbh = new PDO('mysql:host=localhost;dbname=mydatabase', $user, $pass, array( PDO::ATTR_PERSISTENT => true ));
SELECT a.id, a.sku FROM product AS a INNER JOIN product_stock AS b ON a.id = b.product_id WHERE b.in_stock = 1 AND a.type = 'X' and exists ( SELECT 'EXISTS' FROM product d INNER JOIN product_relation AS c ON c.child_id = d.product_id WHERE c.product_id = a.product_id AND (d.quantity > 0 or d.in_stock = true) )
UPDATE tableName SET ImagePath = REPLACE(ImagePath, '/project/images/', '/projects/project-a/images')
SELECT a.US, a.decade, b.total FROM (SELECT COUNT(A.Award) AS US, SUBSTRING(CAST(M.Year as char(4)), 0 , 4) AS Decade FROM Movies M, Awards A WHERE {SOME WHERE CLAUSE} GROUP BY Decade ) AS a INNER JOIN (SELECT COUNT(*) AS Total, SUBSTRING(CAST(A2.Year as char(4)), 0 , 4) AS Decade FROM Awards A2 WHERE {SOME WHERE CLAUSE} GROUP BY Decade) AS b ON a.decade = b.decade
UPDATE test2 t2 SET t2.name = (SELECT t1.name FROM test1 t1 WHERE t1.id = t2.mob)
select * from orders o left join orderdata od on o.orderId=od.orderid
select distinct cr1.movie from credits as cr1 join credits as cr2 using (movie) where cr1.person = {person 1 goes here} and cr2.person = {person 2 goes here}
SELECT t1.* FROM PlanActual AS t1 INNER JOIN ( SELECT MIN(Seq) AS minSeq, Phase FROM PlanActual GROUP BY Phase ) AS t2 ON t1.Phase = t2.Phase ORDER BY t2.minSeq
create table YOUR_TABLE(ID integer, DT datetime); insert into YOUR_TABLE select 2, '02/02/2016 12:00:00' union all select 3, '02/05/2016 12:00:00' union all select 4, '02/06/2016 12:00:00' union all select 5, '02/07/2016 12:00:00' ; select ID, DT, datediff(day, DT, lead(DT) over (order by ID)) as DIFF from your_table;
select * from myTable where CHARINDEX(cast(mycol as varchar), @myVar) > 0
UPDATE goals_scored SET goalRank = ( SELECT count(*) FROM goals_scored AS i WHERE i.numGoalsScored > goals_scored.numGoalsScored AND i.gender = goals_scored.gender ) + 1;
update detail_box set name = decode(sn, 2, 'Gita', 3, 'Krish', name), date1 = (case when sn = 2 and date2 is null then to_date('2015-10-16', 'YYYY-MM-DD') else date1 end), date2 = (case when sn = 3 and date2 is null then to_date('2015-10-16', 'YYYY-MM-DD') else date2 end)
Private Sub cboProject_Change() cboPlans.RowSource = "SELECT * FROM tblPlans WHERE ProjectID = " & cboProject.Value cboPlans.Requery End Sub
WITH tokenkeys as ( select regexp_substr('A set of words from other side','[^ ]+', 1, level) WORDSPLIT from dual connect by regexp_substr('A set of words from other side', '[^ ]+', 1, level) is not null ) select distinct p.* from people p join tokenkeys on p.name in (tokenkeys.wordsplit) or UTL_MATCH.EDIT_DISTANCE_SIMILARITY(p.lastname, tokenkeys.wordsplit) > 60
select s.id as id, s.msts as msts, s.action as action from ( select min(named_struct('msts', msts, 'id', id, 'action', action)) as s from A group by id ) t;
SELECT S.*, Su.* FROM Student AS S INNER JOIN Student_Subject AS SS ON S.StudentID = SS.StudentID INNER JOIN Subject AS Su ON SS.OfferCode = Su.OfferCode
declare @directorId int select @directorId = DirectorID from dbo.tblDirector where DirectorName='Steven Spielberg'
select t1.date, case when t3.IDCLIENT is not NULL then t3.value else t2.value end as Value from Table1 t1 inner join Table2 t2 on t1.IDCLIENT = t2.IDCLIENT inner join Table3 t3 on t1.IDCLIENT = t3.IDCLIENT
CREATE OR REPLACE PROCEDURE ReverseOf(input IN varchar2) IS reverse varchar2(50); BEGIN FOR i in reverse 1..length(input) LOOP reverse := reverse||''||substr(input, i, 1); END LOOP; dbms_output.put_line(reverse); END;
Select user.id, all_time.total AS theCount, last_month.total AS theCount2 From users AS user Left Outer Join (Select Count(id) as total, invited_by_id From users Group By invited_by_id) as all_time On all_time.invited_by_id = user.id Left Outer Join (Select Count(id) as total, invited_by_id From users Where signup_date >= NOW() - INTERVAL 30 DAY Group By invited_by_id) AS last_month On last_month.invited_by_id = user.id
select * from demo a where not exists( select 1 from demo b where a.demo_id!=b.demo_id AND A.S < B.E AND B.S < A.E)
select a.FORM_JOURNAL_ID, a.COMPANY_ID, a.RETAIL_PRICE as RETAIL, a.WHOLE_SALE_PRICE as WHOLESALE, nvl(b.INDIVIDUALS,0) as INDIVIDUALS, nvl(b.ENTITIES,0) as ENTITIES, nvl(b.COMPLEX,0) as COMPLEX from TableA a, TableB b where a.FORM_JOURNAL_ID = b.FORM_JOURNAL_ID (+) and a.COMPANY_ID = b.COMPANY_ID (+) union select b.FORM_JOURNAL_ID, b.COMPANY_ID, nvl(a.RETAIL_PRICE,0) as RETAIL, nvl(a.WHOLE_SALE_PRICE,0) as WHOLESALE, b.INDIVIDUALS, b.ENTITIES, b.COMPLEX from TableA a, TableB b where b.FORM_JOURNAL_ID = a.FORM_JOURNAL_ID (+) and b.COMPANY_ID = a.COMPANY_ID (+);
select post_id, min(topic_id) from YourTable group by post_id
AND textfield1 LIKE '* value3 *'
order by (case when t1.ordering > t2.number then 1 else 2 end), t1.ordering
#define kDatabaseName (@"levelProgress.db") - (void)checkAndCopyDatabaseIfNeeded { if (!self.databasePath) { // Database should be present in user sandbox at root. self.databasePath = [NSString pathWithComponents:[NSArray arrayWithObjects:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject], kDatabaseName, nil]]; } // Check if the file already copied/exists. NSFileManager *fileManager = [NSFileManager defaultManager]; BOOL success = [fileManager fileExistsAtPath:self.databasePath]; if(!success) { // Copy the file from app bundle to user sandbox (Files in app bundle can not be edited). NSString *databasePathFromApp = [[[NSBundle mainBundle] resourcePath] stringByAppendingPathComponent:kDatabaseName]; #if DEBUG BOOL isCopied = #endif [fileManager copyItemAtPath:databasePathFromApp toPath:self.databasePath error:nil]; NSAssert(isCopied, @"Problem copying database file to user document folder"); } }
SELECT COUNT(DISTINCT PoliticianId) AS result FROM Votes WHERE UserId = 1010 ;
select st.name [Table], sc.name [Column], sep.value [Description] from sys.tables st inner join sys.columns sc on st.object_id = sc.object_id left join sys.extended_properties sep on st.object_id = sep.major_id and sc.column_id = sep.minor_id and sep.name = 'MS_Description' where st.name = @TableName and sc.name = @ColumnName
select start_date, stop_date_original from dates where start_date is not null and stop_date_original is not null and start_date > str_to_date('10/10/2009','%d/%m/%Y') and stop_date_original < str_to_date('24/01/2013','%d/%m/%Y')
SELECT widget, max(CASE WHEN rn = 1 THEN a_name ELSE NULL END) a_name1, max(CASE WHEN rn = 1 THEN a_value ELSE NULL END) a_value1, max(CASE WHEN rn = 2 THEN a_name ELSE NULL END) a_name2, max(CASE WHEN rn = 2 THEN a_value ELSE NULL END) a_value2, max(CASE WHEN rn = 3 THEN a_name ELSE NULL END) a_name3, max(CASE WHEN rn = 3 THEN a_value ELSE NULL END) a_value3, max(CASE WHEN rn = 4 THEN a_name ELSE NULL END) a_name4, max(CASE WHEN rn = 4 THEN a_value ELSE NULL END) a_value4 FROM( SELECT widget, a_name, a_value, row_number() over (partition by widget order by a_name, a_value) rn FROM attrs ) GROUP BY widget
Select Case Cells(1, 1).Text ' cell A1 contains Y or N Case "Y": sWhereClause = " where Med_D = 'Y'" Case "N": sWhereClause = " where Med_D in ('Y','N')" Case Else: MsgBox "error": Exit Sub End Select Debug.Print SQL & sWhereClause ' send this to Access
UPDATE c SET c.Price = c.Quantity * a.Rate FROM TableC c INNER JOIN TableB b ON c.ProductID = b.ProductID INNER JOIN TableA a ON b.StoreID = a.StoreID WHERE c.Price = 0
var query = from table1 in data.Table1s join table2 in data.Table2s on table1.ID equals table2.ID into x select new { table1.Shirt, Pants = x.Sum(c=>c.Pants) + table1.Pants, table1.Shoes };
SELECT s.SR_Service_RecID , sc.Config_RecID FROM SR_Service s LEFT JOIN SR_Config sc ON sc.SR_Service_RecID = s.SR_Service_RecID AND sc.Config_RecID = ( SELECT TOP 1 Config_RecID FROM SR_Config sc2 WHERE sc2.SR_Service_RecID = s.SR_Service_RecID )
select s = sum(len(firstname) + len(lastname) + len(emailaddress) + len(coalesce(LEFT(CategoryNames,LEN(CategoryNames) - 1),''))) , r.ClientID from Customer r cross apply (Select cc.description + '|' FROM Category cc join CustomerCategory c on c.categoryid = cc.categoryid WHERE r.customerid = c.customerid For XML PATH('')) x (CategoryNames) group by r.ClientID order by 1 desc
WHERE YEAR(A.[reimbursementDate]) = YEAR(GETDATE())
SELECT * FROM ( select ACCESSION_PAYMENTS_DAILY_KEY, accession_id, check_num, procedure_code, paid_amt, row_number() over (partition by accession_id, check_num,procedure_code,paid_amt order by ACCESSION_PAYMENTS_DAILY_KEY) as occurrence from [MILLENNIUM_DW_DEV].[dbo].[F_PAYOR_PAYMENTS_DAILY] where PROCEDURE_CODE is not null and PAID_AMT>0 ) x WHERE x.occurrence>1
SELECT [orderId], MAX([datetime]) FROM [table] GROUP BY [orderId] ORDER BY MAX([datetime]) DESC
select key, max(ts) from yourTable group by key
$sql = "SELECT DATE_FORMAT(NOW(), '%%Y') - DATE_FORMAT(DOB, '%%Y') - (DATE_FORMAT(NOW(), '00-%%m-%%d') < DATE_FORMAT(DOB, '00-%%m-%%d')) AS age from test where user_name = '%s'";
SELECT a.* FROM ( select s.*, sum(volume) OVER previous_rows as total from stuff s WINDOW previous_rows as (ORDER BY priority desc ROWS between UNBOUNDED PRECEDING and CURRENT ROW) order by priority desc ) AS a where a.total < 1000
UPDATE visits SET logout_datetime = NOW() WHERE member_id = 1 AND visit_message = "accept"
select ID, Word from ( select ID, Word, row_number() over(partition by left(Word, 1) order by Word) as rn from YourTable ) as T where rn = 1
WITH inventory_time_in_freezer AS ( SELECT i1.inv_id, SUM(i1.out_time - i1.in_time) as time_in_freezer FROM inventory_tack i1 WHERE out_time IS NOT NULL GROUP BY i1.inv_id ) SELECT i2.inv_id, MAX(i2.in_time) - MIN(i2.in_time) - iif.time_in_freezer FROM inventory_tack i2 JOIN inventory_time_in_freezer iif ON iif.inv_id = i2.inv_id GROUP BY i2.inv_id, iif.time_in_freezer
SELECT users.id, roles.id, CASE WHEN usersroles.roles_id IS NULL THEN 0 ELSE 1 END AS has_the_role FROM users INNER JOIN roles LEFT JOIN usersroles ON users.id = usersroles.users_id AND roles.id = usersroles.roles_id
select col2name, sum(col3 + col5) from (select COL1, COL2 as COL2NAME, sum(COL3A+COL3B) as COL3, COL4 as COL4NAME, count(COL5NO) as COL5, DENSE_RANK() OVER (ORDER BY COL1) as GROUPID from TAB group by COL1, COL2, COL4 ) t where GROUPID IN (1, 2) group by col2name;
SELECT username from user_logins WHERE username=? AND password_md5 = md5(?)
SELECT w.adharno, w.phone w_phone, descrip_w, amount_w, a.phone a_phone, decrip_a, amount_a FROM table_w w JOIN table_a a ON a.adharno = w.adharno AND w.descrip_w = a.decrip_a AND (w.phone <> a.phone OR w.amount_w <> a.amount_a)
CREATE TABLE userColors ( userID INT, color VARCHAR(16), FOREIGN KEY (userID) REFERENCES users(user_id) );
select survey.worker_id, (Select Value from Code where ID = survey.code_number_of_days_id) as No_of_Days, (Select Value from Code where ID = survey.code_gender) as Gender, Info.Name, (Select Value from Code where ID = Info.code_category_id) as Category, (Select Value from Code where ID = Info.code_confirmed_status_id) as Confirmed, from Survey full outer join Info on Survey.worker_id = Info.id
SELECT DISTINCT name FROM items WHERE something = 'foo' AND name < (SELECT name FROM items WHERE name = ...) ORDER BY name DESC LIMIT 1
select t.id, t.player_name, t.team from tablename t join (select team, min(id) as minid from tablename group by team) x on x.team = t.team and x.minid = t.id
select regexp_matches(page,'[^[[]+(?=\]])','g') from book
UPDATE repName SET repName.Entered = x FROM GenItems INNER JOIN repName ON GenItems.Job_Code = repName.Job_Code WHERE repName.repID = x AND GenItems.Item_Name = 'y'
SELECT * FROM information_schema.columns Where TABLE_SCHEMA='test';
CREATE OR REPLACE FUNCTION dblink(text, text) RETURNS SETOF record AS '$libdir/dblink', 'dblink_record' LANGUAGE 'c' VOLATILE STRICT COST 1 ROWS 1000; ALTER FUNCTION dblink(text, text) OWNER TO postgres; GRANT EXECUTE ON FUNCTION dblink(text, text) TO public; -- or whatever INSERT INTO tbl_B select * from (SELECT * from dblink('hostaddr=localhost port=5432 dbname=db_A user=postgres password=postgres', 'select id, a, b from tbl_A limit 20 ' ) t( id integer, a integer, b integer )) as q;
DROP TABLE IF EXISTS meetings; CREATE TABLE IF NOT EXISTS meetings ( meeting_id int(10) unsigned NOT NULL AUTO_INCREMENT , meeting_time datetime NOT NULL , PRIMARY KEY (meeting_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS meetings_users; CREATE TABLE IF NOT EXISTS meetings_users ( user_id int(10) unsigned NOT NULL , meeting_id int(10) unsigned NOT NULL , PRIMARY KEY (meeting_id,user_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; DROP TABLE IF EXISTS users; CREATE TABLE IF NOT EXISTS users ( user_id int(10) unsigned NOT NULL AUTO_INCREMENT , PRIMARY KEY (user_id) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; INSERT INTO users ( user_id ) VALUES (1),(2),(3),(4); INSERT INTO meetings ( meeting_id, meeting_time ) VALUES (1, '2013-01-14 10:00:00'), (2, '2013-01-15 10:00:00'), (3, '2013-01-16 10:00:00'), (4, '2013-01-17 10:00:00'), (5, '2013-01-18 10:00:00'), (6, '2013-01-19 10:00:00'), (7, '2013-01-20 10:00:00'), (8, '2013-01-14 12:00:00'); INSERT INTO meetings_users (meeting_id, user_id ) VALUES (1, 1), (2, 1), (2, 3), (3, 1), (3, 3), (4, 2), (4, 3), (5, 2), (6, 1), (1, 8); SET @dt = '2013-01-15'; SELECT user_id , start , DATEDIFF(@dt,start)+1 cons FROM ( SELECT a.user_id , a.meeting_date Start , MIN(c.meeting_date) End , DATEDIFF(MIN(c.meeting_date),a.meeting_date) + 1 diff FROM (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) a LEFT JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) b ON b.user_id = a.user_id AND a.meeting_date = b.meeting_date + INTERVAL 1 DAY LEFT JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) c ON c.user_id = a.user_id AND a.meeting_date <= c.meeting_date LEFT JOIN (SELECT DISTINCT mu.user_id,DATE(m.meeting_time) meeting_date FROM meetings_users mu JOIN meetings m ON m.meeting_id = mu.meeting_id) d ON d.user_id = a.user_id AND c.meeting_date = d.meeting_date - INTERVAL 1 DAY WHERE b.meeting_date IS NULL AND c.meeting_date IS NOT NULL AND d.meeting_date IS NULL GROUP BY a.user_id , a.meeting_date ) x WHERE @dt BETWEEN start AND end; +---------+------------+------+ | user_id | start | cons | +---------+------------+------+ | 1 | 2013-01-14 | 2 | | 3 | 2013-01-15 | 1 | +---------+------------+------+
select version from versions_table where to_date('<myInputDate>', 'dd.mm.yy') between to_date('from', 'mm.dd.yy') and to_date('to', 'mm.dd.yy');
select musicianID from musicians m left join gigs g on g.musicianId = m.musicianID where g.musicianId is null
SELECT [ID] , CASE WHEN MAX(CASE WHEN [Date] IS NULL THEN 1 ELSE 0 END) = 0 THEN MAX([Date]) END FROM YourTable GROUP BY [ID]
select purchases.customer_name, purchases.product_name, COUNT(purchases.product_name) from purchases where customer_name "Brian" and product_name like 'Al% GROUP BY purchases.product_name, purchases.customer_name;
UPDATE FROM EmployeeAS e LEFT JOIN Department as dept ON e.? = dept.? AND e.Name = 'Good Employee' SET e.Department = dept.AID
select NVL(MAX(A_COUNT),0) from MYTABLE where VEH_YEAR = '2003';
`foo bar` - is a valid MySQL identifier foo bar - is not, since foo is the identifier, and bar is ambiguous
update table1 set value1 = (select value3 from table2 where id=7) , value2 = (select value4 from table2 where id=7) where id=1
SELECT k.`id`, m.`MACHINE`, kd.`key` FROM KPIs as k, MACHINE as m, KPIDATA as kd WHERE k.`id` = SUBSTR(kd.`key`,LOCATE('.',kd.`key`)+1,3) AND m.`MACHINE` = SUBSTR(kd.`key`,LOCATE('.i.',kd.`key`)+3,3)
declare @month varchar(2) = '10', @year varchar(4) = '2015', @fullWeekCount int; declare @firstOfTheMonth datetime = @year + '-' + @month + '-1'; declare @daysInMonth int = datediff(day, @firstOfTheMonth, dateadd(month, 1, @firstOfTheMonth)) select @fullWeekCount = (@daysInMonth / 6) declare @i int = 1, @startDate datetime = @firstOfTheMonth, @endDate datetime; declare @dates table (StartDay datetime, EndDay datetime); while (@i <= @fullWeekCount) begin if (@i = @fullWeekCount) set @endDate = @year + '-' + @month + '-' + cast(@daysInMonth as varchar(2)); else set @endDate = dateadd(day, 6, @startDate) insert into @dates (StartDay, EndDay) values (@startDate, @endDate) set @startDate = dateadd(day, 1, @endDate) set @i = @i + 1; end select * from @dates d
new_val := REPLACE( REPLACE( string_val, ':F:', CHR(10)||'F:' ) , ':L:', CHR(10)||'L:' );
UPDATE your_table SET comment_author_url = '' WHERE comment_author_url = 'http://google.com'
list_replace.setOnItemClickListener(new OnItemClickListener() { @Override public void onItemClick(AdapterView<?> Parent,View v, int Position, long id) { ContentValues cvs = new ContentValues(); cvs.put(COLUMN_NAME_READING_MODE, ReadingMode); cvs.put(COLUMN_NAME_PASTDATETIME, StartDate); cvs.put("EndDateTime", CurrentDateTime); cvs.put(COLUMN_NAME_READINGVALUE,Reading); SQLiteDatabase db = context.openOrCreateDatabase(DATABASE_NAME, Context.MODE_PRIVATE, null); // add this line db.update(TABLE_NAME, cvs, "_Id =" + id, null); db.close(); } });
UPDATE Lending.ApplicationFee SET FeeTypeId = ( CASE WHEN t.NewValue IS NOT NULL THEN (SELECT LookupID FROM tblLookup WHERE LookupType = 'FEE_CODE' AND LookupDesc = t.NewValue) ELSE (SELECT LookupID FROM tblLookup WHERE LookupType = 'FEE_CODE' AND LookupCode = 'OTHER') END ) FROM TmpFeesToRules t INNER JOIN tblLookup l ON t.NewValue = l.LookupDesc
WITH prep AS ( SELECT Product + ' Unit' TYPE, Unit Value FROM utilities UNION ALL SELECT Product + ' BaseUnit' TYPE, BaseUnit Value FROM utilities ) SELECT [Gas Unit], [Gas BaseUnit] , [Oil Unit], [Oil BaseUnit] , [Water Unit], [Water BaseUnit] FROM (SELECT TYPE, Value FROM prep ) a PIVOT (MAX(Value) FOR TYPE IN ([Gas Unit], [Gas BaseUnit] , [Oil Unit], [Oil BaseUnit] , [Water Unit], [Water BaseUnit]) ) pvt
WHERE (trunc(sysdate) - trunc(\"DATE\"))<=365;
SQL> ed Wrote file afiedt.buf 1 declare 2 cursor cursor_table is 3 select t.* from kid k, table(k.toys) t where k.name = 'Bob'; 4 begin 5 for i in cursor_table loop 6 dbms_output.put_line(i.column_value); 7 end loop; 8* end; SQL> / truck ball doll PL/SQL procedure successfully completed.
SELECT KB.*, VN.VDescription FROM Knowledge_Base KB INNER JOIN ( select V.[Name] as VDescription, K.Description as KDescription FROM vendor, knowledge_base where knowledge_base.description like '%' + vendor.name + '%' ) VN ON KB.Description = VN.KDescription
select t.movieID, sum(t.qty) as totalQuantity from transaction t group by t.movieId order by sum(t.qty) desc limit 10
consumer = get_object_or_404(Consumer, pk=pk) option = get_object_or_404(Option, pk=option_pk) consumer.options.add(option)
EXECUTE('SELECT * FROM Region R WHERE R.RegionID IN (' + @regions + ')')
;WITH x AS ( SELECT id,bank_code,bank_name,interest_rate, rn = ROW_NUMBER() OVER (PARTITION BY bank_code ORDER BY interest_rate DESC) FROM dbo.[SAMPLE] ) SELECT id,bank_code,bank_name,interest_rate FROM x WHERE rn = 1 ORDER BY interest_rate DESC;
SELECT p.person_id, p.first_nm, p.last_nm, pu.purchase_dt, pr.sku, pr.description, COALESCE(ha.address_type_id, sa.address_type_id) AS address_type_id CASE WHEN ha.address_type_id IS NOT NULL THEN ha.city_cd ELSE sa.city_cd END AS city_cd, CASE WHEN ha.address_type_id IS NOT NULL THEN ha.state_cd ELSE sa.state_cd END AS state_cd, CASE WHEN ha.address_type_id IS NOT NULL THEN ha.postal_cd ELSE sa.postal_cd END AS postal_cd FROM person p LEFT JOIN address ha ON p.person_id = ha.person_id AND ha.address_type_id = 1 LEFT JOIN address sa ON p.person_id = sa.person_id AND sa.address_type_id = 2 INNER JOIN purchase pu ON pu.person_id = p.person_id INNER JOIN product pr ON pr.product_id = pu.product_id
SELECT p.case_number , p.full_address , s.case_owner_name 'case owner' , c.client_name client , r.compiled_date , r.recommendation FROM case_process p JOIN staff s ON s.case_owner_number = p.case_owner_number JOIN client c ON c.client_number = p.client_number JOIN reporting r ON r.case_number = p.case_number JOIN (SELECT case_number,MAX(compiled_date) max_compiled_date FROM reporting GROUP BY case_number) x ON x.case_number = r.case_number AND x.max_compiled_date = r.compiled_date; +-------------+---------------+------------+---------+---------------+----------------+ | case_number | full_address | case owner | client | compiled_date | recommendation | +-------------+---------------+------------+---------+---------------+----------------+ | 1000 | 1 high street | Bob | London | 2012-12-14 | let | | 1001 | 2 high street | Ken | Compton | 2013-12-13 | sell | | 1002 | 3 high street | Ken | Leeds | 2012-12-14 | sell | +-------------+---------------+------------+---------+---------------+----------------+ 3 rows in set (0.00 sec) fiddle of same... http://sqlfiddle.com/#!2/fff224/7
db.stack.aggregate([ {$project:{"treatments._id":1, "treatments.price":1}}, {$unwind:"$treatments"},{$match:{"treatments._id":2}}, {$sort:{"treatments.price":-1}}, {$limit:1} ]);
SELECT id, sumcnt, cnt2 FROM( SELECT id, count(*) as cnt2, sum(cnt) as sumcnt FROM ( SELECT id, kmstand, vacationame, count(*) as cnt FROM `db_1`.`table_new` WHERE (vacationame='vacation1' OR vacationame='vacation2' OR vacationame='vacation3' OR vacationame='vacation4') GROUP BY id, kmstand, vacationame)T GROUP BY id)T WHERE (sumcnt/cnt2 = 1)
DELETE FROM MyTable WHERE A NOT IN (SELECT MIN(A) FROM MyTable GROUP BY B, C, D );
SELECT i.item_id, i.item_name, i.idem_desc, p.quantity, p.price FROM items i LEFT JOIN item_properties p ON i.item_id = p.fk_item_id WHERE i.item_id = 191
select count(distinct lot_id,data_file_id) from data_cst where target_name_id=208082 and wafer_id=425845;
SELECT data.sPort FROM ((SELECT (s.server_port + 1) sPort FROM pro_servers s LEFT JOIN pro_servers sp1 ON sp1.server_port = s.server_port + 1 WHERE (sp1.server_port IS NULL) ORDER BY sPort) UNION ALL (SELECT s.server_port sPost FROM pro_servers s GROUP BY s.server_port HAVING COUNT(s.server_port) = SUM(s.server_deleted) ORDER BY sPort)) AS data ORDER BY data.sPort LIMIT 1
EXEC sp_updatestats
SELECT T2C1, T2C2, CASE WHEN T2C2 = (SELECT T1C2 FROM T1 WHERE (T1C1 = 'A') THEN '1' ELSE '0' END AS SELECTED FROM T2
select id from person p where exists ( select 1 from revenue r where p.id = r.personid and case when r.year1 > 0 then 1 else 0 end + case when r.year2 > 0 then 1 else 0 end + case when r.year3 > 0 then 1 else 0 end + case when r.year4 > 0 then 1 else 0 end + case when r.year5 > 0 then 1 else 0 end >= 2 )
SELECT team, SUM(DECODE(IsNew, 'N', 1, 0)), SUM(DECODE(IsNew, 'Y', 1, 0)) FROM mytable GROUP BY team
INSERT INTO categories (coname) SELECT DISTINCT coName FROM counties
SELECT * FROM Your_Table WHERE app_receipt_date > SYSDATE - (6 * 7);
Select I.Fee From Item I WHERE DATEDIFF(day, GETDATE(), I.DateCreated) < 365
column1 IN (status1, status2, status3, status4, status5) AND column2 IN (status1, status2, status3, status4, status5) AND column3 IN (status1, status2, status3, status4, status5) AND column4 IN (status1, status2, status3, status4, status5) AND column5 IN (status1, status2, status3, status4, status5) AND column6 IN (status1, status2, status3, status4, status5)
WITH Tree AS ( SELECT id, parent, 0 AS Level, id AS Root, hasRights AS HasRights, CAST(id AS VARCHAR(MAX)) AS Sort, user_id FROM SourceTable WHERE parent IS NULL UNION ALL SELECT st.id, st.parent, Level + st.hasRights AS Level, st.parent AS Root, st.hasRights AS HasRights, uh.sort + CASE st.hasRights WHEN 0 THEN '' ELSE '/' + CAST(st.id AS VARCHAR(20)) END AS Sort, st.user_id FROM SourceTable AS st JOIN Tree uh ON uh.id = st.parent ) SELECT * FROM Tree AS t JOIN UserTable AS ut ON ut.id = t.user_id AND ut.user_id = '141F-4BC6-8934' ORDER BY Sort
select START_TIME, STOP_TIME, max(stop_time) over (order by start_time) as MaxCumStopTime from t
SELECT SUM(columnA1) , SUM(columnA2) , ( SELECT SUM(columnB1) FROM tableB WHERE columnB3 = X AND columnB4 = Y AND columnB5 = Z ) as sum_columnB1 FROM tableA WHERE columnA3 = X AND columnA4 = Y AND columnA5 = Z ;
WITH CTE AS ( SELECT u.ContactName ,cu.[User ID] ,c.Name ,c.ID ,cu.[Foreign Table] ,count(*) OVER (PARTITION BY c.ID) AS user_in_this_country FROM dbo.Country AS c INNER JOIN dbo.CountryUser AS cu ON c.ID = cu.[Foreign ID] INNER JOIN dbo.UserColder AS u ON cu.[User ID] = u.ID WHERE EXISTS ( SELECT * FROM CountryUser AS cu2 WHERE cu2.[Foreign ID] = cu.[Foreign ID] AND cu2.[User ID] <> cu.[User ID] AND cu.[Foreign Table] = 'Country') ) SELECT * FROM CTE WHERE user_in_this_country > 1
UPDATE table1 SET table1.Price = table2.price FROM table1 INNER JOIN table2 ON table1.id = table2.id
SELECT a.eID, a.eValue, t.pID, t.pName, t.rID, t.rValue FROM tblAlert a LEFT JOIN ( SELECT p.pID, p.pName, p.eID, r.rID, r.rValue FROM tblPatient p INNER JOIN ( SELECT pID, MAX(rID) AS rID FROM tblPatientRecords GROUP BY pID ) pr ON p.pID = pr.pID INNER JOIN tblRecords r ON pr.rID = r.rID ) t ON a.eID = t.eID
SELECT table_name view_name, column_name, data_type FROM user_tab_columns WHERE table_name = <<name of view>> ORDER BY column_id
UPDATE attempts RIGHT JOIN ( SELECT id FROM attempts a1 WHERE NOT EXISTS ( SELECT 0 FROM attempts a2 WHERE a2.mapID = a1.mapID AND (a2.score > a1.score OR (a2.score = a1.score AND a2.date < a1.date)) ) ) tmp ON tmp.id = attempts.id SET attempts.isHighestScore = 1;
Database mydb = new EnterpriseLibrary.Data.Sql.SqlDatabase("connection string here");
;with cte (rn, id, inst_id, person_name, email) as ( select row_number() over (partition by inst_id order by id) rn, * from person ) update f set person1 = cte1.person_name, email1 = cte1.email, person2 = cte2.person_name, email2 = cte2.email from firm f left join cte cte1 on f.inst_id = cte1.inst_id and cte1.rn = 1 left join cte cte2 on f.inst_id = cte2.inst_id and cte2.rn = 2
Create Trigger trig_StopRecipFriendships for Insert, Update On Friendships As If Exists (Select * From Friendships F1 Join Friendships F2 On F1.UserA = F2.UserB And F1.UserB = F2.UserA) Begin Rollback Transaction Raiserror ('These Users are already friends', 16,1) End
DELETE P1 FROM @Prices P1 join ( SELECT DISTINCT ProductId FROM @Prices WHERE IsSpecialPrice = 1 ) P2 on P1.ProductId = P2.ProductId WHERE P1.IsSpecialPrice = 0
select dept, min(id) keep (dense_rank last order by days) from ( SELECT id , (sum((TO_DATE-FROM_DATE)+1) ) days , dept FROM emp_leave WHERE to_date between ADD_MONTHS(sysdate,-3) AND sysdate group by id,dept) group by dept ;
-- do insert SELECT SCOPE_IDENTITY();
SELECT 'Amount' AS MaxAmount, [Group1], [Group2], [Group3] FROM (SELECT descrip, Amount FROM Table) AS SourceTable PIVOT ( Max(Amount) FOR descrip IN ([Group1], [Group2], [Group3]) ) AS PivotTable;
DECLARE @SQL varchar(max) SET @SQL = 'select * from tableA INNER JOIN tableB on tableA.'+@Input1+' = table B.' @input2 EXEC (@SQL)
SELECT * FROM ( SELECT (trunc(SYSDATE)-2) start_dt -- May 11 -- , (trunc(SYSDATE)-2)-LEVEL bus_days -- All bus days before May 11 -- , to_char((trunc(SYSDATE)-2)-LEVEL, 'DY') wk_day FROM DUAL CONNECT BY LEVEL <= (trunc(SYSDATE)-2)-((trunc(SYSDATE)-2) - 7) -- May 11-7 days ago=May 4 ) WHERE wk_day NOT IN ('SAT', 'SUN') ORDER BY bus_days / START_DT BUS_DAYS WK_DAY -------------------------------- 5/11/2013 5/6/2013 MON 5/11/2013 5/7/2013 TUE 5/11/2013 5/8/2013 WED 5/11/2013 5/9/2013 THU 5/11/2013 5/10/2013 FRI
update table1 set flag =1 where rowid in ( select t1.rowid FROM table1 t1 INNER JOIN table2 t2 ON t1.emp_id = t2.emp_id INNER JOIN table3 t3 ON t2.company = t3.company WHERE t1.emp_id = '5632' AND l2.company = '83CP' AND t1.code = 'LIEU' )
CREATE TEMP TABLE tmp AS SELECT * FROM tbl LIMIT 0 -- copy layout, but no data COPY tmp FROM '/absolute/path/to/file' FORMAT csv; INSERT INTO tbl SELECT tmp.* FROM tmp LEFT JOIN tbl USING (tbl_id) WHERE tbl.tbl_id IS NULL; DROP TABLE tmp; -- else dropped at end of session automatically
db.execSQL("DROP TABLE IF EXISTS TABLENAME");
select docid, (case when sum(case when rn_ds <> rn_sd then 1 else 0 end) = 0 then 'Increasing' else 'Decreasing' end) as SequenceType from (select d.*, row_number() over (partition by docId order by date, state) as rn_ds, row_number() over (partition by docId order by state, date) as rn_sd from d ) d group by docid;
SELECT s.* FROM STUDENTS s INNER JOIN StudentMarks m ON s.STUDENTID = m.STUDENTID ; SELECT m.* FROM STUDENTS s INNER JOIN StudentMarks m ON s.STUDENTID = m.STUDENTID ;
select top 1 first.*, second.username, third.* from first inner join second on first.id = second.master_id inner join third on first.id = third.master_id order by third.date desc
select eventTime/5,count(*) from evalHubSupply group by eventTime/5
CREATE OR REPLACE TRIGGER XXX BEFORE INSERT --<< You need a BEFORE trigger for this to work. ON A FOR EACH ROW BEGIN :new.val := 'LOL'; END;
declare @tab table(branch varchar(3), day int, amount float) ; insert into @tab values ('001',4,300.00), ('001',10,200.12), ('001',30,343.22), ('002',12,423.00), ('005',2,453.21), ('005',12,111.21), ('005',27,321.99); with month_days as (select t.number,t1.branch from (select number from master..spt_values where type='P' and number between 1 and 30) t cross join (select distinct branch from @tab)t1) select md.branch,number as day,isnull(amount,0) amount from @tab t right join month_days md on t.day=md.number and t.branch=md.branch;
Select s.Branch, s.Date, s.containers, lag(s.Date) over (partition by branch order by date) as prev_Date, lag(s.containers) over (partition by branch order by date) as prev_Containers from shipping s;
SELECT CAST('the quick brown fox jumped over the lazy dog' AS VARCHAR(45))
echo "update contact set email_address='foo@bar.com';" | /path/to/isql --your-favorite-switches
where UserChiamante.UserId not in (select UtenteId from ChiamanteInterno)
select ID, First, Last, Date, Time from (select t.*, row_number() over (partition by id order by date, time) as seqnum from test t ) t where seqnum = 1;
CREATE PROC SearchAllTables ( @SearchStr nvarchar(100) ) AS BEGIN CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) SET NOCOUNT ON DECLARE @TableName nvarchar(256), @ColumnName nvarchar(128), @SearchStr2 nvarchar(110) SET @TableName = '' SET @SearchStr2 = QUOTENAME('%' + @SearchStr + '%','''') WHILE @TableName IS NOT NULL BEGIN SET @ColumnName = '' SET @TableName = ( SELECT MIN(QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME)) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE' AND QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) > @TableName AND OBJECTPROPERTY( OBJECT_ID( QUOTENAME(TABLE_SCHEMA) + '.' + QUOTENAME(TABLE_NAME) ), 'IsMSShipped' ) = 0 ) WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) BEGIN SET @ColumnName = ( SELECT MIN(QUOTENAME(COLUMN_NAME)) FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) AND TABLE_NAME = PARSENAME(@TableName, 1) AND DATA_TYPE IN ('char', 'varchar', 'nchar', 'nvarchar', 'int', 'decimal') AND QUOTENAME(COLUMN_NAME) > @ColumnName ) IF @ColumnName IS NOT NULL BEGIN INSERT INTO #Results EXEC ( 'SELECT ''' + @TableName + '.' + @ColumnName + ''', LEFT(' + @ColumnName + ', 3630) FROM ' + @TableName + ' (NOLOCK) ' + ' WHERE ' + @ColumnName + ' LIKE ' + @SearchStr2 ) END END END SELECT ColumnName, ColumnValue FROM #Results END
SELECT REPLACE(SUBSTRING(CreateDate,3,8),'/','') as registerdate, FROM TatEstelam.dbo.tblInquiryRealForeigners RL LEFT JOIN TatEstelam.dbo.CustomerInfo CINFO ON RL.IdentificationDocumentNumber = CINFO.NationalID WHERE-- NationalID <> '0001' IdentificationDocumentNumber <> '' AND REPLACE(SUBSTRING(CreateDate,3,8),'/','') BETWEEN '910404' AND '950505'
SELECT side1, side2, AVG(weight) FROM (SELECT LEAST(to, from) AS side1, GREATEST(to, from) AS side2, weight FROM my_table) GROUP BY side1, side2
SELECT TOP 1 ID_AdvancedRatePlan FROM ARDebitDetails WHERE ID_Hearing = 135878 AND ID_AdvancedRatePlan > 0 ORDER BY ID_ARDebitDetail DESC
CREATE NONCLUSTERED INDEX ix_name ON Members(RelatedMemberId) INCLUDE (MemberId)
SELECT w.resource, watermark value FROM ( SELECT PARSENAME(ResourceKey, 1) AS resource, Value as watermark FROM MyTable WHERE Value like '%.watermark' ) w JOIN ( SELECT PARSENAME(ResourceKey, 1) AS resource, Value as txt FROM MyTable WHERE Value like '%.text' ) t on t.resource = w.resource WHERE watermark = txt
select l.* from logs l where l.result = 'success-changed' and l.timestamp = (select max(l2.timestamp) from logs l2 where l2.result = 'success-changed' and date(l2.timestamp) = date(l.timestamp) );
vw //View udf //UserDefineFunction
1.1) start the **hiveserver** before running the query 1.2) you have to run two queries 1.2.1) USE <database_name> 1.2.2) SHOW TABLES LIKE 'table_name' 1.2.3) Then you check your result using Result set.
string[] myNewColumns = inputColumn.split(";");
WITH toupdate as ( SELECT pr.*, ROW_NUMBER() OVER (PARTITION BY orderpartyrole ORDER BY CASE WHEN Remark > '' THEN 0 ELSE 1 END, Bold_id DESC) as seqnum FROM pricerequest pr ) UPDATE toupdate SET orderpartyrole = -1 WHERE seqnum > 1;
SELECT user_password.UserName, user_password.Password, COUNT(*) FROM user_password JOIN (SELECT UserName FROM user_password GROUP BY UserName HAVING COUNT(DISTINCT Password) > 1) multiple_passwords ON multiple_passwords.UserName = user_password.UserName GROUP BY user_password.UserName, user_password.Password ORDER BY user_password.UserName
SELECT dept_id, dept_name FROM ( SELECT d.dept_id, d.dept_name, 0 AS entity_type_ordinal FROM department d UNION ALL SELECT d.dept_id, e.employee_name, 1 AS entity_type_ordinal FROM department d INNER JOIN employee e ON e.dept_id = d.dept_id ) dept_and_emp ORDER BY dept_id, entity_type_ordinal, dept_name
SELECT x.value from form_data x, form_data y WHERE x.form_id=1 and x.field_id=1 and y.form_id=and y.field_id=1 GROUP BY x.value HAVING SUM(SIGN(1-SIGN(y.value-x.value))) = (COUNT(*)+1)/2;
WITH Temp AS ( SELECT emp.EMpID ,emp.DepID ,COUNT(OrderId) nb_order ,ROW_NUMBER() OVER(PARTITION BY emp.DepID ORDER BY COUNT(OrderId) DESC) Ordre FROM Order ord INNER JOIN Employee emp ON emp.EmpID = ord.EmpID GROUP BY emp.EMpID ,emp.DepID) SELECT * FROM Temp WHERE Ordre = 1
WITH some_data AS( select a.*, trunc( trunc( add_months( "DATE", 1 ), 'MM' ) - "DATE" ) As days_to_end_of_month, trunc( add_months( "DATE", 1 ), 'MM' ) As start_of_next_month from amounts a ), some_other_data AS ( SELECT some_data.*, CASE WHEN days_to_end_of_month >= 6 THEN Amount ELSE ( SELECT some_data.amount * "Cumulative Weight" FROM Weights w WHERE some_data.days_to_end_of_month = DayNum ) END as new_Amount FROM some_data ) SELECT Item, "DATE", New_Amount as amount FROM some_other_data UNION ALL SELECT Item, start_of_next_month, amount-new_amount FROM some_other_data WHERE days_to_end_of_month < 6 ORDER BY "DATE" ;
DECLARE @Id int DECLARE @ForeignKey int DECLARE C CURSOR FOR SELECT Id FROM TableA OPEN C FETCH NEXT FROM C INTO @Id WHILE @@FETCH_STATUS = 0 BEGIN INSERT INTO TableB VALUES (value1) SET @ForeignKey = SCOPE_IDENTITY() UPDATE TableA SET ForeignKey = @ForeignKey WHERE Id = @Id FETCH NEXT FROM C INTO @Id END CLOSE C DEALLOCATE C
SELECT connections.id, connections.Source_Name, connections.Source_port, src.systype SourceType, connections.Destination_Name, connections.Destination_Port, tgt.systype DestinationType FROM connections LEFT JOIN equipment src on connections.system_name_source=src.system_name LEFT JOIN equipment tgt on connections.system_name_dest=tgt.system_name
SELECT @a:=@a+1 serial_number, marks FROM student_marks, (SELECT @a:= 0) AS a;
CREATE TABLE employee ( id NUMBER PRIMARY KEY, -- other details... ); CREATE TABLE attendance ( employee_id NOT NULL REFERENCES employee(id), attendance_date DATE NOT NULL, PRIMARY_KEY(employee_id, attendance_date) );
string schemaFilePath = filePath + "\\" + "Schema.ini"; StreamWriter writer = new StreamWriter(schemaFilePath, false); writer.WriteLine("[" + fileName + "]"); writer.WriteLine("Format=TabDelimited"); writer.Close();
UPDATE person SET dollars = GREATEST(0, dollars-20) WHERE id=1
select xmlelement(name "Customer", xmlelement(name "Name", name), orders, payments ) as the_xml from customers left join ( select c_id as id, xmlelement(name "Orders", xmlagg(xmlelement(name "Order", xmlelement(name "id", id), xmlelement(name "date", date), xmlelement(name "content", content) ) ) ) as orders from orders group by c_id ) o using (id) left join ( select c_id as id, xmlelement(name "Payments", xmlagg(xmlelement(name "Payment", xmlelement(name "id", id), xmlelement(name "date", date), xmlelement(name "amount", amount) ) ) ) as payments from payments group by c_id ) p using (id)
INSERT INTO table_name (col1, col2, col3) SELECT col1, col2, col3 FROM table_x WHERE col1='A' AND col2 in ('1G','2F','3Q') AND col3 ='B'
SELECT book_customer.firstname, book_customer.lastname, TO_CHAR(book_order.orderdate,'MM/DD/YYYY') AS "Order Date" -- Comma removed here FROM book_customer, book_order, order_items, books, publisher WHERE (book_customer.customerid = book_order.customerid) AND (book_order.orderid = order_items.orderid) AND (order_items.bookid = books.bookid) AND (books.pubid = publisher.pubid) AND (publisher.publishername = 'printing with us');
SELECT City, COUNT(CustomerID) as CustomersPerCity FROM Customers GROUP BY City
-- The user can make as many comments as they like Table_review { User ID Game ID Feedback ID } Table_feedback { Feedback ID Comments TimeStamp } -- Now users can comment on what other users think -- but only to one level of nesting Table_feedback_comments { Feedback ID User ID Comment TimeStamp } -- a user can only rate a game once, but they can change their rating over time -- For example more content was added and the user likes this -- and wants to reflect that in their rating Table_rating { Game ID User ID Rating } Table_user { User ID User name User email Comment -- something that describes the user } -- Even if you have only one game you can still store it in the database Table_game { Game ID Game Name -- other columns used to represent a game }
SELECT o.CustomerID, null emptyColumn, o.ShipFirstName, case when o.ShipCountry = 'United States' then 'US' when o.ShipCountry = 'Canada' then 'CA' end, c.EmailAddress FROM Orders o, Customers c WHERE o.CustomerID = c.CustomerID
SELECT pc.product_code, COUNT(*) as count, sum(o.monthly_base_charge) as "Monthly Fee" FROM orders o join product_catalog pc on pc.product_catalog_id = o.product_catalog_id GROUP BY pc.product_code ORDER BY count DESC;
SELECT Name, Color FROM TableA WHERE NOT EXISTS ( SELECT 1 FROM TableB WHERE TableA.Name = TableB.Name AND TableA.Color = TableB.Color)
select count(*) as count from users WHERE ( 3959 * acos( cos( radians( 37.774929 ) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians( -122.419418 ) ) + sin( radians( 37.774929 ) ) * sin( radians( lat ) ) ) ) < 150
least(case when price > 0 then price else 999999 end, case when price_double > 0 then price_double else 999999 end, case when price_triple > 0 then price_triple else 999999 end, case when price_quad > 0 then price_quad else 999999 end )
var edmxNS = XNamespace.Get(@"http://schemas.microsoft.com/ado/2007/06/edmx"); var schemaNS = XNamespace.Get(@"http://schemas.microsoft.com/ado/2006/04/edm"); var xd = XDocument.Load(@"{path}\Model.edmx"); var fields = from e in xd .Elements(edmxNS + "Edmx") .Elements(edmxNS + "Runtime") .Elements(edmxNS + "ConceptualModels") .Elements(schemaNS + "Schema") .Elements(schemaNS + "EntityType") from p in e .Elements(schemaNS + "Property") select new { Entity = e.Attribute("Name").Value, Member = p.Attribute("Name").Value, Type = p.Attribute("Type").Value, Nullable = bool.Parse(p.Attribute("Nullable").Value), };
SELECT DATEDIFF(MILLISECOND, DateFrom, DateTo)
SELECT SUM(cred), status, censusDate, ssn FROM (SELECT sac.cred, s.status, (SELECT NVL (csl.census_dates, tl.census_dates) FROM schema.sections cs, schema.sections_ls csl, schema.terms tl WHERE cs.course_sections_id = csl.course_sections_id(+)AND csl.pos(+) = 1 AND cs.term = tl.terms_id AND tl.pos = 1 AND cs.course_sections_id = cs2.course_sections_id AND ROWNUM = 1)AS censusDate, (SELECT NVL (p.ssn, 'xxx-xx-xxxx') FROM schema.person p WHERE p.id = sac.person_id) AS ssn, //schema.person_name(sac.person_id, 'FML') as fml, //schema.person_name(sac.person_id, 'LF') as lf FROM schema.student_acad_cred sac JOIN schema.statuses s ON s.student_acad_cred_id = sac.student_acad_cred_id JOIN schema.terms tl ON sac.term = tl.terms_id JOIN schema.student_course_sec scs ON sac.student_course_sec = scs.student_course_sec_id JOIN schema.course_sections cs2 ON scs.course_section = cs2.course_sections_id JOIN schema.terms t ON tl.terms_id = t.terms_id WHERE sac.person_id = '1111111111' AND (s.status IN ('A', 'N') OR (s.status = 'D' AND final_grade IS NOT NULL)) AND s.pos = '1'AND tl.pos = '1' AND tl.terms_id = 'spring') GROUP BY status, censusDate, ssn;
from u in context.aspnet_Users join m in context.aspnet_Membership on u.UserId equals m.UserId select new { u.UserName, m.IsApproved};
select LocationName, count(*) num_reservations from reservation where month(PickUpDateTime) = 2 --This can be parameterized if needed group by LocationName order by num_reservations desc
SELECT a.proID, GROUP_CONCAT(b.domainID) domainId, GROUP_CONCAT(b.domainName) domainName FROM projects a LEFT JOIN domain b ON a.domainID = b.domainID GROUP BY a.proID
Select * from mydb Where IsNumeric(sku) = 0x1
Data$bins <- sapply(Data$Name, function(n) paste(as.integer(agrepl(n, Data$Name, max.distance = 2)), collapse="")) Data$Group <- as.integer(as.factor(Data$bins)) # State Zipcode Name bins Group # 1 IL 60693 THISISTHEFIRST 11100000000 4 # 2 IL 60693 TISISTHEFIRS 11100000000 4 # 3 OH 45271 THISISTHEFIRST 11100000000 4 # 4 CA 94085 THISISTHESECOND 00011100000 3 # 5 CA 94085 THISISTHESECOND 00011100000 3 # 6 CA 94085 THISISTHESECCOND 00011100000 3 # 7 SC 29645 THISISTHETHIRD 00000011100 2 # 8 SC 29645 THISISTHETHIRD 00000011100 2 # 9 SC 29645 THISISTHETHIRD 00000011100 2 # 10 SC 29645 THISISTHEFOURTH 00000000011 1 # 11 SC 29645 ISISTHEFOURTH 00000000011 1
UPDATE your_table SET Update_Flag = 1 // this assumes the flag is an integer value WHERE (column1 = "xxx") // if it's a string do SET Update_Flag = "True" OR (column2 = "xxx") OR (column3 = "xxx")
TRANSFORM Sum(tbl_timesheet_hours.[work_order_hours]) AS SumOfwork_order_hours SELECT tbl_timesheet_hours.[work_order_no], Sum(tbl_timesheet_hours.[work_order_hours]) AS [Total Of work_order_hours] FROM tbl_timesheet_hours GROUP BY tbl_timesheet_hours.[work_order_no] ORDER BY Format([work_order_date],'ddd') PIVOT Format([work_order_date],'ddd') In ("Mon","Tue","Wed","Thu","Fri","Sat","Sun");
SELECT * FROM CLASSES JOIN SUBJECTS_PER_CLASS ON CLASSES.ID = SUBJECTS_PER_CLASS.class_id JOIN Subjects ON Subjects.id = SUBJECTS_PER_CLASS.mat_id
select field1, field2, value, 100.0 * value / SUM(value) OVER(PARTITION BY 1) /* the SUM gets the total for the whole dataset. If actually have groups, yous should do PARTITION BY GroupField */ from yourtable
AND location_ns = 'Marriott\\256 Hotel & Convention Centre'
Cursor c = db.query(TABLE_NAME,columns,COLUMN_order + "=? OR " + COLUMN_order + "=?", new String[]{"0", "1"}, null, null, COLUMN_ID); SimpleCursorAdapter adapter = new SimpleCursorAdapter(this, R.layout.list_item, c, new String[] {COLUMN_ID,COLUMN_NAME,COLUMN_order}, new int[] {R.id.list_item_text_id,R.id.list_item_text_main,R.id.list_item_text_sub}, 0); ListView list = (ListView) findViewById(R.id.list_poet_name); list.setAdapter(adapter);
SELECT a.PLANT_NO "PlantNumber", SUM(CASE WHEN a.REC_STATUS_CD = 'RR' THEN -a.KW_CTR_REDELIVERED_HV ELSE a.KW_CTR_REDELIVERED_HV END) "KeepWholeResidueMMBtu", SUM(a.ETH_APPLIED_POP_PCT + a.ISO_APPLIED_POP_PCT + (CASE WHEN a.PLANT_NO = '002' THEN a.ALTLIQ_APPLIED_POP_PCT ELSE 0 END) )/100 "NGLPOPPaymentPercent" FROM GAS_STMT a INNER JOIN SETTLE_SUMMARY c ON CASE WHEN SUBSTR(a.TRNX_ID,1,1) = '-' THEN SUBSTR(a.TRNX_ID, 2, LENGTH(a.TRNX_ID)) ELSE CAST(a.TRNX_ID AS VARCHAR2(100)) END = c.TRNX_ID AND a.MTR_NO||a.MTR_SFX = c.MTR_NO||c.MTR_SFX LEFT JOIN (SELECT MTR_NO,MTR_SFX,TRNX_ID,REC_STATUS_CD,MAX(ACCT_DT) ACCT_DT FROM GAS_STMT WHERE REC_STATUS_CD = 'RR' GROUP BY MTR_NO, MTR_SFX, TRNX_ID, REC_STATUS_CD HAVING COUNT(TRNX_ID) > 1) b ON a.MTR_NO = b.MTR_NO AND a.TRNX_ID = b.TRNX_ID AND a.REC_STATUS_CD = b.REC_STATUS_CD AND a.ACCT_DT = b.ACCT_DT WHERE TO_CHAR(a.PROD_DT, 'YYYY') >= TO_CHAR(ADD_MONTHS(SYSDATE, -36), 'YYYY') AND a.STATUS_UNIT_TM_CD = 'M' AND b.MTR_NO IS NULL GROUP BY a.PLANT_NO ORDER BY a.PLANT_NO
scope :by_type, ->(type){ where(type: type).limit(5) } def self.foo Ticket.by_type('a') + Ticket.by_type('b') + Ticket.by_type('c') end
select top 1 with ties MySubId, Count(MySubId) as MySubIdCount from MyTable group by MuSubId order by 2 desc
SELECT *, count_t1 + count_t2 as count_all FROM (SELECT d_id, COUNT(content) as count_t1 FROM TableA GROUP BY d_id) t1 LEFT JOIN (SELECT d_id, COUNT(dif_content) as count_t2 FROM TableB GROUP BY d_id) t2 ON t1.d_id = t2.d_id;
select ..., sum(manhours) - coalesce(Leavetaken, 0) as calc
CREATE TABLE [Comment]( CommentId int PRIMARY KEY IDENTITY(1,1), UserId int Not NULL, ArticleId int NOT NULL , FOREIGN KEY(UserId) references [User](UserId), FOREIGN KEY(ArticleId) references [Article](ArticleId) ON DELETE CASCADE )
select b.Title from Book b join Author a on b.BookID = a.BookID join Writer w on w.AuthId = a.AuthId join Publisher p on w.PubId = p.PubId where p.Country like 'Australia' group by b.Title, b.BookID having count(*) >= 2;
select * from #test order by case when test like 'The %' then substring(test, 5, 8000) else test end
SELECT * FROM Table1 CROSS JOIN Table2
100XX 1000XX 101XX
SELECT A.PRODUCTCODE, A.STOCKLEVEL, SUM(A.QUANTITY) FROM PRODUCT A INNER JOIN PRODLINE B ON A.PRODUCTCODE=B.PRODCODE GROUP BY A.PRODUCTCODE
select "i. Category " + "Number" + char(13)+char(10) + "ii. -----------------------------------" + char(13)+char(10) + "iii. High: " + cast((select count(1) from tabData where advance > 10000) as varchar) + char(13)+char(10) + "iv. Low: " + cast((select count(1) from tabData where advance >= 5000 and advance <= 10000) as varchar) + char(13)+char(10) + "v. Moderate: " + cast((select count(1) from tabData where advance < 5000) as varchar) + char(13)+char(10) + "vi. N/A " + cast((select count(1) from tabData where advance is null) as varchar)
CREATE PROCEDURE name ( @arg1 as type1, @arg2 as type2 ) AS DECLARE @value1 as type1 SELECT @value1=x from tabley WHERE <something> INSERT INTO Table(x,y,z) VALUES(@arg1,@arg2,@value1)
select (SELECT "count"(*) as val1 from tab1) - (SELECT "count"(*) as val2 from tab2)
Option Compare Database Option Explicit Public Function Func32(HardwareType As String) As Variant Dim cdb As DAO.Database, qdf As DAO.QueryDef, rst As DAO.Recordset Dim sql As String Set cdb = CurrentDb sql = "" sql = sql & "PARAMETERS prmHardwareType TEXT(255);" sql = sql & "SELECT * FROM Table1 WHERE Hardware_Type=[prmHardwareType]" Set qdf = cdb.CreateQueryDef("", sql) ' assign the PK argument as the query parameter and open it as a Recordset qdf!prmHardwareType = HardwareType Set rst = qdf.OpenRecordset(dbOpenSnapshot) ' do your calculations and assign the return value to the function name Func32 = rst!Field1 + rst!Field2 + rst!Field3 rst.Close Set rst = Nothing Set qdf = Nothing Set cdb = Nothing End Function
Private Function qdefSQL() As Boolean Dim db As Database Dim qdef As QueryDef Dim sSQL As String Dim iqdef As Integer Set db = CurrentDb For iqdef = 0 To db.QueryDefs.count - 1 Set qdef = db.QueryDefs(iqdef) sSQL = qdef.SQL If InStr(sSQL, "target") > 0 Then Debug.Print qdef.Name End If Next qdefSQL = True End Function
SELECT ((col1+col2+col3)/col4) as value FROM ((SELECT col1, col2, col3, col4 FROM table1 ) UNION ALL (SELECT col1, col2, col3, col4 FROM table2 ) ) t HAVING value > 4 and value < 5
select * from your_table where year(Start_Date) = year(curdate()) and month(Start_Date) = month(curdate()) and end_date <= curdate() + interval 30 day
WITH Cte AS( SELECT name, rn = ROW_NUMBER() OVER(ORDER BY name) + ((ROW_NUMBER() OVER(ORDER BY name) - 1) / 5) FROM table1 UNION ALL SELECT name, rn = ROW_NUMBER() OVER(ORDER BY name) * 6 FROM table2 ) SELECT name FROM Cte ORDER BY rn
SELECT p1.ID, ( SELECT NAME + ' and ' FROM YourTable p2 WHERE p2.ID = p1.ID ORDER BY NAME FOR XML PATH('') ) AS Name, sum(Amount) FROM YourTable p1 GROUP BY ID ;
select wpg.ID as id1, min(wr.ID) as id2 from Table1 wpg inner join Table2 wp on wp.WpgId = wpg.ID inner join Table3 wr on wr.WpId = wp.ID group by wpg.ID
select * from all_constraints where table_name = 'REGISTRATION';
select n from YourTable group by n having count(*) = 1
DECLARE @KeywordList varchar(max) //This can be a SP param CREATE TABLE #Keywords(varchar(10) keyword NOT NULL); DECLARE @Keyword varchar(10), @Pos int SET @KeywordList= LTRIM(RTRIM(@KeywordList))+ ',' SET @Pos = CHARINDEX(',', @KeywordList, 1) --Parse varchar and split IDs by comma into temp table IF REPLACE(@KeywordList, ',', '') <> '' BEGIN WHILE @Pos > 0 BEGIN SET @Keyword= LTRIM(RTRIM(LEFT(@KeywordList, @Pos - 1))) IF @Keyword <> '' BEGIN INSERT INTO #Keywords(ID) VALUES (@Keyword) END SET @KeywordList = RIGHT(@KeywordList, LEN(@KeywordList) - @Pos) SET @Pos = CHARINDEX(',', @KeywordList, 1) END END --Return a count of all rows SELECT @TotalRows = COUNT(Keyword) FROM #Keywords; --Now process data from #Keywords as required
select distinct M.mtitel as Attribute from merkmale as M where M.MID in ( select A.MID from aREl_Adr_Merk as A where A.AdrID in (252674,247354) )
select person, abs(DATE_PART('epoch', p1 - p2) from (select person, MAX(case when product = 'football' then purchase_time end) as p1, MAX(case when product = 'basketball' then purchase_time end) as p2 from mytable group by person ) p where p1 is not null and p2 is not null
SELECT DISTINCT a.id, b.value AS SIGN_UP, c.value AS FIRST_NAME, d.value AS STREET FROM tbl a LEFT JOIN tbl b ON a.id = b.id AND b.field_name = 'sign_up' LEFT JOIN tbl c ON a.id = c.id AND c.field_name = 'first_name' LEFT JOIN tbl d ON a.id = d.id AND d.field_name = 'street'
# not tested... library(ggplot2) # all on one plot ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD,color=CONGESTION_ZONE)) #four plots ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD)) + facet_wrap(~CONGESTION_ZONE) # coloring beased on day_type ggplot(df) + geom_point(aes(x=AVG_TEMP,y=TOTAL_LOAD, color=DAY_TYPE_CD))+ facet_wrap(~CONGESTION_ZONE)
SELECT * FROM TABLE WHERE ID NOT IN (SELECT ID FROM TABLE WHERE KEY = 'LATLNG')
DECLARE @Start date = '2013-06-03' DECLARE @End date = '2013-06-10' ;WITH Dates AS ( SELECT @Start AS [Date] UNION ALL SELECT DATEADD(DAY, 1, [Date]) FROM Dates WHERE [Date] < @End ) SELECT [Date] FROM Dates OPTION (MAXRECURSION 0)
CREATE NONCLUSTERED INDEX ix_p ON tblProductRegistration (RegistrationDate, ProductID) GO CREATE NONCLUSTERED INDEX ix_d ON tblDealerDistributionDetails (model, DealerCode) INCLUDE (BarCode, BarCode2) GO SELECT DealerCode, COUNT_BIG(*) AS [Activated] FROM tblDealerDistributionDetails d WHERE model = 'Olvio L12' AND EXISTS( SELECT * FROM tblProductRegistration r WHERE r.RegistrationDate BETWEEN '20160301' AND '20160302' AND r.ProductID IN (d.BarCode, d.BarCode2) ) GROUP BY DealerCode --OPTION(RECOMPILE)
COLUMN_NAME position(1:14) CHAR "STRIP_NONNUMERIC(:LAST_NAME)",
var results = from rs in db.ratesSchedule join ud in db.userdetails on new { rs.sid, rs.tabletype } equals new { ud.sid, tabletype = "d" }
SELECT * FROM table1 INNER JOIN table2 ON table1.id = table2.id AND table1.name <> table2.name
SELECT stocks.* FROM stocks WHERE part_id IN ( SELECT part_id FROM parts ON parts.id = stocks.part_id INNER JOIN features ON features.part_id = parts.id INNER JOIN feature_titles ON feature_titles.id = features.feature_title_id WHERE parts.category_id = 20 AND stocks.manufacturer_id = 4 AND ( feature_titles.title = 'Title One' AND features.value = '0.1' OR feature_titles.title = 'Title Two' AND features.value = '7 MAX' ) GROUP BY parts.id HAVING COUNT(features.id) = 2 )
select Table1.id, Table1.Name, Table1.idObject, Table2.City, Table3.State from Table1 join Table2 ON Table1.idObject = case when Table1.Name='abc' then Table2.idLineItem when Table1.Name='def' then Table2.idOrder else Table2.idSupplier end join Table3 on Table2.idAdv=Table3.idAdv group by Table1.id, Table1.idObject;
SELECT td = [Status],'', td = [Number],'', td = CONVERT(varchar(25), [Date], 21),'', td = [Error Message] FROM [Views].dbo.Errors ORDER BY Date
substring(articletext, patindex('/images/imgs/', articletext) + length('/images/imgs/'), patindex('" alt') - (patindex('/images/imgs/', articletext) + length('/images/imgs/')))
ALTER TABLE `invoices`.`invoices` CHANGE `DateTime` `DateTime` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
select Location ,sum(case when [Month] = 'January' then value else 0 end) as January ,sum(case when [Month] = 'February' then value else 0 end) as February ,sum(case when [Month] = 'March' then value else 0 end) as March ,sum(case when [Month] in ( 'January', 'February', 'March') then value else 0 end) as Q1 ... -- Repeat months... ... ,sum(value) as AllMonthTotal from myTempTable group by Location -- UNION to get rowwise total union select 'TOTAL' ,sum(case when [Month] = 'January' then value else 0 end) as January ,sum(case when [Month] = 'February' then value else 0 end) as February ,sum(case when [Month] = 'March' then value else 0 end) as March ,sum(case when [Month] in ( 'January', 'February', 'March') then value else 0 end) as Q1 ... -- Repeat months... ... ,sum(value) as AllMonthTotal from myTempTable
Select ... From WorkOrder As W Where Exists ( Select 1 From WorkOrder As W1 And W1.CustomerId = W.CustomerId And DatePart( dw, W1.TimeWindowStart ) <> DatePart( dw, W.TimeWindowStart ) )
db2 "create table test ( x int, y clob(1M) )" db2 "insert into test (x,y) values (1,cast('The string to find is CEMENTO, how do we do that?')" db2 "insert into test (x,y) values (2,cast('The string to find is CEMENT, how do we do that?' as clob))" db2 "select x, DBMS_LOB.INSTR(y, 'CEMENTO', 1) from test where DBMS_LOB.INSTR(y, 'CEMENTO', 1) > 0" X 2 ----------- ----------- 1 23 1 record(s) selected.
select array_agg(console_id) as consoles from archive_sessions where tournament_id = 14817
WHERE Month(DateOfSession) = " & me.cboSelectMonth
select * from ( select * from your_table where some_conditions limit 1000 ) as some_aliases order by rand() limit 4;
DECLARE @AssessmentID INT; CREATE TABLE #AssessmentIDs (AssessmentID INT); INSERT #AssessmentIDs (AssessmentID) SELECT AssessmentID FROM Assessments WHERE EpisodeID = @EpisodeID; WHILE (SELECT COUNT(*) FROM #AssessmentIDs WHERE AssesmnentID = @AssessmentID) > 0 BEGIN SELECT @AssessmentID = TOP 1 AssessmentID FROM #AssessmentIDs EXEC DeleteAssessment @AssessmentID DELETE #AssessmentIDs WHERE AssessmentID = @AssessmentID END;
update tablename t set gender = (case when gender = 'm' then 'f' when gender = 'f' then 'm' else gender end);
DECLARE @tbl VARCHAR(60), @sql VARCHAR(8000) SET @tbl = 'tblData' -- change for the table SELECT @sql = 'SELECT ' + STUFF( ( SELECT ', ' + ColumnName + ' as ' + ColumnLabel FROM columnOrder ORDER BY Position FOR XML PATH('') ) , 1, 1, '' ) + ' FROM ' + @tbl --SELECT @sql EXEC (@sql)
SELECT title, COUNT(art) AS art_count FROM table1 GROUP BY art HAVING art_count >= (select count(*) * X / 100 from table1)
SELECT id, username FROM user LEFT JOIN ( SELECT DISTINCT user2_id AS blockee_id FROM blocked_user WHERE user1_id = :current_user_id ) this_user_blocked ON user.id = this_user_blocked.blockee_id LEFT JOIN ( SELECT DISTINCT user1_id AS blocker_id FROM blocked_user WHERE user2_id = :current_user_id ) blocked_this_user ON user.id = blocked_this_user.blocker_id WHERE this_user_blocked.blockee_id IS NULL AND blocked_this_user.blocker_id IS NULL
WITH CategoryTree AS ( SELECT *, 0 AS Generation FROM dbo.Category WHERE CategoryName = 'Animation' UNION ALL SELECT Cat.*, Generation + 1 FROM CategoryTree JOIN dbo.Category AS Cat ON Cat.Id = CategoryTree.CategoryMaster ) SELECT * FROM CategoryTree
select e.id,per.id,t.status from employee e join person per on e.personId=per.id left join training t on e.id=t.employeeId and t.courseId = ?
SELECT 'Person.Contact' as "@name", (SELECT (SELECT * from (SELECT 'FirstName' as [@name], [FirstName] as [*] union all SELECT 'LastName' as [@name], [LastName] as [*]) y for xml path('field'), TYPE) from Person.Contact for XML path, TYPE) for XML path('entity'), root('querydata')
SELECT m.id muppet_id, m.name, p.id phone_id, p.phone, p.valid FROM muppet m FULL OUTER JOIN phone p ON (M.ID = P.MUPPET_ID) WHERE P.VALID = 'Y' or P.MUPPET_ID is null;
CREATE PROCEDURE spData4 (@Year smallint) AS BEGIN CREATE TABLE #temp1 (RegionName NVARCHAR(50), TotalSitesVisited INT, TotalViolations INT) CREATE TABLE #temp2 (RegionName NVARCHAR(50), TotalSiteVisits INT) CREATE TABLE #temp3 (RegionName NVARCHAR(50), TotalBadSites INT) INSERT INTO #temp1 EXEC spData1 @Year INSERT INTO #temp2 EXEC spData2 @Year INSERT INTO #temp3 EXEC spData3 @Year SELECT COALESCE(t1.RegionName, t2.RegionName, t3.RegionName) RegionName ,TotalSitesVisited,TotalViolations,TotalSiteVisits,TotalBadSites FROM #temp1 t1 FULL JOIN #temp2 t2 ON t1.RegionName = t2.RegionName FULL JOIN #temp3 t3 ON t1.RegionName = t3.RegionName OR t2.RegionName = t3.RegionName END
1: Remove properties from the model. 2: Run 'Enable-Migrations' in package manage console. 3: Next Run 'Add-Migration "MigrationsName"'. if any case it is showing 'The project tesproject failed to build then build project again. 4: Now run 'Update-Database'
select concat('alter table ', table_name, ' modify column ', column_name, ' VARCHAR(40)') from information_schema.columns where table_schema='yourdb' and table_name='table1' and column_name NOT IN('col1','col2','col3')
List<A> aList = dataTable.AsEnumerable() .GroupBy(row => row.Field<int>("A_Id")) .Select(grp => new A { Id = grp.Key, Name = grp.First().Field<DateTime>("A_Date"), Bs = grp.Select(m => new B { Id = m.Field<int>("B_Id"), Name = m.Field<string>("B_Name") }).ToList(), }) .ToList()
db.execSQL("DELETE FROM SQLITE_SEQUENCE WHERE NAME = '" + name_of_the_table + "'");
select "t"."trip_id", "c"."service_id", "start_s"."stop_name" as "departure_stop", "start_st"."departure_time", "end_s"."stop_name" as "arrival_stop", "end_st"."arrival_time", "end_st"."departure_time" as "end_departure", "last_st"."arrival_time" as "last_arrival", "last_s"."stop_name" as "last_stop" from "trips" as "t" inner join "calendar" as "c" on "t"."service_id" = "c"."service_id" inner join "routes" as "r" on "t"."route_id" = "r"."route_id" inner join "stop_times" as "start_st" on "t"."trip_id" = "start_st"."trip_id" inner join "stops" as "start_s" on "start_st"."stop_id" = "start_s"."stop_id" inner join "stop_times" as "end_st" on "t"."trip_id" = "end_st"."trip_id" inner join "stops" as "end_s" on "end_st"."stop_id" = "end_s"."stop_id" inner join "stop_times" as "last_st" on "t"."trip_id" = "last_st"."trip_id" inner join "stops" as "last_s" on "last_st"."stop_id" = "last_s"."stop_id" where "start_s"."stop_id" = '245' -- my data's stop id and "end_s"."stop_id" = '762' -- my data's stop id and "last_st"."stop_sequence" = (select max("stop_sequence") from "stop_times" where "t"."trip_id" = "trip_id") and start_st.departure_time < end_st.arrival_time order by arrival_time asc
DECLARE @TempTable TABLE ( id int NOT NULL, PRIMARY KEY ( id ) )
SELECT * FROM pledger WHERE dcno <> 1 OR pledger.etype <> 'sale'
SELECT a.* FROM tableName a INNER JOIN ( SELECT ITEMID , MAX(DATEPHYSICAL) max_date FROM tableName GROUP BY ITEMID ) b ON a.ITEMID = b.ITEMID AND a.DATEPHYSICAL = b.max_date
val results: List[(Int, Int, String)] = SQL("SELECT t.id, t.field1, t.field2 from table1 t WHERE t.field1 = {param1}") .on("param1" -> param1)() .as(int("t.id") ~ int("t.field1") ~ get[Option[String]]("t.field2") map(flatten) *) .toList
DECLARE @myString NVARCHAR(MAX) = '{local.txt_concept_id} != "" & {local.txt_ICD_code} != "" & {local.txt_diagnosis_uniq_id} != "" & {local.txt_ICD_desc} != ""& {FIND( {local.txt_ICD_code} , "asp", 0 )}!=-1& {LEN( {local.txt_diagnosis_uniq_id})}'; SELECT T2.X.value('.', 'varchar(50)') FROM (SELECT CAST(REPLACE(REPLACE((SELECT @myString FOR XML PATH('')), '{', '<X>'), '}', '</X>') AS XML).query('.')) AS T1(X) CROSS APPLY T1.X.nodes('/X/text()') AS T2(X);
SELECT * FROM table ORDER BY LENGTH(column) - LENGTH(REPLACE(column, ' ', ''))
SELECT name, code FROM new n WHERE NOT EXISTS(SELECT * FROM current c WHERE c.name = n.name OR c.code = n.code)
IsLocate as (case when locates is not null then 'Y' else 'N' end), IsAdjustment as (case when shares is not null then 'Y' else 'N' end),
SELECT c.* , COALESCE(t1.Value, t2.Value,t3.Value) AS Value , COALESCE(t1.Date, t2.Date,t3.Date) AS Date FROM Common c LEFT JOIN Table1 t1 ON c.tableid = t1.[id] AND [Table] = 'table1' LEFT JOIN Table2 t2 ON c.tableid = t2.[id] AND [Table] = 'table2' LEFT JOIN Table2 t3 ON c.tableid = t3.[id] AND [Table] = 'table3' ORDER BY ID;
select * from test where model_number in ( select model_number from test group by model_number having count(distinct description) > 1)
SELECT thing_type, thing_id, parent_id FROM Sample_Table T1 WHERE thing_type = 'Desired Type' AND thing_id NOT IN ( SELECT parent_id FROM Sample_Table T2 WHERE T2.thing_type = 'Desired Type' )
SQL> with test (DATE_, USERID, DOMAIN, VALUE) 2 as ( 3 select '03/16/2016', 1001 ,'ASIA' ,10 from dual union all 4 select '03/16/2016', 1001 ,'EUROPE' ,20 from dual union all 5 select '03/16/2016', 1002 ,'ASIA' ,20 from dual union all 6 select '03/17/2016', 1001 ,'ASIA' ,20 from dual union all 7 select '03/17/2016', 1002 ,'EUROPE' ,10 from dual 8 ) 9 SELECT * 10 FROM (select * 11 from test) 12 PIVOT ( sum(value) FOR (domain) IN ('ASIA', 'EUROPE')) 13 ORDER BY 1, 2; DATE_ USERID 'ASIA' 'EUROPE' ---------- ---------- ---------- ---------- 03/16/2016 1001 10 20 03/16/2016 1002 20 03/17/2016 1001 20 03/17/2016 1002 10
SELECT q.ColA as "Next Repricing", q.ColA as "Balloon Date" FROM (select acct, name, address, case when pterm||' '||ptermc = '0' then date(digits(matdt7)) when pterm||' '||ptermc = '1 D' then curdate() when pterm||' '||ptermc = '1 M' then date(digits(prevd7))+30 day when pterm||' '||ptermc = '3 M' then date(digits(prevd7))+90 day when pterm||' '||ptermc = '6 M' then date(digits(prevd7))+180 day when pterm||' '||ptermc = '12 M' then date(digits(prevd7))+365 day else null end as ColA, ...) As q
Select Count(*) From Product where active = 'true'
SELECT a.artist, a.title, a.imgurl, a.id, MAX(i.price), MIN(i.price) FROM albums AS a JOIN inventory AS i ON a.id = i.albumId --WHERE ...conditions on artist or album... GROUP BY a.artist, a.title, a.imgurl, a.id
With Numbers As ( Select Row_Number() Over ( Order By C1.object_id ) As Value From sys.columns As C1 Cross Join sys.columns As C2 ) , ProposedSequences As ( Select NTRIId , Row_Number() Over ( Order By NTRIId ) As Sequence From Table Where NTRITCode = 'PROPOSED' Group By NTRIId ) , CurrentSequences As ( Select RID, NTRITCode, NTRIId, Parameter, Usage, Rate , Numbers.Value As Sequence From Table Cross Join Numbers Where NTRITCode = 'Current' And Numbers.Value <= (Select Max(Sequence) From ProposedSequence) ) Select Sequence, RID, NTRITCode, NTRIId, Parameter, Usage, Rate From CurrentSequences Union All Select PS.Sequence, T.RID, T.NTRITCode, T.NTRIId, T.Parameter, T.Usage, T.Rate From ProposedSequences As PS Join Table As T On T.NTRIId = PS.NTRIId Order By PS.Sequence, T.NTRITCode
SELECT "username" FROM user
SELECT column_name + ' ' + DATA_TYPE + COALESCE('(' + CASE WHEN DATA_TYPE = 'XML' THEN NULL WHEN CHARACTER_MAXIMUM_LENGTH = -1 THEN 'max' ELSE Cast(CHARACTER_MAXIMUM_LENGTH AS VARCHAR(5)) END + ')', '(' + Cast(NUMERIC_PRECISION AS NVARCHAR(5)) + ',' + Cast(NUMERIC_SCALE AS NVARCHAR(5)) + ')', '') + ' ' + CASE IS_NULLABLE WHEN 'YES' THEN 'NULL' ELSE 'NOT NULL' END + COALESCE(' DEFAULT' + COLUMN_DEFAULT, '') FROM INFORMATION_SCHEMA.Columns WHERE table_name = 'mytable'
select x.a, c.b from ( select 'v1' as a union all select 'v2' as a union all select 'v3' as a ) x left outer join c on c.a = x.a
WITH cte AS (SELECT RN=Row_number() over(PARTITION BY a.Car_Name ORDER BY (SELECT NULL)), a.car_name, a.color, a.size, b.part_number FROM table1 INNER JOIN table2 ON a.car_name = b.car_name) SELECT car_name=CASE WHEN rn = 1 THEN car_name ELSE NULL END, color=CASE WHEN rn = 1 THEN color ELSE NULL END, size=CASE WHEN rn = 1 THEN size ELSE NULL END, part_number FROM cte
select e.*, max(photoname) as photoname, max(docname) as docname) from estates e join ((select p.estateid, p.photoname, NULL as docname, (@rnp := @rnp + 1) as seqnum from photos p cross join (select @rnp := 0) params where p.estateid = 1 ) union all (select d.estateid, NULL, d.docname, (@rnd := @rnd + 1) as seqnum from documents d cross join (select @rnd := 0) params where d.estateid = 1 ) ) dp on dp.estateid = e.estateid group by e.stateid, dp.seqnum order by e.stateid, dp.seqnum;
SELECT id, consumption, IF(@s=@s:=id, @s2:=@s2+consumption, @s2:=consumption) AS total FROM temp_reading, (SELECT @s:=0, @s2:=0);
select * from emp_history where emp_no in (select * from table(your pipelined function))
UPDATE t SET ID = (SELECT MIN(ID) FROM t AS t2 WHERE t.Num = t2.Num)
select CONVERT(DATE,FormUpdated) FormUpdated, DATENAME(dw, CONVERT(DATE,FormUpdated)), SUM(CASE WHEN TrackingStatus = 'ViewRates' THEN 1 ELSE 0 END) c_ViewRates, SUM(CASE WHEN TrackingStatus = 'Complete' THEN 1 ELSE 0 END) c_Complete, SUM(CASE WHEN TrackingStatus = 'SaveforLater' THEN 1 ELSE 0 END) c_SaveforLater from Sales where FormUpdated <= GETDATE() AND FormUpdated >= DATEADD(D,-8,GetDate()) group by CONVERT(DATE,FormUpdated) order by CONVERT(DATE,FormUpdated) desc
select max(dateofstat) from dhg.statistics where assetid in ( select /*+ parallel(relatedasset,4) */ assetid from dhg.relatedasset group by assetid having max( case when assetid in (191759.0, 3.0, 5.0, 98.0, 99.0) or linkid in (3232.0, 1049.0, 1057.0, 1067.0, 102.0, 1032.0, 104.0, 105.0, 1051.0) then 1 else 0 end ) = 1 and max( case when assetid in (192106.0, 1014.0, 10302.0) or linkid in (210.0, 737.0, 126.0, 1053.0, 1054.0, 119.0, 3133.0) then 1 else 0 end ) = 0 );
ALTER PROCEDURE dbo.BCP_Text_File @table NVARCHAR(255), @filename VARCHAR(100) AS BEGIN SET NOCOUNT ON; IF OBJECT_ID(@table) IS NOT NULL BEGIN DECLARE @sql NVARCHAR(MAX), @cols NVARCHAR(MAX) = N''; SELECT @cols += ',' + name FROM sys.columns WHERE [object_id] = OBJECT_ID(@table) ORDER BY column_id; SELECT @cols = STUFF(@cols, 1, 1, ''); SET @sql = N'EXEC master..xp_cmdshell ''bcp "SELECT ''''' + REPLACE(@cols, ',', ''''',''''') + ''''' UNION ALL SELECT ' + 'RTRIM(' + REPLACE(@cols, ',', '),RTRIM(') + ') FROM ' + DB_NAME() + '..' + @table + '" queryout "' + @filename + '" -c'''; EXEC sp_executesql @sql; END ELSE BEGIN SELECT 'The table '+@table+' does not exist in the database'; END END GO
SELECT * FROM mytable WHERE DATE(registration_date) BETWEEN @startDate AND @endDate AND EXISTS ( SELECT NULL FROM dbo.split(',', COALESCE(@affiliateId, @channel)) WHERE value = CASE WHEN @affiliateId IS NULL THEN channel ELSE affiliateId END ) AND EXISTS ( SELECT NULL FROM dbo.split(',', @channel) WHERE value = registration_channel )
SELECT COALESCE(csv.functionCC,t.functionCC) AS functionCC from #b as t LEFT outer JOIN WR_16h_vs_MVA_16h_csv as csv on t.PROBE_ID = csv.PROBE_ID;
select p.user_id as user_id, p.pictures_count, p.likes_count, l.likers_count from (select p.user_id, count(*) as pictures_count, sum(likes) as likes_count from pictures p group by p.user_id ) p left join (select p.user_id, count(distinct l.user_id) as likers_count from pictures p left join likers l on p.wall_id = l.wall_id and p.picture_id = l.picture_id group by p.user_id ) l on p.user_id = l.user_id;
SELECT col FROM tbl WHERE INSTR(REVERSE('123456'), REVERSE(col))=1;
SELECT d.adst , min(d.total) mttl FROM (SELECT a.date adate, b.date bdate, a.price + b.price total, ( b.date - a.date ) days, a.dst adst FROM flights a JOIN flights b ON a.dst = b.dst ORDER BY total) d group by adst order by mttl;
SELECT u.Userid, u.Name, MAX(S.Salary) FROM Usertable u LEFT JOIN Salarytable s ON u.Userid = s.userid GROUP BY u.userid, u.name
SELECT party_code, 1 + ROW_NUMBER() OVER (ORDER BY party_code) AS [serial number] FROM myTable ORDER BY party_code
<?xml version="1.0" encoding="utf-8"?> <languages> <language name="SCLEX_MYSQL"> <!-- This is the base language setting. It's usually not directly used, but provides values shared by more specialized MySQL versions. --> <!-- Lexer properties --> <property name="fold" value="1" /> <property name="fold.compact" value="0" /> <property name="fold.comment" value="1" /> ... <style id="1" fore-color="#A0A0A0" /> <!-- SCE_MYSQL_COMMENT --> <style id="2" fore-color="#A0A0A0" /> <!-- SCE_MYSQL_COMMENTLINE --> ... </language> ... </languages>
SELECT DISTINCT p.*, m.MemberID, m.FirstName + ' ' + m.LastName AS ProjectManager FROM Project p INNER JOIN Iterations i ON p.ProjectID = i.ProjectID INNER JOIN ProjectIterationMember pim1 ON i.ProjectIterationId = pim1.ProjectIterationID INNER JOIN Member m ON pim1.ProjectIterationMemberID = m.MemberID AND m.CompanyRole = 'Project Manager' INNER JOIN ProjectIterationMember pim2 ON i.ProjectIterationId = pim2.ProjectIterationID AND pim2.ProjectIterationMemberID = ? WHERE p.CompanyID = ? ORDER BY p.StartDate DESC
CREATE TABLE Loan ( LoanID INTEGER NOT NULL PRIMARY KEY , BranchID INTEGER NOT NULL CONSTRAINT tl_fk_branchid REFERENCES Branch(BranchID) ON DELETE CASCADE , LoanNumber CHAR(20) NOT NULL CONSTRAINT tl_u_loannumber UNIQUE -- right padded to length of 20 with blanks , LoanType VARCHAR2(30) NOT NULL , Amount Number(*,4) NOT NULL -- cf. http://stackoverflow.com/a/29014422, changed per @BobJarvis' comment , ModifiedDate DATE DEFAULT SYSDATE );
1997-12-31 23:59:59.999,kishore 2014-12-31 23:59:59.999999,manish create table mytable_tmp(mytime string,myname string) row format delimited fields terminated by ','; load data local inpath 'input.txt' overwrite into table mytable_tmp; create table mytable(myname string,mytimestamp string) PARTITIONED BY (mydate string) row format delimited fields terminated by ','; SET hive.exec.dynamic.partition = true; SET hive.exec.dynamic.partition.mode = nonstrict; INSERT OVERWRITE TABLE mytable PARTITION(mydate) SELECT myname,mytime,to_date(mytime) from mytable_tmp; select * from mytable where mydate='2014-12-31'; manish 2014-12-31 23:59:59.999999 2014-12-31
select pt.*, row_number() over (partition by code order by code) as Position from PositionTest pt
select t.name As TriggerName, ss.name As SchemaName, so2.name As TableName from sys.triggers t Join sysobjects so On t.object_id = so.id Join sysobjects so2 On so.parent_obj = so2.id Join sys.schemas ss On so2.uid = ss.schema_id Where t.name = 'NAME'
select classes, id, value, sum(value) over (partition by classes order by id) as cumesum from t;
SELECT ... FROM MyTable WHERE Id < (SELECT MAX(Id) FROM MyTable)
SELECT calendar_date FROM (SELECT calendar_date, ROW_NUMBER() OVER(ORDER BY calendar_date DESC) as rownum FROM Calendar WHERE calendar_date < CURRENT_DATE AND business_day = 'Y') c WHERE ROW_NUM = 3
SELECT a.Employee_ID, a.Accept_International_Assignment, a.Plan_Year FROM dbo.v_sc08_CD_Employee_Availabilities a INNER JOIN (SELECT Employee_ID, MAX(Plan_Year) maxPlanYear from dbo.v_sc08_CD_Employee_Availabilities GROUP BY Employee_ID) m ON a.Plan_Year = m.maxPlanYear AND a.Employee_ID = m.Employee_ID
SELECT Avg(Value), Max(Value), Min(Value) FROM tableName
{ "stuffA": 415125, "OnSwitch" : {"A" , "C"}, "OffSwitch" : {"C"} }
INSERT INTO Table2 (CUSTOMER_ID, MERCHANT_ID, col1, col2, etc...) SELECT t3.ID, t4.ID, t1.col1, t2.col2, etc.. FROM Table1 t1 INNER JOIN Table3 t3 ON t1.CUSTOMER = t3.CUSTOMER_DESC INNER JOIN Table4 t4 ON t1.MERCHANT = t4.MERCHANT_DESC
DECLARE @date DATETIME = GETDATE() WHILE @date > DATEADD(year,-1,GETDATE()) BEGIN --do marvelous things SET @date = DATEADD(MONTH,-1,@date) END
procedure TCustForm.yourQueryCalcField(DataSet : TDataset); begin DataSet.FieldByName('Cost').AsCurrency := DataSet.FieldByName('Price').AsCurrency* DataSet.FieldByName('Quantity').AsInteger; end;
SELECT t1.* FROM table_name t1 WHERE NOT EXISTS (select 1 from tablename t2 where t2.project = t1.project and t2.report_date < t1.report_date and t2.percentage_complete = 100)
UPDATE SPORTS SET matchup = REPLACE(matchup, 'Manchester United', 'Man Utd')
SELECT * FROM table2 WHERE obj2.param1 IN ( SELECT obj1.param1 FROM table1 WHERE... GROUP BY obj1.param1 HAVING COUNT(*) = 1 )
INSERT INTO [Vendor List] ([Vendor Number], [Vendor Name]) SELECT nv.[Vendor Number], nv.[Vendor Name] FROM 2_Onbase_NewVendors nv LEFT JOIN [Vendor List] vl ON nv.[Vendor Number] = vl.[Vendor Number] WHERE vl.[Vendor Number] IS NULL
SET @player_ID = 0; -- <<== the playerID SELECT a.*, b.*, 'player' Status -- this is the first part of the union FROM game a -- which gets all the game of INNER JOIN game_player b -- the selected player and its info ON a.id_game = b.id_game WHERE id_player = @player_ID UNION ALL SELECT d.*, c.*, 'opponent' status FROM game_player c INNER JOIN ( SELECT a.* FROM game aa INNER JOIN game_player bb ON aa.id_game = bb.id_game WHERE bb.id_player = @player_ID ) d ON c.id_game = d.id_game AND c.id_player <> @player_ID ORDER BY id_game, status
select item from data,generate_series(0,1000) where generate_series<qty order by item;
SELECT * FROM `articles` WHERE `body` REGEXP '[[:<:]][acgj]'
SELECT * FROM (select user_id, prod_and_ts.product_id as product_id, regex_replace(prod_and_ts.timestamps, "#\\d*", "") as timestamps FROM table2 LATERAL VIEW explode(purchased_item) exploded_table as prod_and_ts) prod_and_ts;
SELECT BookID, Price, ISBN, Pages FROM ( SELECT BookID, Key, Value FROM yourTable ) AS SourceTable PIVOT ( SUM(Value) FOR Key IN (Price, ISBN, Pages) ) AS PivotTable ORDER BY BookID
select /* index_ffs (a [name of index]) */ id, rowid from a where id is not null order by id, rowid;
@newnumber = number.find(:all, :conditions => ["id = ?", @dictionary.id], :select => "number * 2 as newnumber") @newnumber = number.all(:conditions=>"id='#{@dictionary.id}'",:select=>"number * 2 as newnumber")
select USERNAME from ACCESSACTIVITY where UPPER(LOCATION)=UPPER('remote-PC')and DATE(TIMESTAMP) = STR_TO_DATE('28-05-2016 ','%d-%m-%Y')
SELECT inv_nr, inv_date, inv_customer FROM invoice i WHERE NOT EXISTS(SELECT 1 FROM cancel_invoice c WHERE c.inv_nr = i.inv_nr)
SELECT AR.* FROM stats3_last_join AR INNER JOIN (SELECt max(value) mv, uuid FROM stats3_last_Join GROUP BY uuid) MaxOnly on MaxOnly.mv= AR.Value and MaxOnly.uuid = AR.Uuid
SELECT tblMyFriends.FriendID, tblMyFriends.GroupID, tblMessages.MyMessage, MAX(tblMessages.MyTime) FROM tblMyFriends LEFT JOIN tblMessages ON COALESCE(tblMyFriends.FriendID, tblMyFriends.GroupID) = COALESCE(tblMessages.FriendID, tblMessages.GroupID) GROUP BY tblMyFriends.FriendID, tblMyFriends.GroupID
public void TreeView_Droped (object sender, RoutedEventArgs e) { //Do some work UpdateMyDataSource(sender, e, [another_fields_you_need]); }
SELECT a.ORDER_NO, a.RELEASE_NO, a.SEQUENCE_NO, b.C_OPERATION_SEQUENCE as OP_SEQ, b.OPERATION_NO, b.OP_ID, NVL(c.GUIDELINE_TEXT,'Nothing to see, move along') AS GUIDELINE_TEXT
SELECT employee.pin, CASE WHEN gender='M' THEN CONCAT_WS(' ', 'Mister', employee.titel, person.fname) WHEN gender='W' THEN CONCAT_WS(' ', 'Mrs', employee.titel, person.fname) END AS salutation FROM person INNER JOIN employee ON person.pin=employee.pin ORDER BY pin
db.execute("UPDATE ...") if db.affected_rows == 0: db.execute("INSERT ...")
select T1.* from table t1 LEFT JOIN table t2 ON t1.type = t2.type and t1.created < t2.created where t2.id is null
select 'Table' AS object_type, table_name from all_tables where owner = '<owner>' UNION ALL select 'View' AS object_type, view_name from all_views where owner = '<owner>' order by table_name;
this.ReportViewer1.ShowToolBar = false;
CREATE PROCEDURE ProcName @chklname bit, @chkfname bit, @chkcity bit, @chkmobile bit AS BEGIN SET NOCOUNT ON; --Only execute the statement if at least one of the checkboxes are set if @chklname = 1 or @chkfname = 1 or @chkcity =1 or @chkmobile =1 begin declare @sqlcommand nvarchar(max) set @sqlcommand = N'Select ' if @chklname = 1 set @sqlcommand += N'FirstName ' if @chkfname = 1 begin if len(@sqlcommand) > 1 set @sqlcommand += N',' set @sqlcommand += N'LastName ' end if @chkcity = 1 begin if len(@sqlcommand) > 1 set @sqlcommand += N',' set @sqlcommand += N'City ' end if @chkmobile = 1 begin if len(@sqlcommand) > 1 set @sqlcommand += N',' set @sqlcommand += N'Mobile ' end set @sqlcommand += N' FROM table1' exec sp_executesql @statement = @sqlcommand end END GO
UPDATE U SET U.Units = U.Units + CI.ItemUnits FROM @CurrentItems CI INNER JOIN U ON U.UId=CI.ItemId;
SELECT ID, WeeklyAvg, MonthlyAvg FROM ( SELECT ID, WeeklyAvg, MonthlyAvg, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY ID) RowNum FROM {table} ) A WHERE RowNum = 1
Declare @s varchar(100) = '/ABCDEF/ABCDEF/ABC/8921/154535' select REVERSE(SUBSTRING(REVERSE(@s),0,CHARINDEX('/',REVERSE(@s))))
SELECT Room_Type, COUNT(*) AS NumarRezervari FROM dbo.Reservation re JOIN dbo.Room ro ON ro.RoomID = re.RoomID JOIN dbo.Room_Type rt ON rt.Room_Type_ID = ro.Room_Type_ID WHERE MONTH(re.Data_Check_in) = 5 GROUP BY Room_Type
source ~/.bashrc
INSERT INTO MyTable (col1, col2) SELECT 'foo' AS col1, * FROM OPENROWSET(BULK N'c:\foo.bin', SINGLE_BLOB) AS col2
SELECT * FROM x WHERE name IN ('Jon', 'Peter', 'Paul')
create table #table (name varchar(30),[order] varchar(10),id varchar(3)) DECLARE @name varchar(30), @id int DECLARE curs_Fp CURSOR FOR SELECT c.name, c.id FROM customer c OPEN curs_Fp FETCH NEXT FROM curs_Fp INTO @name, @id WHILE @@FETCH_STATUS = 0 BEGIN insert into #table SELECT @name, @id ,'' insert into #table SELECT '',o.[order],o.id FROM ORDER o where o.id = @id FETCH NEXT FROM curs_Fp INTO @name, @id END CLOSE curs_Fp DEALLOCATE curs_Fp select * from #table drop table #table
public class PricingTablePackages { public int ID { get; set; } public int PricingTableID { get; set; } public virtual PricingTable PricingTable { get; set; } public string Title { get; set; } public decimal Price { get; set; } public decimal PricePerTime { get; set; } public string Info { get; set; } public bool Flag { get; set; } public string Link { get; set; } } public class PricingTablePackagesFeatures { public int ID { get; set; } public int PricingTableID { get; set; } public virtual PricingTable PricingTable { get; set; } public string Feature { get; set; } public string Value { get; set; } public string MoreInfo { get; set; } } public class PricingTable { public int ID { get; set; } public string Name { get; set; } public int ServiceID { get; set; } public virtual Service Service { get; set; } // if there is a Service class public string Style { get; set; } }
WITH daily_count AS -- temp table to store daily counts ( SELECT parking_meter_id, COUNT(*) AS cnt, to_char(start,'YYYYMMDD') AS day FROM parking_transactions WHERE start >= now() - interval '3 month' -- last three months AND to_char(start,'D') = to_char(now(),'D') -- same weekday AND to_char(now(),'HH24MISS') BETWEEN to_char(start,'HH24MISS') AND to_char(stop,'HH24MISS') -- same time GROUP BY parking_meter_id, to_char(start,'YYYYMMDD') -- group by parking meter id and day ), avg_count_minus_today AS -- temp table to store avg count minus today ( SELECT parking_meter_id, AVG(cnt) AS avg_count FROM daily_count WHERE day < to_char(now(),'YYYYMMDD') -- but not today GROUP BY parking_meter_id ) SELECT a.parking_meter_id, a.avg_count, --avg count minus today d.cnt AS today_count FROM avg_count_minus_today a INNER JOIN daily_count d ON a.parking_meter_id= d.parking_meter_id AND d.day=to_char(now(),'YYYYMMDD'); --today in daily count
create table #t (col1 real, col2 real, col3 real) select checksum(*) from #t if @@rowcount = 0 print 'All values are NULL' else print 'Non-NULL value(s) found' drop table #t
DECLARE @Columns NVARCHAR(MAX)='', @Query NVARCHAR(MAX)='' DECLARE @CastColumns NVARCHAR(MAX)='' SELECT @Columns = @Columns + QUOTENAME(COLUMN_NAME) + ',', @CastColumns = @CastColumns+CASE WHEN data_type <> 'float' THEN 'CAST('+QUOTENAME(COLUMN_NAME)+' AS FLOAT) AS '+QUOTENAME(COLUMN_NAME) ELSE QUOTENAME(COLUMN_NAME) END+',' FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'YourTable' ORDER BY ORDINAL_POSITION SET @Columns = LEFT(@Columns,LEN(@Columns)-1) SET @CastColumns = LEFT(@CastColumns,LEN(@CastColumns)-1) SET @Query = ' SELECT ROW_NUMBER() OVER(ORDER BY CO.Ordinal_Position) Id, ColumnName, Value FROM (SELECT '+@CastColumns+' FROM YourTable) AS P UNPIVOT(value FOR ColumnName IN ('+@Columns+')) AS UC JOIN (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ''YourTable'') CO ON ColumnName = CO.COLUMN_NAME ' INSERT INTO @TTABLE EXEC sp_executesql @Query
SELECT price_est.sau_price_avg INTO _est_price FROM price_est WHERE (price_est.neighbourhood_id = _neighbourhood_id OR price_est.neighbourhood_id IS NULL) AND price_est.district_id = _district_id AND price_est.municipality_id = _municipality_id AND price_est.county_id = _county_id ORDER BY price_est.neighbourhood_id NULLS LAST LIMIT 1;
with subquery1 as (select /*big query*/ ), subquery2 as (select /*big query*/ ) select * from ... join subquery1 where foo in (select foo from subquery2)
select sku, catalogname, getdate() from ( select sku, catalogname, categoryname, parentOID from uswebdb.commerce.catalogproducts union all select sku, catalogname, categoryname, parentOID from ukwebdb.commerce.catalogproducts ) F where (F.CategoryName is not null or F.ParentOID = 113) and (F.sku not like '%[a-z]%')
SELECT AssetID_1, AssetID_2, ((psum - (sum1 * sum2 / n)) / sqrt((sum1sq - sum1*sum1 / n) * (sum2sq - sum2*sum2 / n))) AS [Correlation Coefficient], n FROM (SELECT n1.AssetClass_ID AS AssetID_1, n2.AssetClass_ID AS AssetID_2, SUM(n1.RunResults_Value) AS sum1, SUM(n2.RunResults_Value) AS sum2, SUM(n1.RunResults_Value * n1.RunResults_Value) AS sum1sq, SUM(n2.RunResults_Value * n2.RunResults_Value) AS sum2sq, SUM(n1.RunResults_Value * n2.RunResults_Value) AS psum, COUNT(*) AS n FROM dbo.tbl_RunResults AS n1 LEFT JOIN dbo.tbl_RunResults AS n2 ON n1.Simulation_ID = n2.Simulation_ID WHERE n1.AssetClass_ID < n2.AssetClass_ID AND n1.series_ID = 2332 AND n2.series_ID = 2332 GROUP BY n1.AssetClass_ID, n2.AssetClass_ID) AS step1 ORDER BY AssetID_1
DECLARE @id int; SET @id = (select top(1) id from [table] where [x] = 0 order by id desc); select * from [table] where id = @id; update [table] set [x] = 20 where id = @id;
my $rs = My::Schema->resultset('Students') # ->search({ status => 6, grad_date => { 'between' => [ $start_dt, $end_dt ] }, }); my $num_grads = $rs->count(); my $num_employed = $rs->search({ employment_status => 1 })->count();
select somevalue1,somevalue2,somevalue3,value1_t1,value2_t1,cast(null as int) as value2_t2,cast(null as int) as value3_t2 from table1 union all select somevalue1,somevalue2,somevalue3,null,null,value2_t2,value3_t2 from table2
select * from (select row_number() over (ORDER BY cars.CarId) as Row, * from cars ) temp where Row between 20 and 29
select item_id , title , description , sum(votes) as totalVotes from items left join votes on items.item_id = votes.item_id group by votes.item_id order by item_id desc
Select count(*) as rows, month(create_datetime) as month, year(create_datetime) as year FROM [table_name] WHERE year(create_datetime) BETWEEN 1999 AND 2014 GROUP BY month(create_datetime), year(create_datetime)
SELECT Product FROM ProductWeek GROUP BY Product HAVING COUNT(*) = (SELECT COUNT(*) from (SELECT distinct weekending from ProductWeek ) as t);
Select type1,type2,code,Max(Amt) Over(PARTITION BY Code) AS MaxAmt from Table1
tblMember memberID memberName tblEvent eventID eventType eventDate tblAttendance memberID eventID
select t1.* from your_table t1 join ( select entity, department, max(Code_count) as Code_count from your_table group by entity, department ) t2 on t1.entity = t2.entity and t1.department = t2.department and t1.Code_count = t2.Code_count
jdbc:macromedia:oracle:TNSNamesFile=C:\\Oracle\\product\\11.2.0\\client_1\\network\\admin\\tnsnames.ora; TNSServerName=tnsentry
Select e.* From employee e Where Not Exists ( Select 1 From employee_roles r Where r.employee_id = e.employee_id And r.role_id = 5330 )
SELECT 'abc' AS C1, 1 AS NO FROM DUAL UNION SELECT c1 AS C1, 2 AS NO FROM t2 ORDER BY NO;
Mid([X], InStr([X], "\") + 1)
INSERT INTO tForeignLanguage ([Name]) VALUES (N'Араб')
select tablename, count(*) from (select 'table1' as tablename, someid from table1 union all select 'table2' as tablename, someid from table2 ) t where someid in ('1815972751', '1815751159', '1815752967', '1815756079') group by tablename;
Select * from tbl_Events where startDate <= @end AND @start <= EndDate
DECLARE @TEMP_TBL TABLE (COL1 INT, COL2 VARCHAR(100)) INSERT INTO @TEMP_TBL select ID, NAME FROM TB1
with virtualTable as( SELECT ... FROM [...] UNION SELECT ... FROM [...] ) select vt1.field, vt2.field from virtualTable vt1 join virtualTable vt2 on vt1.someField = vt2.otherField
CREATE TABLE TableName ( UID INT AUTO_INCREMENT PRIMARY KEY, -- other columns... )
SELECT o.Id, o.attrib1, o.attrib2 FROM table1 o JOIN ( SELECT DISTINCT Id FROM table1, table2, table3 WHERE ... ) T1 ON o.id = T1.Id
SELECT DISTINCT releases.* FROM releases INNER JOIN artist_love ON releases.all_artists LIKE CONCAT('%',artist_love.artist,'%') AND artist_love.user = 'Quickinho' INNER JOIN label_love ON label_love.label = releases.label_no_country AND label_love.user = 'Quickinho' left join charts_extended on charts_extended.release_id=label_love=releases.id and charts_extended.artist = 'Quickinho' where charts_extended.release_id is null ORDER BY releases.date DESC LIMIT 0 , 102
SELECT workingDate as [date], openTime as [Start], COALESCE(breakStart, closeTime) as [End] FROM workingSchedule LEFT JOIN ( SELECT breakDate, breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM FROM breakTable ) as firstBreak ON workingSchedule.workingDate = firstBreak.breakDate AND firstBreak.ROWNUM = 1 UNION SELECT breakStart.breakDate, breakStart.breakEnd, coalesce(breakEnd.breakStart, endTime.closeTime) FROM ( SELECT breakDate, breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM FROM breakTable ) as breakStart LEFT JOIN ( SELECT breakDate, breakStart, breakEnd, ROW_NUMBER() OVER (PARTITION BY breakDate ORDER BY breakStart) AS ROWNUM FROM breakTable ) as breakEnd ON breakStart.breakDate = breakEnd.breakDate AND breakStart.ROWNUM = breakEnd.ROWNUM - 1 LEFT JOIN ( SELECT workingDate, closeTime FROM workingSchedule ) AS endTime ON breakStart.breakDate = endTime.workingDate
DECLARE @t TABLE (AMID INT, Entry VARCHAR(100)) INSERT @t VALUES ( 1000 ,'MARS'), ( 1001 ,'JUPITER'), ( 1002 ,'SATURN'), ( 1003 ,'VENUS'), ( 1003 ,'SATURN'), ( 1004 ,'NEPTUNE'), ( 1004 ,'SATURN'), ( 1005 ,'JUPITER'), ( 1005 ,'MARS') ;WITH a AS( SELECT *, ROW_NUMBER() OVER (PARTITION BY AMID ORDER BY CASE Entry WHEN 'VENUS' THEN 0 WHEN 'MARS' THEN 1 WHEN 'JUPITER' THEN 2 WHEN 'SATURN' THEN 3 WHEN 'NEPTUNE' THEN 4 END) num FROM @t ) SELECT AMID, Entry FROM a WHERE num = 1
;WITH CTE AS ( SELECT ROW_NUMBER() OVER(PARTITION BY tblB.[No] ORDER BY tblB.[Date]) AS RowNbr, tblB.* FROM B AS tblB ) SELECT * FROM A AS tblA LEFT JOIN CTE ON tblA.No=CTE.No AND CTE.RowNbr=1
SELECT my_Group, my_sum, my_sum/my_total as my_Percent FROM( SELECT categories.cat AS my_Group, SUM(atual) AS my_sum FROM `table1` INNER JOIN categories ON table1.category_id=categories.id GROUP BY categoria ) as t LEFT JOIN ( SELECT SUM(atual) as my_total FROM `table1` ) as t1
select t.visitty, t.specialty, t.doctors from table t join (select specialty, sum(doctors) as numdoctors from table t group by specialty ) tsum on t.specialty = tsum.specialty order by tsum.doctors desc, tsum.specialty, t.doctors desc;
CREATE VIEW T4 AS SELECT T1.a, T3.d FROM T1 JOIN T2 ON T1.b = T2.b JOIN T3 ON T2.c = T3.c
regexp_replace(yourValue,'(XX)0([0-4])(*)', '\1\2\3')
select book_num, t.booktype, x.avgcost, bookcost, x.avgcost-bookcost from tablename t join (select booktype, avg(bookcost) as avgcost from tablename group by booktype) x on t.booktype = x.booktype
select (case when count(*) = count(a.DateTimeChangedUtc) and count(*) = count(b.DateTimeChangedUTC) then SUM(DATEDIFF(SECOND, a.DateTimeChangedUtc, b.DateTimeChangedUTC)) end) AS TimeSpentSeconds
create table tmp (a int primary key, b int) GO create trigger tr_insupd_tmp on tmp instead of insert, update as if not exists(select * from deleted) -- Process Insert insert into tmp select a, 1 from inserted else -- Process Update update tmp set b = 2 from tmp t inner join inserted i on t.a = i.a GO
select t1.[Fiscal Year],t1.Value,(t1.[Fiscal Year]-1) [previous_year],t2.Value [previous_value] from ( select [Fiscal Year], sum([value]) value from [table1] group by [Fiscal Year] )t1 LEFT JOIN ( select [Fiscal Year], sum([value]) value from [table1] group by [Fiscal Year] )t2 ON t1.[Fiscal Year]=t2.[Fiscal Year]+1
select t.*, count(*) over (partition by EmpId) as Count from table t;
SELECT username, email FROM users WHERE (username LIKE '%bla%' or username like '%bla2%' or username like '%bla3%') AND last_visit > '2013-05-15 00:00:00'";
SELECT null as Status, sum(IIF(layer='key info',1,0)) AS [Key Info], sum(IIF(layer='approaches',1,0)) AS [Approaches], sum(IIF(layer='research',1,0)) AS [Research] FROM resources WHERE (literacy OR numeracy OR poverty) UNION SELECT [copyright status], sum(IIF(layer='key info',1,0)) AS [Key Info], sum(IIF(layer='approaches',1,0)) AS [Approaches], sum(IIF(layer='research',1,0)) AS [Research] FROM resources WHERE (literacy OR numeracy OR poverty) GROUP BY [copyright status] UNION SELECT [lw status], sum(IIF(layer='key info',1,0)) AS [Key Info], sum(IIF(layer='approaches',1,0)) AS [Approaches], sum(IIF(layer='research',1,0)) AS [Research] FROM resources WHERE (literacy OR numeracy OR poverty) AND [lw status] = 'In Reserve' GROUP BY [lw status] UNION SELECT [lw status], sum(IIF(layer='key info',1,0)) AS [Key Info], sum(IIF(layer='approaches',1,0)) AS [Approaches], sum(IIF(layer='research',1,0)) AS [Research] FROM resources WHERE (literacy OR numeracy OR poverty) AND [lw status] = 'Published' GROUP BY [lw status];
CREATE PROC #bar AS SELECT * FROM sys.objects EXEC ('SELECT * FROM sys.objects') GO CREATE PROC #foo AS SET ROWCOUNT 1 EXEC #bar GO SET ROWCOUNT 4 EXEC #foo /*Returns 2 resultsets with 1 row*/ EXEC #bar /*Returns 2 resultsets with 4 rows*/ DROP PROC #foo DROP PROC #bar
SELECT M.*, Data.* FROM [Measure] M CROSS APPLY (SELECT TOP 1 EV.* FROM [Event] E JOIN EventValues EV ON E.EventID = EV.EventID WHERE M.Time >= E.Time ORDER BY E.Time DESC) AS Data ORDER BY M.Distance
SET DATEFIRST 7; DECLARE @Date DATETIME = '20120101'; DECLARE @Dates TABLE ( Date DATE, MonthNum INT, MonthName VARCHAR(15), DayNum INT, MonthStart DATE, Day VARCHAR(2) ); WITH Dates AS ( SELECT [Date] = DATEADD(DAY, ROW_NUMBER() OVER(ORDER BY Object_ID) - 8, @Date) FROM sys.All_Objects ) INSERT @Dates (Date, MonthNum, MonthName, DayNum, MonthStart, Day) SELECT Date, [MonthNum] = DATEPART(MONTH, Date), [MonthName] = LEFT(DATENAME(MONTH, Date), 3), [DayNum] = DATEPART(WEEKDAY, Date), [MonthStart] = DATEADD(MONTH, DATEDIFF(MONTH, 0, d1.Date), 0), [Day] = CONVERT(VARCHAR(2), DATEPART(DAY, Date)) FROM Dates d1 WHERE Date < DATEADD(YEAR, 1, @Date); WITH Calendar AS ( SELECT MonthName, MonthNum, [Identifier] = CONVERT(VARCHAR(1), DayNum) + CONVERT(VARCHAR(1), Occurance), [Day] FROM @Dates d1 CROSS APPLY ( SELECT [Occurance] = COUNT(*) FROM @Dates d2 WHERE d2.Date >= DATEADD(DAY, 1 - DATEPART(WEEKDAY, d1.MonthStart), d1.MonthStart) AND d2.Date <= d1.Date AND d1.DayNum = d2.DayNum ) o WHERE d1.Date >= @Date UNION ALL SELECT [MonthName] = LEFT(DATENAME(MONTH, '2012' + RIGHT('0' + CONVERT(VARCHAR(2), MonthNumber), 2) + '01'), 3), MonthNumber, [ID] = DayNumber + Occurance, [Day] = '' FROM (VALUES ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7')) AS d (DayNumber) CROSS JOIN (VALUES ('1'), ('2'), ('3'), ('4'), ('5'), ('6')) AS o (Occurance) CROSS JOIN (VALUES (1), (2), (3), (4), (5), (6), (7), (8), (9), (10), (11), (12)) AS m (MonthNumber) ) SELECT [MonthName], [Sun] = [11], [Mon] = [21], [Tues] = [31], [Wed] = [41], [Thu] = [51], [Friday] = [61], [Sat] = [71], [Sun] = [12], [Mon] = [22], [Tues] = [32], [Wed] = [42], [Thu] = [52], [Friday] = [62], [Sat] = [72], [Sun] = [13], [Mon] = [23], [Tues] = [33], [Wed] = [43], [Thu] = [53], [Friday] = [63], [Sat] = [73], [Sun] = [14], [Mon] = [24], [Tues] = [34], [Wed] = [44], [Thu] = [54], [Friday] = [64], [Sat] = [74], [Sun] = [15], [Mon] = [25], [Tues] = [35], [Wed] = [45], [Thu] = [55], [Friday] = [65], [Sat] = [75], [Sun] = [16], [Mon] = [26], [Tues] = [36], [Wed] = [46], [Thu] = [56], [Friday] = [66], [Sat] = [76] FROM Calendar PIVOT ( MAX([Day]) FOR [Identifier] IN ( [11], [21], [31], [41], [51], [61], [71], [12], [22], [32], [42], [52], [62], [72], [13], [23], [33], [43], [53], [63], [73], [14], [24], [34], [44], [54], [64], [74], [15], [25], [35], [45], [55], [65], [75], [16], [26], [36], [46], [56], [66], [76] ) ) AS pvt ORDER BY MonthNum;
CREATE FUNCTION dbo.CostAtDate ( @costdate AS datetime , @product AS int ) RETURNS table AS Return ( Select Top 1 BASE_InventoryCostLogDetail.AverageCostAfter From BASE_InventoryCostLogDetail Where CreatedDttm < @costdate And CreatedDttm > DATEADD(month,-1,@costDate) And ProdId = @product Order By CreatedDttm Desc)
SELECT REPLACE(REPLACE(REPLACE(`phone`, '-', ''), ' ', ''),'"','') AS `phone_number` FROM `table`;
INSERT INTO table_name( id , name ) SELECT id, name FROM temp_table; TRUNCATE TABLE temp_table;
SELECT a.*, b.column1, b.column2, ... FROM Table_1 a JOIN Table_2 b on a.ID=b.ID UNION SELECT a.*, '' AS column1, '' AS column2, ... FROM Table_1 a WHERE a.ID NOT IN (SELECT a.ID FROM Table_1 a JOIN Table_2 b on a.ID=b.ID);
select MONTH(DATE) As "Month" from DW******.SL**** Group By MONTH(DATE) Order by MONTH(DATE)
SELECT id , GREATEST(field1, field2) max_val , CASE WHEN field1 >= field2 THEN 2 ELSE 3 END col_idx FROM my_table
tbl_name (name_id, name) tbl_location (locaiton_id, location) tbl_name_location (name_id, location_id)
SELECT s.userid, 'Sell' as type, s.ProductId, s.ProductName, s.ProductPrice FROM Sell s WHERE UserId = 1 UNION ALL SELECT p.userid, 'Purchase' as type, p.ProductId, p.ProductName, p.ProductPrice FROM Purchase P WHERE UserId = 1
SELECT Document.* FROM Document INNER JOIN DocumentField ON Document.DocumentKey = DocumentField.DocumentKey WHERE (DocTypeKey IS NOT NULL) AND Document.DocumentKey IN ( SELECT DocumentKey FROM DocumentField WHERE FieldId = '1' AND FieldValue LIKE 'PO1%' INTERSECT SELECT DocumentKey FROM DocumentField WHERE FieldId = '2' AND FieldValue LIKE 'INV1%' )
SELECT CASE WHEN COALESCE(A1,0)<>1 AND COALESCE(A2,0)<>1 AND COALESCE(A3,0)<>1 AND COALESCE(A4,0)<>1 AND COALESCE(A5,0)<>1 THEN 1 ELSE '' END A , CASE WHEN COALESCE(A1,0)<>2 AND COALESCE(A2,0)<>2 AND COALESCE(A3,0)<>2 AND COALESCE(A4,0)<>2 AND COALESCE(A5,0)<>2 THEN 2 ELSE '' END B , CASE WHEN COALESCE(A1,0)<>3 AND COALESCE(A2,0)<>3 AND COALESCE(A3,0)<>3 AND COALESCE(A4,0)<>3 AND COALESCE(A5,0)<>3 THEN 3 ELSE '' END C , CASE WHEN COALESCE(A1,0)<>4 AND COALESCE(A2,0)<>4 AND COALESCE(A3,0)<>4 AND COALESCE(A4,0)<>4 AND COALESCE(A5,0)<>4 THEN 4 ELSE '' END D , CASE WHEN COALESCE(A1,0)<>5 AND COALESCE(A2,0)<>5 AND COALESCE(A3,0)<>5 AND COALESCE(A4,0)<>5 AND COALESCE(A5,0)<>5 THEN 5 ELSE '' END E FROM NumTest WHERE COALESCE(A1,0)+COALESCE(A2,0)+COALESCE(A3,0)+COALESCE(A4,0)+COALESCE(A5,0)<>15
SELECT a.id, a.shipmentNo, a.status, a.date FROM (SELECT a.id, a.shipmentNo, a.status, a.date FROM shipment a ORDER BY a.shipmentNo, FIELD(a.status, 'S', 'I') WHERE a.date = '2013-12-12' ) A GROUP BY a.shipmentNo
SELECT l.* FROM listings l LEFT JOIN addresses a_l ON a_l.addressable_id = l.id AND a_l.addressable_type = "App\\Listing" AND a_l.suburb = "Melbourne" LEFT JOIN addresses a_u ON a_u.addressable_id = l.user_id AND a_u.addressable_type = "App\\User" AND a_u.suburb = "Melbourne" WHERE a_l.id IS NOT NULL OR a_u.id IS NOT NULL
(case when left(str1, 10) = left(str2, 10) then 10 when left(str1, 9) = left(str2, 9) then 9 ... when left(str1, 1) = left(str2, 1) then 1 else 0 end)
create table #T (s varchar(128)) declare @T table (s varchar(128)) insert into #T select 'old value #' insert into @T select 'old value @' begin transaction update #T set s='new value #' update @T set s='new value @' rollback transaction select * from #T select * from @T
SELECT * FROM ( .... ) YourQuery WHERE Disponible='Si';
select brand_name, count(*) AS num from (select SUBSTRING_INDEX(new_name, ':', 1) as brand_name from table WHERE date<='".$american_today."' AND date>= '".$two_weeks_ago."' GROUP BY day(date), products_id) as brands group by brand_name ORDER BY num DESC LIMIT 5
SELECT ids.id FROM (SELECT 2 AS id UNION SELECT 3 UNION SELECT 4) AS ids LEFT OUTER JOIN products ON ids.id = products.id WHERE products.id IS NULL
SELECT [TableName] = so.name, [RowCount] = MAX(si.rows) FROM sysobjects so, sysindexes si WHERE so.xtype = 'U' AND si.id = OBJECT_ID(so.name) GROUP BY so.name ORDER BY 2 DESC
SELECT a.*, c.* -- <<== select the columns you want to display FROM Users a INNER JOIN UserTagLink b ON a.UserID = b.UserID INNER JOIN Tags c ON b.TagID = c.TagID
select * from ( SELECT pictures.id, ts_rank_cd(to_tsvector('english', pictures.title), to_tsquery('small dog')) AS score FROM pictures ) s WHERE score > 0 ORDER BY score DESC
insert into table1(col1, col2, col3) select 1, col2, 0 from <your other query here>;
Delete From StudentTb Where StudentType in (1, 2) and StudentI in ( select StudentI from StudentTb except Select StudentI From StudentLog )
SELECT Tot = ISNULL(Val1, 0) + ISNULL(Val2, 0) FROM Table
SELECT * FROM Table_1 AS t1 LEFT OUTER JOIN Table_2 AS t2 ON t1.firstname = t2.firstname AND t1.lastname = t2.lastname WHERE t2.firstname IS NULL AND t2.lastname IS NULL
.Parameters.Add(New OracleParameter("vinspectiondatetime", OracleClient.OracleType.DateTime)).Value = new DateTime(2010, 2, 5, 11, 46, 0)
SELECT CASE WHEN rn=1 THEN cnt END cnt, order_name, status FROM ( SELECT count(*) OVER (PARTITION BY status) cnt, ROW_NUMBER() OVER (PARTITION BY status ORDER BY order_name) rn, order_name,status FROM input_table )
SELECT p.id, p.name, group_concat(DISTINCT cat.name separator ',') as categories FROM places p LEFT JOIN places_categories_rel rel ON p.id=rel.place_id LEFT JOIN categories cat ON cat.id=rel.category_id WHERE EXISTS ( SELECT 1 FROM places_categories_rel pcr JOIN categories c ON c.id=pcr.category_id WHERE name = 'Lounge' AND p.id=pcr.place_id ) GROUP BY p.id
SELECT SELECT MAX(t1.ID) ,STUFF( (SELECT ','+Info3 FROM temp t WHERE t.Rank=A.RankFOR XML PATH('')) , 1 , 1 , '' ) FROM temp A GROUP BY A.Rank
SELECT id, p_id, offer FROM offers WHERE p_id = 1 order by offer desc limit 1
SELECT * FROM my_table ORDER BY id DESC LIMIT 10;
ORDER BY rand()*pow(<probability-field-name>,<n>)
;WITH x AS ( SELECT ID,NAME,[LAST NAME],PHONE,STATE, ROW_NUMBER() OVER (PARTITION BY NAME,[LAST NAME],PHONE ORDER BY ID DESC) FROM dbo.YourTable ) UPDATE x SET STATE = CASE rn WHEN 1 THEN NULL ELSE 'DUPE' END;
Convert MMM dd yyyy HH:MM[AM|PM] to dd/MM/yyyy hh:mm:ss Declare @Date VARCHAR(20) = 'Jan 27 2015 12:05AM' SELECT CONVERT(VARCHAR(10), CONVERT(DATETIME, @Date),103) + ' ' + CONVERT(VARCHAR(8), CONVERT(DATETIME, @Date),108) Result: 27/01/2015 00:05:00
set serveroutput on; declare XML CLOB; XML_DOCUMENT DBMS_XMLDOM.DOMDOCUMENT; XML_NODE DBMS_XMLDOM.DOMNODE; begin XML := ' <ROOT> <A> <B>2</B> <C>3</C> <D> <E>12</E> </D> <F/> <G/> </A> </ROOT> '; XML_DOCUMENT := DBMS_XMLDOM.NEWDOMDOCUMENT(XML); XML_NODE := DBMS_XMLDOM.MAKENODE(XML_DOCUMENT); XML_NODE := DBMS_XSLPROCESSOR.SELECTSINGLENODE(XML_NODE,'ROOT/A/B/text()'); IF(DBMS_XMLDOM.ISNULL(XML_NODE) = FALSE) THEN dbms_output.put_line(DBMS_XMLDOM.GETNODEVALUE(XML_NODE)); END IF; end;
SELECT k.name AS hicompany, count( * ) AS howmany FROM people p JOIN hicompany k ON p.id= k.id GROUP BY name ORDER BY COUNT(*) DESC
select t1.*, t2.dispatcher_id, t2.dispatcher_score, t2.dispatcher_score - t1.score as delta_score from ( select dispatcher_id, dispatcher_score, final_indx, rank() over (partition by final_indx order by dispatcher_score desc) as rnk from table2 ) t2 join table1 t1 on t1.res_score_id = t2.final_indx where t2.rnk = 1;
CREATE TABLE STUDENT (ID NUMBER(9), STUDENT_NAME VARCHAR2(500), CONSTRAINT PK_STUDENT PRIMARY KEY(ID)); -------- CREATE TABLE ATTENDANCE_TYPE (ID NUMBER(9), AT_DESCRIPTION VARCHAR2(250), CONSTRAINT PK_ATTENDANCE_TYPE PRIMARY KEY(ID)) ------------------------ CREATE TABLE ATTENDANCE( ID NUMBER(9), STUDENT_ID NUMBER(9), ATTENDANCE_DAY DATE, ATTENDANCE_TYPE_ID NUMBER(9), CONSTRAINT PK_ATTENDANCE PRIMARY KEY(ID), CONSTRAINT FK_ATTENDANCE_TYPE FOREIGN KEY (ATTENDANCE_TYPE_ID) REFERENCES ATTENDANCE_TYPE(ID), CONSTRAINT FK_STUDENT FOREIGN KEY (STUDENT_ID) REFERENCES STUDENT(ID)); --this gets the number of students late in Jan, Feb and March 1st this year SELECT COUNT(*) FROM student s JOIN attendance att ON s.ID = att.student_id WHERE att.attendance_type_id = 2 AND att.attendance_day BETWEEN TO_DATE('01-JAN-2016', 'DD-MON-YYYY') AND TO_DATE('01-MAR-2016', 'DD-MON-YYYY');
SELECT A.item_ID, A.item_name FROM A LEFT JOIN B ON A.item_ID = B.item_ID WHERE (B.option_ID=34 AND B.option_value BETWEEN 1000 AND 2000) OR (B.option_ID=12 AND B.option_value BETWEEN 0 AND 4000) GROUP BY A.item_ID HAVING COUNT(A.item_ID) >= 2
select t.*, (case when min(NumEmployees) over (partition by grp) = max(NumEmployees) over (partition by grp) then 1 else 0 end) as DerivedField from table t;
SELECT a,b,c, min(d) FROM myTable GROUP BY a,b,c ORDER BY a,b,c
select comp_id, app_id, cnt from (select t.*, row_number() over (partition by app_id order by cnt desc) as seqnum from (SELECT COMP_ID, APP_ID, count(*) as cnt FROM APP_ACCT_VIEW GROUP BY COMP_ID, APP_ID ) t ) t where seqnum = 1
SELECT (case when count(*) = count(oran*deger) then SUM(oran*deger/100) end) FROM @tablo;
select sector_id, count(distinct resort_id) as NumResorts, count(distinct country_id) as NumCountries from resorts group by sector_id;
SELECT name, (SELECT SUM(WarengruppeVK.netto) FROM Kunde JOIN PbsRow ON Kunde.PK = PbsRow.kunde JOIN WarengruppeVK ON PbsRow.PK = WarengruppeVK.pbsrow WHERE Kunde.admitarbeiter = Adm.PK AND PbsRow.jahr = 2012 ) AS vj_netto, (SELECT SUM(PbsRow.sollfracht) FROM Kunde JOIN PbsRow ON Kunde.PK = PbsRow.kunde WHERE Kunde.admitarbeiter = Adm.PK AND PbsRow.jahr = 2012 ) AS vj_sollfracht (SELECT SUM(WarengruppeVK.netto) FROM Kunde JOIN PbsRow ON Kunde.PK = PbsRow.kunde JOIN WarengruppeVK ON PbsRow.PK = WarengruppeVK.pbsrow WHERE Kunde.admitarbeiter = Adm.PK AND PbsRow.jahr = 2013 ) AS j_netto, (SELECT SUM(PbsRow.sollfracht) FROM Kunde JOIN PbsRow ON Kunde.PK = PbsRow.kunde WHERE Kunde.admitarbeiter = Adm.PK AND PbsRow.jahr = 2013 ) AS j_sollfracht FROM Adm
tblPhone(Phone_Type_ID, Phone_Type_Name, Phone_Type_Min_Price, Phone_Type_Max_Price)
;WITH T AS ( SELECT *, MAX(NULLIF(Column2,'')) OVER (PARTITION BY Column1) AS C2 FROM YourTable ) UPDATE T SET Column2 = C2 WHERE Column2 IS NULL OR Column2 = '';
DECLARE @docIds VARCHAR(MAX) SELECT @docIds = STUFF(( SELECT ',' + CONVERT(VARCHAR(50), docUid) FROM dbo.Document FOR XML PATH(''), TYPE).value('.', 'VARCHAR(MAX)'), 1, 1, '') SELECT @docIds, LEN(@docIds)
select 'apples' as productName, count(*) from fruit where apples = '1' union select 'oranges', count(*) from fruit where oranges = '1' union select 'kiwis', count(*) from fruit where kiwis = '1'
CREATE TEMPORARY table IF NOT EXISTS tbl ( REF_REQ_ID int AUTO_INCREMENT PRIMARY KEY, FunctionalArea varchar(200), Industry varchar(200) ); TRUNCATE TABLE tbl; INSERT INTO tbl SELECT 1, 'IT Jobs', 'IT related Jobs' UNION ALL SELECT 2, 'HR Jobs', NULL UNION ALL SELECT 3, NULL, 'HR related Jobs' UNION ALL SELECT 4, NULL, 'IT related Jobs' UNION ALL SELECT 5, NULL, NULL UNION ALL SELECT 6, 'IT Jobs', 'IT related Jobs' UNION ALL SELECT 7, 'HR Jobs', NULL UNION ALL SELECT 8, NULL, 'HR related Jobs' UNION ALL SELECT 9, 'HR Jobs', NULL; CREATE TEMPORARY table IF NOT EXISTS tbl_industry ( REF_REQ_ID int, Industry varchar(200) ); TRUNCATE TABLE tbl_industry; INSERT INTO tbl_industry SELECT REF_REQ_ID, Industry FROM tbl WHERE Industry IS NOT NULL; SELECT JobTitle As JobTitle, COUNT(REF_REQ_ID) As NoOfJobs FROM (SELECT FunctionalArea As JobTitle, REF_REQ_ID FROM tbl UNION SELECT Industry As JobTitle, REF_REQ_ID FROM tbl_industry)t WHERE JobTitle IS NOT NULL GROUP BY JobTitle ORDER BY NoOfJobs desc
select * from oc_user , oc_groups ORDER BY gid, uidS
SELECT B.* FROM SO_total_days2 A INNER JOIN SO_total_days2 B ON B.monthnumber = A.monthnumber + 360 WHERE A.from_date = '2010-01-01' from_date to_date days_in_month monthnumber 1980-01-01 1980-01-31 31 1 1980-02-01 1980-02-29 29 2 1980-03-03 1980-03-31 31 3 ... 1981-01-01 1981-01-31 31 13 1981-12-01 1981-12-31 31 24 ... 1985-01-01 1985-01-31 31 49 1985-12-01 1985-12-31 31 60
SELECT Col1, Col2, EventType, DateTime FROM theTable A WHERE DateTime > (SELECT MAX(DateTime) FROM theTable SUB WHERE EventType = 3 AND SUB.COL1 = A.COL1 AND SUB.COL2 = A.COL2)
SELECT TOP 1 * FROM tblHistory a INNER JOIN (SELECT Unit Number, Max([Date]) as MaxDate FROM tblHistory GROUP BY Unit Number) b on a.[Unit Number] = b.[Unit Number] and a.[Date] = b.MaxDate
SELECT period, 'Truck' AS NameOfVehicle, Truck AS Value FROM vehicle UNION ALL SELECT period, 'Car', Car FROM vehicle UNION ALL SELECT period, 'Boat', Boat FROM vehicle
$where = ''; $sql= "SELECT * FROM maklumatakaun LEFT JOIN detailakaun ON maklumatakaun.id = detailakaun.id LEFT JOIN maklumatbilakaun ON maklumatakaun.NoAkaun = maklumatbilakaun.NoAkaun LEFT JOIN kodjenisakaun ON detailakaun.KodJenisAkaun = kodjenisakaun.KodJenisAkaun LEFT JOIN kodlokasi ON detailakaun.KodLokasi = kodlokasi.KodLokasi LEFT JOIN kodkategori ON maklumatakaun.KodKategori = kodkategori.KodKategori LEFT JOIN koddaerah ON maklumatakaun.KodDaerah = koddaerah.KodDaerah WHERE maklumatakaun.KodKategori = '$KodKategori' AND detailakaun.KodJenisAkaun = '$KodJenisAkaun' AND maklumatbilakaun.BulanBil = '$BulanBil' AND maklumatbilakaun.TahunBil ='$TahunBil' ".mysql_real_escape_string($where)." GROUP BY maklumatakaun. NoAkaun "; if($KodDaerah != 'all'){ $where .= "AND maklumatakaun.KodDaerah = '$KodDaerah' "; //Add your where statement here //Whatever you want to do }
WHERE LEVENSHTEIN(Field_A, Field_B) < 4;
AverageMarks: (CourseworkMarks+ExaminationMarks)/2
SELECT t.category_id, MIN(t.date) AS first_date, CASE WHEN MAX(t.date) = MIN(t.date) THEN NULL ELSE MAX(t.date) END AS last_date FROM TABLE t GROUP BY t.category_id, t.client_id
select rp.NameEN, rd.NameDefault, (select COUNT(NameEN) from [OTOP].[Custom].[tblRefProvince] ) as district from [OTOP].[Custom].[tblRefProvince] rp inner join [OTOP].[Custom].[tblRefDistrict] rd on rp.ID = rd.ProvinceID;
obj = MyModel.objects.get(pk=1) obj.pk = None obj.save()
SELECT * FROM booking WHERE rid = '5' AND active = '1' AND ('2010-10-01' BETWEEN datefrom AND dateto - INTERVAL 1 DAY OR '2010-10-09' BETWEEN datefrom + INTERVAL 1 DAY AND dateto OR datefrom BETWEEN '2010-10-01' AND '2010-10-09' - INTERVAL 1 DAY) LIMIT 0 , 30
select t.*, cumepaid / cumeqty as avg_cost from (select t.*, (select SUM(qty) from t t2 where t2.item_id = t.item_id and t2.purch_id <= t.purch_id ) as cumeqty, (select SUM(qty*unit_price) from t t2 where t2.item_id = t.item_id and t2.purch_id <= t.purch_id ) as cumepaid from t ) t
osql -Sdb -Uautosys -Pdata_load -ddms -Q"EXEC dbo.sp @start_time = '%mydate%' "
Select a.Col1, a.Col2, b.Col1, b.Col2, c.Col1 from [Table A] a inner join [Table C] c on c.key1= a.key1 inner join [Table B] b on b.key1 = a.key1 inner join [Table D] d ON b.key3 = d.key1 where c.key2 = 'static value' and b.key2 = 'static value' and right(b.key4,1) in ('static value 1', 'static value 2') and substring(b.key4, 1, len(b.key4)-1) = c.key1 group by a.Col1, a.Col2, b.Col1, b.Col2, c.Col1
INSERT INTO tags ('name', 'slug') VALUES('Category X','category_x') ON DUPLICATE KEY UPDATE 'slug' = 'category_x'
SELECT invited_by_id, COUNT(*) AS invited_count FROM table GROUP BY invited_by_id
select top 1 a, b, c, d from Products where CodDep IN (10,12,12,13,26,27,32,34,248442,259741) order by LastUpdate
WITH q AS ( SELECT startId, endId FROM ranges UNION ALL SELECT startId + 1, endId FROM q WHERE startId < endId ) SELECT startId FROM q OPTION (MAXRECURSION 0)
<?php // copy your string of ids into this variable $input = "'123', '234r', '345', '456xyz'"; // modify next line to get your desired filename $filename = 'insert.sql' // modify next line to your table name $insert_statement = "INSERT INTO your_table_name (id, status) VALUES \n" . '(' . implode(", 'discard')\n(", explode(', ', $input)) . ", 'discard');\n"; file_put_contents($filename, $insert_statement); ?>
UPDATE tblDocs SET Active = CASE WHEN DocLocation = 'something' THEN 1 ELSE 0 END, DocID = CASE WHEN DocLocation = 'something' THEN NULL ELSE DocID END
<cfoutput query="getEmpsByDept" group="Department"> <cfset empCount = 0> <cfoutput> <cfset empCount++> </cfoutput> <tr> <td><b>#Ucase(getEmpsByDept.Department)# #empCount# Employees</b></td> </tr> <cfoutput> <tr> <td>&nbsp;&nbsp; #TRIM(getEmpsByDept.First)#&nbsp;#TRIM(getEmpsByDept.Last)#</td> </tr> </cfoutput> <tr> <td height="0">&nbsp;</td> </tr> </cfoutput>
select t1.*, t2.* from t1 left outer join t2 on t2.id=t1.id WHERE flag = 1 OR t2.id IS NOT NULL
create table business ( id int not null auto_increment primary key, name varchar(255) ); create table open_hour_range ( id int not null auto_increment primary key, business_id int, day_of_week tinyint, /* 0-6 */ open_time time, close_time time, foreign key(business_id) references business(id) );
CREATE OR REPLACE PROCEDURE PROC_CREATE_ROLES IS BEGIN EXECUTE IMMEDIATE 'CREATE ROLE ADMIN_STAFF'; EXECUTE IMMEDIATE 'GRANT SELECT ON BLAH TO ADMIN_STAFF'; EXECUTE IMMEDIATE 'GRANT SELECT, UPDATE ON BLORT TO ADMIN_STAFF'; EXECUTE IMMEDIATE 'GRANT SELECT, INSERT, UPDATE ON YADA TO ADMIN_STAFF'; EXECUTE IMMEDIATE 'GRANT ADMIN_STAFF TO USER1, USER2, USER3'; END PROC_CREATE_ROLES;
SELECT SUM(SALES_AMOUNT)SALES, YEAR, MONTH, CATAGORY_ID, TO_CHAR(SALES_PERSON_ID) SALES_PERSON_ID, ITEM_TYPE_ID FROM APEX_FINAL where sales_amount is not null and catagory_id is not null GROUP BY (YEAR,MONTH,CATAGORY_ID,SALES_PERSON_ID,ITEM_TYPE_ID) union all SELECT SUM(SALES_AMOUNT)SALES, YEAR, MONTH, CATAGORY_ID, 'all others' SALES_PERSON_ID, ITEM_TYPE_ID FROM APEX_FINAL where sales_amount is not null and sales_person_id is null GROUP BY (YEAR,MONTH,CATAGORY_ID,SALES_PERSON_ID,ITEM_TYPE_ID)
SELECT [group], [code] , COUNT(1) as CNT FROM YourTableName GROUP BY [group], [code] HAVING COUNT(1) > 1 ORDER BY CNT;
SET [File] = cast(b.Header as text) + CHAR(13) + CHAR(10) + d.Detail + c.Trailer + CHAR(13) + CHAR(10) + CHAR(26)
Select * From table Where (@Column = 'name' and name is null) or (@Column = 'surname' and surname is null) or (@Column = 'name and surname' and surname is null and name is null)
CREATE TABLE my_table ( col1 VARCHAR(10), col2 VARCHAR(20), expiration_date DATE, is_expired AS CASE WHEN expiration_date > GETDATE() THEN 1 ELSE 0 END );
>>ssh user@your_website.com >>Enter password: your_password >>mysqldump -u [uname] -p[pass] [dbname] > [backupfile.sql]
select group_concat(lev0) from (select concat_ws(',',lev2,group_concat(lev3)) as lev0 from (SELECT t2.id as lev2, t3.id as lev3, t4.id as lev4 FROM menus AS t1 LEFT JOIN menus AS t2 ON t2.parent_id = t1.id LEFT JOIN menus AS t3 ON t3.parent_id = t2.id LEFT JOIN menus AS t4 ON t4.parent_id = t3.id WHERE t1.id = '2') t0 group by lev2) t;
string createSql = "CREATE VIRTUAL TABLE TweetFts USING FTS3(TweetId, Title, Description)"; string insertSql = "INSERT INTO TweetFts (TweetId, Title, Description) SELECT TweetId, Title, Description FROM Tweet"; string sql = @"select TweetId from TweetFts where Title match '" + allWords + "'"; sql += " union "; sql += @"select TweetId from TweetFts where Description match '" + allWords + "'"; sql += " union "; sql += @"select TweetId from TweetFts where Title match '""" + exactMatch + @"""'"; sql += " union "; sql += @"select TweetId from TweetFts where Description match '""" + exactMatch + @"""'";
SET HEADING OFF SET PAGESIZE 0 SET LONG 90000 SET FEEDBACK OFF SET ECHO OFF SPOOL P:\other\file_name.sql SELECT DBMS_METADATA.get_ddl ('TABLE', table_name) || ';' FROM user_tables; SPOOL OFF
SELECT InitCap( your_column ) FROM your_table
CREATE QUEUE ExpenseQueue WITH STATUS=ON, ACTIVATION ( PROCEDURE_NAME = expense_procedure, MAX_QUEUE_READERS = 5, EXECUTE AS 'ExpenseUser' ) ;
SELECT * FROM TABLE WHERE FIELD LIKE '%&%'
EXECUTE msdb.dbo.sysmail_delete_account_sp EXECUTE msdb.dbo.sysmail_delete_profile_sp EXECUTE msdb.dbo.sysmail_add_account_sp EXECUTE msdb.dbo.sysmail_add_profile_sp EXECUTE msdb.dbo.sysmail_add_profileaccount_sp
using (SqlConnection conn = new SqlConnection(@"Persist Security Info=False;Integrated Security=true;Initial Catalog=myTestDb;server=(local)")) { SqlCommand addvalues = new SqlCommand(@"INSERT INTO customer (id,name,age,occupation) VALUES (@id,@name,@age,@occupation)", conn); addvalues.Parameters.AddWithValue("@bla", "bla"); addvalues.Connection.Open(); addvalues.ExecuteNonQuery(); addvalues.Connection.Close(); }
SELECT t.PhoneNumber1, t.PhoneNumber2, t1.SomeOtherFieldForPhone1, t2.someOtherFieldForPhone2 FROM Table1 t JOIN Table2 t1 ON t1.PhoneNumber = t.PhoneNumber1 JOIN Table2 t2 ON t2.PhoneNumber = t.PhoneNumber2
ALTER TRIGGER [dbo].[tid2] ON [dbo].[tblPrac2] AFTER INSERT AS declare @nid int; set @nid = ( select MAX(TicketID) from [tblPrac2] ); if(@nid is null) begin set @nid = 1; end else set @nid = @nid + 1; update tblPrac2 set TicketID = @nid where ID in (select ID from inserted)
select cake from caketable c where not exists ( select * from icingtable i where i.cake = c.cake and i.consumed = '1' ) and not exists ( select * from sprinkletable s where s.cake = c.cake and s.consumed = '1' )
DELETE From test WHERE Col1 IN( SELECT Col1 FROM test GROUP BY Col1 HAVING COUNT(1) > 1) AND Col2 = '1'
CREATE TABLE `swap_test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `x` varchar(255) DEFAULT NULL, `y` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB; INSERT INTO `swap_test` VALUES ('1', 'a', '10'); INSERT INTO `swap_test` VALUES ('2', NULL, '20'); INSERT INTO `swap_test` VALUES ('3', 'c', NULL);
SELECT PersonID, DateKey, [C/L], [C/L_New] = ISNULL([C/L], (SELECT TOP 1 t2.[C/L] FROM dbo.TableName t2 WHERE t2.PersonID = t.PersonID AND t2.DateKey <= t.DateKey AND t2.[C/L] IS NOT NULL ORDER BY DateKey DESC)) FROM dbo.TableName t Order By PersonID, DateKey
SELECT i1.id AS id1, NULL AS id2, NULL AS id3, i1.amount FROM items i1 UNION ALL SELECT i1.id AS id1, i2.id AS id2, i3.id AS id3, i1.amount + i2.amount AS total FROM items i1, items i2 WHERE i1.amount + i2.amount = 30 AND i1.id <> i2.id AND i1.id <> i3.id UNION ALL SELECT i1.id AS id1, i2.id AS id2, i3.id AS id3, i1.amount + i2.amount + i3.amount AS total FROM items i1, items i2, items i3 WHERE i1.amount + i2.amount + i3.amount = 30 AND i1.id <> i2.id AND i1.id <> i3.id AND i2.id <> i3.id
SELECT D.ID FROM Data D WHERE NOT EXISTS(SELECT 1 FROM Data WHERE D.ID = CXL)
insert into master.schema.employee (id, name) select case when id = 1 then 201 else id end, name from northwind.schema.employee
SELECT [author] ,[pubDate] ,MAX([dateadded]) FROM [Feeds].[dbo].[socialPosts] WHERE CAST(FLOOR(CAST(dateadded AS float)) AS datetime) > dateadd(day,datediff(day, 0, getdate()-2), 0) AND CAST(FLOOR(CAST(dateadded AS float)) AS datetime) < dateadd(day,datediff(day, 0, getDate()), 0) GROUP BY [author] , [pubdate]
SELECT Table1.Numbers, Table1.Name FROM Table1 WHERE NOT EXISTS( SELECT 1 FROM Table2 WHERE Table1.Numbers=Table2.Numbers )
SELECT CourseCode FROM Course WHERE CourseName='?' UNION ALL SELECT 'Not Applicable' WHERE NOT EXISTS ( SELECT CourseCode FROM Course WHERE CourseName='?' )
SELECT employees.eno, employees.ename, SUM(parts.price * odetails.qty) as TotalSales FROM test.employees INNER JOIN test.orders ON empoyee.eno = orders.eno INNER JOIN test.odetails ON orders.ono = odetails.ono INNER JOIN test.parts ON odetails.pno = parts.pno GROUP BY employees.eno, employees.ename
SELECT TB_USER.ID, TB_QUESTION.ID AS "Q_ID" FROM TB_USER, TB_QUESTION minus SELECT ID_USER, ID_QUESTION FROM tb_answer
SELECT * FROM mytable WHERE left(Telephone,3) = '765'
SELECT ID, CASE WHEN nvl(doc_after,'') <> '' THEN doc_after ELSE doc_before END AS doc , CASE WHEN nvl(doc_after) <> '' THEN 'doc_after' ELSE 'doc_before' END AS camefrom FROM yourtable
insert into my_table select --<number of columns you want -- use dbms_random if you would like> from dba_objects a, dba_objects b where rownum<=20000;
sql_query = "<prefix>" sql_query += "?, " * 69 sql_query += "?)<suffix>"
CREATE OR REPLACE FUNCTION f_x (p_id IN NUMBER) RETURN BOOLEAN IS BEGIN RETURN TRUE; END f_x; CREATE OR REPLACE PROCEDURE p_x (i_id IN NUMBER, o_val OUT BOOLEAN) IS BEGIN o_val := f_x(i_id); END p_x;
select coalesce(t1.day, t2.day) "day", coalesce(t1.acount, 0) acount, coalesce(t2.bcount, 0) bcount from table1 t1 full outer join table2 t2 on t1.day = t2.day;
SELECT [SIGNAL NAME], CAST(SAMPLETIME AS DATE) AS SAMPLEDATE, MAX(VALUE)-MIN(VALUE) As Diff_Value FROM Table1 GROUP BY CAST(SAMPLETIME AS DATE),[SIGNAL NAME]
SELECT 42 AS [@tag], (SELECT content AS [*] FROM #test T FOR XML PATH(''), TYPE) AS [*] FOR XML PATH('root')
select a.*,b.MedianWeight,c.MedianLength from ( SELECT speciesID, min(catchLength) MinLength, max(catchLength) MaxLength, avg(catchLength) AvegrageLength, isnull(STDEV(catchLength),0) StDevLength , min(catchWeight) MinWeight, max(catchWeight) MaxWeight, avg(catchWeight) AvegrageWeight, isnull(STDEV(catchWeight),0) StDevWeight from #Catchestemp c group by speciesID ) a join ( select speciesID, avg(catchWeight) MedianWeight from ( select speciesID, catchWeight, ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchWeight ASC, id ASC) AS RowAsc, ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchWeight DESC, id DESC) AS RowDesc from #Catchestemp ) x WHERE RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1) group by speciesID ) b on a.speciesID = b.speciesID join ( select speciesID, avg(catchLength) MedianLength from ( select speciesID, catchLength, ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchLength ASC, id ASC) AS RowAsc, ROW_NUMBER() OVER (PARTITION BY speciesID ORDER BY catchLength DESC, id DESC) AS RowDesc from #Catchestemp ) x WHERE RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1) group by speciesID ) c on a.speciesID = c.speciesID
SELECT column0, column2, table.column1, columncount FROM table INNER JOIN (SELECT column1, COUNT(column1) columncount FROM table WHERE column1> 0 GROUP BY column1 HAVING COUNT(column1) > 1) t2 ON table.column1 = t2.column1
SELECT CustomerID FROM Customers AS C WHERE EXISTS ( SELECT 1 -- no need for a columns list since you only check for existance FROM (SELECT TOP 12 DueDate, PaymentDate -- no need for all the columns, only the ones you use FROM Payments as P WHERE P.CustomerID = C.CustomerID ORDER BY PaymentDate ) AS First12Payments WHERE DATEDIFF(MONTH, First12Payments.DueDate, First12Payments.PaymentDate) > 3
--Declare UserId and CpyId declare @UserId int = 100001 declare @CpyID int = 1; --Select all possible results and rank WITH subryUnion AS ( --Select hits by CpyId, Rank 1 SELECT *, 1 AS Ranking, 'Hit by CpyId' Descr FROM tbl_Entity_Column_Details WHERE CpyId = @CpyId UNION ALL --Select hits by User_Id, Rank 2 SELECT *, 2 AS Ranking, 'Hit by User_Id' Descr FROM tbl_Entity_Column_Details WHERE User_Id = @UserId UNION ALL --Select no hits by CpyID or User_Id, Rank 3 SELECT *, 3 AS Ranking, 'Not hit by CpyId or User_Id' Descr FROM tbl_Entity_Column_Details WHERE COALESCE(CpyId,User_Id) IS NULL ) SELECT * FROM subryUnion --Show only the minimum ranked results WHERE Ranking = (SELECT MIN(Ranking) FROM subryUnion)
select LTRIM(RTRIM(FIELD_ONE)) + LTRIM(RTRIM(FIELD_TWO)) + LTRIM(RTRIM(FIELD_THREE)) FROM copyfrom
convert(datetime,'24/05/2012 09:56:06',103)
ORDER BY `products`.`product_category_id` DESC ,`naam` ASC
GROUP BY GROUPING SETS ((o.VendorNo, LEFT(HVI.EncodeData, 3), pto.PrintBatch, pto.PickBit), (o.VendorNo, LEFT(HVI.EncodeData, 3)), (o.VendorNo) )
SELECT *, GROUP_CONCAT(item_category) AS item_categories FROM (`dev_pages`) LEFT JOIN `dev_items_to_categories` ON `dev_items_to_categories`.`item_id` = `dev_pages`.`page_id` AND `item_category` = '16' WHERE deleted_time IS NULL AND `page_type` = 'blog' GROUP BY dev_pages.page_id ORDER BY `page_title` ASC
select t1.vm_name, t2.object_id as vm_id, t1.host_name, t3.object_id as host_id from table1 t1 join table2 t2 on t1.vm_name = t2.object_name join table2 t3 on t1.host_name = t3.object_name order by t1.vm_name
select departmentname, [1] status1, [2] status2, [3] status3 from ( select d.departmentname, e.empid, e.workstatus from dbo.department d left join dbo.employee e on d.deptid = e.deptid ) d pivot ( count(empid) for workstatus in ([1],[2],[3]) ) piv;
select client_ID, status_id, from_date, to_date, sum(start_of_group) over (order by client_ID, from_date) + 1 rank from (SELECT c.client_ID, c.status_id, c.from_date, c.to_date, case when lag(c.client_ID, 1, c.client_ID) over (order by c.client_ID, c.from_date) = c.client_ID and lag(c.status_id, 1, c.status_id) over (order by c.client_ID, c.from_date) = c.status_id then 0 else 1 end start_of_group FROM client c) order by client_ID, from_date
SQL> SET SERVEROUTPUT ON SQL> DECLARE 2 TYPE t_tab IS TABLE OF NUMBER; 3 l_tab1 t_tab := t_tab(1,1,3,3,5,5); 4 BEGIN 5 l_tab1 := l_tab1 MULTISET INTERSECT DISTINCT l_tab1; 6 FOR i IN l_tab1.first .. l_tab1.last 7 LOOP 8 DBMS_OUTPUT.put_line('Distinct values are '||l_tab1(i)); 9 END LOOP; 10 END; 11 / Distinct values are 1 Distinct values are 3 Distinct values are 5 PL/SQL procedure successfully completed.
ALTER TRIGGER [ATrigger] ON [dbo].[A] FOR INSERT, UPDATE, DELETE AS -- those are true INSERTs - the (ID) as primary key is *not* present in the "Deleted" table INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus]) SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'N', getDate(), 0 FROM inserted WHERE (id) NOT IN (SELECT DISTINCT (id) FROM DELETED) -- those are true DELETEs - the (ID) as primary key is *not* present in the "Inserted" table INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus]) SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'Y', getDate(), 0 FROM deleted WHERE (id) NOT IN (SELECT DISTINCT (id) FROM INSERTED) -- those are the UPDATEs - the (ID) as primary key is present in both the "Inserted" and "Deleted" table INSERT INTO [dbo].[aAudit]([BusinessDate], [DataTypeId], [BookId], [Version], [DelFlag], [AuditDate], [ExtStatus]) SELECT [BusinessDate], [DataTypeId], [BookId], [Version], 'N', getDate(), 0 FROM Inserted i INNER JOIN Deleted d on i.ID = d.ID
SELECT username, loginstart, loginend, SUM(data1) as TotData1, SUM(data2) as TotData2, SUM(data3) as TotData3 FROM YourTable GROUP BY username, loginstart, loginend
SELECT o1.object_name, r1.object_name, o2.object_name FROM edge e JOIN object o1 ON o1.id = e.arg1 JOIN object r ON r.id = e.relation JOIN object o2 ON o2.id = e.arg2;
SQL> select regexp_replace('éaéABcdEF', '([a-zA-Z])', '' ) problems from dual; PROBLEMS -------- éé
$mresult = mysql_query(" SELECT * FROM books WHERE GoodName LIKE '%$title%' AND GroupCode IN (" . implode(",", $array_of_cat) . ")");
Update lm_Artikel A INNER JOIN lm_Schwellwert S ON A.Typ = S.Typ SET A.Status = 'NOK' WHERE A.Bestand < S.Schwellwert
WITH CTE AS ( SELECT ROW_NUMBER() OVER (PARTITION BY ID ORDER BY Seq DESC) AS RN , ID, Age FROM Persons ) SELECT ID, Age FROM CTE WHERE RN = 1
select id,b,c from tablename inner join ( select id, count(A) as CountDuplicates from TableName as base group by A,id having (count(A) > 1) )d on tablename.id= d.id
SELECT [Origin], [Destination], (ABS(SUM(CASE WHEN [DeliveryWeek] = 2 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 1 THEN 1 ELSE 0 END)) + ABS(SUM(CASE WHEN [DeliveryWeek] = 3 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 2 THEN 1 ELSE 0 END)) + ABS(SUM(CASE WHEN [DeliveryWeek] = 4 THEN 1 ELSE 0 END)-SUM(CASE WHEN [DeliveryWeek] = 3 THEN 1 ELSE 0 END)) ) / 3
CREATE INDEX email_index ON emaildata(emailaddress) USING BTREE;
SELECT * FROM ( SELECT RIC.CarrierName, L.LoadGuid, RIC.RateIQCarrierid, RIRD.Cost, --Partition says look at each carrier as a group, then number them in order of cost lowest to highest. ROW_NUMBER() OVER (PARTITION BY RIC.CarrierName ORDER BY Cost) rank_num FROM tblLoads L INNER JOIN RateIQRecord RIR ON L.LoadGuid = RIR.LoadGuId INNER JOIN RateIQCarrier RIC ON RIR.RateIQRecordID = RIC.RateIQRecordID INNER JOIN RateIQRateDetail RIRD ON RIC.RateIQRecordID = RIRD.RateIQRecordID --Don't do it this way --AND CAST(L.CreatedDate AS Datetime) Between '03/3/2014' and '03/3/2014 23:59:59.997' --Try this instead AND CAST(L.CreatedDate AS DATE) = '03/03/2014' ) A --Only grab the lowest number aka first of row number WHERE A.rank_num = 1
create procedure dbo.test as begin create table #temp ( name varchar(100) , id int ) insert #temp select name , id from master..sysobjects update #temp set name='ALL Same' from #temp select * from #temp drop table #temp end go
Select Y.S - X.S As Sum from (select sum(qteMv) S from mouventDeStock where typemv=1 and codemv = 'ART_18') Y, (select sum(qteMv) S from mouventDeStock where typemv=0 and codemv = 'ART_18') X;
select * from gpaTable where gpa in ( select distinct gpa from gpaTable order by gpa desc limit 2 )
UPDATE contents c JOIN ( SELECT what, AVG(rating) rating, COUNT(rating) ratingsCount FROM ratings WHERE what = ? GROUP BY what ) r ON c.id = r.what SET c.rating = r.rating, c.ratingsCount = r.ratingsCount
SELECT p.p1, p.p2 FROM Likes p INNER JOIN Likes p2 ON p.p1=p2.p2 AND p.p2=p2.p1 AND p.p1<p2.p1
create table yourtable(RowID int, Layout varchar(200)) INSERT yourtable VALUES (1,'hello,world,welcome,to,tsql') INSERT yourtable VALUES (2,'welcome,to,stackoverflow') ;WITH SplitSting AS ( SELECT RowID,LEFT(Layout,CHARINDEX(',',Layout)-1) AS Part ,RIGHT(Layout,LEN(Layout)-CHARINDEX(',',Layout)) AS Remainder FROM YourTable WHERE Layout IS NOT NULL AND CHARINDEX(',',Layout)>0 UNION ALL SELECT RowID,LEFT(Remainder,CHARINDEX(',',Remainder)-1) ,RIGHT(Remainder,LEN(Remainder)-CHARINDEX(',',Remainder)) FROM SplitSting WHERE Remainder IS NOT NULL AND CHARINDEX(',',Remainder)>0 UNION ALL SELECT RowID,Remainder,null FROM SplitSting WHERE Remainder IS NOT NULL AND CHARINDEX(',',Remainder)=0 ) SELECT part FROM SplitSting ORDER BY RowID
select date, price, @total := @total + price as total from (select date, price from your_table order by date) x CROSS JOIN (select @total := 0) r
SELECT * FROM table WHERE 10 = ANY (values);
INSERT INTO gender (sex, date) VALUES ( 'male are allowed \\ female are not allowed', "2012-10-06")
select SrNo,Name, Amount , case when ApplyTax = 'Yes' then Amount*0.20 else 0 end as Tax from tablename
CREATE VIEW myOrderedTable AS SELECT ID, ClientID, Designation, Contact, Tag, Email FROM tableName;
update table t join (select s.*, @rn := @rn + 1 as FakeServerNumber, NumServers from servers s cross join (select count(*) as NumServers, @rn := -1 from servers where isup = 'isup' ) const where s.isup = 'isup' ) s on t.primary_key % s.NumServer = s.rn set t.server_id = s.server_id where t.server_id is null;
CREATE NONCLUSTERED INDEX <index name> ON _T_VENTAS_DIARIAS (Año, Semana, Dia_Calendario);
SELECT XMLELEMENT ("MAIN_TAG", XMLAGG (XMLCONCAT (l_head_xml, l_pos_xml))) INTO l_complete_xml FROM (SELECT DUMMY FROM DUAL CONNECT BY LEVEL <= 2);
data data; input name1 $ c1 c2 c3; datalines4; a 1 2 3 a 1 2 3 b 1 2 3 b 1 2 3 ;;;; run; %macro test(k=); PROC SQL; CREATE TABLE WORK.data1 AS SELECT t1.name1 %do i=1 %to &k.; , SUM(C&i.) AS C&i. %END; FROM WORK.data t1 GROUP BY t1.name1; QUIT; %mend test; %test(k=3);
SELECT c.month, coalesce(a.mycount,0), coalesce(b.totalPhones,0), coalesce(b.newphones,0) FROM (SELECT monthStart as month FROM TestGB UNION SELECT monthEnd as month FROM TestGB) c LEFT OUTER JOIN (SELECT monthStart as month, count(distinct obild) as mycount, from TestGB group by monthStart) a on a.month = c.month LEFT OUTER JOIN (SELECT monthStart as month, sum(newPhones) as newPhones, sum(totalPhones) as totalPhones from TestGB group by monthEnd) b ON b.month = c.month
SELECT row1, row2, string_agg(row3, ',') as row3 FROM your_table GROUP BY row1, row2
UPDATE <table> SET PRICE = IIF([TYPE] IN ("A1","A3", "A4"); [Price]*1,05; [Price]*1,065)
SELECT t1.number FROM t1 INNER JOIN t2 ON t1.number = t2.number
SELECT ... FROM tickets t INNER JOIN ticket_text_fields f ON t.id=f.ticket_id WHERE f.textfield_id IN (7, 8, 9, ...) UNION ALL SELECT ... FROM tickets t INNER JOIN ticket_date_fields d ON t.id=d.ticket_id WHERE d.datafield_id IN (434, 435, 436, ...)
SELECT * FROM table1 INNER JOIN table2 ... INNER JOIN table3 ... INNER JOIN table4 ... WHERE NOT ( ( table1.Value IS NULL) AND ( table2.Value IS NULL) AND ( table3.Value IS NULL) AND ( table4.Value IS NULL) )
with recursive tree (userid, siblingid) as ( select userid, siblingid from users where userId = 1 union all select c.userid, c.siblingid from users c join tree p on p.userid c.siblingId ) select * from tree;
declare v_columns varchar2(255); v_select varchar2(2000); v_result sys_refcursor; begin v_columns := 'rownum'; IF p_plant_cd = 1 THEN v_columns := v_columns || ',p_plant_cd'; END IF; IF p_global_duns_nbr = 1 THEN v_columns := v_columns || ',p_global_duns_nbr'; END IF; IF p_global_duns_nbr = 1 THEN v_columns := v_columns || ',p_global_duns_nbr'; END IF; IF p_matrl_grp = 1 THEN v_columns := v_columns || ',p_matrl_grp'; END IF; IF p_mrp = 1 THEN v_columns := v_columns || ',p_mrp'; END IF; v_select := 'SELECT ' || v_columns || ' FROM table'; open v_result for v_select; end;
;WITH top_cte AS ( SELECT *, ROW_NUMBER() OVER(PARTITION BY Company ORDER BY Revenue DESC) AS [Rank] FROM table ) SELECT * FROM top_cte WHERE [Rank] <= 6
select count(eo.equal_opps_id) as 'Age 40 - 49' ,DateAdd(yy,-49,getDate()) as LesserDate ,DateAdd(yy,-39,getDate()) as GreaterDate from dbo.app_equal_opps eo, dbo.app_status s where eo.date_of_birth > DateAdd(yy,-49,getDate()) and eo.date_of_birth < DateAdd(yy,-39,getDate()) and eo.application_id = s.status_id and s.job_reference_number = '33211016' and s.submitted = 1
SELECT name FROM sqlite_master WHERE type = 'table' AND name LIKE '%your_table_name%'
SELECT [PostingID] ,[EmployerID] ,[JobTitle] ,MIN(pin.[IndustryID]) FROM [Posting] p INNER JOIN [City] c ON p.CityID = c.CityID LEFT OUTER JOIN PostingIndustry pin ON p.PostingID = pin.PostingID WHERE (c.CityID = @CityId OR @CityId IS NULL) AND (p.StateProvinceID = @StateProvinceId OR @StateProvinceId IS NULL) AND (pin.IndustryID = @IndustryId OR @IndustryId IS NULL) AND ( (p.[Description] LIKE '%' + @Keyword + '%' OR @Keyword IS NULL) OR (p.[JobTitle] LIKE '%' + @Keyword + '%' OR @Keyword IS NULL) ) AND p.StreetAddress IS NOT NULL AND p.ShowOnMap = 1 GROUP BY [PostingID],[EmployerID],[JobTitle]
select p.firstname, p.lastname, p.location, p.uid, case when f.A is null then 1 else 2 end as type from profile as p left join favorites as f on p.uid = f.B and f.A = 'myid' where p.firstname like 'mich%' or p.lastname like 'mich%'
select customers.ssn, certs.cert_num, certs.cert_start, certs.cert_finish from customers INNER JOIN certs ON certs.ssn = customers.ssn group by customers.ssn having sum(case when certs.cert_finish < Date_ADD(now(), INTERVAL 14 DAY) and certs.cert_finish > now() then 1 else 0 end) > 0 and -- has soon to expire certicate sum(case when certs.cert_finish > Date_ADD(now(), INTERVAL 14 DAY) then 1 else 0 end) = 0 -- has no certificate that will expire later
SELECT di.DocName as DocumentName, di.Uploadfile as FileUploaded, d.DepType as Department, di.UploadedBy as UploadedBy, at.ApproveType as Status, u.Email as UserEmail FROM dbo.DocumentInfo di INNER JOIN dbo.Approval a ON di.DocID = a.DocID INNER JOIN dbo.ApproveType at ON a.ApproveID = at.ApproveID INNER JOIN dbo.Userss u ON u.UserId = di.UserId INNER JOIN dbo.Department d ON di.DepID = d.DepID INNER JOIN dbo.DocType dct ON di.DocTypeID = dct.DocTypeID where di.DepID= @DepID
Use [MyDatabase] GO
UPDATE PEOPLE SET ID_STATE = 5 WHERE ID_STATE IN (SELECT ID_STATE FROM STATE_PEOPLE WHERE labelStatePeople = 'strange' and ID_STATE IS NOT NULL)
SELECT STUDENT_ID, BOOK_TITLE, TERM FROM ASSIGNMENTS WHERE STUDENT_ID IN (SELECT DISTINCT STUDENT_ID FROM ASSIGNMENTS WHERE TERM = 2012) ORDER BY STUDENT_ID, TERM DESC
DECLARE @ParentID INT = 1 DECLARE @Widgets AS XML = N'<Widgets> <Widget> <WidgetID /> <StartDate /> <EndDate /> <Details> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>4</SomeID> <SomeData/> </WidgetDetailItem> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>323</SomeID> <SomeData/> </WidgetDetailItem> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>1</SomeID> <SomeData/> </WidgetDetailItem> </Details> </Widget> <Widget> <WidgetID>10</WidgetID> <StartDate>January 1, 2015</StartDate> <EndDate /> <Details> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>4</SomeID> <SomeData/> </WidgetDetailItem> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>99</SomeID> <SomeData/> </WidgetDetailItem> <WidgetDetailItem> <WidgetDetailItemID></WidgetDetailItemID> <WidgetID/> <SomeID>6</SomeID> <SomeData/> </WidgetDetailItem> </Details> </Widget> </Widgets>'; --Used to hold the pseudoID -> WidgetID relationship for inserting the details DECLARE @WidgetIds AS TABLE ([Action] varchar(10), PseudoID INT, WidgetID INT); ; --Use a CTE of the subset of data to be more performant. If we just went straight to the --merge we'd be operating on the entire table and that can have some major performance hits WITH T AS ( SELECT w.* FROM [dbo].[Widget] as w WHERE w.[ParentID] = @ParentID ) MERGE INTO T USING ( SELECT --Generate a pseudoid based on the order of the Widget elements so that we have some way of --linking the detail records to the master row_number() OVER(ORDER BY PROPERTYFEED.P) PseudoID, 'WidgetID' = P.value('WidgetID[1]', 'INT'), 'ParentID' = @ParentID, 'StartDate' = P.value('StartDate[1]', 'DATETIME'), 'EndDate' = P.value('EndDate[1]', 'DATETIME') FROM @Widgets.nodes('/Widgets/Widget') PROPERTYFEED(P) ) AS xmlIn ( [PseudoID], [WidgetID], [ParentID], [StartDate], [EndDate] ) ON T.[WidgetID] = xmlIn.[WidgetID] WHEN NOT MATCHED THEN INSERT ( [ParentID], [StartDate], [EndDate] ) VALUES ( xmlIn.[ParentID], xmlIn.[StartDate], xmlIn.[EndDate] ) WHEN MATCHED AND ( (T.[StartDate] <> xmlIn.[StartDate]) OR (T.[EndDate] <> xmlIn.[EndDate])) THEN UPDATE SET T.[StartDate] = xmlIn.[StartDate], T.[EndDate] = xmlIn.[EndDate] WHEN NOT MATCHED BY SOURCE AND T.[DeletedDate] IS NULL THEN UPDATE SET T.[DeletedDate] = GETDATE() OUTPUT $action, xmlIn.PseudoID, INSERTED.WidgetID INTO @WidgetIds ; --This is some magic to generate a temp table of numbers from 1 to COUNT(Widget) --This is so we can reference the parent Widget row in the same order as the pseudoid generated above --http://stackoverflow.com/a/1134379/4375845 ;WITH Total(TotalWidgets) AS (SELECT COUNT(1) TotalWidgets FROM @Widgets.nodes('/Widgets/Widget') PROPERTYFEED(P)) , Numbers(Num) as ( SELECT 1 AS Num UNION ALL SELECT Num+1 FROM Numbers JOIN Total t ON 1 = 1 WHERE Num < t.TotalWidgets ) INSERT INTO WidgetDetailItem (WidgetID,SomeID,SomeData) SELECT w.WidgetID ,Details.SomeID ,Details.SomeData FROM (SELECT P.value('WidgetDetailItemID[1]','int') WidgetDetailItemID , P.value('SomeID[1]','int') SomeID , P.value('SomeData[1]','varchar(5)') SomeData , n.Num AS PsuedoID FROM Numbers n --This is what gives us our pseudo ID to link to the row_number() function from the first merge statement CROSS APPLY @Widgets.nodes('/Widgets/Widget[sql:column("n.Num")]/Details/WidgetDetailItem') AS M(P) ) Details JOIN @WidgetIds w on Details.PsuedoID = w.PseudoID WHERE w.Action = 'INSERT' --We only want inserts by your spec SELECT * FROM Widget; SELECT * FROM WidgetDetailItem;
SELECT i.investment_type as investmentType,COUNT(*) as investmentCount FROM investment i,vertical v WHERE v.vertical_name =i.investment_type AND v.type='STR' AND i.status_funding ='o' group by i.investment_type order by investmentCount desc limit 6 UNION SELECT "others" as investmentType, SUM(othersInvestmentCount) as investmentCount FROM ( SELECT COUNT(*) as othersInvestmentCount FROM investment i,vertical v WHERE v.vertical_name =i.investment_type AND v.type='STR' AND i.status_funding ='o' group by i.investment_type order by investmentCount desc limit 6, 4294967296 )
SELECT name, Case WHEN Table1.tag = 'Y' then CODES.Desc ELSE 'Other String' END as description FROM TABLE1 join CODES on TABLE1.code = CODES.code
UPDATE library SET key = key + 1 WHERE value = 'e_book';
SELECT m.MapName, SEC_TO_TIME(TRUNCATE(t.Time,3)) AS Time, t.PlayerID, u.name FROM times t INNER JOIN maps m ON t.MapID = m.MapID INNER JOIN (SELECT t.MapId, MIN(t.time) as time FROM times t GROUP BY t.MapId ) tmin ON tmin.MapId = t.MapId and tmin.time = t.time INNER JOIN Users u ON t.PlayerId = u.PlayerId
Article ------- ArticleID int PK Article_Tags ------------ ArticleTagID int PK ArticleID int FK TagId int FK Tag --- TagId int identity(1,1) PK TagText varchar(50)
SELECT RPAD(numcol::text, 3, '0'), -- Zero-pads to the right up to the length of 3 LPAD(numcol::text, 3, '0'), -- Zero-pads to the left up to the length of 3 FROM my_table
<img src="/content/u/10234/abcde.img" width="300" height="200">
SELECT * FROM ticket WHERE hour(time) >= 18;
UPDATE tableB SET PRIMARYKEYCOLUMN = tableA.PRIMARYKEYCOLUMN FROM tableA WHERE tableA.OLDPRIMARYKEYCOLUMN = tableB.PRIMARYKEYCOLUMN
Create TRIGGER [dbo].[DeleteUser] ON dbo.ParentTable INSTEAD OF DELETE AS BEGIN SET NOCOUNT ON; declare @Search varchar(200) select @Search=d.Id from deleted as d Declare @tablevar table(Id nvarchar(200),ColName nvarchar(200)) --FindStringAndReturnCols return the name of columns And Id's of rows that have value insert into @tablevar(Id,ColName) exec FindStringAndReturnCols @Search declare @Id nvarchar(200), @ColName nvarchar(200),@SqlQuery as nvarchar(max) Declare c Cursor For Select Id,ColName From @tablevar Open c Fetch c into @Id,@ColName While @@Fetch_Status=0 Begin set @SqlQuery='' set @SqlQuery= 'update ChildTable set '+ @ColName +' = null where Id like N''%'+@Id+'%''' exec (@SqlQuery) Fetch c into @Id,@ColName End delete from Parent where Id=@Search Close c Deallocate c END
SELECT section, question, answer, COUNT(*) AS count FROM table WHERE academicYear = ??? AND testNo = ??? GROUP BY section, question, answer
SELECT USERNAME , DATE_CREATED FROM ( SELECT USERNAME , DATE_CREATED , COUNT( *) over ( PARTITION by USERNAME, TRUNC( DATE_CREATED, 'DD') ) cnt FROM THE_TABLE ) WHERE cnt > 1 ;
SELECT SUM(bytes) AS total_bytes, stamp_updated FROM acct WHERE stamp_updated BETWEEN datetime('now', 'localtime','-7 hours') AND datetime('now', 'localtime') GROUP BY ip_src ORDER BY total_bytes DESC limit 10;
Property ------------------- Property ID Owner ID Location (unknown? Beach?) Address Weekly Rate Property Type No of Rooms Kitchen (Yay, Nay) Owner ------------------- Owner ID Address
SELECT Worker.Name, BoxSize.Name, SUM(CASE WHEN BoxColor.id=0 THEN 1 ELSE 0 END) AS BoxColor_0, SUM(CASE WHEN BoxColor.id=1 THEN 1 ELSE 0 END) AS BoxColor_1, SUM(CASE WHEN BoxColor.id=2 THEN 1 ELSE 0 END) AS BoxColor_2 FROM Worker JOIN Box ON Worker.ID=Box.ID_Worker JOIN Item ON Item.ID_box=Box.ID JOIN BoxColor ON BoxColor.ID=Item.ID_BoxColor JOIN BoxSize ON BoxSize.ID=Item.ID_BoxSize GROUP BY Worker.Name, BoxSize.Name
with linkT (parent_code, child_code) as (select 'A1','B1' from dual union all select 'A1','B2' from dual union all select 'B1','C1' from dual union all select 'B1','C2' from dual union all select 'B2','C3' from dual union all select 'B3','C3' from dual union all select 'C3','D1' from dual union all select 'E1','F1' from dual ), T1 as ( select parent_code, child_code, 0 Dir from linkT union all select child_code, parent_code, 1 Dir from linkT ) select distinct decode(dir, 0, parent_code, child_code) as Parent_code, decode(dir, 0, child_code, parent_code) as Child_Code from ( select parent_code, child_code, dir from T1 x start with x.child_code='A1' connect by nocycle prior x.parent_code=x.child_code ) order by 1,2
SELECT regions.region, projectTypes.projectType, (SELECT count(*) FROM projects WHERE projects.typeID = projectTypes.id AND projects.regionID = regions.id) as totalCount FROM regions, projectTypes
UPDATE p SET column1 = t.column1 from <dbname>.<schema>.mytable p join <TestLinkedServerName>.<dbname>.<schema>.mytable t on p.<id> = t.<id>
;with cte as (select ColA, ColB, case when ColA < ColB then ColA else ColB end as ColC, case when ColA > ColB then ColA else ColB end as ColD from yourtable) select ColC as ColA, ColD as ColB, count(1) as Count from cte group by ColC, ColD order by ColC, ColD
BEGIN TRANSACTION; INSERT INTO Persons(Name) VALUES(...); INSERT INTO PhoneNumbers(PersonForeignKey, Number) VALUES(last_insert_rowid(), 'number 1'); INSERT INTO PhoneNumbers(PersonForeignKey, Number) SELECT PersonForeignKey, 'number 2' FROM PhoneNumbers where PhonePrimaryKey = last_insert_rowid(); INSERT INTO PhoneNumbers(PersonForeignKey, Number) SELECT PersonForeignKey, 'number 3' FROM PhoneNumbers where PhonePrimaryKey = last_insert_rowid(); END TRANSACTION;
where find_in_set(id, ?)
Update Products Set ProductName = 'Shoes' WHERE ProductID IN (1,2,3,4,5,6,7,8)
INSERT INTO SERVICEPAYANT (TYPE_FLUX, DELAI) SELECT 161, '9999' FROM dual WHERE NOT EXISTS (SELECT 1 FROM SERVICEPAYANT WHERE TYPE_FLUX = 161 AND DELAI = '9999')
select user_name, status, sum(calls) as calls from table where status in ('cars', 'bikes', 'skates') group by user_name, status
SELECT a.*,b.*,z.* FROM tbl_event a left JOIN (SELECT type_person FROM tbl_event WHERE id_animal = 1) as b ON a.type_person = b.type_person left JOIN tbl_animal z ON z.id_animal = a.id_animal WHERE z.id_animal = 1;
select count(*) from ( select CustomerId from Retail where Itemset in (30,31) group by CustomerId having count(distinct Itemset) = 2 -- this guarantees that CustomerId have at least one 30 and at least one 31 in column Itemset ) T
CREATE TABLE Customer ( CustomerId int not null identity(1,1) constraint PK_Customer primary key clustered ,(...) ) CREATE TABLE UserAccount ( UserAccountId int not null constraint PK_UserAccount primary key clustered constraint FK_UserAccount__Customer foreign key references Customer (CustomerId) ,(...) )
SELECT DATE_FORMAT(myDateColumn, '%Y-%m'), COUNT(*) FROM myTable GROUP BY DATE_FORMAT(myDateColumn, '%Y-%m') ORDER BY 1
SELECT distinct * FROM jobs START WITH ( city, title ) IN ( SELECT city, title FROM people WHERE name IN ( 'Bill', 'Jim', 'Jane' ) ) CONNECT BY PRIOR parent_title = title;
select location, sum(qty) as total from (select case when Location in ('Location A','Location B') then Location else 'Container' end as location, qty from tablename) group by location
select t.* from table t where (t.id - t.seq) = (select t2.id - t2.seq from table t2 where t2.type = 'C' and t2.acct = '2345' and t2.date = '6/5/2014' ) and t.type is null;
SELECT d.id, d.district_name, (SELECT COUNT(b.id) FROM blocks b WHERE b.district_id = d.id) total_block, (SELECT COUNT(p.id) FROM panchayats p WHERE p.district_id = d.id) gp_total, (SELECT COUNT(v.id) FROM villages v WHERE v.district_id = d.id) vi_total, (SELECT COUNT(h.id) FROM habitations h WHERE h.district_id = d.id) h_total FROM districts d
select p.propertynum, p.branchnum, p.area, p.city, p.postcode, p.prop_type, p.rooms, b.area, b.city, coalesce(i.NumInspected, 0) from yr_property p join yr_branch b on p.branchnum = b.branchnum left outer join (select propertynum, count(*) as NumInspected from yr_inspection i group by propertynum ) i on i.propertynum = p.propertynum;
select count(1) from teams where UserId = 100
DECLARE @theDate varchar(60) SET @theDate = '''2010-01-01'' AND ''2010-08-31 23:59:59''' DECLARE @SQL VARCHAR(MAX) SET @SQL = 'SELECT AdministratorCode, SUM(Total) as theTotal, SUM(WOD.Quantity) as theQty, AVG(Total) as avgTotal, (SELECT SUM(tblWOD.Amount) FROM tblWOD JOIN tblWO on tblWOD.OrderID = tblWO.ID WHERE tblWO.Approved = ''1'' AND tblWO.AdministratorCode = tblWO.AdministratorCode AND tblWO.OrderDate BETWEEN '+ @theDate +')' EXEC(@SQL)
SQLiteDatabase db; // initialize the db SQLiteStatement statement = null; try { db.compileStatement("select max(_id) from table"); int max = statement.simpleQueryForLong(); } catch (SQLException e) { // handle } finally { if (statement != null) { statement.close(); } }
SELECT ID_PROJECT FROM PROJECTS p1 WHERE (select balance from ...) > 0;
SELECT m.memo, (SELECT TOP 1 x.id FROM checking x WHERE x.memo = m.memo ORDER BY x.id) as ID FROM checking m GROUP BY m.memo
schedule day 1 1 1 3 1 7
SELECT MAX(field) FROM table WHERE field < (SELECT MAX(field) FROM table)
SELECT mc.CampaignId, c.CampaignTitle FROM MallCampaign mc where mallid in (SELECT FavoriteItemId AS FavoriteMalls FROM Favorite WHERE UserId = @UserId AND FavoriteItemType=1 ) and brandId in (SELECT FavoriteItemId AS FavoriteBrands FROM Favorite WHERE UserId = @UserId AND FavoriteItemType=3 ) and sectorid in (SELECT FavoriteItemId AS FavoriteSectors FROM Favorite WHERE UserId = @UserId AND FavoriteItemType=2 )
SELECT Col, COUNT(*) AS TOT FROM ( SELECT ColumnA AS Col FROM table UNION ALL SELECT ColumnB FROM table UNION ALL SELECT ColumnC FROM table ) AS A GROUP BY Col
SELECT ... From ... WHERE date > add_months(sysdate, -6)
INSERT INTO new_tbl SELECT * FROM old_tbl;
SELECT p.id as productid, p.some_column1, p.some_column2, pp.id as ProductPropertiesId, pp.name FROM `Products` p JOIN `ProductProperties` pp ON p.id = pp.product_id
IF OBJECT_ID('tmpEmployees_Test', 'U') IS NOT NULL DROP TABLE tmpEmployees_Test; CREATE TABLE tmpEmployees_Test (EmployeeID INT, EmployeeName VARCHAR(255)); INSERT tmpEmployees_Test (EmployeeID, EmployeeName) VALUES (1, 'Doe, Jane'), (2, 'Doe, John'), (3, 'Guy, Some'); IF OBJECT_ID('tmpOrders_Test', 'U') IS NOT NULL DROP TABLE tmpOrders_Test; CREATE TABLE tmpOrders_Test (EmployeeID INT, Customer VARCHAR(255), Date DATE, OrderType VARCHAR(255)); INSERT tmpOrders_Test (EmployeeID, Customer, Date, OrderType) VALUES (1, 'Fake Customer', '2016-05-14', 'New') , (2, 'Some Company', '2016-05-13', 'Change') , (3, 'Stuff Inc.', '2016-05-14', 'New') , (3, 'Cool Things', '2016-05-12', 'Change') , (3, 'Amazing Things', '2016-05-12', 'Change'); DECLARE @columns NVARCHAR(MAX), @sql NVARCHAR(MAX); SET @columns = N''; SELECT @columns += N', p.' + QUOTENAME(Name) FROM (SELECT distinct CONVERT(nvarchar(30) , p.Date , 101) as Name FROM dbo.tmpOrders_Test AS p where [Date] > GETDATE()-7 ) AS x; -- Kept it for formatting Purpose DECLARE @columns1 NVARCHAR(MAX) SET @columns1 = N''; SELECT @columns1 += N', ISNULL(p.' + QUOTENAME(Name) + ',''/'') AS ' + QUOTENAME(Name) FROM (SELECT distinct CONVERT(nvarchar(30) , p.Date , 101) as Name FROM dbo.tmpOrders_Test AS p where [Date] > GETDATE()-7 ) AS x; SET @sql = N' SELECT EmployeeName, Count(*) as Total ' + @columns1 + ' FROM ( SELECT EmployeeID, EmployeeName' + ''+ @columns1 + '' + ' FROM ( SELECT o.employeeID,EmployeeName, CAST(COUNT(case WHEN OrderType = ''New'' then 1 end) as varchar(5)) + ''/'' + CAST(COUNT(case WHEN OrderType = ''Change'' then 1 end) as varchar(5)) as OrderType, CONVERT(nvarchar(30) , p.Date , 101) as Date FROM dbo.tmpOrders_Test AS p INNER JOIN dbo.tmpEmployees_Test AS o ON p.EmployeeID = o.EmployeeID GROUP BY EmployeeName, Date, o.employeeID ) AS j PIVOT ( Max(OrderType) FOR Date IN (' + STUFF(REPLACE(@columns, ', p.[', ',['), 1, 1, '') + ') ) AS p) as p JOIN tmpOrders_Test as m on p.employeeID = m.employeeID where [Date] > GETDATE()-7 GROUP BY EmployeeName ' + @columns + ' '; PRINT @sql; EXEC sp_executesql @sql;
UPDATE playerRegSeason s INNER JOIN players p ON s.playerID = p.playerID SET s.NewPlayerID = p.NewPlayerID
(SELECT * FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = 'dashboard' -----------------------------^ --------^ AND TABLE_NAME = '".$this->table_name."' ---------------------------^ --------------------^ AND COLUMN_NAME = 'timestamp') ----------------------------^ --------^
SELECT * FROM Claims AS c WHERE EXISTS ( SELECT * FROM Edits AS e1 WHERE c.ClaimID = e1.ClaimID AND e1.RuleId=205) AND NOT EXISTS ( SELECT * FROM Edits AS e2 WHERE c.ClaimID = e2.ClaimID AND e2.RuleId=913)
SELECT * FROM mytable m WHERE (ts, id) < ( SELECT ts, id FROM mytable mi WHERE mi.id = :myid ) ORDER BY ts DESC, id DESC LIMIT 50
SELECT e.id, e.name, e.description, (SELECT count(*) FROM day d WHERE d.event_id = e.id) AS days FROM event e;
create or replace view DeptInfo as SELECT q1.dnumber, q1.dname, q1.AvgSal, q2.MaxSal, q3.MinSal FROM (SELECT dnumber, dname, AVG(salary) as AvgSal FROM department, employee GROUP BY dnumber, dname) q1, (SELECT dnumber, dname, MAX(salary) as MaxSal FROM department, employee GROUP BY dnumber, dname) q2, (SELECT dnumber, dname, MIN(salary) as MinSal FROM department, employee GROUP BY dnumber, dname) q3 WHERE q1.dnumber = q2.dnumber AND q2.dnumber = q3.dnumber AND q1.dname = q2.dname AND q2.dname = q3.name
WITH CTE AS (CARD, PRIORITY, SALE_CD, ROW_NUM) AS ( SELECT CARD , PRIORITY , SALE_CD , ROW_NUMBER() OVER(PARTITION BY SALE_CD ORDER BY PRIORITY ASC) AS ROW_NUM FROM PAYMENT ) SELECT main_data.id, main_data.dt, main_data.seq_num, main_data.sale_amt, main_data.sale_cd, promo.promo_cd, CTE.card, CTE.priority FROM main_data INNER JOIN promo ON promo.id = main_data.id AND main_data.dt >= promo.start_dt AND main_data.dt <= promo_end_dt INNER JOIN CTE CTE ON CTE.sale_cd = main_data.sale_cd AND CTE.card = main_data.card WHERE main_data.dt BETWEEN '2013-10-12' AND '2013-10-12' AND CTE.ROW_NUM = '1'
select DISTINCT E_reg.applicant_id, E_REG.L_NAME, E_REG.F_NAME, E_REG.B_DATE, E_REG.REG_DATE, from E_REG join TRANSACTION on E_REG.ID=TRANSACTION.PAR_ID where TRANSACTION.BEGIN_DATE BETWEEN to_date ('01-APR-2012')AND to_date('30-JUN- 2012') and (e_reg.applicant_id NOT IN (select applicant_id from w_reg where reg_date <'01-JUL-2012' and exit_date is NULL or exit_date >='01-APR-2012' or e_reg.applicant_id NOT IN (select applicant_id from t_reg where reg_date <'01-JUL-2012' and exit_date is NULL or exit_date>='01-APR-2012') or e_reg.applicant_id NOT IN (select applicant_id from r_reg where reg_date <'01-JUL-2012' and o_attend IS NOT NULL and term_date is NULL or term_date >='01-APR-2012') )
SELECT A.*, B.*, C.*, D.*, GET_E(A."PK"), GET_F(A."PK"), GET_G(A."PK") FROM A LEFT OUTER JOIN B ON A."PK" = B."FK" LEFT OUTER JOIN C ON A."PK" = C."FK" LEFT OUTER JOIN D ON A."FK" = D."PK" WHERE A.PK = ####
protected HqlTreeNode VisitNhMax(NhMaxExpression expression) { return _hqlTreeBuilder.Cast( _hqlTreeBuilder.Max( VisitExpression(expression.Expression).AsExpression()), expression.Type); }
while($row = mysqli_fetch_array($result)) { echo '<tr><td><a href="'.$row['link'].'">'.$row['Title'].'</a></td></tr>'; }
INSERT INTO [GT_INVESTMENT] ([ID],[SEQN],[OrgSQENNo], OrgPaymentDate, InvestAmnt, InvestmentDate) SELECT [ID],@NEW_SEQN , CASE [OrgSQENNo] WHEN 0 THEN @SEQN ELSE [OrgSQENNo] END , OrgPaymentDate, (InvestAmnt+TotalInterest), MatDate FROM [GT_INVESTMENT] WHERE SEQN = @SEQN
sudo gem install ibm_db <<heredoc 1 heredoc
SELECT OrderID FROM dbo.FooTable ORDER BY CAST(OrderID AS VARCHAR(255))
Select empSal from Emp_Master where empID = '&1'; -- not &2 exit
select * from orders where extract(month from order_date) in (3,4,5);
OFFSET { integer_constant | offset_row_count_expression } { ROW | ROWS } [ FETCH { FIRST | NEXT } {integer_constant | fetch_row_count_expression } { ROW | ROWS } ONLY ]
UPDATE categories SET categories_image = 'bearings.jpg' WHERE categories_id IN ( SELECT categories_id FROM categories_description WHERE categories_name = 'Bearings' )
create or replace function random_str(v_length number) return varchar2 is my_str varchar2(4000); begin for i in 1..v_length loop my_str := my_str || dbms_random.string( case when dbms_random.value(0, 1) < 0.5 then 'l' else 'x' end, 1); end loop; return my_str; end; / select random_str(30) from dual; RANDOM_STR(30) -------------------------------------------------------------------------------- pAAHjlh49oZ2xuRqVatd0m1Pv8XuGs
WITH RECURSIVE months(m) AS ( SELECT strftime('%Y-%m', 'now') UNION ALL SELECT strftime('%Y-%m', m || '-01', '-1 month') FROM months LIMIT 5 ) SELECT m FROM months;
Public Sub MIAB1290() Dim lastB&, k&, e, f, z, v, w, vErr, r As Range With [a2] Set r = .Resize(.Item(.Parent.Rows.Count - .Row + 1, 5).End(xlUp).Row - .Row + 1, .Item(, .Parent.Columns.Count - .Column + 1).End(xlToLeft).Column - .Column + 1) lastB = .Item(.Parent.Rows.Count - .Row + 1, 2).End(xlUp).Row - .Row + 1 End With With r .Worksheet.Sort.SortFields.Clear .Sort Key1:=.Item(1, 2), Order1:=1, Key2:=.Item(1, 2), Order2:=1, Header:=xlYes v = .Value2 End With ReDim w(1 To UBound(v), 1 To 1) vErr = CVErr(xlErrNA) For k = 2 To UBound(v) e = v(k, 5) f = v(k, 6) w(k, 1) = vErr z = BSearch(v, 2, e, 1, lastB) If z Then Do While v(z, 2) = e If Abs(v(z, 3) - f) <= 3 Then w(k, 1) = v(z, 1) Exit Do End If z = z + 1 If z > UBound(v) Then Exit Do Loop End If Next r(1, 8).Resize(r.Rows.Count) = w End Sub Private Function BSearch(vA, col&, vVal, ByVal first&, ByVal last&) Dim k&, middle& While last >= first middle = (last + first) / 2 Select Case True Case vVal < vA(middle, col) last = middle - 1 Case vVal > vA(middle, col) first = middle + 1 Case Else k = middle - 1 Do While vA(k, col) = vA(middle, col) k = k - 1 If k > last Then Exit Do Loop BSearch = k + 1 Exit Function End Select Wend BSearch = 0 End Function
update Dash set Analysts = stuff( ( select ', ' + P.NameLast from dbo.Item as I inner join dbo.Assignment as A on A.ItemId = I.ItemId inner join dbo.Person as P on P.PersonId = A.PersonId where I.ItemId = D.DPItem and P.RoleId in (3, 4) for xml path(''), type ).value('.', 'nvarchar(max)') , 1, 2, '') from dbo.Dash as D
SELECT GROUP_CONCAT(i SEPARATOR '|') FROM ( SELECT i FROM ( SELECT i FROM integers WHERE i BETWEEN 1 AND 50 ORDER BY RAND() LIMIT 5) sort_these_five ORDER BY i) concat_these_five;
select (select top 1 Name from Period where StartDate < DateModified order by StartDate desc), a.OldValue, a.NewValue from Audit a
SELECT COUNT(DISTINCT User_Id) FROM ( SELECT User_Id FROM t1 GROUP BY User_Id, Action_Type HAVING COUNT(*) > 1 ) t
SELECT col1, col2, MIN(grp) AS source_group FROM (SELECT 1 AS grp, col1, col2 FROM t1 UNION ALL SELECT 2 AS grp, col1, col2 FROM t2) AS t GROUP BY col1, col2 ORDER BY MIN(grp), col1
select DATEADD(dd, DATEDIFF(dd, 0, COL),0) from TABLE
select * from table_name order by date desc, case when new='true' then 1 else 0 end desc
type t_id_table is table OF other_table.id%type index by binary_integer; v_table t_id_table; -- fill the table select id bulk collect into v_table from other_table where abc in ('&val1','&val2','&val3'); -- then at a later stage... select * from some_table st , table(cast(v_table AS t_id_table)) idt where st.id = idt.id;
select date_posted, count(*) from (select date_posted from article union all select date_posted from blogposts) v group by date_posted
UPDATE table SET FieldA = CONCAT(IFNULL(FieldB,'No Value'), ' - arbitrary string')
IF EXISTS (SELECT 1 FROM people WHERE person_id = my_person_id) THEN -- do something END IF;
select replace(replace(img_name, '.png', ''), '.jpg', '') as name from image group by replace(replace(img_name, '.png', ''), '.jpg', '') having count(*) = 3
SELECT col1, SUM(A) TotalA, SUM(B) TotalB FROM ( select col1, CASE WHEN col2 = 1 THEN col3 ELSE 0 END A, CASE WHEN col2 = 2 THEN col3 ELSE 0 END B from tabella ) t GROUP BY Col1
create unique index idx_tbl_col2_col3 on (col2, col3)
DECLARE @TotalHours VARCHAR(5) = '44:43' SELECT CAST(CAST(AvgMinutes AS INT)/60 AS VARCHAR) + ':' + CAST(CAST(AvgMinutes AS INT)%60 AS VARCHAR) FROM ( SELECT CEILING((CAST(LEFT(@TotalHours,CHARINDEX(':',@TotalHours) - 1) AS INT ) * 60 + CAST(RIGHT(@TotalHours,LEN(@TotalHours) - CHARINDEX(':',@TotalHours)) AS INT ))/5.0) AvgMinutes ) AS TotalMinutes
INSERT INTO Table_C (SELECT null, Table_A.item, Table_B.color, null FROM Table_A CROSS JOIN Table_B);
SELECT * FROM (SELECT id, itemcount, version, ROW_NUMBER() OVER (ORDER BY version DESC, itemcount DESC) AS rn FROM (SELECT id, SUM(itemcount) as itemcount, version FROM ARTICLE_COUNTER_STATISTICS_m WHERE id != '0' GROUP BY id, version ) ) WHERE rn BETWEEN 3 AND 20 -- just an example
select sa.name as "Sender Account" from security_account sa join spot s on sa.id = s.provider_account_id where s.format = 'SD' except select sa.name as "Sender Account" from security_account sa join spot s on sa.id = s.provider_account_id where s.format <> 'SD'
SELECT * FROM `job` WHERE c_name = 'John doe' AND (customer_ref LIKE '%do%' OR order_details LIKE '%do%')
package com.MyPackage; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.UUID; import android.content.Context; import android.database.Cursor; import android.database.SQLException; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteException; import android.database.sqlite.SQLiteOpenHelper; import android.util.Log; public class AnyDBAdapter { private static final String TAG = "AnyDBAdapter"; private DatabaseHelper mDbHelper; private static SQLiteDatabase mDb; //make sure this matches the //package com.MyPackage; //at the top of this file private static String DB_PATH = "/data/data/com.MyPackage/databases/"; //make sure this matches your database name in your assets folder // my database file does not have an extension on it // if yours does // add the extention private static final String DATABASE_NAME = "data"; //Im using an sqlite3 database, I have no clue if this makes a difference or not private static final int DATABASE_VERSION = 3; private final Context adapterContext; public AnyDBAdapter(Context context) { this.adapterContext = context; } public AnyDBAdapter open() throws SQLException { mDbHelper = new DatabaseHelper(adapterContext); try { mDbHelper.createDataBase(); } catch (IOException ioe) { throw new Error("Unable to create database"); } try { mDbHelper.openDataBase(); } catch (SQLException sqle) { throw sqle; } return this; } //Usage from outside // AnyDBAdapter dba = new AnyDBAdapter(contextObject); //in my case contextObject is a map // dba.open(); // Cursor c = dba.ExampleSelect("Rawr!"); // contextObject.startManagingCursor(c); // String s1 = "", s2 = ""; // if(c.moveToFirst()) // do { // s1 = c.getString(0); // s2 = c.getString(1); // } while (c.moveToNext()); // dba.close(); public Cursor ExampleSelect(string myVariable) { String query = "SELECT locale, ? FROM android_metadata"; return mDb.rawQuery(query, new String[]{myVariable}); } //Usage // AnyDBAdatper dba = new AnyDBAdapter(contextObjecT); // dba.open(); // dba.ExampleCommand("en-CA", "en-GB"); // dba.close(); public void ExampleCommand(String myVariable1, String myVariable2) { String command = "INSERT INTO android_metadata (locale) SELECT ? UNION ALL SELECT ?"; mDb.execSQL(command, new String[]{ myVariable1, myVariable2}); } public void close() { mDbHelper.close(); } private static class DatabaseHelper extends SQLiteOpenHelper { Context helperContext; DatabaseHelper(Context context) { super(context, DATABASE_NAME, null, DATABASE_VERSION); helperContext = context; } @Override public void onCreate(SQLiteDatabase db) { } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { Log.w(TAG, "Upgrading database!!!!!"); //db.execSQL(""); onCreate(db); } public void createDataBase() throws IOException { boolean dbExist = checkDataBase(); if (dbExist) { } else { //make sure your database has this table already created in it //this does not actually work here /* * db.execSQL("CREATE TABLE IF NOT EXISTS \"android_metadata\" (\"locale\" TEXT DEFAULT 'en_US')" * ); * db.execSQL("INSERT INTO \"android_metadata\" VALUES ('en_US')" * ); */ this.getReadableDatabase(); try { copyDataBase(); } catch (IOException e) { throw new Error("Error copying database"); } } } public SQLiteDatabase getDatabase() { String myPath = DB_PATH + DATABASE_NAME; return SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY); } private boolean checkDataBase() { SQLiteDatabase checkDB = null; try { String myPath = DB_PATH + DATABASE_NAME; checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READONLY); } catch (SQLiteException e) { } if (checkDB != null) { checkDB.close(); } return checkDB != null ? true : false; } private void copyDataBase() throws IOException { // Open your local db as the input stream InputStream myInput = helperContext.getAssets().open(DATABASE_NAME); // Path to the just created empty db String outFileName = DB_PATH + DATABASE_NAME; // Open the empty db as the output stream OutputStream myOutput = new FileOutputStream(outFileName); // transfer bytes from the inputfile to the outputfile byte[] buffer = new byte[1024]; int length; while ((length = myInput.read(buffer)) > 0) { myOutput.write(buffer, 0, length); } // Close the streams myOutput.flush(); myOutput.close(); myInput.close(); } public void openDataBase() throws SQLException { // Open the database String myPath = DB_PATH + DATABASE_NAME; mDb = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READWRITE); } @Override public synchronized void close() { if (mDb != null) mDb.close(); super.close(); } } }
SELECT t.src , t.title , t.maker , t.partnum , t.price FROM ( SELECT '[data]' AS `src` , d1.title AS `title` , d1.maker AS `maker` , d1.partnum AS `partnum` , d1.price AS `price` , d1.partnum AS `product` FROM data d1 WHERE d1.sysn = ? UNION ALL SELECT '[cross]' , c2.title , c2.maker , c2.partnum , c2.price , c2.product FROM cross c2 JOIN data d2 ON d2.partnum = c2.product WHERE d2.sysn = ? ) ORDER BY t.product DESC, t.src DESC, t.price ASC
select m.id, m.datecolumn, m.note from (select max(datecolumn) datecolumn, id from mytable group by id) sub inner join mytable m on m.id = sub.id and m.datecolumn= sub.datecolumn
select pallet_id, case when count(case when product_group not in ('LAMINAAT','ACCESSORIE') then 1 end) > 0 then '' when count(distinct product_group) > 1 then 'Mix' when count(case when product_group = 'LAMINAAT' then 1 end) > 0 then 'LAM' else 'ACC' end as label from mytable group by pallet_id
SELECT p FROM BlogRegionBundle:Post p LEFT JOIN p.tags t WHERE t.id = :blogId AND p.state = :state AND p.deleted = 0 AND :user NOT MEMBER OF p.views
NODE id NODE_POST id pk fk node(id) title body NODE_COMMENT id pk fk node(id) body post_id fk node_post(id) parent_comment_id fk node_comment(id)
INSERT INTO Client_First_Name VALUES(SELECT Client_Name LIKE '% %' THEN LEFT(Client_Name, Charindex(' ', Client_Name) - 1)); INSERT INTO Client_Surname VALUES(SELECT Client_Name LIKE '% %' THEN RIGHT(Client_Name, Charindex(' ', Reverse(Client_Name)) - 1));
Using a SQL query SELECT nspname, -- schema name defaclobjtype, -- object type defaclacl -- default access privileges FROM pg_default_acl a JOIN pg_namespace b ON a.defaclnamespace=b.oid;
<?php $dates = array( '2014-07-26', '2014-08-04' ); $this->db->from('tblName'); $this->db->where('id','007'); // first variant foreach($dates as $date){ $this->db->where('doj !=',$date); } // or second variant $this->db->where_not_in('doj',$dates); // <- seems to be better // finally get result $result = $this->db->get(); if($result->num_rows()){ var_dump($result->result_array()); } else { echo 'no rows found'; } // check query echo $this->db->last_query(); ?>
select 'Current' As TimePeriod, sum(case when CPT_ORIGINATED > SUBDATE(DATE(NOW()),30) THEN 1 else 0 end) as CountOfThings, from `cpt-prod` where CPT_STATE <> 'Closed' UNION ALL SELECT 'Past1' AS TimePeriod, sum(case when CPT_ORIGINATED > SUBDATE(DATE(NOW()),60) AND CPT_ORIGINATED < SUBDATE(DATE(NOW()),30) THEN 1 else 0 end) as CountOfThings, from `cpt-prod` where CPT_STATE <> 'Closed'
OPEN V_CF_CURSOR FOR SELECT COUNT(*) FROM "VPA"."Employee"; -- returns 1 row FETCH V_CF_CURSOR INTO CF_ROWCOUNT;
WHERE (pc.IsBusinessDay IS NULL AND ac.IsBusinessDay = 0) OR pc.IsBusinessDay = 0
if @SelectFlag = 1 select name, Address, salary, CreatedBy from employee else if @UpdateFlag = 1 select name, Address, salary from employee
SELECT * FROM financials WHERE date >= NOW() - INTERVAL 30 DAY
var conn = { host : '127.0.0.1', user : 'user', password : 'pass', charset : 'utf8' }; // connect without database selected var knex = require('knex')({ client: 'mysql', connection: conn}); knex.raw('CREATE DATABASE my_database') .then(function(){ knex.destroy(); // connect with database selected conn.database = 'my_database'; knex = require('knex')({ client: 'mysql', connection: conn}); knex.schema.createTable('my_table', function (table) { table.string('my_field'); }) .then(function() { knex.destroy(); }); });
SELECT ImpFile, DATEADD(hh, DATEDIFF(hh, 0, ImpDate), 0) FROM nol_artikula_izmaina
SELECT a.name, b.office, c.firm, d.status FROM job a JOIN depts b ON a.office = b.ref JOIN firms c ON b.firm = c.ref JOIN statuses d ON a.status = d.ref
with start_grp as ( select dt, user_id, programme, case when dt - lag(dt,1) over (partition by user_id order by dt) > interval '0 day 2:00:00' then 1 else 0 end grp_start from binge ), assign_grp as ( select dt, user_id, programme, sum(grp_start) over (partition by user_id order by dt) grp from start_grp) select user_id, grp as binge, max(dt) - min(dt) as binge_length from assign_grp group by user_id, grp having count(programme) > 1
select column1 from the_table where column2 in ('Doc1', 'Doc2', 'Doc3') group by column1 having count(distinct column2) = 3;
SELECT Col1, Col2, Col3 FROM( SELECT Col1, Col2, Col3, ROW_NUMBER() OVER (PARTITION BY Col1 ORDER BY Col1, Col2, Col3) RNum FROM YourTable )X WHERE RNum<=5
UPDATE userprofileplus SET mobile = 9199225533 WHERE (mobile is null and userid = 5) and (Id IN (SELECT TOP (1) Id FROM userprofileplus AS userprofileplus_1 WHERE (mobile IS NULL) AND (UserId = 5)))
select g.* , home.team_name as home_team_name , road.team_name as road_team_name from Games g inner join Teams home on home.tid = g.home_team_id inner join Teams road on road.tid = g.road_team_id where g.home_team_id = 1 or g.road_team_id = 1
Private Sub txtFileName_AfterUpdate() If Not IsNull(txtFileName) Then txtFileName = Trim$(txtFileName) If Not Right$(txtFileName, 4) = ".zip" Then txtFileName = txtFileName & ".zip" End If End If End Sub
WITH all_items AS ( SELECT t1.import_id , t1.import_at , t2.item_id , t2.item_url , t2.item_name , t2.item_description , ROW_NUMBER() OVER(PARTITION BY item_url ORDER BY t1.import_at DESC) AS item_url_rank FROM dbo.table1 AS t1 JOIN dbo.table1 AS t2 ON t2.import_id = t1.import_id ) SELECT t1.import_id , import_at , item_id , item_url , item_name , item_description WHERE item_url_rank = 1;
SELECT DISTINCT PosterID FROM table1 x WHERE PostingDate BETWEEN '2012-05-01' AND '2012-06-30' AND posterID NOT IN (SELECT PosterID FROM table1 y WHERE PostingDate > '2012-07-01' AND x.CategoryID = y.CategoryID);
SELECT TO_CHAR(696585242087, '99G999G999G9999', 'NLS_NUMERIC_CHARACTERS=",."') FROM dual
Select I_Ftn, I_Col, count(c.i_id_num) cnt From DSCL_ALL.W_CALENDER c Where c.UNIT_CODE= '01' AND c.i_g_vill = '45' and c.i_g_code = '1' and c.survey_year = '2012-2013' and not exists (select 1 from w_mill_pur m where m.unit_code = c.unit_code and m.m_vill = c.i_g_vill and m.m_grow = c.i_g_code and m.m_indent = c.i_number) Group By I_Ftn, I_Col ORDER BY I_ftn, I_col)
SELECT currency, SUM(total1) AS total FROM ( SELECT currency_a AS currency, SUM(a_amount) AS total1 FROM table1 GROUP BY currency_a UNION ALL SELECT currency_b, SUM(b_amount) AS total2 FROM table1 GROUP BY currency_b UNION ALL SELECT currency_c, SUM(c_amount) AS total2 FROM table1 GROUP BY currency_c ) T GROUP BY currency
select (case when min(name) = max(name) then max(name) else thegroup end) as name, sum(balance) as balance from theRecords r group by thegroup;
sqlplus x/x@orcl <sql.txt
SELECT COUNT(Dispute_Reference_no) AS reg_inc FROM mytable WHERE reasoncd in ('b2', 'b3') AND ((DATENAME(weekday, GETDATE()) = 'monday' AND datecreated = dbo.fn_getdateonly(GETDATE()-3)) OR (DATENAME(weekday, GETDATE()) = 'tuesday' AND datecreated BETWEEN dbo.fn_getdateonly(GETDATE()-3) AND dbo.fn_getdateonly(GETDATE())) OR (atecreated = dbo.fn_getdateonly(GETDATE()-1) )
;WITH cte AS ( SELECT StaffId, FirstWeekEnding AS WeekEnding FROM STAFF UNION ALL SELECT StaffId, DATEADD(D, 7, WeekEnding) FROM cte WHERE DATEADD(D, 7, WeekEnding) <= GETDATE() ) SELECT StaffId, WeekEnding FROM cte LEFT JOIN Header ON cte.StaffId = Header.StaffId AND cte.WeekEnding = Header.WeekEnding WHERE Header.WeekEnding IS NULL OPTION (MAXRECURSION 32767)
SELECT TO_CHAR ( TO_DATE ( SUBSTR (regexp_replace(file_name, '[A-Z][a-z]', '') , INSTR (regexp_replace(file_name, '[A-Z][a-z]', '') , '_', -1, 2)+ 1, 8), 'YYYYMMDD'), 'DD-MM-YYYY') FROM dual;
WITH temp_roles as ( SELECT * FROM role_ WHERE name IN ('User', 'Owner', 'Portal Content Reviewer', 'Community Owner', 'Administrator') UNION SELECT <values> FROM dual )
ORDER BY Min([Transaction Date]) DESC ORDER BY 4 DESC
create table albums ( album_id integer primary key, -- other fields... ); create table special_offers ( album_id integer primary key references albums(album_id), -- other fields... );
select s.col1, s.col2, ... s.colN, max(s.col1) over (partition by s.col2, ... ), min(s.col1) over (partition by s.col2, ... ) from stuff as s;
declare @Questions varchar(max), @SQLQuery varchar(max) create table #OutputTable ( refID int, SessionID int, QuestionID varchar(50), AnswerValue varchar(50) ) insert into #OutputTable values (9000,205545715,'[4907]','Good morning'), (12251,205543469,'[10576:16307]','3'), (12255,205543469,'[10907:17001]','4'), (13157,205543703,'[10576:16307]','3'), (14387,205543493,'[10907:17001]','2'), (14389,205543493,'[10911:17007]','3') set @Questions = (STUFF((SELECT distinct ',' + cast(i.QuestionID as varchar(20)) FROM #OutputTable i FOR XML PATH(''), TYPE).value('.','VARCHAR(max)'), 1, 1, '')) set @SQLQuery = ' select SessionID,'+ @Questions +' from ( select SessionID, replace(replace(QuestionID,''['',''''),'']'','''') QuestionID, AnswerValue from #OutputTable ) p PIVOT ( max(Answervalue) FOR p.QuestionID IN ('+ @Questions +') ) as pvt order by SessionID desc' exec(@SQLQuery)
select (case when value between 0 and 20 then '0-20' when value between 21 and 45 then '21-45' when value between 46 and 100 then '46-100' else 'other' end) as range, count(*) from RandomValueTable group by (case when value between 0 and 20 then '0-20' when value between 21 and 45 then '21-45' when value between 46 and 100 then '46-100' else 'other' end);
SELECT a.student_id, s.name, COUNT(a.subject_id) as taken_subjects FROM assignments a INNER JOIN students s ON a.student_id = s.id GROUP BY a.student_id, s.name HAVING COUNT(a.subject_id) = (SELECT COUNT(*) FROM assignments GROUP BY student_id LIMIT 1)
ALTER FUNCTION dbo.CalcMinsInHour(@start DATETIME, @end DATETIME, @hour INTEGER) RETURNS INTEGER AS BEGIN DECLARE @StartOfHour DATETIME DECLARE @EndOfHour DATETIME SELECT @StartOfHour = DATEADD(hh, @hour, CAST(CAST(@start AS DATE) AS DATETIME)) IF NOT (@StartOfHour BETWEEN @start and @end) SET @StartOfHour = DATEADD(hh, @hour, CAST(CAST(@end AS DATE) AS DATETIME)) SELECT @EndOfHour = DATEADD(hh, 1, @StartOfHour) RETURN ( SELECT CASE WHEN @EndOfHour < @start OR @StartOfHour > @end THEN 0 ELSE DATEDIFF(mi, CASE WHEN @StartOfHour <= @start THEN @start ELSE @StartOfHour END, CASE WHEN @EndOfHour > @end THEN @end ELSE @EndOfHour END) END ) END
create table Editions ( EditionsId int not null identity(1, 1) primary key, JournalId varchar(10) references Publications(JournalId), EditionName varchar(255), . . . )
Select ID as Num, (select Count(*) from TASK t where t.ID = o.ID) as Total from ORDER o;
Id TaskId PersonId MonthYearKey MonthYearValue
db.collection.find({"string_list" : {$all:["large","world","hello"]}, "string_list": {$size: 3}});
SELECT (left(convert(char(11), date, 107), 3) + " " + right(convert(char(11), date, 107), 2)) as date from ( select date from yourtable group by date order by year(date) asc, month(date)asc ) as a
SELECT CASE WHEN fourthlevel.case_type IN ('Complaint') THEN (SELECT cast(COUNT(*) as varchar2(255)) FROM work_days1 WHERE work_days1.business_date > fourthlevel.cdate AND work_days1.business_date <= COALESCE (fourthlevel.close_date, SYSDATE)) WHEN fourthlevel.case_type IN ('Enquiry') THEN (SELECT cast(COUNT(*) as varchar2(255)) FROM work_days1 WHERE work_days1.business_date > fourthlevel.create_date AND work_days1.business_date <= COALESCE (fourthlevel.close_date, SYSDATE)) WHEN fourthlevel.case_status = 'Cancelled' THEN 'N/A' END AS sla_days FROM fourthlevel
Select case when firstcity = '008' then secondcity else firstcity end 'City', Distance,Roadname,Roadstatus from table where (firstcity= '008' or secondcity ='008')
SELECT A.Date, SUM(CASE WHEN A.Methos = 'A' THEN A.Count ELSE 0 END) AS 'A', SUM(CASE WHEN A.Methos = 'B' THEN A.Count ELSE 0 END) AS 'B', SUM(CASE WHEN A.Methos = 'C' THEN A.Count ELSE 0 END) AS 'C', SUM(CASE WHEN A.Methos = 'D' THEN A.Count ELSE 0 END) AS 'D', SUM(CASE WHEN A.Methos = 'E' THEN A.Count ELSE 0 END) AS 'E', SUM(CASE WHEN A.Methos = 'F' THEN A.Count ELSE 0 END) AS 'F', SUM(CASE WHEN A.Methos = 'G' THEN A.Count ELSE 0 END) AS 'G', SUM(CASE WHEN A.Methos = 'H' THEN A.Count ELSE 0 END) AS 'H' FROM tableA A GROUP BY A.Date
if (ds.Tables.Count > 0) { ds.Tables[ds.Tables.Count - 1].TableName = "name"; }
DECLARE @sql1 VARCHAR(4000) = '' DECLARE @sql2 VARCHAR(4000) = '' DECLARE @sql3 VARCHAR(4000) = '' SELECT @sql1 = 'SELECT Id , Team ' SELECT @sql2 = @sql2 + ' , MAX(CASE WHEN RN = ' + CONVERT(VARCHAR(10), RN) + ' THEN Players END) AS [' + CONVERT(VARCHAR(10), RN) + ']' + CHAR(10) FROM( SELECT DISTINCT RN = ROW_NUMBER() OVER(PARTITION BY Id, Team ORDER BY (SELECT NULL)) FROM Tbl )t ORDER BY RN SELECT @sql3 = 'FROM( SELECT *, RN = ROW_NUMBER() OVER(PARTITION BY Id, Team ORDER BY (SELECT NULL)) FROM Tbl )t GROUP BY Id, Team' PRINT (@sql1 + @sql2 + @sql3) EXEC (@sql1 + @sql2 + @sql3)
public boolean Exists(String link) { Cursor cursor = ourDatabase.rawQuery("select 1 from fav where link='"+link+"'",new String[] {}); boolean exists = (cursor.getCount() > 0); cursor.close(); return exists; }
CREATE TYPE my_dates AS TABLE OF DATE; / SELECT d.column_value AS Date_Of_Concern, count(Player_Id) AS Retained FROM Player JOIN TABLE (my_dates(to_date('2012-sep-03', 'yyyy-mon-dd'), to_date('2012-sep-04', 'yyyy-mon-dd'), to_date('2012-sep-05', 'yyyy-mon-dd'))) d ON d.column_value - trunc(Init_Dtime) BETWEEN 0 AND 7 GROUP BY d.column_value
create table dbo.Products ( ProductCode char(10) not null primary key, ProductName nvarchar(50) not null, ProductDescription nvarchar(100) not null, -- other columns ) create table dbo.ProductsTranslations ( ProductCode char(10) not null, LanguageCode char(2) not null, ProductName nvarchar(50) not null, ProductDescription nvarchar(100) not null, -- other translations constraint FK1 foreign key (ProductCode) references dbo.Products (ProductCode), constraint FK2 foreign key (LanguageCode) references dbo.Languages (LanguageCode), constraint PK primary key (ProductCode, LanguageCode) )
Select (Select Count (*) from tso_skf_nomeas_in60days_v) / (Select Count (*) from tso_skf_recent_meas) as perc from dual
with cte as ( select p.productcategory, p.ProductSubCategory, COUNT(*) cnt, ROW_NUMBER() over (partition by p.productcategory order by count(*) desc) rn from products p join sales s on p.ProductSubCategory = s.ProductSubCategory group by p.productcategory, p.ProductSubCategory ) select * from cte where rn = 1
Declare @Date date = '2015-05-02' While DATENAME(WEEKDAY,@Date) <> 'Thursday' begin Set @Date = DATEADD(dd, -1,@Date) end Select @Date
SELECT DIM_DRUG_NAME_SHORT.Drug_Name_Short AS 'Med_Name_Short' , SUM(Baseline.Doses) as 'DOT' , Day(Baseline.Dispense_Date) as 'd_Date' FROM FACT_AMS_Baseline_Report Baseline INNER JOIN DIM_DRUG_NAME_SHORT ON Baseline.Med_Name_ID = DIM_DRUG_NAME_SHORT.Drug_Name_Long INNER JOIN DIM_Date tDate ON Baseline.Dispense_Date = tDate.Date WHERE Baseline.Encounter = '00000001/01' GROUP BY DIM_DRUG_NAME_SHORT.Drug_Name_Short , Baseline.Dispense_Date Order By Drug_Name_Short
SELECT year_born as year, count(*) as numridersborn FROM Riders GROUP BY year_born ORDER BY year_born;
lstResults.RowSource = "select EmpId from tblTesting where Empid = " & Me.txtSearchEmpId.Value
select r.ID, m.MATERIALID, m.LOT, sum(ms.AMMOUNT) as aantal, sum(m.NETPRICE )as prijs, sum(ms.AMMOUNT * m.NETPRICE) as Total from rc_recall r inner join RC_RECALLMATSTORE ms on r.ID = ms.RECALLID inner join RC_RECALLMATERIAL m ON ms.RECALLID = m.RECALLID and ms.LINE = m.LINE where r.ID = '2015073' and d.LANG = 'FR' group by r.ID, m.MATERIALID, m.LOT;
select * from dbo.ONE where LastLogin is NULL and datediff(ss,regdate,GetDate())<30
;with cte AS (SELECT *,COUNT(*) OVER(PARTITION BY Country,Category) CT ,CASE WHEN Category IS NOT NULL THEN DENSE_RANK() OVER (ORDER BY Country) END Rank_ FROM Table1) SELECT Country ,State ,Category ,CASE WHEN CT > 1 AND Rank_ IS NOT NULL THEN DENSE_Rank() OVER(ORDER BY Rank_ DESC) END AS Group_ FROM cte ORDER BY Country DESC,State
SELECT c.id, c.name FROM customers c WHERE not exists (select customer_id from modulemembers m where c.id = m.customer_id) order by c.name
WHERE ProductID NOT IN ( SELECT ProductID FROM ProductCustomerLevel WHERE CustomerLevelID=9 )
SELECT Username, COUNT(DISTINCT(Date)) AS UniqueDaysAppeared FROM Occurrences GROUP BY Username
select A.transactionNumber, A.DealNumber, C.GroupLookup AS [Group] from TableOne A inner join TableTwo B on A.transactionNumber = B.tranNumber inner join TableThree C on C.Group = A.Group where B.ID = 111111
# get all rows with distinct (unique) hashes from Remote and create a list of hashes. remote_hash_list = [item.hash for item in Remote.query.distinct(Remote.hash).all()] # Now get all Local items that hash is not in remote hashes list local_items = Local.query.filter(Local.hash.notin_(remote_hash_list)).all()
select customer.customer_num, customer.fname, isnull(sum(items.total_price),0) amountSpent from customer left join orders on customer.customer_num = orders.customer_num left join items on orders.order_num = items.order_num and items.manu_code like 'HRO' group by customer.customer_num, customer.fname
BEGIN SET NOCOUNT ON; SELECT Top 20 A.imgID, COUNT(*) OVER() AS volume, ( SELECT B.commentID, COUNT(*) OVER() AS volume FROM MOC_ImgComments B WHERE B.imgID = A.imgID FOR XML PATH(''), ELEMENTS, TYPE ) FROM MOC_ImgComments A ORDER BY volume desc, A.imgID FOR XML PATH('images'), ELEMENTS, TYPE, ROOT('ranks') group by A.imgID END
SELECT *, ROW_NUMBER() OVER (ORDER BY somefield) rownum FROM table;
SELECT something*1.0/total FROM somewhere
UPDATE table_name SET column1_name = round(column1_name, 2 ), column2_name = round(column2_name, 2 ), ... columnN_name = round(columnN_name, 2 )
;With OrgChart as ( SELECT id,id as BaseID FROM employee WHERE Active=1 UNION ALL SELECT e.ID, g.BaseID as BaseID FROM employee e JOIN OrgChart g on e.supervisorid=g.id WHERE e.Active=0 ), ForUpd as (SELECT ID,BASEID FROM OrgChart WHERE ID<>BAseID) UPDATE A SET empid = B.baseID FROM component A JOIN ForUpd B ON A.empid = B.id
select * from sampleTable where status = 'A' and SUBSTR(some_code_column, 1, 4) = 9999
create table re (country varchar2(10),reg varchar2(100)); insert into re values ('us','^[0-9]{3}-[0-9]{2}-[0-9]{4}$'); select case when regexp_like('987-65-4321' ,reg) then 'Match Found' else 'No Match Found' end as output from re where country = 'us'; Match Found
SELECT month(u.`userRegistredDate`), sum(CASE WHEN u.`userTypeID`=1 THEN 1 ELSE 0 END) AS agent, sum(CASE WHEN u.`userTypeID`=2 THEN 1 ELSE 0 END) AS individuals, sum(CASE WHEN u.`userTypeID`=3 THEN 1 ELSE 0 END) AS builders, sum(CASE WHEN u.`userTypeID`=4 THEN 1 ELSE 0 END) AS real_estate_companies, u.`userRegistredDate` AS 'timestamp',m.month FROM ( SELECT 'January' AS MONTH UNION SELECT 'February' AS MONTH UNION SELECT 'March' AS MONTH UNION SELECT 'April' AS MONTH UNION SELECT 'May' AS MONTH UNION SELECT 'June' AS MONTH UNION SELECT 'July' AS MONTH UNION SELECT 'August' AS MONTH UNION SELECT 'September' AS MONTH UNION SELECT 'October' AS MONTH UNION SELECT 'November' AS MONTH UNION SELECT 'December' AS MONTH ) AS m left join `dp_users` AS u ON m.month = MONTHNAME(u.`userRegistredDate`) and u.`userRegistredDate` < Now( ) AND u.`userRegistredDate` > DATE_ADD( Now( ) , INTERVAL -12 MONTH ) LEFT JOIN `dp_user_types` AS ut ON u.`userTypeID` = ut.`type_id` GROUP BY m.month order by FIELD(m.month,'July','August','September','October','November','December','January','February','March','April','May','June')
SELECT FixHours, AddHours, CalculatedValue FROM tbl WHERE FixHours = 0 OR AddHours = 0 UNION SELECT FixHours, 0, CalculatedValue FROM tbl WHERE FixHours <> 0 AND AddHours <> 0 UNION SELECT 0, AddHours, CalculatedValue FROM tbl WHERE FixHours <> 0 AND AddHours <> 0
select @one := 1 as one, 2 * @one as two;
SELECT CST_ID, SUM(CASE WHEN Type='SH' THEN 1 ELSE 0 END) as SH, SUM(CASE WHEN Type='KA' THEN 1 ELSE 0 END) as KA, SUM(CASE WHEN Type='EF' THEN 1 ELSE 0 END) as EF, SUM(CASE WHEN Type='SC' THEN 1 ELSE 0 END) as SC, SUM(CASE WHEN Type='KA' THEN 1 ELSE 0 END) as KA, SUM(CASE WHEN Type='NO' THEN 1 ELSE 0 END) as NO, SUM(CASE WHEN Type='WE' THEN 1 ELSE 0 END) as WE, SUM(CASE WHEN Type='TH' THEN 1 ELSE 0 END) as TH, SUM(CASE WHEN Type='BV' THEN 1 ELSE 0 END) as BV FROM ( SELECT CST_ID,TRC_TYPE as Type FROM T UNION ALL SELECT CST_ID,COLL_TYPE as Type FROM T ) T1 GROUP BY CST_ID
DELETE FROM code_sum_country WHERE code in (SELECT code FROM code_sum_country GROUP BY code HAVING COUNT (code) > 1) AND country NOT IN (SELECT MIN(country) FROM code_sum_country GROUP BY code HAVING COUNT (code) > 1)
SELECT T1.id, T1.business_key, T1.result FROM dbo.My_Table T1 LEFT OUTER JOIN dbo.My_Table T2 ON T2.business_key = T1.business_key AND T2.id > T1.id WHERE T2.id IS NULL
SELECT DISTINCT SUBCASE_ID FROM YOUR_TABLE WHERE SUBCASE_ID NOT IN (SELECT SUBCASE_ID FROM YOUR_TABLE where ACTIVITY='Closed')
SELECT a.`date`, count(*) cnt, a.ip FROM fwlog a JOIN (SELECT ip, count(*) today_count FROM fwlog where `date` = date(now()) group by ip) t ON a.ip = t.ip and t.today_count > 100 GROUP BY a.ip, a.date ORDER BY t.today_count DESC, a.ip, a.`date` DESC
update t set t.ID = r.ID FROM (Select Min(ID) as ID,Cat1 From Records group by cat1) r INNER JOIN #Records t ON r.Cat1 = t.cat1 Where t.cat1 is not null
declare v_sql varchar2(32767) := 'select 1 column1, 2 column2 from dual'; v_cursor_id integer; v_col_cnt integer; v_columns dbms_sql.desc_tab; begin v_cursor_id := dbms_sql.open_cursor; dbms_sql.parse(v_cursor_id, v_sql, dbms_sql.native); dbms_sql.describe_columns(v_cursor_id, v_col_cnt, v_columns); for i in 1 .. v_columns.count loop dbms_output.put_line(v_columns(i).col_name); end loop; dbms_sql.close_cursor(v_cursor_id); exception when others then dbms_sql.close_cursor(v_cursor_id); raise; end; / Output: COLUMN1 COLUMN2
UPDATE webform_submitted_data as a, webform_submitted_data as b SET a.data = b.data WHERE a.sid = b.sid AND a.cid = 64 AND b.cid = 56
SELECT IFNULL((SELECT _id FROM empty_table LIMIT 1), 1)
ALTER proc [dbo].[prcAdvanceSearchUser] @username varchar(50) as begin select *,1 as tag from userdetails where vname like @username + '%' Union select *,2 as tag from userdetails where vemail like @username + '%' Union select *,3 as tag from userdetails where vpassword like @username +'%' order by tag end
select s.uid , s.scenid, group_concat(distinct b.badgeid) badges, group_concat(distinct w.warningid) `warnings`, s.score, s.attempts from tblUserScenScores s join tblUserWarnings w on(s.uid = w.uid and s.scenid = w.scenid) join tblUserBadges b on(s.uid = b.uid and s.scenid = b.scenid) group by s.uid ,s.scenid
POST /service/$batch HTTP/1.1 Host: host OData-Version: 4.0 Content-Type: multipart/mixed;boundary=batch_36522ad7-fc75-4b56-8c71-56071383e77b --batch_36522ad7-fc75-4b56-8c71-56071383e77b Content-Type: multipart/mixed;boundary=changeset_77162fcd-b8da-41ac-a9f8-9357efbbd --changeset_77162fcd-b8da-41ac-a9f8-9357efbbd Content-Type: application/http Content-Transfer-Encoding: binary Content-ID: 1 POST /service/Customers HTTP/1.1 Host: host Content-Type: application/atom+xml;type=entry Content-Length: ### <AtomPub representation of a new Customer> --changeset_77162fcd-b8da-41ac-a9f8-9357efbbd Content-Type: application/http Content-Transfer-Encoding: binary Content-ID: 2 POST $1/Orders HTTP/1.1 Host: host Content-Type: application/atom+xml;type=entry Content-Length: ### <AtomPub representation of a new Order> --changeset_77162fcd-b8da-41ac-a9f8-9357efbbd-- --batch_36522ad7-fc75-4b56-8c71-56071383e77b--
# Microsoft Developer Studio Project File - Database Project Begin DataProject = "Database Project" MSDTVersion = "80" SccProjectName = "SAK" SccLocalPath = "SAK" SccAuxPath = "SAK" SccProvider = "SAK" Begin Folder = "Changes" Script = "Create users table.sql" End End
DECLARE @version_group int select @version_group = version_replace from (you're missing this from your query) where id=@sid
Select in_date, Sum (case when item_code = item1 then 1 else 0 end) item1, Sum (case when item_code = item2 then 1 else 0 end) item2 From tbl Group by in_date
SELECT MIN(ID), FileName FROM YourTable GROUP BY FileName
SET @row := -1; UPDATE chart SET indx = @row := @row + 1 WHERE report = 2 ORDER BY indx
bcp AdventureWorks2012.Sales.Currency out Currency.dat -T -c -SServer1 bcp AdventureWorks2012.Sales.Currency in Currency.dat -T -c -SServer2
select * from cards c left join ( select * from schedules s join users u on s.UserID = u.ID where u.ID = 1 ) x on c.ID = x.CardID
Update T1 Set T1.EndDate = T2.StartDate From [Table] T1 Inner Join [Table] T2 on T1.Id = T2.Id - 1
SQL Fiddle DEMO SELECT class, SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) `M`, SUM(CASE WHEN gender = 'F' THEN 1 ELSE 0 END) `F`, COUNT(1) Total FROM Table1 GROUP BY class
$db->select() ->from(array('a' => 'my_table'), array()) ->join(array('b' => 'my_table'), 'b.Sender = a.Recipient', array('Recipient')) ->where('a.Sender = ?', $id)
MERGE INTO [Episode] AS T USING ( SELECT [E], [1], [2], [3], [4] FROM ( SELECT [E], [I], ROW_NUMBER() OVER (PARTITION BY [E] ORDER BY [O]) AS rn FROM [ICD] ) AS p PIVOT ( MAX([I]) FOR rn IN ([1], [2], [3], [4])) AS p2 ) AS S ON T.[Epinum] = S.[E] WHEN MATCHED THEN UPDATE SET [DX1] = S.[1], [DX2] = S.[2], [DX3] = S.[3], [DX4] = S.[4];
SELECT c.city, t.time_slot FROM cities c LEFT JOIN city_date d on d.city_id = c.id LEFT JOIN city_time t on t.city_date_id = d.city_id AND t.city_date_id = '1'
SELECT DATEPART(YEAR,f_downloadtimestamp) as var_Year, DATEPART(MONTH,f_downloadtimestamp) as var_Month, DATEPART(DAY,f_downloadtimestamp) as var_Day, COUNT(DISTINCT f_downloadIPaddress) Total_Downloads, COUNT(DISTINCT CASE WHEN f_product = 'Product A' THEN f_downloadIPaddress END) Downloads_Prod_A, COUNT(DISTINCT CASE WHEN f_product = 'Product B' THEN f_downloadIPaddress END) Downloads_Prod_B FROM tb_downloads GROUP BY DATEPART(YEAR,f_downloadtimestamp), DATEPART(MONTH,f_downloadtimestamp), DATEPART(DAY,f_downloadtimestamp) ORDER BY var_Year desc, var_Month desc, var_Day DESC
,DECODE(IS_COMPLETED,'Y','<a href="f?p=&APP_ID.:1:&SESSION.::::P1_FILE_NAME:' || FAC_FILE.NAME ||'">View Detail</a>','N','') AS 'Detail'
select * from orders where to_char(OrderDate,'MM') = to_char(add_months(sysdate,-1),'MM')
WHERE ... AND FIND_IN_SET(group_user.group_id, '64,66,63') > 0
select acc_yr, dev_age, state, (case when dev_age > 12 then rev12 else revenue end) as revenue, loss from (select l.acc_yr, l.dev_age, l.state, r.revenue, l.loss, max(case when l.dev_age = 12 then r.revenue end) over (partition by l.acc_yr, l.state) as rev12 from loss l left join revenue r on l.acc_yr = r.acc_yr and l.dev_age = r.dev_age and l.state = dev.state ) lr;
CREATE TABLE page ( domain_name text, domain_suffix text, page_url text, page_title text, page_descr text, page_updated timestamp, PRIMARY KEY ((domain_suffix, domain_name), page_updated) );
SELECT Data_CardCustomer.Code, Isnull(Data_ActionPriceList.Price1 ,0) As price1, Isnull(Data_ActionPriceList.Price2 ,0) As price2, Isnull(Data_ActionPriceList.Price3 ,0) As price3 FROM Data_CardCustomer left join Data_ActionPriceList on Data_ActionPriceList.CustomerId=Data_CardCustomer.CustomerId and StockId=10005
SESSION 1 SESSION 2 -------------------------------- -------------------------------------- SELECT count(*) FROM test; => 10 INSERT INTO test VALUES ('x'); SELECT count(*) FROM test; => 10 with read committed/serializable => 11 with read uncommited (dirty read) COMMIT; SELECT count(*) FROM test; => 10 with serializable => 11 with read uncommitted/read committed
SELECT B.Book_ID , B.Book_Title , group_concat(A.Author_name order by ABP.Prec Desc separator ', ') as Authors FROM Author_Book_Percent ABP INNER JOIN AUTHORS A on ABP.Author_ID = A.Author_ID INNER JOIN BOOKS B on ABP.Book_ID = B.Book_ID GROUP BY B.Book_ID, B.Book_Title
select 'DROP TRIGGER ' || rdb$trigger_name || ';' from rdb$triggers where (rdb$system_flag = 0 or rdb$system_flag is null)
set delimiter // create procedure iskanje(in naziv varchar(10)) BEGIN SELECT A.ime, A.opis, B.kategorija FROM file as A, cathegory as B WHERE A.ime LIKE concat('%',naziv,'%') OR A.opis LIKE concat('%',naziv,'%') OR B.kategorija LIKE concat('%',naziv,'%'); END// set delimiter ;
Dim adapter As New SqlDataAdapter(cmd) Dim ds As New DataSet adapter.Fill(ds) lsbDestination.DataTextField = "Company" lsbDestination.DataValueField = "CustomerId" lsbDestination.DataSource = ds.Tables(0) lsbDestination.DataBind()
SELECT * FROM posts p WHERE NOT EXISTS( SELECT 1 FROM comments c WHERE c.comment_date >= 'deadline' AND p.post_id = c.post_id )
SELECT to_char(rs.cr_date, 'MM/DD/YYYY') as "Date", sum(case when rs.s_method Like '%RTS%' then 1 else 0 end) as "RTS Returned Orders" FROM return_sku rs join order_sku os on os.ord_sku_id = rs.ord_sku_id WHERE trunc(created_date) = trunc(SYSDATE) GROUP BY to_char(rs.cr_date, 'MM/DD/YYYY');
<c:forEach var="row" items="${recordset.rows}"> <tr> <td><c:out value="${row.INSEE_COMMUNE}"/></td> <td><c:out value="${row.NOM_COMMUNE_MIN}"/></td> <td><c:out value="${row.NOM_CC}"/></td> </tr> </c:forEach>
UPDATE myTable old JOIN myTable new USING (id) SET new.start_year = old.end_year, new.end_year = old.start_year WHERE old.start_year > old.end_year
UPDATE YourTable set StateCol = replace(StateCol,'.','')
CREATE OR REPLACE FUNCTION test( p_test text[] ) RETURNS void AS $BODY$ BEGIN SELECT id FROM unnest( p_test ) AS id; END; $BODY$ LANGUAGE plpgsql IMMUTABLE COST 1;
with count_table as ( select 1001 device_id, 4 quantity from dual union all select 1002 device_id, 20 quantity from dual union all select 1003 device_id, 1 quantity from dual ), device_table as ( select 1001 id, 'Yes' wifi, 'No' email, 'No' bluetooth from dual union all select 1002 id, 'Yes' wifi, 'Yes' email, 'No' bluetooth from dual union all select 1003 id, 'Unknown' wifi, 'Unknown' email, 'Yes' bluetooth from dual ) ---------------------------------------- select * from ( select feature, yes_no_unknown, sum(quantity) quantity from count_table c join device_table d on c.device_id = d.id unpivot ( yes_no_unknown for feature in (wifi, email, bluetooth) ) group by feature, yes_no_unknown ) pivot ( sum (quantity) -- only this line I have changed .. for featur in ('WIFI' as Wifi, 'EMAIL' as Email, 'BLUETOOTH' as Bluetooth) );
select a.Id, a.Answer1, a.Answer2, a.Answer3, a.Answer4, TopAnswers.* from AnswerTable a outer apply ( select top 1 Answer, count(*) as cnt from ( select Answer1 as Answer from AnswerTable where Id = a.Id union all select Answer2 from AnswerTable where Id = a.Id union all select Answer3 from AnswerTable where Id = a.Id union all select Answer4 from AnswerTable where Id = a.Id ) x group by Answer order by count(*) desc, Answer asc ) TopAnswers
select (case when ref like 'FA%' then 'FA' else 'OTHER' end) as grp, sum(ETILIQUIDO) as total from pn where FDATA between #1# and #2# group by (case when ref like 'FA%' then 'FA' else 'OTHER' end);
Private Sub TotalMonthlyEnquiries_Click() DoCmd.OpenForm "frmQuery2", acFormDS Forms!frmQuery2.Filter = "Format([DateOfEnquiry], ""mmmm"") = '" & Me![Month] & "'" Forms!frmQuery2.FilterOn = True End Sub
INSERT INTO sys.book SELECT * FROM syste.mytable WHERE column1 = valueThatYouWantInTableBook
SELECT id, first_name, last_name FROM users WHERE (first_name LIKE 'jo%' OR last_name like 'jo%')
INSERT Table2 (Produce, Cust1_Totals, Cust2_Totals, Cust3_Totals) SELECT Fruit , SUM(case when Customer_ID = 1 then quantity end) , SUM(case when Customer_ID = 2 then quantity end) , SUM(case when Customer_ID = 3 then quantity end) FROM Table1 WHERE Customer_ID IN (1,2,3) GROUP BY Fruit
select Id from tbl group by Id having max(case when Code='a' then 0 else 1 end) = 0
SELECT context, SUM(file_size) AS size FROM content_resource GROUP BY context HAVING SUM(file_size) > 5000000000
SELECT ([Address Line 1] + ', ' + [Address Line 2] + ', ' + [Address Line 3] + ', ' + Town + ', ' + Region + ', ' + Postcode) AS Address FROM TableName
select 0, sum(iif(coffee = 0, 1, 0)) as coffee, sum(iif(tea = 0, 1, 0)) as tea, sum(iif(water = 0, 1, 0)) as water, sum(iif(hot_choc = 0, 1, 0)) as hot_choc from drinks d union all select 1, sum(iif(coffee = 1, 1, 0)) as coffee, sum(iif(tea = 1, 1, 0)) as tea, sum(iif(water = 1, 1, 0)) as water, sum(iif(hot_choc = 1, 1, 0)) as hot_choc from drinks d union all select 2, sum(iif(coffee = 2, 1, 0)) as coffee, sum(iif(tea = 2, 1, 0)) as tea, sum(iif(water = 2, 1, 0)) as water, sum(iif(hot_choc = 2, 1, 0)) as hot_choc from drinks d;
SELECT * FROM ( SELECT people.*, IF(gender=0, @mr:=@mr+1, @fr:=@fr+1) AS rank FROM people, (SELECT @mr:=0, @fr:=0) initvars ) tmp ORDER BY rank ASC, gender ASC;
with ValidNumbers as ( select 1 as begin_num, 10 as end_num from dual union all select 11, 20 from dual union all select 21, 30 from dual union all select 55, 70 from dual ) select v_begin, v_end, sum(1 + (case when v_end >= vn.end_num then vn.end_num else v_end end) - (case when v_begin >= vn.begin_num then v_begin else vn.begin_num end) ) as SumInRecords, max(1 + v_end - v_begin) as TheRange, (case when sum(1 + (case when v_end >= vn.end_num then vn.end_num else v_end end) - (case when v_begin >= vn.begin_num then v_begin else vn.begin_num end) ) = max(1 + v_end - v_begin) then 'All' else 'Missing' end) from ValidNumbers vn cross join (select 2 as v_begin, 8 as v_end from dual union all select 2, 18 from dual union all select 2, 28 from dual union all select 2, 38 from dual ) const where v_begin <= vn.end_num and v_end >= vn.begin_num group by v_begin, v_end;
create table a(line string) row format delimited fields terminated by '\A'; create view b as select regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 1) as col1, regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 2) as col2, regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 3) as col3, regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 4) as col4, regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 5) as col5, split(regexp_extract(line, '([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)\;([^\;]*)', 6), '\;') as rest from a;
declare @totalProfitAndLoss decimal(18,0); --I'd go for BIGINT here unless you're sure you need 18 digits declare @resultTable table ( Particular varchar(100), Amount decimal(18,0), Particular2 varchar(100), Amount2 decimal(18,0)); insert into @resultTable exec ssspAccProfitAndLoss select @totalProfitAndLoss = sum(Amount1) from @resultTable
+------------+---------------------------------+ | SourceValue| DestinationValue After execution| +------------+---------------------------------+ | 0.579 | 0.579 | | 0.637 | 0.637 | | 0.503 | 0.503 | +------------+---------------------------------+
to_char(date_column, 'dd/mm/yyyy')
SET NOCOUNT ON; DECLARE @sql NVARCHAR(MAX) = N''; SELECT @sql += ' UNION ALL SELECT [name] = ''' + QUOTENAME(name) + ''', catalog_name = name COLLATE Latin1_General_CI_AI, is_importing FROM ' + QUOTENAME(name) + '.sys.fulltext_catalogs' FROM sys.databases WHERE database_id > 4; SET @sql = 'SELECT [database] = d.name, s.catalog_name, s.is_importing FROM sys.databases AS d LEFT OUTER JOIN (' + STUFF(@sql, 1, 10, '') + ') AS s ON QUOTENAME(d.name) = s.name WHERE d.database_id > 4;'; CREATE TABLE #temp(db SYSNAME, catalog_name NVARCHAR(255), is_importing BIT); INSERT #temp EXEC sp_executesql @sql; DECLARE @db SYSNAME, @catalog_name NVARCHAR(255), @is_importing BIT; DECLARE c CURSOR LOCAL STATIC FORWARD_ONLY READ_ONLY FOR SELECT db, catalog_name, is_importing FROM #temp; OPEN c; FETCH NEXT FROM c INTO @db, @catalog_name, @is_importing; WHILE @@FETCH_STATUS = 0 BEGIN IF @catalog_name IS NULL BEGIN PRINT 'No catalogs for ' + @db; END ELSE BEGIN IF @is_importing = 1 BEGIN PRINT 'Do something to ' + @db + '(importing)'; END ELSE BEGIN PRINT @db + ' is not importing.'; END END FETCH NEXT FROM c INTO @db, @catalog_name, @is_importing; END CLOSE c; DEALLOCATE c; DROP TABLE #temp;
for e in Entry.objects.all(): print e.headline
select (case when su1.id is not null and su2.id is not null then 'BOTH' when su1.id is not null then 'TYPE1' when su2.id is not null then 'TYPE2' else 'Neither' end) from (select 999 as user_id from dual) u left join sub_user_1 su1 on su1.id = u.user_id left join sub_user_2 su2 on su2.id = u.user_id
select EOMonth(weeks), sum(month_summ) from ((select weeks, year(weeks) as yy, month(weeks) as mm, (case when day(weeks) >= 7 then summ else summ * day(weeks) / 7.0 end) as month_summ from #old o ) union all (select dateadd(month, -1, weeks) as weeks, year(dateadd(month, -1, weeks)) as yy, month(dateadd(month, -1, weeks)) as mm, summ * (1 - day(weeks) / 7.0) from #old o where day(weeks) < 7 ) ) group by EOMonth(weeks);
SELECT @Average = case when convert(int, @hour) <> 0 then convert(varchar(9), convert(int, @hour)) + ':' else '' end + right('00' + convert(decimal(10,0), convert(decimal(18,2), @Mns)), 2) + ':' + right('00' + CONVERT(decimal(10,0), convert(varchar(10), @second)), 6)
SELECT YearCreated, COUNT(*) FROM (SELECT UserId, DATEPART(year, MIN(DateCreated)) AS YearCreated FROM users GROUP BY UserId) t GROUP BY YearCreated
SELECT t.ID, count(case when A between 2 and 4 then ID end), AVG(case when B between 19 and 40 then B end), COUNT(case when C between 12 and 14 then id end) FROM t GROUP BY ID UNION select 'Overall', count(case when A between 2 and 4 then ID end), AVG(case when B between 19 and 40 then B end), COUNT(case when C between 12 and 14 then id end) FROM t
try { // Create the TransactionScope to execute the commands, guaranteeing // that both commands can commit or roll back as a single unit of work. using (TransactionScope scope = new TransactionScope()) { using (SqlConnection connection1 = new SqlConnection(connectString1)) { // Opening the connection automatically enlists it in the // TransactionScope as a lightweight transaction. connection1.Open(); // Call sql stored procedure(SP1) to generate a reference Number SqlCommand command1 = new SqlCommand(commandText1, connection1); returnValue = command1.ExecuteScalar(); //Begin loop. loop count would be number of records that are in a collection //Insert records to database using another stored procedure(SP2) using the //reference number generated in the previous step //End Loop } // The Complete method commits the transaction. If an exception has been thrown, // Complete is not called and the transaction is rolled back. scope.Complete(); } } catch (TransactionAbortedException ex) { writer.WriteLine("TransactionAbortedException Message: {0}", ex.Message); }
Use XML path for this. select (select BandName+',' from BandMaster where BandId<100 for xml path('')) as NewColumnName Try this
DELIMITER $$ CREATE PROCEDURE ABC() BEGIN CREATE TEMPORARY TABLE tmpEnt SELECT 1; END$$ CREATE PROCEDURE XYZ() BEGIN INSERT INTO tmpEnt VALUES (100); END$$ DELIMITER ; CALL ABC; -- it will create temp. table CALL XYZ; -- it will insert one more record into temp. table SELECT * FROM tmpEnt; +-----+ | 1 | +-----+ | 1 | | 100 | +-----+
SELECT url,row_number FROM( SELECT url,row_number() OVER (PARTITION BY domain) FROM website WHERE domain IN (SELECT DISTINCT domain FROM link) ) AS links WHERE row_number <= 10 LIMIT 25
select [Your column list] from tableA A inner join tableB B on A.EANno = B.EANno union all select [Your column list] from tableB B where B.EANno not in (select distinct EANno from tableA)
select t1.*,t2.team as opponent, t2.group as opponentgroup, t2.country as opponent country from table t1 inner join table t2 on t1.country<>t2.country and t1.group<>t2.group
CREATE OR REPLACE PROCEDURE TST_SMS_IN ( --P_MSISDN NUMBER, P_MOBILE_NO varchar2, P_SMS_BODY VARCHAR2, p_IN_ID INTEGER ) IS V_SYSTEM_DATE DATE; V_YEAR NUMBER; V_YEAR_SYSTEM NUMBER; V_TABLE_NAME VARCHAR2(100) :=''; V_SQL VARCHAR2(1000) :=''; V_ERROR_MESSAGE VARCHAR2(1000) :=''; P_AVG NUMBER; V_CREATED_BY NUMBER; BEGIN INSERT INTO SMS_IN(IN_ID,MOBILE_NO,SMS_BODY,STATUS,USERS,REMARKS,IN_TIME) VALUES (SMS_IN_SEQ.NEXTVAL,P_MOBILE_NO,P_SMS_BODY,0,'gp','TEST',sysdate); p_IN_ID := SMS_IN_SEQ.CURRVAL; COMMIT; END TST_SMS_IN;
SELECT * FROM table1 where ID in (SELECT min(ID) FROM table1 WHERE ID > 12)
ALTER TABLE DEPARTAMENTOS ADD CONSTRAINT FK_DEPT_EMP FOREIGN KEY (numDirect) REFERENCES EMPLEADOS(numEmpl) DEFERRABLE INITIALLY DEFERRED ; ALTER TABLE EMPLEADOS ADD CONSTRAINT FK_EMP_DEPT FOREIGN KEY (numDept) REFERENCES DEPARTAMENTOS(numDept) DEFERRABLE INITIALLY DEFERRED ;
SET NOCOUNT ON GO DECLARE @DataSource TABLE ( [IssueDependencyId] BIGINT IDENTITY(1,1) NOT NULL, [IssueId] BIGINT NOT NULL, [DependsOnIssueId] BIGINT NOT NULL ) INSERT INTO @DataSource ( [IssueId], [DependsOnIssueId]) VALUES (48, 0) ,(49, 48) ,(50, 48) ,(51, 48) ,(55, 48) ,(56, 48) ,(52, 49) ,(52, 50) ,(52, 51) ,(53, 52) ,(57, 54) ,(54, 55) ,(57, 56) ;WITH DataSource ([IssueId], [DependsOnIssueId], [Start_Point], [End_Point]) AS ( SELECT AnchorMebemr.[IssueId] ,AnchorMebemr.[DependsOnIssueId] ,0 ,10 FROM @DataSource AS AnchorMebemr WHERE AnchorMebemr.[IssueId] = 48 UNION ALL SELECT RecursiveMebemer.[IssueId] ,RecursiveMebemer.[DependsOnIssueId] ,DS.[End_Point] ,DS.[End_Point] + 10 FROM @DataSource AS RecursiveMebemer INNER JOIN DataSource DS ON RecursiveMebemer.[DependsOnIssueId] = DS.[IssueId] ) SELECT DISTINCT DS.[IssueId] ,DS.[DependsOnIssueId] ,DS.[Start_Point] ,DS.[End_Point] FROM DataSource DS ORDER BY DS.[IssueId] ,DS.[DependsOnIssueId] SET NOCOUNT OFF GO
SELECT SUM(o.duration) / 60.00 AS duration FROM dbo.tbl_chatMessages t1 OUTER APPLY ( SELECT TOP 1 CASE WHEN DATEDIFF(second, t2.messageTime, t1.messageTime) > 600 THEN 0 ELSE DATEDIFF(second, t2.messageTime, t1.messageTime) END FROM dbo.tbl_chatMessages t2 WHERE t1.messageTime > t2.messageTime ORDER BY t2.messageTime DESC ) o(duration)
for (i in 1:1000) { tmp.ids <- ids[((i - 1) * 100 + 1) : (i * 100)] query <- paste0("SELECT * FROM myTable WHERE idvar IN (", paste0(tmp.ids, collapse = ", "), ")") dbSendquery(con, query) fetch results, etc.. }
SELECT * , COUNT(UserID) OVER(PARTITION BY UserID) AS 'Total' FROM TBL1 1 INNER JOIN TBL2 2 On 2.FK = 1.FK INNER JOIN TBL3 3 On 3.PK = 2.PK INNER JOIN TBL4 4 On 4.PK = 3.PK LEFT OUTER JOIN TBL5 5 ON 4.PK = 5.PK WHERE 1.Date_Time_In BETWEEN '2010-11-15 12:00:00' AND '2010-11-30 12:00:00' ORDER BY 4.Column, 3.Column, 3.Column2, 1.Date_Time_In DESC
CREATE table #msg(id integer, type integer, msg nvarchar(max), ts datetime) INSERT INTO #msg VALUES (1, 2, 'user msg 1', '2011-11-01 16:00') INSERT INTO #msg VALUES (2, 2, 'user msg 2', '2011-11-01 16:01') INSERT INTO #msg VALUES (3, 1, 'operator msg 1', '2011-11-01 16:02') INSERT INTO #msg VALUES (4, 1, 'operator msg 2', '2011-11-01 16:03') INSERT INTO #msg VALUES (5, 1, 'operator msg 3', '2011-11-01 16:04') INSERT INTO #msg VALUES (6, 2, 'user msg 3', '2011-11-01 16:05') INSERT INTO #msg VALUES (7, 2, 'user msg 4', '2011-11-01 16:06') ;WITH o AS ( SELECT id, ts, msg FROM #msg WHERE type = 1 ) ,u AS ( SELECT id, ts, msg, (SELECT TOP 1 id FROM o WHERE o.ts <= x.ts ORDER BY ts DESC) AS o_id FROM #msg x WHERE type = 2 ) SELECT o.msg, (SELECT u.msg + ',' FROM u WHERE u.o_id = o.id ORDER BY u.ts, u.id FOR XML PATH('')) AS u_msg FROM o ORDER BY o.ts
UPDATE A SET A.Balance = @Balance , @PreBalance = @Balance , @Balance = ( CASE WHEN (@Balance IS NULL OR @AccountType <> A.AccountType) THEN CASE WHEN A.Balance - A.Due >= 0 THEN A.Balance ELSE A.Balance + A.Due END ELSE CASE WHEN @Balance - A.Due >= 0 AND (@Flag = 1 OR @AccountNO <> A.AccountNO) THEN @Balance ELSE @Balance + A.Due END END) - A.Due , A.FLAG = @Flag , @AccountNO = CASE WHEN A.Flag = 0 THEN A.AccountNO ELSE 'NoDueFoundForAcc' END , @Flag = CASE WHEN @AccountType = A.AccountType THEN CASE WHEN @PreBalance = @Balance THEN 0 ELSE 1 END ELSE CASE WHEN A.Balance - A.Due >= 0 THEN 1 ELSE 0 END END , @AccountType = A.AccountType FROM #tempTable A SELECT * FROM #tempTable A WHERE A.Flag = 1
CREATE TRIGGER [dbo].[TRIG_MyTable] ON [dbo].[MyTable] AFTER INSERT, UPDATE AS DECLARE @INS int, @DEL int SELECT @INS = COUNT(*) FROM INSERTED SELECT @DEL = COUNT(*) FROM DELETED IF @INS > 0 AND @DEL > 0 BEGIN -- a record got updated, so log accordingly. INSERT INTO MyLogTable SELECT 'New Values', getdate() FROM INSERTED INSERT INTO MyLogTable SELECT 'Old Values', getdate() FROM DELETED END ELSE BEGIN -- a new record was inserted. INSERT INTO MyLogTable SELECT 'Insert', getdate() FROM INSERTED END
Select min(ID), Name, min(value) From yourtable Group by name
insert into DiscussionParticipation (User_id, Discussion_id) ( select a.User_id as User_id, d.id as Discussion_id from Discussion d inner join Activity a on (a.id = d.Activity_id) union select r.User_id as User_id, d.id as Discussion_id from Discussion d inner join Response r on (r.Activity_id = d.Activity_id) );
with location_code as ( select 'ASDFSFD' loc_code, 555555 zipcode from dual union all select 'OUIXVCX', 555555 from dual union all select '2KLJSDF', 555555 from dual union all select '887CSD', 555555 from dual ) select rtrim (xmlagg (xmlelement (e, loc_code || ',')).extract ('//text()'), ',') from location_code where zipcode = 555555;
select Parent, max(case when Child='Color' then Value End) 'Color', max(case when Child='Height' then Value End) 'Height', max(case when Child='Width' then Value End) 'Width', max(case when Child='Length' then Value End) 'Length' from yourtable group by Parent
SELECT id, chapter_id, question, answer FROM (SELECT IF(@chapterId=@chapterId:=chapter_id, @id:=@id+1, @id:=0) queNo, id, chapter_id, question, answer FROM `questions`, (SELECT @chapterId:=0, @id:=0) AS A WHERE `chapter_id` IN (19, 20, 21, 22, 23) ORDER BY `chapter_id` ) AS A WHERE queNo < 10
SUM(Totals) AS "Week Day Count"
WHERE ISNULL(Code4,SomeInteger)=SomeInteger
columnID columnId columnIDAlternative columnIdAlternative RASCScore RascScore column_id column_id_alternative rasc_score
SELECT * FROM table WHERE LOWER(A) = 'x' AND LOWER(B) IN ('w', 'y', 'z')
SELECT type, car_numbers, AVG(price) AS average_price FROM (SELECT type_id, type, SUM(car_numbers) AS car_numbers FROM table1 GROUP BY type_id) AS t1 JOIN table2 AS t2 ON t1.type_id = t2.type_id GROUP BY type
CREATE EVENT DO_INSERT_OP ON SCHEDULE AT CURRENT_TIMESTAMP + INTERVAL 1 SECOND DO INSERT INTO mytable (name,surname) VALUES ('john','john');
select c.caseNo, max(e.eventDate) as eventDate from cases c inner join events e on c.id = e.caseid group by c.caseNo
select p.id, p.text, c.id, c.parent, c.feature from Parents p left join (select c1.id, c1.parent, c1.feature from Childs c1 join (select p1.id, max(c2.feature) maxFeature from Parents p1 left join Childs c2 on p1.id = c2.parent group by p1.id) cf on c1.parent = cf.id and c1.feature = cf.maxFeature) c on p.id = c.parent
DELIMITER // CREATE FUNCTION STRINGDECODE(str TEXT CHARSET utf8) RETURNS text CHARSET utf8 DETERMINISTIC BEGIN declare pos int; declare escape char(6) charset utf8; declare unescape char(3) charset utf8; set pos = locate('\\u', str); while pos > 0 do set escape = substring(str, pos, 6); set unescape = char(conv(substring(escape,3),16,10) using ucs2); set str = replace(str, escape, unescape); set pos = locate('\\u', str, pos+1); end while; return str; END// DELIMITER ;
SELECT MIN(time) time, status FROM ( SELECT time, status, @n := @n + 1 rnum, @g := IF(status = @s, @g + 1, 1) rnum2, @s := status FROM table1 CROSS JOIN (SELECT @n := 0, @g := 0, @s := NULL) i ORDER BY time ) q GROUP BY rnum - rnum2
@PrePersist void makeCreationTimestamp() { createdAt = System.currentTimeMillis(); }
SELECT name,gender from ( SELECT name,gender, row_number() OVER(PARTITION BY gender ORDER BY name ASC) as rnk FROM YourTable) WHERE rnk = 1
CREATE OR REPLACE TRIGGER trigger_name BEFORE INSERT ON TABLE_NAME FOR EACH ROW BEGIN IF :new.NAME = 'Bob' then :new.VALUE := :new.VALUE + (:new.VALUE*0.25) ; END IF; END; /
select year, count(distinct case when `Genre` = 'hip hop' then 1 end) as hiphop, count(distinct case when `Genre` = 'pop-dance' then 1 end) as popdance from tbl group by year
select center_id, month_id, sales_amt, ( sales_amt + lead (sales_amt,1,0) over (PARTITION BY center_id ORDER BY month_id desc) + lead (sales_amt,2,0) over (PARTITION BY center_id ORDER BY month_id desc) + lead (sales_amt,3,0) over (PARTITION BY center_id ORDER BY month_id desc) ) sales_4_month from Sales
SELECT PLSSUPostcode ,case when CHARINDEX(' ', PLSSUPostcode) > 0 then SUBSTRING(PLSSUPostcode, 1, CHARINDEX(' ', PLSSUPostcode)) else PLSSUPostcode end AS PCode FROM TblPostcodes
SELECT CASE WHEN CAST(tDate as DATE) < CAST(GETDATE() as date) -- if older then Today THEN DATEADD(dd,-1,CAST(GETDATE() as date)) -- assgin yesterday's date ELSE CAST(tDate as date) -- use the date END as tDate, SUM(tDuration-ISNULL(tDone,0)) as tToDo FROM tTable WHERE .....conditions..... GROUP BY CASE WHEN CAST(tDate as DATE) < CAST(GETDATE() as date) -- if older then Today THEN DATEADD(dd,-1,CAST(GETDATE() as date)) -- assgin yesterday's date ELSE CAST(tDate as date) -- use the date END ORDER BY tDate
UPDATE test SET name = INSERT(name, LENGTH(name), 0, '_');
-- BAD! DO NOT DO THIS! -- insert customer (email, count) select 'foo@example.com', 0 where not exists ( select 1 from customer where email = 'foo@example.com' )
column = Production.t171.label('3harm') column.quote = True session.query(column)
select m.maker, t.type from (select distinct maker from product) m cross join (select distinct type from product) t;
@Query("from table t where t.propertyOne in :param1 and (t.propertyTwo like :param2 or t.propertyThree like :param3 or t.propertyFour like :param4)") List<Table> findByParams(@Param("param1") List<String> param1, @Param("param2") String param2, @Param("param3") String param3, @Param("param4") String param4);
SELECT * FROM table_a WHERE CURDATE() <= date_created
PLAYER_ATTEMPTS_TB::Game_Level
SELECT CL.CompanyName, count([IncentiveId]) FROM AdminInvoices INNER JOIN (select distinct AdminId, CompanyId from AdminClientSystem) as ACS ON AdminInvoices.AdminId = ACS.AdminId INNER JOIN ClientData ON ACS.CompanyId= ClientData.CompanyId GROUP BY CL.CompanyName ORDER BY CL.CompanyName ASC
INSERT INTO SecondTable SELECT id, A, B, C FROM CurrentTable INSERT INTO ThirdTable SELECT id, D, E FROM CurrentTable
SQL> set long 5000 SQL> var c clob SQL> SQL> declare 2 ctx dbms_xmlgen.ctxhandle; 3 begin 4 ctx := dbms_xmlgen.newcontext('select * from emp where deptno = 10'); 5 -- set EMPTY_TAG flag 6 dbms_xmlgen.SETNULLHANDLING (ctx, 2); 7 :c := dbms_xmlgen.getxml(ctx); 8 end; 9 / PL/SQL procedure successfully completed. SQL> SQL> print c C -------------------------------------------------------------------------------- <?xml version="1.0"?> <ROWSET> <ROW> <EMPNO>7782</EMPNO> <ENAME>BOEHMER</ENAME> <JOB>MANAGER</JOB> <MGR>7839</MGR> <HIREDATE>09-JUN-81</HIREDATE> <SAL>2450</SAL> <COMM/> <DEPTNO>10</DEPTNO> <LEAVE_DATE/> </ROW> <ROW> <EMPNO>7839</EMPNO> <ENAME>SCHNEIDER</ENAME> <JOB>PRESIDENT</JOB> <MGR/> <HIREDATE>17-NOV-81</HIREDATE> <SAL>5000</SAL> <COMM/> <DEPTNO>10</DEPTNO> <LEAVE_DATE/> </ROW> <ROW> <EMPNO>8070</EMPNO> <ENAME>DUGGAN</ENAME> <JOB>SALES</JOB> <MGR>7782</MGR> <HIREDATE>19-NOV-09</HIREDATE> <SAL>2500</SAL> <COMM/> <DEPTNO>10</DEPTNO> <LEAVE_DATE/> </ROW> </ROWSET> SQL>
UPDATE your_table t1 -- Your table goes here SET [Column3] = rand() FROM your_table t2 -- and here WHERE (t1.[Column1] = t2.[Column1] AND t1.[Column2] = t2.[Column2]) OR (t1.[Column1] = t2.[Column2] AND t1.[Column2] = t2.[Column1])
select convert(decimal(10,2),sum(balance)/100.0) as Balance from member
SELECT l.img_id, l.img_name, (SELECT COUNT(*) FROM tbl_comments c WHERE i.img_id = c.img_id ) AS comment_count, (SELECT COUNT(*) FROM tbl_vote v WHERE i.img_id = v.img_id ) AS vote_count FROM tbl_images i
select e.* from events e where exists (select 1 from events e2 where e2.name = e.name and year(e2.DateOfAttendence) = 2002 );
CREATE TABLE Owner ( ownerID int not null primary key indentity(1,0), FirstName varchar(255), LastName varchar(255), /* other fields here */ ) GO CREATE TABLE Car carID int not null primary key identity(1,0), ownerID int not null references Owner(ownerID), /* other fields go here */ GO /* a convenience, read only view to replace your old CAR OWNER table */ CREATE VIEW Car_Owner AS SELECT c.*, o.FirstName, o.LastName FROM Car c INNER JOIN Owner o ON c.ownerID = o.ownerID
SELECT userID, game_level, SUM(score), x.avg FROM my_table JOIN ( SELECT AVG(CASE WHEN (@rank := (CASE WHEN t.userID = @userID AND t.game_level = @gamelevel THEN @rank + 1 ELSE 0 END) < 20 THEN score END) AS avg, @userID := userID AS userID, @game_level := game_level AS game_level FROM my_table, (SELECT @rank := @userID := @game_level := NULL) init ORDER BY userID, game_level, date_of_attempt DESC ) x USING (userID, game_level) GROUP BY userID, game_level
WITH t AS ( SELECT Client, Task, Hours, ROW_NUMBER() OVER(PARTITION BY Client,Task,Date ORDER BY Date) rn, DATEPART(dw,date) DayOfWeek FROM MyTable ) SELECT Client, Task, [1] Sun, [2] Mon, [3] Tues, [4] Wed, [5] Thu, [6] Fri, [7] Sat FROM t PIVOT(SUM(Hours) FOR DayOfWeek IN ([1],[2],[3],[4],[5],[6],[7])) p
select distinct owner from all_tables where table_name = 'mytable'
select e.name from employee e where -- Projects in department exists ( select * from workon w join project p on w.pid = p.pid and p.did = e.did where w.empid = e.empid ) -- Projects out of department and exists ( select * from workon w join project p on w.pid = p.pid and p.did != e.did where w.empid = e.empid )
SELECT e.ID, e.firstName, e.lastName,ee.firstName, ee.lastName from employees e JOIN employees ee ON e.reportsTo=ee.ID
select distinct id, department from tbl
select day2,count(*), group_concat(id) from resultater group by day having count(*)>1;
select pm.post_id from post_meta pm where pm.key = 'coolness' order by pm.value + 0;
strSQL = "SELECT tblCases.CaseNumber, tblCasesClients.ClientID" strSQL = strSQL & " FROM tblCases" strSQL = strSQL & " LEFT JOIN tblCasesClients ON (tblCases.AgencyID = tblCasesClients.AgencyID)" strSQL = strSQL & " AND (tblCases.CaseNumber = tblCasesClients.CaseNumber)" strSQL = strSQL & " WHERE (((tblCases.CaseNumber) Like '*" & [Forms]![frmCaseSearch]![txtCaseFilter] & "*')" If Not IsNull([Forms]![frmCaseSearch]![cboClients]) Then strSQL = strSQL & " AND ((tblCasesClients.ClientID)=([Forms]![frmCaseSearch]![cboClients])))" Else strSQL = strSQL & ")" End If strSQL = strSQL & " ORDER BY tblCases.CaseNumber;" Forms!frmCaseSearch!lstCases.RowSource = strSQL
alter table university add constraint uni_name_uk unique (name_of_university);
SQL> SELECT rawtohex('Ý') FROM dual; RAWTOHEX('Ý') -------------- C39D
SELECT COLUMN1 FROM MYTABLE WHERE (COLUMN1 != 'A' OR COLUMN1 IS NULL)
SQLiteDatabase db = sqlHelper.getWritableDatabase(); // get a writable database here db.beginTransaction(); try { for (int insertQuery : listOfQueries) { // loop through your records db.insert(...); } db.setTransactionSuccessful(); } finally { db.endTransaction(); } db.close();
;WITH CTE AS ( select case WHEN @Weight <= BP then minimum when @Weight < value then Normal when @Weight >= value AND @weight <= Q then Price WHEN @weight >= Value AND @Weight > Q then Price end as 'Price' from Waybill.RoutePrices inner join Waybill.RoutePriceQ on Waybill.RoutePrices.Id = Waybill.RoutePriceQ.RoutePriceId where RouteFrom = @from and routeTo = @to ) SELECT TOP 1 * FROM CTE ORDER BY Price
GROUP BY t1.NumberID, t1.Copies, t1.NameStreet
Function FCN_QClip(strQRY As String) As String qds = CurrentDb.QueryDefs(strQRY).SQL FCN_QClip = qds End Function
Declare @Resolution int = 3 -- resolution in hours Select DateAdd(Hour, DateDiff(Hour, 0, datetime) / @Resolution * @Resolution, -- integer arithmetic 0) as bucket, Sum(values) From table Group By DateAdd(Hour, DateDiff(Hour, 0, datetime) / @Resolution * @Resolution, -- integer arithmetic 0) Order By bucket
WHERE (INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Apple') > 0 OR INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Park') > 0 OR INSTR('500 Oracle Parkway, Redwood Shores, CA', 'Shores') > 0)
delete games from games inner join (select min(id) minid, date, time, hometeam_id, awayteam_id, locationcity, locationstate from games group by date, time, hometeam_id, awayteam_id, locationcity, locationstate having count(1) > 1) as duplicates on (duplicates.date = games.date and duplicates.time = games.time and duplicates.hometeam_id = games.hometeam_id and duplicates.awayteam_id = games.awayteam_id and duplicates.locationcity = games.locationcity and duplicates.locationstate = games.locationstate and duplicates.minid <> games.id)
SELECT DISTINCT t1.Ebeln, t2.Ebelp, t1.Ekorg, t2.belnr, t3.netpr FROM TABLE1 t1 RIGHT JOIN TABLE2 t2 ON t1.EBELN = t2.EBELN FULL JOIN table3 t3 ON t2.belnr = t3.belnr
select tmp.id, tmp.email, tmp.date_val, min(tmp.timestamp) from ( select id, email, timestamp, date_format(from_unixtime(timestamp), '%e %b %Y') as date_val from email_table ) as tmp group by tmp.email, tmp.date_val
SELECT timestamp, badge_id FROM mytable GROUP BY timestamp, badge_id HAVING COUNT(*) > 1
UPDATE noeuds INNER JOIN (SELECT noeuds.* FROM noeuds WHERE (((noeuds.LONG_CABLE)=" 1") AND (noeuds.DELETED=" "))) a ON noeuds.n_amount = a.n_amount SET noeuds.insee_com = a.insee_com, noeuds.rivoli = a.rivoli, noeuds.num_voie = a.num_voie
SELECT date, time, custom_id, Number FROM traffic t WHERE CONCAT(date, ' ', time) BETWEEN '01/06/2014 00:00' AND '01/10/2014 23:00' AND Number = (SELECT MAX(CAST(Number as smallint)) FROM traffic WHERE t.date = date and t.custom_id = custom_id) ORDER BY date, CAST(Number as smallint) DESC, custom_id
SELECT words, count(*), group_concat(idtag) as tags FROM (SELECT idTag, GROUP_CONCAT(idWord order by position ASC SEPARATOR ' ') AS words FROM tTagWord GROUP BY idTag ) t GROUP BY words HAVING count(*) > 1;
Insert into child (`CASE`,`LASTNAME`,`FIRSTNAME`,`GENDER`, `DOB`,`SSN`,`RACE`,`STREET`,`STREET2`,`CITY`, `STATE`,`ZIP`,`PHONE`,`WORKPHONE`,`CELLPHONE`, `PARENT NAME`,`GR`,`ADMITDATE`,`DISCHDATE`, `WRK`,`WFIRSTNAME`,`WRKPHONE`) VALUES ('null', 'Sivanesh', 'Jashawn', 'Male', '2002-03-08', '206-80-2175', 'African American', '1689 Crucible Street', 'null', 'Pittsburgh', 'PA', '15210', '(412)458-3788', 'null', '(412)377-6079', 'Latel Williams', '2nd', '2010-03-17', 'null', 'null', 'Addison', '(412)594-2545') ON DUPLICATE KEY UPDATE LASTNAME = 'Sivanesh', FIRSTNAME= 'Jashawn',...
Select * FROM test_table WHERE user_id = value AND date_added = (select max(date_added) from test_table where user_id = value)
SELECT cashier.cashier_name, COALESCE(gross_amount, 0) AS gross_amount, (CASE WHEN item.other_discount_type = 'PATRONAGE_CASH' THEN COALESCE(item.other_discount_amount, 0) ELSE 0 END) AS other_discount_amount, COALESCE(item.net_of_discount_amount, 0) AS net_of_discount_amount FROM item_tbl item INNER JOIN (Select receipt_no, Max(payment_dt) payment_dt from payment_tbl Group By receipt_no) payment ON item.receipt_no = payment.receipt_no LEFT JOIN cashier_tbl cashier ON cashier.id = item.cashier_id WHERE AND date(payment.payment_dt) = to_date('31 May 2016', 'dd Mon YYYY')
Select item_descr, [shop1], [Shop2] from ( Select item_descr, shop_id, times from [Order] )p pivot ( sum(times) for shop_id in ([shop1], [Shop2]) )pvt;
select t.* from t group by val1 having count(*) = 1;
// fetch liferay's session factory SessionFactory sessionFactory = (SessionFactory) PortalBeanLocatorUtil.locate("liferaySessionFactory"); Session session = null; try { // open session using liferay's session factory session = sessionFactory.openSession(); // fetches the query string from the default.xml String sql = CustomSQLUtil.get(FIND_ONLY_ACTIVE_SITES); SQLQuery sqlQuery = session.createSQLQuery(sql); // use portal class loader, since this is portal entity sqlQuery.addEntity("Group_", PortalClassLoaderUtil.getClassLoader().loadClass("com.liferay.portal.model.impl.GroupImpl")); return (List<Group>) QueryUtil.list(sqlQuery, getDialect(), 0, QueryUtil.ALL_POS); } catch (Exception e) { throw new SystemException(e); } finally { sessionFactory.closeSession(session); // edited as per the comment on this answer // closeSession(session); }
SELECT o.OwnerName, i.Id, i.ItemName FROM Items AS i JOIN Owners AS o ON o.Id = i.OwnerId
FOR tbl IN (SELECT owner, table_name FROM dba_tables WHERE table_name = 'MYTABLE') LOOP EXECUTE IMMEDIATE 'update ' || tbl.owner || '.' || tbl.table_name || ' set field1 = ''N'', ' || ' field2 = null '; END LOOP;
select machine_id, (lastend - start_time) as down_time from (select pt.*, lag(end_time, 1) over (partition by machine_id order by end_time) as lastend from process_time pt ) pt where lastend is not null
function view( $id ) { // .... $this->Model->updateAll( array( 'Model.viewcount', 'Model.viewcount + 1' ), array( 'Model.id', $id ) ); }
CREATE INDEX idx_partial ON othertable (m_id) WHERE (col1 is not null and col2 is not null and col3 is not null);
SELECT t1.Team, t1.Sprint,g.wh-SUM(t2.WorkHours) FROM tbl t1 JOIN tbl t2 ON t1.Team = t2.Team AND t2.Sprint <= t1.Sprint JOIN (SELECT SUM(WorkHours) AS wh, Team FROM tbl GROUP BY Team) g ON t1.Team=g.Team GROUP BY t1.Team, t1.Sprint,g.wh
select no from (SELECT 1 a, 2 b FROM DUAL) dummy unpivot (no for col in (a as 'A', b as 'B'))
DECLARE @Table TABLE ( column_a INT , column_b VARCHAR (128), column_c VARCHAR (128), column_d VARCHAR (128), column_date [time] ); INSERT INTO @Table VALUES ('1', 'test_1', 'test_1', 'type_1', '11:00'), ('2', 'test_2', 'test_2', 'type_2', '11:01'), ('3', 'test_3', 'test_6', 'type_2', '11:02'), ('4', 'test_4', 'test_4', 'type_3', '11:03'), ('5', 'test_2', 'test_6', 'type_2', '11:04'), ('6', 'test_1', 'test_2', 'type_1', '11:05'); WITH C AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY column_d ORDER BY column_date DESC) AS RN FROM @Table), ToCompare AS (SELECT * FROM c WHERE Rn < 3 AND EXISTS (SELECT * FROM c AS C2 WHERE C.column_d = C2.column_d AND Rn = 2)) SELECT T.column_a, NULLIF (T.column_b, T2.column_b) AS [column_b], NULLIF (T.column_c, T2.column_c) AS [column_c], T.column_d, T.column_date FROM ToCompare AS T INNER JOIN ToCompare AS T2 ON T.column_d = T2.column_d WHERE T.Rn = 1 AND T2.RN = 2 ORDER BY T.column_a;
SELECT AVG(Salary) as AVERAGE, MAX(case when seqnum = cnt / 2 then salary end) as median, MAX(SALARY) as MAXIMUM, MIN(SALARY) as MINIMUM, SUM(SALARY) as TOTAL, TOTAL as NUMBER_OF_EMP FROM (SELECT e.*, count(*) over () as total, row_number() over (order by salary) as seqnum FROM TblEmployees e ) e
SELECT 'Column1' as Name, Column1 as Value FROM my_table UNION ALL SELECT 'Column2' as Name, Column2 as Value FROM my_table UNION ALL SELECT 'Column3' as Name, Column3 as Value FROM my_table
SELECT * FROM SYS.COLUMNS WHERE NAME NOT IN ( SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'XXXX' AND CHARINDEX(COLUMN_NAME + ';', 'ABC;XYZ;') > 0 );
SELECT DISTINCT AccountKey FROM TABLE WHERE (ProductGroup = 'A' AND ProductVersion = 13) OR (ProductGroup != 'A' AND ProductVersion = 19)
;WITH Hierarchy AS ( SELECT DISTINCT JID ,CAST(NULL AS DATETIME) EntryDate ,CAST(NULL AS DATETIME) RefundDate ,CAST(NULL AS VARCHAR(MAX)) Comments ,CAST(NULL AS BIT) Refund ,CAST(NULL AS VARCHAR(30)) ActionBy ,nLevel = 1 ,CAST(NULL AS INT) AS CID FROM refundrequested UNION ALL SELECT CAST(NULL AS INT) JID ,E.EntryDate ,E.RefundDate ,E.Comments ,E.Refund ,E.ActionBy ,H.nLevel+1 ,H.JID AS CID FROM refundrequested E JOIN Hierarchy H ON E.JID = H.JID ) SELECT * FROM Hierarchy ORDER BY COALESCE(JID, CID) DESC, nLevel
ID Version 1 1 2 2 3 3 1 4
SELECT a.id ,a.[year],valA,valB from( SELECT id ,[year],SUM(Total_Volume)/ (count(distinct(month))*7) valA from TableA group by id,[year]) a INNER JOIN (select id,[year],SUM(Total_volume)/(count(distinct(month))*5) valB from TableA WHERE weekday NOT IN ('Friday','Saturday') group by station_id,[year]) b on a.id=b.id and a.[year]=b.[year]
INSERT INTO t_Duration SELECT t.interval ,t.call_id ,t.agent_id ,t.service_id ,t.state ,t.duration FROM ( SELECT * FROM inserted AS i CROSS APPLY ( SELECT * FROM fInterval2(i.state_time,i.end_time,15) AS iid ) AS ext ) AS t
using System; using System.Collections.Generic; using System.Linq; using System.Text; using Microsoft.Deployment.WindowsInstaller; using System.IO; using System.Text.RegularExpressions; namespace SaveSqlStrings { public class CustomActions { [CustomAction] public static ActionResult SaveSqlStrings(Session session) { StringBuilder sqlStrings = new StringBuilder(); Database db = session.Database; View view = db.OpenView("SELECT * FROM `SqlString`"); IList<string> SqlStringElements = db.ExecuteStringQuery("SELECT `String` FROM `SqlString`"); Regex bracketedProperties = new Regex(@"\[(\b[A-Z_]*\b)\]"); Regex formattedProperties = new Regex(@"{\[(\b[A-Z_]*\b)\]}"); Regex openeningSquareBrackets = new Regex(@"\[\\\[\]"); Regex closingSquareBrackets = new Regex(@"\[\\\]\]"); string sqlDb_ = ""; string sqlString = ""; string Database = ""; foreach (string dbString in SqlStringElements) { sqlDb_ = (string)db.ExecuteScalar("SELECT `SqlDb_` FROM `SqlString` WHERE `String` ='{0}'",dbString); sqlString = (string)db.ExecuteScalar("SELECT `SQL` FROM `SqlString` WHERE `String` ='{0}'",dbString); view.Close(); view = db.OpenView("SELECT * FROM `SqlDatabase`"); Database = (string)db.ExecuteScalar("SELECT `Database` from `SqlDatabase` WHERE `SqlDb`='{0}'", sqlDb_); if(bracketedProperties.IsMatch(Database)) { Database = bracketedProperties.Match(Database).Groups[1].Value; Database = session[Database]; } if (openeningSquareBrackets.IsMatch(sqlString)) sqlString = openeningSquareBrackets.Replace(sqlString, "["); if (closingSquareBrackets.IsMatch(sqlString)) sqlString = closingSquareBrackets.Replace(sqlString, "]"); if(formattedProperties.IsMatch(sqlString)) { string propertyName = formattedProperties.Match(sqlString).Groups[1].Value; string propertyValue = session[propertyName]; sqlString = formattedProperties.Replace(sqlString, propertyValue); } sqlStrings.AppendLine(String.Format("use {0}",Database)); sqlStrings.AppendLine(sqlString); } string home = session["PersonalFolder"]; string sqlPath = string.Concat(home, @"Script.sql"); try { File.WriteAllText(sqlPath, sqlStrings.ToString()); } catch (Exception ex) { session["FailedTowrite"] = sqlPath; } view.Close(); db.Close(); return ActionResult.Success; } } }
CASE WHEN (CAST(SVS_DT AS DATE) - CAST(DSCH_TS AS DATE)) < 90 THEN 1 ELSE 0 END AS FU90
LEFT(A.IVC_Number+' ',6) INV_Nr ,
select 'max', max(thickness) value from thicknesses where thickness < requirement union select 'min', min(thickness) value from thicknesses where thickness > requirement
SELECT dbo.AlbumTags.Tag_Name, COUNT(dbo.AlbumTagBridge.Tag_Id) AS Cnt FROM dbo.AlbumTagBridge INNER JOIN dbo.AlbumTags ON dbo.AlbumTagBridge.Tag_Id = dbo.AlbumTags.Tag_ID GROUP BY dbo.AlbumTags.Tag_Name
SELECT ads.id, ads.title, count(sign_ups.user_id) AS total FROM sign_ups RIGHT JOIN ads ON ads.id = sign_ups.ad_id WHERE advertiser_id=1 AND sign_ups.user_id IS NOT NULL UNION ALL SELECT ads.id, ads.title, 0 AS total FROM sign_ups RIGHT JOIN ads ON ads.id = sign_ups.ad_id WHERE advertiser_id=1 AND sign_ups.user_id IS NULL
create table house_law ( -- the proposed up for vote law_id varchar(50) NOT NULL PRIMARY KEY, descr varchar(255) ); insert house_law (law_id,descr) values ('HR-109B','Forbid driving near turtles'); create table house_rep ( -- a session is say Monday to Friday, captures a start date rep_id int not null PRIMARY KEY, fullname varchar(80) not null, party varchar(80) ); insert house_rep (rep_id,fullname,party) values (1001,'Thomas Jefferson','Whig'); insert house_rep (rep_id,fullname,party) values (800,'fred','Abstain Party'); insert house_rep (rep_id,fullname,party) values (700,'stan','Abstain Party'); create table votes_cast (law_id varchar(50) not null, rep_id int not null, the_vote varchar(20) -- for, against, abstain ); insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',1001,'against'); insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',800,'abstain'); insert votes_cast (law_id,rep_id,the_vote) values ('HR-109B',700,'abstain'); -- get the results select l.law_id, l.descr, sum(case when v.the_vote='for' then 1 else 0 end) for_votes, sum(case when v.the_vote='against' then 1 else 0 end) against_votes, sum(case when v.the_vote='abstain' then 1 else 0 end) abstain_votes from house_law l join votes_cast v on v.law_id=l.law_id group by l.law_id -- or a where close for 1 law in particular
CREATE PROCEDURE my_procedure_name AS v_file UTL_FILE.file_type; BEGIN ... END; /
INSERT INTO tblinbox /* maybe add column definitions here to make it clearer column definitions could look like this: ( someField, type, subject, LRN, content, `date`, newyearLevel, someOtherField, userType, id ) */ SELECT '', '$sender', '$type', '$subject', '$LRN', '$content', '$date', '$newyearLevel', '', '$userType', id FROM tblscholar WHERE schoYear = '$newyearLevel'
create table XXX ( key number primary key, parent number ) / alter table XXX add constraint XXX_FK foreign key (parent) references XXX /
begin dbms_stats.gather_table_stats('ALERTS_OWNER','ASYNC_PROCESSING_REQUEST_T'); end;
SELECT CONVERT(CHAR(10), GETDATE(), 105) result: 10-12-2015
Insert Into TargetDatabase.SchemaName.TableName (TargetColumn) Select SouorceColumn From SourceDatabase.SchemaName.TableName
SELECT * FROM emp WHERE convert(datetime, date, 101) BETWEEN (Getdate() - 6) AND Getdate() ORDER BY date
SELECT T1.F01 AS UPC, T2.F254 AS TheDate, (SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 1 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS PURCHASED, (SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 1 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_P, (SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 2 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS SOLD, (SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 2 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_S, (SELECT SUM (COALESCE (X.F64, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 3 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS ADJUSTED, (SELECT SUM (COALESCE (X.F65, 0)) FROM [STORESQL].[dbo].[RPT_ITM_D] X WHERE X.F1034 = 3 AND X.F01 = T2.F254 AND X.F01 = T1.F01) AS AMT_A FROM [STORESQL].[dbo].[COST_TAB] t1 LEFT OUTER JOIN [STORESQL].[dbo].[RPT_ITM_D] t2 ON t1.F01=t2.F01 AND (F254='2011-10-1') and (F1034=1 or F1034=2 or F1034=3) group by T1.F01, T2.F254 ORDER BY T1.F01, T2.F254
SELECT MyTable.team AS team, MyTable.rel AS rel, AVG(iif(Testable,1,0)) AS result FROM MyTable WHERE MyTable.team IN (1,2) AND MyTable.rel IN (1,2,3) GROUP BY MyTable.rel, MyTable.team ORDER BY MyTable.team, MyTable.rel
SELECT Id, Year, Type, Date, Amount - IFNULL((SELECT Amount FROM data AS previousQuarter WHERE previousQuarter.Year = data.year AND previousQuarter.Type = data.Type AND previousQuarter.Periods = data.Periods - 1 ), 0) AS Amount FROM data
SELECT CONVERT(VARCHAR(4),YEAR(LastModifedDate)) + ' ' + CONVERT(VARCHAR(3),DATENAME(MONTH,LastModifedDate)) AS Dates, COUNT(*) as Number FROM aims.Modification WHERE CompanyID = @companyID AND LastModifedDate >= DATEADD(MONTH,@numberOfMonths * -1,GETDATE()) GROUP BY CONVERT(VARCHAR(4),YEAR(LastModifedDate)) + ' ' + CONVERT(VARCHAR(3),DATENAME(MONTH,LastModifedDate)), CONVERT(VARCHAR(6),LastModifedDate,112) ORDER BY CONVERT(VARCHAR(6),LastModifedDate,112)
WHERE MD2.iBatchNumber = @iBatchNumber ORDER BY MD2.sTableName, MD2.iRowIndex
select t.number, t.status, row_number() over (partition by status, grp order by number) as seqnum from (select t.*, (row_number() over (order by number) - row_number() over (partition by status order by number ) as grp from table t ) t;
SELECT company_name, cnt FROM ( SELECT company_name, count(employee_name) AS cnt FROM works GROUP BY company_name ) w1 ORDER BY cnt DESC LIMIT 1
DECLARE @result varchar(MAX) SET @result = ''; SELECT @result = @result + NAME + ',' FROM Table WHERE ID = @Id SET @result = SUBSTRING(@result, 1, LEN(@result) - 1) SELECT @result
with j as ( select * from jobs ) select j.*, inv.* from invoices inv join j on ( inv.job_no = j.job_no) union select j.*, inv.* from invoices inv join j on ( inv.job_no = j.client_no)
CREATE OR REPLACE TRIGGER TBL_ADMINCOMMAND_TRG BEFORE INSERT OR UPDATE ON tbl_AdminCommands FOR EACH ROW BEGIN IF inserting AND :new.ADMINCOMMANDID IS NULL THEN SELECT TBL_ADMINCOMMANDS_SEQ.nextval INTO :new.ADMINCOMMANDID FROM DUAL; END IF; END; / ALTER TRIGGER TBL_ADMINCOMMAND_TRG ENABLE;
declare @s varchar(100) select @s = 'http://info@abc.com' select right(@s, len(@s) - charindex('@', @s))
UPDATE (PB INNER JOIN Noeuds ON PB.NOEUD = Noeuds.NOEUD) INNER JOIN ColInfo ON Noeuds.NUM_COL = ColInfo.NUM_COL SET PB.FORFAIT = "E" WHERE (((ColInfo.INTEREXTER)=2));
select t1.id , case when t1.value1=t2.value then t2.value else null end as value1 , case when t1.value2=t2.value then t2.value else null end as value2 , case when t1.value3=t2.value then t2.value else null end as value3 from temp1 t1 left join temp2 t2 on ((t1.value1=t2.value) and (t1.id = t2.id)) OR ((t1.value2=t2.value) and (t1.id = t2.id)) OR ((t1.value3=t2.value) and (t1.id = t2.id))
CREATE PROC dbo.Paramtest (@foo int = 42) AS SET NOCOUNT ON; GO SELECT OBJECT_NAME(object_id), has_default_value, default_value FROM sys.parameters WHERE name = '@foo' AND object_id = OBJECT_ID('dbo.Paramtest') -- gives Paramtest, 0, NULL
create view PAIRWISE_DISTANCE_SQUARES as select a.id as a_id, b.id as b_id, (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) as square from point_table as a, point_table as b -- where a.id != b.id if you wish
protected void HistoryEngine_AddedEntry(object sender, HistoryAddedEventArgs e) { Item item = e.Database.GetItem(e.Entry.ItemId); //TODO: Add logic to make sure e.Entry.ItemId requires a parent/child reindex as well //TODO: Make sure that logic also prevents excessive or infinite recursion since we'll be triggering the AddedEntry event again below Item parent = item.Parent; //RegisterItemSaved doesn't appear to do anything with its second argument e.Database.Engines.HistoryEngine.RegisterItemSaved(parent, null); }
;WITH Top10Distinct AS ( SELECT DISTINCT TOP 10 YourColumn FROM dbo.YourTable ORDER BY YourColumn DESC ) SELECT * FROM dbo.YourTable tbl INNER JOIN Top10Distinct cte ON tbl.YourColumn = cte.YourColumn
SELECT accommodation_id, SUM(amount * persons) as max_persons_available FROM availabilities WHERE available = 1 and arrival >= '2015-12-19' and arrival < '2015-10-26' GROUP BY accommodation_id
select usrs.* from students s join system_users usrs on s.father=usrs.user_id OR s.mother=usrs.user_id OR s.guardian=usrs.user_id where s.user_id = '201209291';
class procedure TdmodCheckDatabase.UpgradeDatabase(databasePath: string; currentVersion, newVersion: integer); var module: TdmodCheckDatabase; f: integer; begin module:= TdmodCheckDatabase.create(nil); try module.OpenDatabase( databasePath ); for f:= 0 to module.ComponentCount -1 do begin if module.Components[f] is TDBISAMTable then begin try // if we need to upgrade table to dbisam 4 if currentVersion <= DB_VERSION_FOR_DBISAM4 then TDBISAMTable(module.Components[f]).UpgradeTable; module.UpgradeTable(TDBISAMTable(module.Components[f])); except // logging and error stuff removed end; end; end; for f:= currentVersion + 1 to newVersion do module.RunUpgradeScripts(f); module.sqlMakeIndexes.ExecSQL; // have to create additional indexes manually finally module.DBISAMDatabase1.Close; module.free; end; end; procedure TdmodCheckDatabase.UpgradeTable(table: TDBISAMTable); var fieldIndex: integer; needsRestructure: boolean; canonical: TField; begin needsRestructure:= false; table.FieldDefs.Update; // add any new fields to the FieldDefs if table.FieldDefs.Count < table.FieldCount then begin for fieldIndex := table.FieldDefs.Count to table.Fields.Count -1 do begin table.FieldDefs.Add(fieldIndex + 1, table.Fields[fieldIndex].FieldName, table.Fields[fieldIndex].DataType, table.Fields[fieldIndex].Size, table.Fields[fieldIndex].Required); end; needsRestructure:= true; end; // make sure we have correct size for string fields for fieldIndex := 0 to table.FieldDefs.Count -1 do begin if (table.FieldDefs[fieldIndex].DataType = ftString) then begin canonical:= table.FindField(table.FieldDefs[fieldIndex].Name); if assigned(canonical) and (table.FieldDefs[fieldIndex].Size <> canonical.Size) then begin // field size has changed needsRestructure:= true; table.FieldDefs[fieldIndex].Size:= canonical.Size; end; end; end; if needsRestructure then table.AlterTable(); // upgrades table using the new FieldDef values end; procedure TdmodCheckDatabase.RunUpgradeScripts(newVersion: integer); begin case newVersion of 3: sqlVersion3.ExecSQL; 9: sqlVersion9.ExecSQL; 11: begin // change to DBISAM 4 sqlVersion11a.ExecSQL; sqlVersion11b.ExecSQL; sqlVersion11c.ExecSQL; sqlVersion11d.ExecSQL; sqlVersion11e.ExecSQL; end; 19: sqlVersion19.ExecSQL; 20: sqlVersion20.ExecSQL; end; end;
using (OleDbConnection connection = new OleDbConnection(connectionString)) { connection.Open(); DataTable tableColumns = connection.GetOleDbSchemaTable(OleDbSchemaGuid.Columns, new object[] { null, null, "Streets", null })); foreach (DataRow row in tableColumns.Rows) { var columnNameColumn = row["COLUMN_NAME"]; var dateTypeColumn = row["DATA_TYPE"]; var ordinalPositionColumn = row["ORDINAL_POSITION"]; ... } }
SELECT u.id, u.orderId, p.productName, u.key2, i.forced_matrix_sponsor_id FROM ubercart_reseller_orders u join productInfo p on p.productId=u.productId join ir i on u.key2=i.id where p.productName like '%OSS HOSTING FEE%' and u.createdDate > '2014-02-1' and ----------------------^ forced_matrix_sponsor_id is null order by u.key2;
ALTER TABLE tableName ADD NewIdn INT NOT NULL AUTO_INCREMENT KEY
SELECT Position, Count(position) AS 'QTY' FROM tblemployee GROUP BY Position HAVING Count(Position) != 1
mysql> select * from t; +------+-------+ | id | data | +------+-------+ | 1 | max | | 2 | linda | | 3 | sam | | 4 | henry | +------+-------+ 4 rows in set (0.02 sec) mysql> update t set data=concat(data, 'a'); Query OK, 4 rows affected (0.01 sec) Rows matched: 4 Changed: 4 Warnings: 0 mysql> select * from t; +------+--------+ | id | data | +------+--------+ | 1 | maxa | | 2 | lindaa | | 3 | sama | | 4 | henrya | +------+--------+ 4 rows in set (0.00 sec)
WITH t AS ( SELECT row, scan, col, val FROM MyTable UNPIVOT(val FOR col IN ([1],[2],[3],[4],...<snip>...,[2570],[2571]))p ) SELECT row, scan, col AS range_start, col + 15 AS range_end, min_val FROM t t1 CROSS APPLY ( SELECT MIN(t2.val) AS min_val FROM t WHERE row = t1.row AND scan = t1.scan AND col BETWEEN t1.col AND t1.col + 15 ) t2
WITH cteRanges AS ( SELECT site, CASE WHEN MONTH(date) IN (1) THEN CAST(YEAR(date) - 1 AS VARCHAR(4)) + '-8' + ' ' + CAST(YEAR(date) AS VARCHAR(4)) + '-1' WHEN MONTH(date) IN (8, 9, 10, 11, 12) THEN CAST(YEAR(date) AS VARCHAR(4)) + '-8' + ' ' + CAST(YEAR(date) + 1 AS VARCHAR(4)) + '-1' ELSE CAST(YEAR(date) AS VARCHAR(4)) + '-2' + ' ' + CAST(YEAR(date) AS VARCHAR(4)) + '-7' END AS range FROM test ) SELECT site, COUNT(*), range FROM cteRanges GROUP BY site, range ORDER BY range, site;
ResultSet rs = ... ResultSetMetaData rsmd = rs.getMetaData(); int numberOfColumns = rsmd.getColumnCount(); String columnLabel = rsmd.getColumnLabel(1); String columnName = rsmd.getColumnName(1); int columnType = rsmd.getColumnType(1); String columnTypeName = getColumnTypeName(1); etc
DECLARE @var VARCHAR(100) = 'ABC' + CHAR(13) + CHAR(10); SELECT @var = CASE WHEN @var LIKE '%' + CHAR(13) + CHAR(10) THEN LEFT(@var, LEN(@var) - 2) ELSE @var END; SELECT @var, LEN(@var);
SELECT W.LastName + ', ' + W.FirstName AS [Worker], M.LastName + ', ' + M.FirstName AS [Manager], Details.SiteName AS [Site Name], Details.Description AS [Description], Details.Action AS [Action], FROM Details INNER JOIN Staff AS W ON Details.Worker = W.StaffID INNER JOIN Staff AS M ON Details.Manager = M.StaffID
create table Drawing ( DrawingId int not null primary key, Name varchar not null ) create table ShapeKind ( ShapeKindId int primary key, ShapeKindName varchar ) insert into ShapeKind values (1, 'Line') insert into ShapeKind values (2, 'Circle') create table Shape ( ShapeId int not null, ShapeKindId int not null, DrawingId int not null, CenterX numeric not null, CenterY numeric not null, SizeX numeric not null, SizeY numeric not null, Color int not null, primary key (ShapeId, ShapeKindId), foreign key (ShapeKindId) references ShapeKind (ShapeKindId), foreign key (DrawingId) references Drawing (DrawingId) ) create table Line ( ShapeId int not null, ShapeKindId int not null check (ShapeKindId = 1), LineWidth int not null, Orientation int not null, primary key (ShapeId, ShapeKindId), foreign key (ShapeId, ShapeKindId) references Shape (ShapeId, ShapeKindId) ) create table Circle ( ShapeId int not null, ShapeKindId int not null check (ShapeKindId = 2), FillColor int, -- null if not filled primary key (ShapeId, ShapeKindId), foreign key (ShapeId, ShapeKindId) references Shape (ShapeId, ShapeKindId) )
SELECT name, GROUP_CONCAT(start_time ORDER BY start_time) AS start_times FROM your_table GROUP BY name ORDER BY COUNT(start_time)
ALTER proc [dbo].[sp_mysp] @starttime datetime, @endtime datetime as SELECT [Day], SUM(CASE WHEN [Type] = 'a' OR [Type] = 'c' THEN price ELSE 0.00 END) SELL, SUM(CASE WHEN [Type] = 'b' OR [Type] = 'd' THEN price ELSE 0.00 END) BUY FROM [TABLE] WHERE [Day] BETWEEN @starttime AND @endtime GROUP BY [Day]
select c.customer_id, count(distinct o.order_id) distinct_orders, group_concat(distinct i.sku) ordered_item_skus from customers c left outer join orders o on c.customer_id = o.customer_id left outer join order_items oi on o.order_id = oi.order_id left outer join items i on oi.item_id = i.item_id group by c.customer_id
SELECT m.* FROM main_table m JOIN category_available c ON c.main_table_id = m.id WHERE c.category_id IN (206, 207) GROUP BY m.id HAVING COUNT(DISTINCT c.category_id) = 2
SELECT DATE_FORMAT(CHANGE_DATE, '%Y-%m') AS date, COUNT(DISTINCT CHANGE_ID) AS change_count, NAME FROM CHANGE_TABLE, (SELECT NAME AS name, COUNT(DISTINCT CHANGE_ID) AS changes FROM CHANGE_TABLE WHERE DATE(CHANGE_DATE) > DATE(now() - INTERVAL 1 MONTH) GROUP BY name ORDER BY changes DESC ) subq WHERE CHANGE_DATE > curdate() - INTERVAL 10 MONTH AND change_table.name = subq.name GROUP BY date, name
= "update table set name = '" & B1 & "' where namefk = '" & A1 & "'"
select '[''' || table1.collectdatetime as "['Date-Time",table1.cycletime as "'Time'" from table1 where interfacename='somename' and collectdatetime > (CURRENT_DATE - 1) order by collectdatetime ASC;
SELECT * FROM v$tempseg_usage
Select FROM_UNIXTIME(stime), bytes from argusTable_2009_10_22 where stime > (UNIX_TIMESTAMP()-600) group by floor(stime /10)
SELECT 'Quarter '+CAST(DATEPART(Q,DATEADD(MM,-3,GETDATE())) AS VARCHAR) AS QUARTER
select t1.id, t1.time2-case when status='HOLD' then t2.time else 0 end-t1.time1 from t1 left join t2 on t1.id=t2.id and t2.status='HOLD'
@DatabaseField(dataType = DataType.BYTE_ARRAY) byte[] imageBytes;
CREATE VIEW [dbo].[School_Year_Amount] AS SELECT ISNULL(ROW_NUMBER() OVER (ORDER BY (SELECT NULL)), -1) AS sID, Parent_Share_Amount.trans_name AS parent_trans_name, OJT_Share_Amount.trans_name AS ojt_trans_name, Parent_Share_Amount.ID_Number AS ID_Number, Parent_Share_Amount.adviser_info_id AS adviser_info_id, Parent_Share_Amount.student_fname AS student_fname, Parent_Share_Amount.student_lname AS student_lname, Parent_Share_Amount.student_info_id AS student_info_id, Parent_Share_Amount.amount AS parent_amount, OJT_Share_Amount.amount AS ojt_amount, isnull(OJT_Share_Amount.amount,0) + isnull(Parent_Share_Amount.amount,0) AS total_amount, (120000 - isnull(OJT_Share_Amount.amount,0) - isnull(Parent_Share_Amount.amount,0)) AS total_balance FROM [Parent_Share_Amount] LEFT OUTER JOIN OJT_Share_Amount ON Parent_Share_Amount.student_info_id = OJT_Share_Amount.student_info_id;
Select col1, col2, col3 From dbo.vw_MyView With (NoExpand)
CREATE VIEW test.t1 AS ( SELECT 'pcount' AS type, `temp`.`pcount` AS value FROM `temp` WHERE ( `temp`.`id` = ( SELECT MAX(`temp`.`id`) FROM `temp` ) ) UNION SELECT 'ncount' AS type, `temp`.`ncount` AS value FROM `temp` WHERE ( `temp`.`id` = ( SELECT MAX(`temp`.`id`) FROM `temp` ) ) )
$params = array( ... 'contain' => array( 'Class' => array( 'conditions' => array( 'Class.exp IS NOT NULL', 'Class.tb <20', ), 'fields' => array('a', 'b') ) ) );
select <city_id>, c.y, count(t.city_id) from generate_series(1990, 2005) as c(y) left outer join Table1 as t on c.y between extract(year from t.start_date) and extract(year from t.end_date) and t.city_id = <city_id> group by c.y order by c.y
SELECT * FROM numbers WHERE id NOT IN ( SELECT id FROM numbers WHERE val IN ( SELECT MAX(val) FROM numbers ) OR val IN ( SELECT MIN(val) FROM numbers ) );
select substring(reverse(str), patindex('%[^0-9]%', reverse(str)), 1)
SELECT d.Department, d.DepartmentID, count(e.EmployeeID) FROM Departments d LEFT JOIN employees e ON d.DepartmentID = e.DepartmentID GROUP BY d.Department, d.DepartmentID
Select p.ProductID , p.ProductDesc, count(p.ProductId) from Product p inner join OrderDetails od on p.productid = od.productid inner join Order1 o on o.orderid = od.orderid where orderpayment = 'cash' Group by p.ProductID, p.ProductDesc
select c.name as "Conference Name", c.Date, coalesce(n2.name, n2."fallback_name") as "Main Contact", group_concat(coalesce(n.name, n."fallback_name"), ', ') as Attendees from conferences c inner join attendees a on c."Conference ID" = a."Conference ID" inner join name n on n.id = a."Name Row" inner join name n2 on n2.Contact_id = c."main_contact" group by c.name order by c.date
DROP TABLE bar CASCADE CONSTRAINTS;
SELECT * FROM ( SELECT g.*, @r:= CASE WHEN @g = g.`user` THEN @r +1 ELSE 1 END rownum, @g:= g.`user` user_group FROM sn.sn_graph_reduced g CROSS JOIN (SELECT @g:=0,@r:=0) t2 ORDER BY `user` , RAND() ) t WHERE rownum <= 100
DECLARE @OrigDate datetime DECLARE @NewDate datetime SET @OrigDate = '1/12/2012' SET @NewDate = DATEADD(Day, -1, DATEADD(Month, 1, Cast(CAST(Month(@OrigDate) as varchar) + '/1/' + CAST((Year(@OrigDate)+1) as varchar) as datetime)))
SELECT DISTINCT c.Cust, options = ((SELECT c2.opt1 + c2.opt2 FROM dbo.myDB AS c2 WHERE c2.Cust = c.Cust FOR XML PATH(''), TYPE).value('.[1]', 'nvarchar(max)')) FROM dbo.myDB AS c;
SET NOCOUNT ON; -- (use temp table, since table vars do not participate in transactions) CREATE TABLE #T1(C int); CREATE TABLE #T2(C int); CREATE TABLE #T3(C int); CREATE TABLE #T4(C int); CREATE TABLE #T5(C int); INSERT INTO #T1 SELECT 1; INSERT INTO #T2 SELECT 1; INSERT INTO #T3 SELECT 1; INSERT INTO #T4 SELECT 1; INSERT INTO #T5 SELECT 1; BEGIN TRY BEGIN TRAN TR1; DELETE FROM #T1; DELETE FROM #T2; DELETE FROM #T3; DELETE FROM #T4; --select 1/0 as 'forced error @ stage1'; END TRY BEGIN CATCH PRINT 'error @stage1'; PRINT 'rollback @stage1'; ROLLBACK TRAN TR1; RETURN; END CATCH BEGIN TRY DELETE FROM #T5; select 1/0 as 'forced error @stage2'; COMMIT TRAN TR1; END TRY BEGIN CATCH PRINT 'error @stage2'; ROLLBACK TRAN TR1; BEGIN TRY print 'redo delete T4' BEGIN TRAN TR2; DELETE FROM #t4; --select 1/0 as 'forced error @redo delete'; COMMIT TRAN TR2; END TRY BEGIN CATCH ROLLBACK TRAN TR2; PRINT 'second chance delete from T4 failed'; END CATCH END CATCH select count(*) as count,'T1' as 'table' from #T1 union all select count(*) as count,'T2' as 'table' from #T2 union all select count(*) as count,'T3' as 'table' from #T3 union all select count(*) as count,'T4' as 'table' from #T4 union all select count(*) as count,'T5' as 'table' from #T5 DROP TABLE #T1; DROP TABLE #T2; DROP TABLE #T3; DROP TABLE #T4; DROP TABLE #T5;
SELECT domains.domainID, domainName, COUNT(*), SUM(uniqueUploads) FROM domains INNER JOIN files ON files.domainID = domains.domainID INNER JOIN serverFiles on serverFiles.fileID = files.fileID GROUP BY domains.domainID, domainName
SELECT 'EMAIL', Email.Email FROM Contacts.Email WHERE Email.ContactId = :contactId UNION ALL SELECT 'PHONE', Phone.Phone FROM Contacts.Phone WHERE Phone.ContactId = :contactId ORDER BY 1 -- put e-mail addresses before phone-numbers ;
=", '" & TEXT(ScriptSQL!L5, "yyyy-MM-dd") & "'"
SELECT activity ,DATEADD(wk, DATEDIFF(wk,0,Cast(starttime AS DATE)), 0) AS Week ,SUM(datediff(second, starttime, endtime)) / 60.0 AS TimePerDay FROM cte WITH (NOLOCK) WHERE starttime >= dateadd(week, @LastXWeeks, last_update) GROUP BY activity ,DATEADD(wk, DATEDIFF(wk,0,Cast(starttime AS DATE)), 0)
SELECT * FROM Articles as a INNER JOIN comments as c ON a.articleId = c.ArticleId
select x.ID, x.mindate as FirstActionDate, x.FirstAction as FirstAction, y.maxdate as LastActionDate, y.LastAction as LastAction from ( --FirstDate and Action select a.ID, a.mindate as mindate, t.action as FirstAction from ( select ID, Min(date) as mindate from data group by ID ) a inner join data t on a.mindate = t.date ) x inner join ( --Last Date And Action select a.ID, a.maxdate, t.action as LastAction from ( select ID, max(date) as maxdate from data group by ID ) a inner join data t on a.maxdate = t.date ) y on x.ID = y.ID
SELECT a.*, b.key, COALESCE(c.value, b.default) Value FROM Objects a CROSS JOIN Attributes b LEFT JOIN Object_Attributes c ON a.ID = c.object_id AND b.key = c.key ORDER BY a.ID, b.key
Select Distinct t1.id From Table_1 t1 Inner Join Table_1 t2 On t1.Id = t2.Id And t1.Boolean = True And t2.Boolean = False And DateDiff(Second, t1.Timestamp, t2.Timestamp) Between 0 And 1
SELECT event.event_name, event.event_date, MAX(CASE WHEN participant.fighter_id = fighter.id THEN fighter.name END) AS fighter, MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.wins END) AS wins, MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.draws END) AS draws, MAX(CASE WHEN participant.fighter_id = fighter.id THEN record.losses END) AS losses, CASE WHEN fight.winner = participant.fighter_id THEN 'Win' WHEN fight.winner IS NULL THEN 'Draw' ELSE 'Loss' END AS result, fight.method, MAX(CASE WHEN participant.fighter_id <> fighter.id THEN fighter.name END) AS Opp, MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.wins END) AS Opp_wins, MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.draws END) AS Opp_draws, MAX(CASE WHEN participant.fighter_id <> fighter.id THEN record.losses END) AS Opp_losses FROM event INNER JOIN fight ON event.id = fight.event_id INNER JOIN participant ON participant.fight_id = fight.id INNER JOIN ( SELECT participant.fighter_id, participant.fight_id, SUM(CASE WHEN prevFight.winner = participant.fighter_id THEN 1 ELSE 0 END) AS wins, SUM(CASE WHEN prevFight.winner IS NULL) AS draws, SUM(CASE WHEN prevFight.winner <> participant.fighter_id THEN 1 ELSE 0 END) AS losses FROM participant INNER JOIN fight ON participant.fight_id = fight.id INNER JOIN participant AS prevParticipant ON prevParticipant.fighter_id = participant.fighter_id INNER JOIN fight AS prevFight ON prevFight.id = prevParticipant.fight_id AND prevFight.fight_date_time < fight.fight_date_time GROUP BY participant.fighter_id, participant.fight_id ) AS record ON record.fight_id = participant.fight_id INNER JOIN fighter ON fighter.id = record.fighter_id GROUP BY event.id, fight.id, participant.fighter_id
SELECT CASE WHEN LTRIM(RTRIM(Desk_name)) LIKE '% %' -- finds any space in string THEN Desk_name ELSE Desk_name + ' mm' END AS Name, head AS sector_head FROM tableName
SELECT ID, Score, ISNULL(convert(int, lead(Score) over(partition by id order by timestamp)), 0) - convert(int, Score) FROM RiskPredLog -- where ID = '1002010'
A R PROM A MACT 2A A MITEM 20A A MP 2A A MPITCL 2A A MSTDAT 8S 0 A MEXDAT 8S 0 A MLIST 8S 2 A MRETAL 8S 2 A MCOST 8S 2 A MQTY 10S 0 A MPCHNG 6S 0 A MNPEFT 12A A MNSTDT 8S 0 A MNEXDT 8S 0 A MNLST 8S 2 A MPNRTL 8S 2 A MNCOST 8S 2 A ZZ14 8A A MALPHA 8A A ZZ64 170A A K MITEM A K MP A K MPITCL
ALTER INDEX IX_Index ON dbo.Table DISABLE ;
declare @v varchar(max) = 'bzip2,1,668,sometext' select substring(@v, CHARINDEX(',', @v, CHARINDEX(',', @v, CHARINDEX(',', @v)+1)+1)+1, len(@v))
db.newColl.insert([a, b])
WHERE 0=1 OR (owner_name = 'A' AND table_name = 'T1') OR (owner_name = 'B' AND table_name = 'T2') OR (owner_name = 'A' AND table_name = 'T3')
<security:http auto-config="true" use-expressions="true"> <security:intercept-url pattern="/login" access="permitAll" /> <security:intercept-url pattern="/registration" access="permitAll" /> <security:intercept-url pattern="/**" access="isAuthenticated()" /> ... </security:http>
Tournament.objects.order_by(Func('date', function='"time"')).all()
SELECT c.* FROM dbo_Contact AS c WHERE c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise1, 'BOGUS') & '*' OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise2, 'BOGUS') & '*' OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise3, 'BOGUS') & '*' OR c.Expertise Like '*' & Nz(Forms!Data_Qry_Test_Page!Expertise4, 'BOGUS') & '*'
SELECT p.name, p.birth_date FROM Player p WHERE p.birth_date > '1986-04-30' AND p.birth_date < '1986-06-01';
SELECT Department, COUNT(DISTINCT ID) AS total, COUNT(DISTINCT CASE WHEN course LIKE 'AS%' THEN id END) Total_AS FROM schedule GROUP BY Department ORDER BY Department ASC
WITH cte AS (SELECT ph.IC_PO_HEADER, ph.PO_NUMBER, ph.revision_number, pl.ic_line_key, pl.ic_po_line, Row_number() OVER ( ORDER BY ph.IC_PO_HEADER, IC_LINE_KEY) Rn FROM PO_HEADER ph INNER JOIN PO_LINE pl ON ph.po_number = pl.po_number ) SELECT t1.IC_PO_HEADER, t1.PO_NUMBER, t1.revision_number, t1.ic_line_key, t2.ic_line_key + t1.rn - 1, t2.IC_PO_LINE + t1.rn - 1 FROM cte t1 INNER JOIN cte t2 ON t2.rn = 1 ORDER BY IC_PO_HEADER
delete from tvsemp e where rowid>(select min(rowid) from tvsemp m where e.ename=m.ename);
SELECT `mid`, `message`, `created_at`, CASE WHEN (SELECT `uid` FROM `bulletin_message` AS t2 WHERE t1.`bid` = t2.`bid` ORDER BY `mid` ASC LIMIT 1) = t1.`uid` THEN 1 ELSE 0 END AS `is_op` FROM`bulletin_message` AS t1 ORDER BY `mid` ASC
BEGIN TRY BEGIN TRANSACTION INSERT INTO table1(col1, col2) SELECT DISTINCT col1, col2 FROM tbl INSERT INTO table2(col3, table1fk) SELECT t.col3, t1.Id FROM tbl t INNER JOIN table1 t1 ON t1.col1 = t.col1 AND t1.col2 = t.col2 COMMIT TRANSACTION END TRY BEGIN CATCH IF (@@TRANCOUNT > 0) BEGIN ROLLBACK TRANSACTION END DECLARE @ErrorNumber INT, @ErrorMessage NVARCHAR(4000), @ErrorState INT, @ErrorSeverity INT, @ErrorLine INT SELECT @ErrorNumber = ERROR_NUMBER(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE(), @ErrorMessage = ERROR_MESSAGE() RAISERROR(@ErrorMessage, @ErrorSeverity, @ErrorState) PRINT 'Error detected, transaction rolled back.' END CATCH
SELECT C.Id AS CategoryId, C.Title AS CategoryTitle, N.Id, N.Title From NewsCategories C OUTER APPLY ( SELECT TOP 10 * FROM News WHERE CategoryId = C.Id ) AS N ORDER BY C.Id Desc
SELECT t_cluster.id, t_cluster.name, t_cluster.desc, t_logging_max.xd1 FROM t_cluster LEFT OUTER JOIN ( SELECT id, MAX(xd1) AS xd1 FROM t_logging GROUP BY id ) t_logging_max ON t_cluster.id = t_logging_max.id WHERE t_cluster.id LIKE '%73%';
select top 1 [price] from( select [id], [count], [price], sum([count]) over(order by [id]) as run_sum from tbl ) x where 120 <= run_sum order by run_sum
:connect server1 use DatabaseName GO :r StoredProcedure.sql GO :connect server2 use DatabaseName GO :r StoredProcedure.sql GO :connect server3 use DatabaseName GO :r StoredProcedure.sql GO
SELECT Customer_details.CUS_name, (SUM(SALES.Bill_Amount) - SUM(SALES.Recived_Amount)) as Subtract,Customer_details.Cus_id from sales INNER JOIN Customer_details ON Customer_details.Cus_id=sales.Cus_id where SALES.Cus_id = 1 group by Customer_details.CUS_name,Customer_details.Cus_id order BY Cus_id
SELECT movie, string_agg(actor, ', ') AS actor_list FROM tbl GROUP BY 1;
with cte as (select o.*, case AdjustmentFlag when 1 then -1 else 1 end DrCr, row_number() over (partition by OrderId, Amount, case AdjustmentFlag when 1 then 1 end order by AdjustmentFlag, Id) Rn from [Order] o) select OrderId, max(case DrCr when 1 then Id end) DrId, sum(case DrCr when 1 then Amount else 0 end) DrAmount, max(case DrCr when 1 then AdjustmentFlag end) DrAdjustmentFlag, max(case DrCr when -1 then Id end) CrId, sum(case DrCr when -1 then Amount else 0 end) CrAmount, max(case DrCr when -1 then AdjustmentFlag end) CrAdjustmentFlag, sum(DrCr * Amount) BalanceAmount from cte group by OrderId, Amount, Rn having sum(DrCr * Amount) >= 0 /* excludes unmatched cancelled orders */
declare @ctr integer set @ctr = 1 while @ctr < 1000 begin --Do your logic select @ctr = @ctr + 1 end
cast(621*1.0/7 as Decimal(5,3))
SELECT a_id FROM mytable GROUP BY a_id HAVING count(a_id) > 1
SELECT p1.product_id, substring( ( SELECT ',' + engine_id FROM ProductEngine p2 WHERE p2.product_id = p1.product_id FOR XML PATH('') ), 2, 4000) AS engine_id FROM Products p1;
WHERE ( @param_1 is NULL or field_1 = @param_1) AND ( @param_2 is NULL or field_2 = @param_2) AND ( @param_3 is NULL or field_3 = @param_3) OPTOIN(RECOMPILE)
SELECT * FROM tower WHERE sitenumber NOT IN (SELECT sitenumber FROM sites)
columnname type
SELECT orderNumber FROM `order` WHERE id IN ( SELECT orderid FROM orderDetail od1 INNER JOIN orderDetail od2 USING (orderid) WHERE od1.reference = 'F40' AND od2.description = "Epee" )
SELECT @StartTm=CASE WHEN @SOSlckTm=8 THEN DATEADD(day,1,@SODocDueD) end
CREATE INDEX ON my_table (name) WHERE name IS NOT NULL;
declare @t table ( group_code varchar(15)) insert into @t values ('122.2') ,('122.3' ) ,( '122.4' ) ,( '112.6'),( '112.0') , ( '119.1') SELECT (left(group_code, 3)) as Grop, count(left(group_code, 3)) as occurrence from @t group by left(group_code, 3) select * from ( SELECT (left(group_code, 3)) as Grop, count(left(group_code, 3)) as occurrence from @t group by left(group_code, 3) ) a join @t t on a.Grop = left(t.group_code, 3)
SELECT m.member_id, m.login, p.type, CASE p.type WHEN 1 THEN '<div id=1>' WHEN 2 THEN '<div id=2>' END as MyDiv FROM permissions p INNER JOIN members m ON p.member_id = m.member_id WHERE K_id = '$kid' ORDER BY p.type DESC
CREATE TABLE t1(id int primary key); CREATE TABLE t3(id int primary key); CREATE TABLE t2(t1_id int references t1(id), t3_id int references t3(id)); CREATE TABLE t4(id int primary key, t1_id int references t1(id)); CREATE FUNCTION Foo(@t4_id int, @t3_id int) returns int as begin return (select count(*) from t2 where t3_id=@t3_id and t1_id in (select t1_id from t4 where id=@t4_id)); end; GO; CREATE TABLE t5( t4_id int references t4(id), t3_id int references t3(id), PRIMARY KEY (t3_id,t4_id), CHECK ( Foo(t3_id,t4_id)>0 ) );
select match_id from table_name where "AAA" in (player_1,player_2) and "BBB" in (player_1,player_2);
Private Sub Detail_Format(Cancel As Integer, FormatCount As Integer) Me.MyTextBox = "<div><font face=Arial size=4 color=Blue>" & _ "<strong>My Blue Bold Text</strong></font></div>" End Sub
SELECT DATALENGTH ( (SELECT * FROM products FOR XML RAW, ROOT('products') ) )
v_url := '<your url to the report>'; host ('cmd /c start '||v_url);
DECLARE @minDateTime AS DATETIME; DECLARE @maxDateTime AS DATETIME; SET @minDateTime = '2014-01-13 02:00:00'; SET @maxDateTime = '2014-12-31 14:00:00'; ; WITH Dates_CTE AS (SELECT @minDateTime AS Dates UNION ALL SELECT Dateadd(hh, 1, Dates) FROM Dates_CTE WHERE Dates < @maxDateTime) SELECT * FROM Dates_CTE OPTION (MAXRECURSION 0)
SELECT id from table1 a FULL JOIN table2 b using (id) FULL JOIN table3 c using (id) FULL JOIN table4 using (id);
EXAMPLE CREATE OR REPLACE PROCEDURE target_deletion IS number_of_the_job NUMBER; BEGIN DBMS_JOB.submit (number_of_the_job, 'begin stored_procedure_for_deletion; end;', SYSDATE); END; /
select exists( select 1 from tbl_stats_assigned where username = 'abc' );
select distinct r.risk_ID, r.title, ah.Approval_ID as Approver_ID from dbo.tbl_risk r left join dbo.tbl_Approval_History ah on ah.risk_ID = r.risk_ID and ah.Status_ID = 5 ;
select dvdID as 'unique number', count(*) as 'times hired' from MonthlyRental where month(dateHired) = 8 group by dvdId
SELECT Id, Value FROM(SELECT Id, Value, COUNT(*) OVER (PARTITION BY Id) cnt, SUM(DECODE(Value, 'X', 1, 0)) OVER (PARTITION BY Id) sumx FROM your_table ) WHERE cnt = 1 OR sumx = 0;
select t1.id, t1.name, t2.cnt from yourtable t1 inner join ( SELECT max(id) id, COUNT(id) AS cnt FROM yourtable GROUP BY name HAVING cnt > 1 ) t2 on t1.id = t2.id
WITH CTE AS ( SELECT ID, Rating, CreatedDate, ROW_NUMBER() OVER (PARTITION BY ID ORDER BY CreatedDate DESC) RowID FROM [TABLESWITHJOIN] ) SELECT * FROM CTE WHERE RowID = 1;
SELECT photo.src_big, photo.created, photo.modified, photo.owner, photo.aid, photo.caption FROM photo inner join album on album.aid = photo.aid inner join friend on album.owner = friend.uid2 WHERE uid1=me() or uid2 = me() order by modified desc,created DESC LIMIT 30
SELECT CAST(ABS(CHECKSUM(Indicator)) % 220 AS TINYINT) AS Indicator, CAST(CIndicator AS VARCHAR(100)) AS CIndicator, CAST(ABS(CHECKSUM(SK_IndicatorL2)) % 220 AS TINYINT) AS SK_IndicatorL2, CAST(IndicatorL2 AS varchar(100)) AS IndicatorL2 FROM ( VALUES ('Alcohol', 'Alcohol', 'Audit C recorded', 'Audit C recorded (excluding screen in 3y prior to start of quarter)'), ('Alcohol', 'Alcohol', 'Community Detox and TH CAT', 'Community Detox and TH CAT'), ('Alcohol', 'Alcohol', 'Follow Up appointment', 'Follow Up appointment'), ('Healthy Lifestyles', 'Healthy Lifestyles', 'HealthyLifestyle-Aged 19-39', 'HealthyLifestyle-Aged 19-39'), ('Healthy Lifestyles', 'Healthy Lifestyles', 'Aged 19-39 - BMI recorded', 'Aged 19-39 - BMI recorded') ) AS Nis (Indicator, CIndicator, SK_IndicatorL2, IndicatorL2)
TimeIn >= '1/8/1950' AND TimeIn < '1/9/1950' AND CASE WHEN TimeIn >= '1950-01-08' AND TimeIn < '1950-01-09' THEN DATEADD(week, DATEDIFF(week, '1/8/1950', '9/14/2014'), TimeIn) END >= '2014-09-14'
SELECT dT.partkey, dT.numreturns FROM (SELECT O.o_partkey as partkey, SUM(CASE WHEN O.o_returnflag = 'R' THEN 1 ELSE 0 END) as numreturns FROM [ORDER] O GROUP BY O.o_partkey) AS dT ORDER BY dT.numreturns DESC;
timestampfield > current_timestamp - interval '1' hour
WITH RECURSIVE docCTE AS ( /* Recursive Seed */ SELECT cast(null as int) as parentdoc documentID, 0 as depth, documentid as originalDocument, CAST(null as varchar(100) as docpath FROM dbo.document Where originalDocID IS NULL UNION ALL /* Recursive Term */ SELECT docCTE.DocumentID as parentdoc, document.documentID, depth + 1 as depth, docCTE.originalDocument, docCTE.Path + '>' + document.documentID FROM docCTE INNER JOIN dbo.document on doccte.document = document.originalDocID WHERE depth <= 15 /*Keep it from cycling in case of bad hierarchy*/ ) SELECT * FROM docCTE;
SELECT * FROM ( SELECT * FROM TABLE WHERE event_time < NOW() ORDER BY event_time DESC LIMIT 2 ) First2 UNION ALL SELECT * FROM ( SELECT * FROM TABLE WHERE event_time > NOW() ORDER BY event_time ASC LIMIT 1 ) Next1 ORDER BY event_time
<?php class HompageController extends AppController { public function index(){ ... //For us to be able to call a different Model if it doesnt have a relationship with this model. Instantiate Product Model $Products = ClassRegistry::init('Product'); //to get the data in product database. you can do it in two ways //1. use the find method to get all data in Product database $myproducts = $Products->find('all'); //2. or call some function in your Product model e.g. get_products() that return the data. $myproducts = $Products->get_products(); //pass myproducts variable to homepage index $this->set('myproducts', $myproducts); } ?>
SELECT Branch AS 'Branch Code', SUM(CASE WHEN CustomerStatus_Value = 'E' THEN 1 ELSE 0 END) AS 'Created', SUM(CASE WHEN CustomerStatus_Value = 'A' THEN 1 ELSE 0 END) AS 'Active', SUM(CASE WHEN CustomerStatus_Value = 'B' THEN 1 ELSE 0 END) AS 'Blocked', SUM(CASE WHEN CustomerStatus_Value = 'C' THEN 1 ELSE 0 END) AS 'Cancelled', COUNT(CustomerStatus_Value) AS 'All' FROM CustomerStatusEntries GROUP BY Id
Question Answer -------- ------ Question ID Answer ID Edit counter Edit counter Question text Answer Text
select t1.TableID as TableID1, t1.StateValue as StateValue1, t2.TableID as TableID2, t2.StateValue as StateValue2, t1.StateDefinition from MyTable t1 inner join MyTable t2 on t1.TableID = 1 and t2.TableID = 2 where t1.StateValue = t2.StateValue and t1.StateDefinition = t2.StateDefinition
CREATE OR REPLACE FUNCTION f_test(string1 varchar) RETURNS VOID AS $$ DECLARE string2 varchar = 'A1,A2,A3,A4,A5,A6,A7'; string3 varchar; string4 varchar; string5 varchar; string6 varchar; intCount int; BEGIN string3 := REPLACE(string1,',',' = 1 AND ')||' = 1'; RAISE INFO '%',string3; string4 := REPLACE(string2,string1,string3); RAISE INFO '%',string4; select string_agg(c,' AND ') into string6 from ( select * from ( select c ||'= 1' c from ( select regexp_split_to_table(string2,',') c )t where c in (select regexp_split_to_table(string1,',')) union all select c ||' IS NULL ' c from ( select regexp_split_to_table(string2,',') c )t where c not in (select regexp_split_to_table(string1,',')) ) t group by c order by c )t; RAISE INFO '%',string6; END; $$ LANGUAGE PLPGSQL;
var app = Application; var interval = TimeSpan.FromSeconds(1); var windowSize = TimeSpan.FromSeconds(10); var hopSize = TimeSpan.FromSeconds(1); /* Replace the Observable.Interval with your logic to poll the database and convert the messages to instances of TPayload. It just needs to be a class that implements the IObservable<TPayload> interface. */ var observable = app.DefineObservable(()=> Observable.Interval(interval)); // Convert the observable to a point streamable. var streamable = observable.ToPointStreamable( e=> PointEvent.CreateInsert(DateTimeOffset.Now, e), AdvanceTimeSettings.IncreasingStartTime); /* Using the streamable from the step before, write your actual LINQ queries to do the analytics you want. */ var query = from win in streamable.HoppingWindow(windowSize, hopSize) select new Payload{ Timestamp = DateTime.UtcNow, Value = win.Count() }; /* Create a sink to output your events (WCF, etc). It just needs to be a class that implements the IObserver<TPayload> interface. The implementation is highly dependent on your needs. */ var observer = app.DefineObserver(()=> Observer.Create<Payload>(e => e.Dump())); query.Bind(observer).Run();
SELECT SUM(transaction_amount) WHERE YEAR(transaction_date) = '2008' GROUP BY YEAR(transaction_date)
SELECT VRI.Street_Number_and_Modifier + CASE WHEN VRI.Street_Number_and_Modifier <> '' THEN ', ' ELSE '' END + VRI.Street_Direction + CASE WHEN VRI.Street_Direction <> '' THEN ', ' ELSE '' END + VRI.Street_Name + CASE WHEN VRI.Street_Name <> '' THEN ', ' ELSE '' END + VRI.Street_Direction + CASE WHEN VRI.Street_Direction <> '' THEN ', ' ELSE '' END + VRI.Street_Suffix + CASE WHEN VRI.Street_Suffix <> '' THEN ', ' ELSE '' END + VRI.Street_Post_Direction + CASE WHEN VRI.Street_Post_Direction <> '' THEN ', ' ELSE '' END + VRI.Unit + CASE WHEN VRI.Unit<> '' THEN ', ' ELSE '' END FROM View_Report_Information_Tables VRI
CREATE PROCEDURE MyFolder_DeleteFolder @UserId int AS SET NOCOUNT on DECLARE @RowsDeleted int SET @RowsDeleted = 1 WHILE @RowsDeleted > 0 BEGIN -- Loop until a call to DELETE does not delete any rows DELETE Folder WHERE FolderID IN (SELECT ch.FolderID FROM Folder ch LEFT JOIN Folder p ON ch.ParentID = p.FolderID WHERE p.FolderID IS NULL AND ch.ParentID > 0) AND UserID = @UserID SET @RowsDeleted = @@rowcount END RETURN 0
DECLARE @MaxKeyLength INT = (SELECT MAX(LEN([Name])) FROM testTable) select '(''{' + cast(UniqueId as varchar(MAX)) + '}'',''' + LEFT(LTRIM([Name]) + ''', ', @MaxKeyLength + 4) + '''' + Address+ '''),' from testTable;
SELECT a.id, b.id as AlternateID, a.value FROM (SELECT MIN(id) as id , value FROM YourTable GROUP BY value) a JOIN YourTable b on a.value = b.value and a.id <> b.id
;WITH cte As ( SELECT array_id, [date], comment, ROW_NUMBER() OVER (PARTITION BY array_id ORDER BY [date] DESC) AS RN FROM my_table WHERE master_frame = 1 ) SELECT array_id, [date], comment FROM cte WHERE RN=1;
UPDATE mytable SET url = SUBSTRING_INDEX(url, '?', 1)
SELECT * FROM ( **(** SELECT profileId FROM ( SELECT profileId FROM profile profile2 WHERE profile2.profilePublishDate <= Now() ORDER BY profile2.profilePublishDate DESC LIMIT 0,40 ) AS profile1 ORDER BY RAND() LIMIT 0,20 **)** UNION ( SELECT profileId FROM profile profile4 WHERE profileId NOT IN ( SELECT profileId FROM profile profile4 WHERE profile4.profilePublishDate <= Now() ORDER BY profile4.profilePublishDate DESC LIMIT 0,40 ) ORDER BY RAND() LIMIT 0,40 ) ) TEMP ORDER BY RAND();
select p.post_title,m.meta_key,m.meta_value from wp_post p join wp_postmeta m on p.id=m.post_id where p.post_status = 'publish' AND p.post_type = 'product' and (m.meta_key='_price' or m.meta_key='_regular_price')
UPDATE tablename SET columName = columnName / 42 WHERE rowId !=42;
SELECT @var = ISNULL(MAX(Column1), 0) FROM myschema.mytable WHERE Id = @suppliedId;
select c.cust_id, c.name, c.schema_id, s.period, s.amt, s.updated_date from customer c inner join ( select s1.schema_id, s1.period, s1.amt, s1.updated_date from `schemas` s1 inner join ( select schema_id, max(updated_date) MaxDate from `schemas` group by schema_id ) s2 on s1.schema_id = s2.schema_id and s1.updated_date = s2.maxdate ) s on c.schema_id = s.schema_id
select a_id from table_A_B where b_id in ('a','c') group by a_id having count(distinct b_id) = 2
select id as "#",first_name,last_name from student
insert into temp123(description) values('TESTING') returning 23,*;
regexp_replace( CUST_PART_NO, '(.*)(R)(.*)', '\3' )
SELECT u.name FROM friends f JOIN users s ON (u.id = f.user_id_2) WHERE f.user_id_2 = 1234
$ wdiff a b # 1,"abc","( @docid =""00123"" or @docid =""00456"") AND [-a_number-] {+@a_number+} is not NULL"
SELECT `src`, `value` FROM ( SELECT 'a' AS `src`, a AS `value` FROM yourtable WHERE id = 42 UNION ALL SELECT 'b' AS `src`, b AS `value` FROM yourtable WHERE id = 42 UNION ALL -- etc... UNION ALL SELECT 'j' AS `src`, j AS `value` FROM yourtable WHERE id = 42 ) T1 ORDER BY `value` LIMIT 3
substring(fieldname,50,10)
query { for h in dc.Table do where h.SectorId.HasValue select h }
For Each row As DataRow In dtDataTable.Rows If row.Item("fDateAdded") = *your match criteria* Then *Do something - you can utilies* row.Item("fName") *if you need* End if Next row
select * from ( select row_number()over(partition by id order by time desc) Rn, lag(item) over(partition by id order by time) prev_item,* from yourtable ) A Where Rn = 1
;WITH CTE1 AS ( SELECT Div, Dept, REPLACE(States,' ','') + ',' AS States FROM Table2 ), CTE2 AS ( SELECT c1.Div, c1.Dept, LEFT(c1.States,CHARINDEX(',', c1.States)-1) AS IndividualState, RIGHT(c1.States,LEN(c1.States)-CHARINDEX(',', c1.States)) AS RemainingStates FROM CTE1 c1 UNION ALL SELECT c2.Div, c2.Dept, LEFT(c2.RemainingStates,CHARINDEX(',', c2.RemainingStates)-1), RIGHT(c2.RemainingStates,LEN(c2.RemainingStates) - CHARINDEX(',', c2.RemainingStates)) FROM CTE2 c2 WHERE LEN(c2.RemainingStates) > 0 ), CTE3 AS ( SELECT Div, Dept, IndividualState, COUNT(*) AS StateCount FROM CTE2 GROUP BY Div, Dept, IndividualState ), CTE4 AS ( SELECT t1.Div, t1.Dept, ( SELECT c3.IndividualState + ' - (' + CONVERT(varchar(10),c3.StateCount) + '), ' FROM CTE3 c3 WHERE c3.Div = t1.Div AND c3.Dept = t1.Dept FOR XML PATH('') ) AS States FROM Table1 t1 ) SELECT Div, Dept, LEFT(States, LEN(States) - 1) AS States FROM CTE4
SELECT @Result As ReturnVal
email phone_number address
SELECT [coly]/[table].[colx]...
select c.*, m._id, m.message from (select c.*, (select max(_id) as maxid from message m where c._id = m.conversationid ) as messageid from conversation c ) c join message m on c.messageid = m._id;
declare @p table(id int, name varchar(10)) declare @c table(id int, name varchar(10)) declare @pc table(pid int, cid int) insert into @p (id, name) values (1, 'laptop') insert into @p (id, name) values (2, 'desktop') insert into @p (id, name) values (3, 'milk') insert into @c (id, name) values (1, 'computer') insert into @c (id, name) values (2, 'device') insert into @c (id, name) values (3, 'food') insert into @pc (pid, cid) values (1, 1) insert into @pc (pid, cid) values (1, 2) --insert into @pc (pid, cid) values (1, 3) insert into @pc (pid, cid) values (2, 1) insert into @pc (pid, cid) values (2, 2) insert into @pc (pid, cid) values (3, 3) declare @productId int; set @productId = 1; select * from @p p where --count of categories that current product shares with the source product --should be equal to the number of categories the source product belongs to ( select count(*) from @pc pc where pc.pid = p.id and pc.cid in ( select cid from @pc pc where pc.pid = @productId ) ) = (select count(*) from @pc pc where pc.pid = @productId) and p.id <> @productId
WITH cte AS ( SELECT av.userid, av.DateofDays, SUM(rooms.max_guests * av.RoomAvailable) AS maxPeople FROM av AS av INNER JOIN rooms ON av.room = rooms.ID AND av.DateofDays BETWEEN '09/28/2012' AND '10/03/2012' GROUP BY av.userid, av.DateofDays HAVING SUM(rooms.max_guests * av.RoomAvailable) >= 10 ) select cte.userid from cte group by av.userid having COUNT(*) = 6
SELECT t1.a,t1.b,t1.c,t1.d,t1.e FROM tablename AS t1 INNER JOIN (SELECT a, b, c, MAX(d) d FROM tablename GROUP BY a, b, c ) AS t2 ON t1.a = t2.a AND t1.b = t2.b AND t1.c = t2.c AND t1.d = t2.d
select r.employee, d.description from table1 as d inner join (select min(rank) as rank, employee from table1 group by employee) r on d.rank = r.rank and d.employee = r.employee
CREATE VIEW [dbo].[myview] (a,b,c) AS SELECT a,b,CAST(NULL AS NVARCHAR(100)) c;
SET ARITHABORT OFF; SET ANSI_WARNINGS OFF; WITH Product(Quantity,StatusId) As ( SELECT -2147483648,1 ) SELECT (CASE WHEN P.StatusId IN (5, 8) THEN 0 ELSE -P.Quantity END) AS Quantity FROM Product P
SELECT s.id, s.title, s.description, sq.cc FROM survey s join ( SELECT ss.id, count(qq.id) as cc FROM survey ss LEFT OUTER JOIN questionnaire q ON q.survey_id = s.id GROUP BY s.id ) sq on sq.id = s.id
public override void Input0_ProcessInputRow(Input0Buffer Row) { const string pFirstName = @"^[A-Z]([-']?[a-z]+)*"; const string pSuffix = @"((Jr|Sr|I|V|X)( ?))*"; const string pInitial = @"(?<=\s)[A-Z](?=\s)"; const string pLastName = @"(?!(?:Jr|Sr|I|V|X|^))([A-Z][-'\s]?[a-z]+)"; string fullName = Row.Name.ToString(); string firstName = Regex.Match(fullName, pFirstName).Value; string suffix = Regex.Match(fullName, pSuffix).Value; string initial = Regex.Match(fullName, pInitial).Value; string lastName = Regex.Match(fullName, pLastName).Value; if (!string.IsNullOrEmpty(initial)) lastName += " " + initial; if (!string.IsNullOrEmpty(suffix)) lastName += " " + suffix; Row.FirstName = firstName; Row.LastName = lastName; }
select wtdate, CONVERT(DATE, '20'+RIGHT(wtdate,2) +REVERSE(LEFT(SUBSTRING(REVERSE(wtdate),5,2)+'0',2)) +LEFT(RIGHT(wtdate,4),2) ) AS ConvertedDate from Trans group by wtdate order by wtdate
SELECT [FieldA], [FieldB], a.[FieldC], [FieldD], [FieldE] FROM [TABLE] a LEFT JOIN( SELECT DISTINCT [FieldC], pwdencrypt([FieldC]) as [FieldE] FROM [TABLE]) b ON a.[FieldC] = b.[FieldC]
SELECT ParticipantId FROM Contact WHERE EXISTS ( SELECT 1 FROM Contact c2 WHERE c2.ParticipantID = c.ParticipantId AND ContactTypeId = 1 GROUP BY ParticipantID HAVING COUNT(*) > 1 AND COUNT(CASE WHEN IsCurrent = 0 AND IsActive = 1 THEN 1 END) >= 1 );
select k.* from ( select 1 as pk union all select 3 union all select 7 ) k left join your_table t on t.id = k.pk where t.id is null
SELECT * from shops s WHERE s.shoptype = 0 AND NOT EXISTS (SELECT 1 FROM receipts r, receiptaddinfo ri WHERE r.receiptid = ri.receiptid AND r.shop = ri.shop AND ri.shop = s.shop AND ri.creationtime >= '2016-05-19 00:00:00')
SELECT B.PermissionId ,A.RoleId FROM RolesPermissions A INNER JOIN ( SELECT PermissionId FROM RolesPermissions WHERE HasPermission = 0 --Get all permissions for user(Duplicates entries) AND RoleId IN ( SELECT RoleId FROM aspnet_UsersInRoles WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c' ) GROUP BY PermissionId HAVING Count(PermissionId) = ( SELECT count(RoleId) FROM aspnet_UsersInRoles WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c' ) ) AS B ON A.PermissionId = B.PermissionId Where HasPermission = 0 AND A.RoleId IN ( SELECT RoleId FROM aspnet_UsersInRoles WHERE UserId = '3ee38aa9-0e1a-4805-9506-aa47aa38a79c' ) group by B.PermissionId,A.RoleId
SELECT GetName (empno) name , amount FROM bonus;
insert into a (id, ... ) values (coalesce($1, uuid_generate_v4()), ... );
select a.a_name, a.max_b, count(*) as num_a_id from a join a_to_b on a.a_id=a_to_b.a_id group by a_id
declare @Yourtable table (SecID int, Date Date, Price int) INSERT INTO @Yourtable SELECT 1,GETDATE()-5,10 union all SELECT 1,GETDATE()-4,10 union all SELECT 1,GETDATE()-3,5 union all SELECT 1,GETDATE()-2,10 union all SELECT 1,GETDATE()-1, 10 ;WITH cte AS ( SELECT SecID,Date,Price, ROW_NUMBER() OVER (PARTITION BY SecID ORDER BY Date) - ROW_NUMBER() OVER (PARTITION BY Price, SecID ORDER BY Date) AS Grp FROM @Yourtable ) SELECT SecID,Price, MIN(Date) StartDate, MAX(Date) EndDate FROM cte GROUP BY SecID, Grp, Price ORDER BY SecID, MIN(Date)
SELECT cr.TransID, MAX(inv.TransID) as InvoiceID, MAX(CASE WHEN inv.TransID is NULL THEN 1 ELSE 0 END) as Unsatsified FROM @t cr left join @t inv on cr.Product = inv.Product and cr.OrderRef = inv.OrderRef and cr.Qty = inv.Qty and cr.Date = inv.Date and inv.TransType = 'Invoice' WHERE cr.TransType = 'Credit' GROUP BY cr.TransID HAVING MAX(CASE WHEN inv.TransID is NULL THEN 1 ELSE 0 END) = 0
UPDATE DisplayArticles SET ArticleID = (SELECT MAX(ArticleID) FROM Articles AS a WHERE a.CategoryID = CategoryID AND ArticleID NOT IN ( SELECT ArticleID FROM DisplayArticles da WHERE da.CategoryID = CategoryID ) ) WHERE IsAuto = 'true'
SELECT plantname, orderfreq, totalincome FROM plantreview WHERE score >='5' AND recommended='1' ORDER BY score DESC LIMIT 0, 5
SELECT a.Geog1.STIntersection(b.Geog2) AS OverlapGeog , a.Geog1.STIntersection(b.Geog2).STArea() AS AreaOverlap FROM ( SELECT GEOGRAPHY::STGeomFromText('POINT(0.0 0.0)',4326).STBuffer(100) AS Geog1 ) a INNER JOIN ( SELECT GEOGRAPHY::STGeomFromText('POINT(0.001 0.0)',4326).STBuffer(100) AS Geog2 ) b On a.Geog1.STIntersects(b.Geog2) = 1
with ABCOrdered as ( select * , FirstEvent = row_number() over (partition by ID order by CODE_DATE) , LastEvent = row_number() over (partition by ID order by CODE_DATE desc) from ABC ) select f.ID , [RESULT] = case when f.CODE_GROUP = l.CODE_GROUP or l.CODE_GROUP is null then f.CODE_GROUP else f.CODE_GROUP + ' THEN ' + l.CODE_GROUP end , EVER_APPROVED = case when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'APPROVED') then 'Y' else 'N' end , EVER_DENIED = case when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'DENIED') then 'Y' else 'N' end , EVER_ON_HOLD = case when exists (select 1 from ABC where l.ID = ABC.ID and ABC.CODE_GROUP = 'ON HOLD') then 'Y' else 'N' end from ABCOrdered f left join ABCOrdered l on f.ID = l.ID and l.LastEvent = 1 where f.FirstEvent = 1 order by f.ID
SELECT TotalRooms = COUNT(*) , StartDate = MIN(i.StartDate) , EndDate = MAX(i.EndDate) FROM bookings b LEFT JOIN bookingitems bi ON b.BookingID = bi.BookingID GROUP BY b.BookingID WHERE MIN(i.StartDate) >= '2010-01-01' ORDER BY StartDate, EndDate
SELECT YEAR(your_column) AS the_year, DATE_FORMAT(your_column, '%b') AS the_month_abbreviated, GROUP_CONCAT(DATE_FORMAT(your_column, '%D') ORDER BY DAY(your_column) SEPARATOR ', ') AS the_days FROM your_table GROUP BY YEAR(your_column), DATE_FORMAT(your_column, '%b') ORDER BY YEAR(your_column), MONTH(your_column)
SELECT source, user, COUNT(*) FROM logs GROUP BY source, user ;
start_date < sysdate - 30 / (24 * 60)
update ... set gameCapacity = gameCapacity -1 where ...
Category ---------- CategoryId ParentCategoryId --nullable CategoryName
select t.name as TableWithForeignKey, fk.constraint_column_id as FK_PartNo , c.name as ForeignKeyColumn from sys.foreign_key_columns as fk inner join sys.tables as t on fk.parent_object_id = t.object_id inner join sys.columns as c on fk.parent_object_id = c.object_id and fk.parent_column_id = c.column_id where fk.referenced_object_id = (select object_id from sys.tables where name = 'TableOthersForeignKeyInto') order by TableWithForeignKey, FK_PartNo
revoke all on all tables in schema information_schema from public;
Select p1.fkProductId From AttributeBindings p1 inner join AttributeBindings p2 on p1.fkProductId = p2.fkProductId where (p1.fkAttributeId = 17 and p1.fkAttributeValueId = 97) and (p2.fkAttributeId = 6 and p2.fkAttributeValueId = 11)
SELECT * FROM test WHERE timestamp < date('now', '-2 days')
CASE 'some_expression' WHEN 1 THEN concat('Monday',first) WHEN 2 THEN concat('Tuesday',second) ELSE 'undefined' END AS 'days_of_week'
declare @binaryS binary(180) set @binaryS = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000E0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0700000000000000 declare @s varchar(max) set @s = Convert(varchar(max), @binaryS, 2) declare @seconds int set @seconds = 0 declare @i int set @i = 1 declare @t datetime set @t = Convert(datetime, '01/01/2014', 101) WHILE (@i <= 360) BEGIN declare @segment varchar(max) set @segment = substring(@s, @i, 2) --print '0x' + @segment set @seconds = (convert(int, convert(varbinary, '0x' + @segment, 1))) * 15 set @t = DATEADD(ss,480,@t) --print @seconds if(@seconds > 0) print @t set @i = @i + 2 END
USE AdventureWorks2008R2; GO WITH OrderedOrders AS ( SELECT SalesOrderID, OrderDate, ROW_NUMBER() OVER (ORDER BY OrderDate) AS 'RowNumber' FROM Sales.SalesOrderHeader ) SELECT * FROM OrderedOrders WHERE RowNumber BETWEEN 50 AND 60;
select * from TABLE_2 where category_id in (select category_id from TABLE_1 where parent_id = 1)
UPDATE LookUpWrkflwTemp SET SpiralUniverse = (SELECT Count(*) FROM SpiralUniverse su WHERE su.Date = LookUpWrkflwTemp.Date ) WHERE SprialUniverse IS NULL;
SELECT p.* FROM categories c JOIN relationships r ON c.cat_id = r.cat_id JOIN products p ON r.prod_id = p.prod_id WHERE c.name = 'Books' -- or specify parameter like @Books
select name from (select round((min(LATITUDE) + max(LATITUDE)) / 2) as LATITUDE, round((min(LONGITUDE) + max(LONGITUDE)) / 2) as LONGITUDE from STATION where DISTRICT_ID = '110' AND NAME LIKE 'Vancouver%') AS center inner join STATION s where s.DISTRICT_ID = '110' and s.NAME like 'Vancouver%' and s.LATITUDE between center.LATITUDE - 5 and center.LATITUDE + 5 and s.LONGITUDE between center.LONGITUDE - 5 and center.LONGITUDE + 5
SELECT MT.some_date, COALESCE(ST.search_string, MT.column_1) AS my_group, MT.column_2, SUM(MT.column_3) FROM My_Table MT LEFT OUTER JOIN Search_Table ST ON MT.column_1 LIKE '%' + ST.search_string + '%' GROUP BY MT.some_date, COALESCE(ST.search_string, MT.column_1) AS my_group, MT.column_2
CREATE TABLE Customers(ID INT IDENTITY(1,1), CustomerName VARCHAR(100), Country VARCHAR(100)); INSERT INTO Customers (CustomerName, Country) VALUES ('John', 'USA'), ('Martin','Germany'); INSERT INTO Customers (CustomerName, Country) SELECT CustomerName, Country FROM Customers WHERE Country='Germany'; SELECT * FROM Customers;
CREATE PROCEDURE sort_Students_By_Avg ( IN in_student_Id INT(11), OUT out_student_Name VARCHAR(20) ) BEGIN SELECT s.name INTO out_student_name FROM student s WHERE s.id = in_student_Id AND s.avg > 70; END;
439 left outer join 365 on 439.C = 365.C left outer join 444 on 365.K = 444.K left outer join T on 444.K = T.K
SELECT array_agg(id) AS id, "value" FROM Two GROUP BY "value";
SELECT cname, GROUP_CONCAT(survey_id) as survey_ids FROM categories GROUP BY cname
SELECT STAFF.Name ,STAFF.Position ,BRANCH.BranchID FROM STAFF INNER JOIN BRANCH ON STAFF.BranchID = BRANCH.BranchID ORDER BY STAFF.Name;
;WITH CTE AS ( SELECT a.BikePathId, c.ZipCodeId, Rnum =ROW_NUMBER() OVER (PARTITION BY a.BikePathId ORDER BY c.Boundary.STIntersection(d.Boundary)) FROM [dbo].[BikePaths] a INNER JOIN [dbo].[BikePathBoundaries] b on a.BikePathId = b.BikePathId INNER JOIN [dbo].[ZipCodeBoundaries] c on b.Boundary.STIntersects(c.Boundary) = 1 INNER JOIN [dbo].[ZipCodes] d on c.ZipCodeId = d.ZipCodeId) UPDATE a SET a.ZipCodeId = cte.ZipCodeId FROM [dbo].[BikePaths] a INNER JOIN cte on cte.bikepathid =a.bikepathid and cte.rnum=1;
SELECT e.event_id, COUNT(c.parent_id) as NumComments FROM events e left JOIN comments c ON c.parent_id=e.id WHERE e.owner_id = X group by e.event_id;
WITH X AS ( SELECT id, min(value) as minval from Foo group by id ) SELECT * FROM ( SELECT Foo.*, RANK() OVER ( PARTITION by Foo.id order by Foo.hid, Foo.value ) as Rank FROM Foo JOIN X on Foo.id = X.id and Foo.value = X.minval ) tmp WHERE Rank = 1 id hid value Rank ----------- ----------- ----------- -------------------- 1 1 1 1 2 3 3 1 3 2 2 1
ALTER SYSTEM SET resource_limit = TRUE scope = BOTH
WITH cte AS (SELECT DISTINCT * FROM Table2) SELECT t1."pId" FROM Table1 t1 JOIN cte t2 ON t1."pId" = t2."pId" WHERE t1."status" = 1 AND t1."keyVal" = 45 GROUP BY t1."pId" HAVING SUM( CASE WHEN t2."mode"=2 AND t2."modeVal"=5 OR t2."mode"=3 AND t2."modeVal"=6 THEN 1 END) = 2 AND COUNT(*)=2
SELECT SUM(CASE WHEN pKey = 1 THEN 1 ELSE 0 END) = SUM(CASE WHEN pKey = 2 THEN 1 ELSE 0 END) FROM testable WHERE prodStatus = 0
text VARCHAR2(10) generated always as (cast(to_char(id)||'_'||to_char(num) as VARCHAR2(10))) VIRTUAL
UPDATE animal_attrib_values aav SET animal_attrib_value_name= 'true' WHERE aav.animal_attrib_value_id = ( SELECT a.animal_attrib_value_id FROM animals a WHERE a.animal_id = 458 AND a.animal_attrib_type_id = 38 ) ;
UPDATE messages SET message_deleted_from = CASE WHEN message_user = ? AND message_id = ? THEN 1 ELSE message_deleted_from END, messages_delete_to = CASE WHEN message_to=? AND message_id = ? THEN 1 ELSE messages_delete_to END
SELECT i.SenderNumber, COALESCE(c.Name, d.SpvName, sd.SpvName, v.SpvName) as Name, CASE WHEN c.Name IS NOT NULL THEN 'contact' WHEN d.SpvName IS NOT NULL THEN 'district' WHEN sd.SpvName IS NOT NULL THEN 'sub_district' WHEN v.SpvName IS NOT NULL THEN 'village' ELSE '' END AS Type, i.Message FROM inbox i LEFT JOIN contact c ON i.SenderNumber = c.Number LEFT JOIN district d ON i.SenderNumber = d.Number LEFT JOIN sub_district sd ON i.SenderNumber = sd.Number LEFT JOIN village v ON i.SenderNumber = v.Number
select datename(month,date) [month] ,isnull(sum(case when year(DATE) = 2015 then sales end), 0) as '2015' from tblSales where tenantcode = 'cmbina13' group by datename(month,date) Order by DATEPART(MM,datename(month,date)+' 01 2011')
select listagg(source,',') within group (order by source) final_source from ( select distinct b.source source--, from taba_parent a, taba b where b.name = a.parent_name and b.name_type = 'Category' connect by prior a.parent_name = a.name start with a.name = 'Name3' );
SELECT full_table.attribute, main_table.articleID FROM main_table INNER JOIN full_table ON full_table.articleID = main_table.articleID INNER JOIN other_table ON other_table.attribute = full_table.attribute GROUP BY full_table.attribute, main_table.articleID
result := REGEXP_REPLACE(subject, '_0+', '_', 1, 0, 'c');
SELECT p.NamePK, p.Name, STUFF(( select '+' + n.Note from tblNote n where n.NameFK = p.NamePK for xml path('') ), 1, 1, '') FROM tblPeople p
SELECT sp_id, company_name FROM Student_Training GROUP BY company_name
<?xml version="1.0" encoding="utf-16" standalone="no"?> <DataMacros xmlns="http://schemas.microsoft.com/office/accessservices/2009/11/application"> <DataMacro Event="BeforeChange"> <Statements> <ConditionalBlock> <If> <Condition>Updated(&quot;ThingDateStamped&quot;)</Condition> <Statements> <ConditionalBlock> <If> <Condition>Not IsNull([Old].[ThingDateStamped])</Condition> <Statements> <Action Name="RaiseError"> <Argument Name="Number">1</Argument> <Argument Name="Description">An existing datestamp cannot be altered.</Argument> </Action> </Statements> </If> </ConditionalBlock> </Statements> </If> </ConditionalBlock> </Statements> </DataMacro> </DataMacros>
SELECT DISTINCT ON (release) * FROM release_country ORDER BY release, date_year, date_month, date_day;
mysql -u user -p dbnane
SELECT tag, (SELECT COUNT(1) FROM tag_newPosts t2 WHERE t2.tag LIKE CONCAT('%',t1.tag,'%')) AS tag_count FROM tags t1;
SELECT DATEADD(month,6,DATEADD(yy, DATEDIFF(yy,1,GETDATE())-1,0)) AS StartDate ,DATEADD(month,6,DATEADD(dd,-1,DATEADD(yy, DATEDIFF(yy,0,GETDATE()),0))) AS EndDate
SELECT MAX(column_name) FROM table_name where column_name => 901000000
select Id, name, partnumber, param1, param2, param3, stock, active from ( select *, RANK() (parition by id, param1, param2, param3 order by stock desc) as max_stock from product)x where max_stock = 1
CREATE TRIGGER trgAfterPersonInsert ON dbo.Person AFTER INSERT AS BEGIN INSERT INTO dbo.Car(PersonID) SELECT i.PersonID FROM INSERTED i END
DECLARE @TableName SYSNAME = 'Address' DECLARE @DataBaseName SYSNAME = 'AdventureWorks2008' DECLARE @PrimaryKey VARCHAR(max) = '', @sql NVARCHAR(max) SET @sql ='SELECT @PrimaryKey += '',''+COLUMN_NAME FROM ' + @DataBaseName + '.INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE TABLE_NAME = ''' + @TableName + ''' AND CONSTRAINT_NAME LIKE ''PK%''' --print @sql EXEC Sp_executesql @sql, N'@PrimaryKey varchar(1000) output', @PrimaryKey output SELECT RIGHT(@PrimaryKey, Len(@PrimaryKey) - 1)
Select subject_id , Sum( Case When Score = 0 Then 1 Else 0 End ) As [0] , Sum( Case When Score = 1 Then 1 Else 0 End ) As [1] , Sum( Case When Score = 2 Then 1 Else 0 End ) As [2] , Sum( Case When Score = 3 Then 1 Else 0 End ) As [3] , Sum( Case When Score = 4 Then 1 Else 0 End ) As [4] From Table Group By subject_id
IF EXISTS (SELECT ClientId FROM Business WHERE UserId = @userId) BEGIN SELECT DISTINCT Id FROM Client END ELSE BEGIN SELECT Id FROM Client WHERE Id NOT IN ( SELECT DISTINCT ClientId FROM Business ) END
' Note: This code requires the following COM reference: ' ' Microsoft Office 14.0 Access Database Engine Object Library ' Dim dbe As New Microsoft.Office.Interop.Access.Dao.DBEngine Dim db As Microsoft.Office.Interop.Access.Dao.Database = dbe.OpenDatabase("C:\__tmp\testData.accdb") db.TableDefs("Users").Fields("UserName").AllowZeroLength = False
-- ---------------------------- -- Table structure for `gallery_album` -- ---------------------------- DROP TABLE IF EXISTS `gallery_album`; CREATE TABLE `gallery_album` ( `album_id` int(11) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(255) NOT NULL COMMENT 'name of the album', `description` text COMMENT 'description of the album', `visible` enum('0','1') NOT NULL DEFAULT '1' COMMENT 'is album visible', `position` int(11) unsigned NOT NULL, `date_created` datetime NOT NULL, `date_updated` datetime NOT NULL, PRIMARY KEY (`album_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for `gallery_image` -- ---------------------------- DROP TABLE IF EXISTS `gallery_image`; CREATE TABLE `gallery_image` ( `image_id` int(11) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(30) DEFAULT NULL COMMENT 'name of the image used as image ALT attribute', `description` varchar(100) DEFAULT NULL COMMENT 'description of the image used as image TITLE attribute', `visible` enum('0','1') NOT NULL DEFAULT '1', `date_created` datetime NOT NULL, `date_updated` datetime NOT NULL, PRIMARY KEY (`image_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Table structure for `gallery_relation` -- ---------------------------- DROP TABLE IF EXISTS `gallery_relation`; CREATE TABLE `gallery_relation` ( `album_id` int(11) unsigned NOT NULL, `image_id` int(11) unsigned NOT NULL, `position` int(11) unsigned NOT NULL, PRIMARY KEY (`album_id`,`image_id`), KEY `image_id` (`image_id`), CONSTRAINT `gallery_relation_ibfk_1` FOREIGN KEY (`album_id`) REFERENCES `gallery_album` (`album_id`) ON DELETE CASCADE ON UPDATE CASCADE, CONSTRAINT `gallery_relation_ibfk_2` FOREIGN KEY (`image_id`) REFERENCES `gallery_image` (`image_id`) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
select * from all_objects where owner = 'OWNER_NAME' and object_name = 'ISEMPTY' and object_type = 'SYNONYM'
--create list of all possible category values (get first category from every row, then second, then third, etc) declare @Category table (SingleCategory VARCHAR(50)) insert into @Category select distinct LEFT(SingleCategory, charindex('~', SingleCategory)) from ( select categories as SingleCategory from @News union select SUBSTRING(categories, charindex('~', categories)+1, 100) from @News where Categories like '%~%~' union select SUBSTRING(categories, charindex('~', categories, charindex('~', categories)+1)+1, 100) from @News where Categories like '%~%~%~' --repeat if 4 and 5 occurances possible, etc ) sq --create a 'glue' table declare @Glue table(ArticleId INT NOT NULL, DateAdded SMALLDATETIME NOT NULL, Category VARCHAR(50) NOT NULL) insert into @Glue select articleid, dateadded, SingleCategory from @News n inner join @Category c on n.categories LIKE '%' + c.SingleCategory + '%' --use the glue table to identify the articles we do want, and delete all the others delete from @News where ArticleId not in ( SELECT articleid FROM ( SELECT articleid, Category, RANK() OVER(PARTITION BY Category ORDER BY dateadded DESC) AS RankThem FROM @Glue ) sq WHERE RankThem <= 5 )
oMainQueryR = "SELECT * FROM DBSelections WHERE 0 = 1"
declare x sys.odcinumberlist := sys.odcinumberlist(123); y number; begin select column_value into y from table(x); dbms_output.put_line(y); end;
AND (MATCH( T.truck_number, T.make, T.model, T.engine, T.vin_number, T.transmission_number, T.comments) AGAINST( '$vehicle' ) OR MATCH( P.part_num, P.part_desc, P.part_ref,M.comments, M.work_done) AGAINST( '$keywords' ))
WHERE people.LOGIN LIKE CONCAT(TRIM(IFNULL(expression, '')), '%')
select [contact_list_name] as 'Table' , [ov_number_dialed] as 'Number Dialed' , convert(date, [time_of_contact], 101) as 'Date' , convert(time, dateadd(hour, -7,[time_of_contact]), 108) as 'Time' , agent_full_name as 'Agent' , max(case when [response_status] = 'DAM' then response_status end) as 'Disp1_DAM' , max(case when [response_status] = 'DNA' then response_status end) as 'Disp2_DNA' ... FROM [meldb].[dbo].[cl_contact_event] GROUP BY [contact_list_name] , [ov_number_dialed] , convert(date, [time_of_contact], 101) , convert(time, dateadd(hour, -7,[time_of_contact]), 108) , agent_full_name
SELECT coalesce( maingroup, 'subgroup_total' ) As maingroup, coalesce( subgroup, 'group_total' ) As subgroup, count(*) cnt FROM very_complex_subquery GROUP BY GROUPING SETS((maingroup, subgroup), (maingroup), (subgroup)) order by 1,2 ;
SELECT PerceptionistID, SSNLastFour, SUM(CommissionPay) CommissionPay, SUM(PTOPay) PTOPay, SUM(HolidayPay) HolidayPay, SUM(Overtime) Overtime, SUM(TotalPay) TotalPay FROM ( SELECT PerceptionistID, SSNLastFour, CommissionPay, PTOPay, HolidayPay, Overtime, TotalPay FROM [dbo].fnCalculateCommissionForWeekOf(@MondayOfCurrentWeek) UNION ALL -- Need to get the following week's data and sum the two together SELECT PerceptionistID, SSNLastFour, CommissionPay, PTOPay, HolidayPay, Overtime, TotalPay FROM [dbo].fnCalculateCommissionForWeekOf(@MondayOfFollowingWeek) ) t GROUP BY PerceptionistID, SSNLastFour
SELECT Modules.UserID, Module_Info.ModuleTitle, Modules.ModuleMarks, Modules.ExamMark, Modules.AssignmentMark, MarkClassification.MarkDescription, (SELECT AVG(Modules.ExamMark) FROM Module_Info INNER JOIN Modules ON Module_Info.ModuleID = Modules.ModuleID WHERE (Modules.ModuleID = '2')) as Average FROM Module_Info INNER JOIN Modules ON Module_Info.ModuleID = Modules.ModuleID INNER JOIN MarkClassification ON Modules.MarkCodeDescription = MarkClassification.MarkId WHERE(Modules.UserID = '8')
SELECT DISTINCT ON (id) id, x, y FROM table
SELECT DISTINCT col_name FROM table_name WHERE TRIM(col_name) != ''
SELECT * FROM messages LEFT JOIN users ON messages.message_to = users.user_id OR messages.message_user = users.user_id LEFT JOIN message_replies ON messages.message_id = message_replies.message_reply_main LEFT JOIN user_personal_information ON users.user_id = user_personal_information.user_personal_information_user WHERE message_replies.message_reply_date = (SELECT MAX(message_reply_date) FROM message_replies WHERE message_reply_main = messages.message_id) /* AND more criterias */
SELECT M.id, M.accnt, amount = M.amount + Isnull(s.supply, 0), issued = Isnull(I.issued, 0) FROM maintbl M LEFT OUTER JOIN (SELECT id, Sum(supply) AS supply FROM supplytbl WHERE Month(dates) = 1 -- Month filter for Jan - feb Month(dates) in (1,2) GROUP BY id) S ON s.id = M.id LEFT OUTER JOIN (SELECT id, Sum(issued) AS issued FROM issuedtbl WHERE Month(dateissue) = 1 -- Month filter GROUP BY id) I ON I.id = M.id
SELECT ct.competition_id FROM competitions c JOIN competition_type ct ON ct.competition_id = c.id AND ct.Type_id = 1 WHERE NOT EXISTS(SELECT * FROM competitions c2 JOIN competition_type ct2 ON ct2.competition_id = c2.id AND ct2.Type_id = 2 WHERE c2.id = c.id)
select min(value) min, max(value) max from (select value, ROW_NUMBER() over (order by value) - value as [key] from t) v group by [key] order by min
SELECT * FROM TABLE_B B WHERE EXISTS (SELECT field1 from TABLE_A A WHERE A.field1 = B.field1);
SELECT T.[taskId], T.[sectionId], T.[DateAdded], CASE WHEN SectionId IS NULL THEN 1 WHEN o.[type] = 6 THEN 2 ELSE 3 END AS [type] FROM [TASK] AS T -- Applicable join condition goes here ... LEFT OUTER JOIN Organisation o ON t.TaskID = o.TaskID WHERE (T.[deleted] = 0) ORDER BY T.[DateAdded]
DECLARE @i INT, @sql NVARCHAR(512), @tablename varchar(200) = 'tbl' SET @sql = N'SELECT @i = COUNT(*) FROM ' + @tablename EXEC sp_executesql @query = @sql, @params = N'@i INT OUTPUT', @i = @i OUTPUT PRINT @i
SELECT name, entnum, CASE WHEN SUBSTRING(entnum,4,1) = '0' THEN SUBSTRING(entnum,5,2) ELSE SUBSTRING(entnum,4,3) END agencycode FROM CUSTFILE
CREATE TABLE TBL (a int, b varchar(50)) go INSERT INTO TBL SELECT 1,'hello' INSERT INTO TBL SELECT 2,'goodbye' go GRANT SELECT, UPDATE ON TBL TO guest go CREATE TABLE AUDIT ( audittime datetime default(getdate()) , targettable sysname , loginname sysname , spid int , sqltext nvarchar(max)) go CREATE TRIGGER TR_TBL ON TBL FOR INSERT, UPDATE, DELETE AS BEGIN CREATE TABLE #DBCC (EventType varchar(50), Parameters varchar(50), EventInfo nvarchar(max)) INSERT INTO #DBCC EXEC ('DBCC INPUTBUFFER(@@SPID)') INSERT INTO AUDIT (targettable, loginname, spid, sqltext) SELECT targettable = 'TBL' , suser = suser_name() , spid = @@SPID , sqltext = EventInfo FROM #DBCC END GO /* Test the Audit Trigger (can be run as guest) */ UPDATE TBL SET a = 3 WHERE a = 2
SELECT e.* FROM db_events.events e JOIN ( SELECT Max(id) MaxId, device_id FROM db_events.events GROUP BY device_id ) e2 on e.Id = e2.MaxId AND e.device_id = e2.device_id WHERE e.device_id IN ( SELECT device_id FROM db_system.devices WHERE vendor = 1) ORDER BY e.id DESC
select t.template_table_name from templates t, documents d where d.template_id = t.template_id and d.document_id = @param_document_id
SELECT F_SMART_DATE('{?AS_OF}') SMART_DATE FROM DUAL;
select traveldate, lastservicedate, 'Travel services from ' + convert(varchar(20), traveldate) + ' to ' + convert(varchar(20), lastservicedate) as TextResult from tablename
SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = N'2000064';
select * from (select a.*, lag(sdt) over (partition by id order by sdt) as prevsdt, lead(sdt) over (partition by id order by sdt) as nextsdt from table_a a ) a where sdt - prevsdt <= 1/(24*60) or nextsdt - sdt <= 1/(24*60);
select session_id, wm_concat(name_status), time from ( select session_id, (name+':'+status) as name_status, time from stuff ) group by session_id order by time
select Lastname, Firstname, Filename, case when Filename = max(Filename) over(partition by Lastname, Firstname) then Filename else null end as Max_Filename from Table1
SELECT t1.* FROM sales t1 JOIN ( SELECT date, min(price) price FROM sales GROUP BY date ) t2 ON t1.date = t2.date AND t1.price = t2.price
select top(5) * from tbl order by created_date desc
SELECT Total = COUNT(*) OVER() FROM Table1;
''''+cast(cast(table.field as date) as varchar(255))+''''
SELECT * FROM address WHERE name LIKE 'a%' OR name LIKE '% a%' ORDER BY CASE WHEN name LIKE 'a%' THEN 0 ELSE 1 END LIMIT 10
SELECT CAST(`duration` AS DECIMAL(10,4)) * CAST(`fee` AS DECIMAL(10,4)) FROM `simvoip`
EXEC master.dbo.sp_addlinkedserver @server = N'ALIAS', @srvproduct=N'ACTUALSERVER', @provider=N'SQLOLEDB', @datasrc=N'ACTUALSERVER'
Imports System Imports System.Data Imports System.Math Imports Microsoft.SqlServer.Dts.Pipeline.Wrapper Imports Microsoft.SqlServer.Dts.Runtime.Wrapper <microsoft.sqlserver.dts.pipeline.ssisscriptcomponententrypointattribute> _ <clscompliant(false)> _ Public Class ScriptMain Inherits UserComponent Public Overrides Sub Input0_ProcessInputRow(ByVal Row As Input0Buffer) ' Create a Globally Unique Identifier with SSIS Row.Guid = System.Guid.NewGuid() End Sub End Class
select * from ( select sal ,dense_rank() over (order by sal desc) ranking from table ) where ranking = 4 -- Replace 4 with any value of N
select t.time, isnull( (select c.studentCode from tbClassRsv c where c.transdate='2014-02-05 00:00:00' and c.class='ROOM 01' and c.status<>'DEL' and DateAdd(MINUTE, 30, Convert(datetime, t.time))>= Convert(datetime, c.time) and Convert(datetime, t.time) <= Convert(datetime, c.until) ),'-') from [tbTime] t
select type, sum(case when name like '% Smith' then 1 else 0 end) as SmithCount, sum(case when name like '% Anderson' then 1 else 0 end) as AndersonCount from mates group by type
select d.* from (select d.*, (case when month6 is null then 0 when month5 is null then 1 when month4 is null then 2 when month3 is null then 3 when month2 is null then 4 when month1 is null then 5 end) as cnt from data d ) d where cnt >= 3;
type TABSDBHack = class private FFilename: TFileName; // 2 relevant contiguous headers of an Absolute Database file FDBHeader: array [0..SIZEOFDBHEADER-1]; FCryptoHeader: array [0..SIZEOFCRYPTOHEADER-1]; // Mirror of the ControlBlock record from CryptoHeader FControlBlock: array [0..SIZEOFCONTROLBLOCK-1] of Byte; // function GetEncrypted: Boolean; function GetFileName: TFileName; function GetPageSize: Word; function GetPageCountInExtent: Word; function GetCryptoAlgorithm: Byte; protected // Retrieving Data from stream into FDBHeader and FCryptoHeader procedure ReadStream(F: TStream); // Mainly FillChar(..., ...,#0) of the corresponding record procedure ClearDBHeader; procedure ClearCryptoHeader; procedure ClearControlBlock; // Probe the existence of 'ABS0LUTEDATABASE' as file signature function CheckABSSignature: Boolean; // Compute the CRC of FControlBlock record function CRC32: Cardinal; // Decrypt the persisted Control Block into FControlBlock function InternalDecryptBuffer(const APassword: string):Boolean; public procedure Clear; // Wrapping a ReadStream using a local TFileStream procedure LoadFromFile(Filename: TFileName); // Return True if the decrypted Control Block correspond to original plain one. // Otherwise stated: The persisted CRC (in the Crypto Header) is equal to // the value returned by the function CRC32 function CheckPassword(const APassword: string): Boolean; property FileName: TFileName read GetFileName; // Sample of plain Data peristed that can be retrieved property PageSize: Word read GetPageSize; property PageCountInExtent: Word read GetPageCountInExtent; property Encrypted: Boolean read GetEncrypted; property CryptoAlgorithm: Byte read GetCryptoAlgorithm; end;
SELECT AwardReference.ownerID , COUNT(*) AS count FROM AwardReference WHERE AwardReference.ownerType = 'song' GROUP BY AwardReference.ownerID
select min(col1) as col1, col2 from TheTable group by col2 order by col2
-- DB2 select * from table fetch first 10 rows only -- Informix select first 10 * from table -- Microsoft SQL Server and Access select top 10 * from table -- MySQL and PostgreSQL select * from table limit 10 -- Oracle select * from (select * from table) where rownum <= 10
UPDATE B SET B.cpid = 250 FROM A WHERE A.id = B.a_id AND A.cgid LIKE '0002' AND B.cpid = 312
Sub SplitData() Dim rData As Range Dim rCat As Range Dim rProd As Range Dim Cat As String Dim Prod As String Dim Price As Currency Dim Cat_ID As Long Dim Prod_ID As Long Set rData = ActiveWorkbook.Worksheets("Data").Cells(1, 1) Set rCat = ActiveWorkbook.Worksheets("Catagory").Cells(1, 1) Set rProd = ActiveWorkbook.Worksheets("Product").Cells(1, 1) rCat = "id" rCat.Offset(0, 1) = "title" Set rCat = rCat.Offset(1, 0) rProd = "id" rProd.Offset(0, 1) = "title" rProd.Offset(0, 2) = "catagory_id" rProd.Offset(0, 3) = "price" Set rProd = rProd.Offset(1, 0) Cat_ID = 0 Prod_ID = 0 Do While rData <> "" If rData.Font.Bold Then Cat = rData Cat_ID = Cat_ID + 1 rCat = Cat_ID rCat.Offset(0, 1) = Cat Set rCat = rCat.Offset(1, 0) Else Prod = rData Price = rData.Offset(0, 1) Prod_ID = Prod_ID + 1 rProd = Prod_ID rProd.Offset(0, 1) = Prod rProd.Offset(0, 2) = Cat_ID rProd.Offset(0, 3) = Price Set rProd = rProd.Offset(1, 0) End If Set rData = rData.Offset(1, 0) Loop End Sub
SELECT order, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1COS_BLEACHING_FLAG' THEN value END ) AS tech, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF1' THEN value END ) AS bleach, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF2' THEN value END ) AS af1, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF3' THEN value END ) AS af2, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_AF4' THEN value END ) AS af3, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS1G_6LAYER_COS_CIPR_EF' THEN value END ) AS af4, MAX( CASE WHEN attribute LIKE 'CL_ACC%G_ADSL_DETAILS_ACCESS_TECHNOLOGY' THEN TO_DATE( value, 'DD/MM/YYYY' ) END ) AS ef FROM attributes WHERE order IN ( '802605-S844' /*, ...*/ ) GROUP BY order;
SELECT t.formid, t.statusname, MAX(t.actiondate) 'actiondate', t.formtype, t.chargeoffaccount, t.reasoncode, t.approvalcode, MAX(t.followupdate) 'followupdate' FROM ( SELECT t.formid, fs.name 'StatusName', t.actiondate, ft.name 'formtype', coa.account 'ChargeOffAccount', rc.name 'ReasonCode', ac.description 'ApprovalCode', ffu.followupdate, row_number() OVER (PARTITION BY ef.formid ORDER BY t.actiondate DESC) 'DateSortKey' FROM EXTENSION.FORMDATE t JOIN EXTENSION.FORM ef ON ef.formid = t.formid JOIN EXTENSION.FORMSTATUS fs ON fs.statusid = t.statusid JOIN EXTENSION.FORMTYPE ft ON ft.formtypeid = ef.formtypeid LEFT JOIN EXTENSION.CHARGEOFFACCOUNT coa ON coa.chargeoffid = ef.chargeoffid LEFT JOIN EXTENSION.REASONCODE rc ON rc.reasoncodeid = ef.reasoncodeid LEFT JOIN EXTENSION.APPROVALCODE ac ON ac.approvalcodeid = ef.approvalcodeid LEFT JOIN EXTENSION.FORMFOLLOWUP ffu ON ffu.formid = t.formid) t WHERE t.datesortkey = 1 GROUP BY t.formid, t.statusname, t.formtype, t.chargeoffaccount, t.reasoncode, t.approvalcode ORDER BY t.formid
CREATE VIEW dbo.Foo AS SELECT 1 AS X GO CREATE SCHEMA bar GO ALTER SCHEMA bar TRANSFER dbo.Foo; SELECT * FROM bar.Foo
select tablename, HAS_TABLE_PRIVILEGE(tablename, 'select') as select, HAS_TABLE_PRIVILEGE(tablename, 'insert') as insert, HAS_TABLE_PRIVILEGE(tablename, 'update') as update, HAS_TABLE_PRIVILEGE(tablename, 'delete') as delete, HAS_TABLE_PRIVILEGE(tablename, 'references') as references from pg_tables where schemaname='public' order by tablename;
SELECT * FROM table1 tab1 LEFT OUTER JOIN table2 tab2 ON tab1.fg = tab2.fg LEFT OUTER JOIN table4 tab4 ON tab1.ss = tab4.ss INNER JOIN table3 tab3 ON tab4.xya = tab3.xya LEFT OUTER JOIN table5 tab5 ON tab4.kk = tab5.kk
:SYSTEM.MESSAGE_LEVEL := '25'; COMMIT; :SYSTEM.MESSAGE_LEVEL := '0';
SELECT t.date, t.value_A/t2.value_B AS calc FROM table t JOIN table t2 ON t.date = DATE_ADD(t2.date, INTERVAL 1 MONTH)
DECLARE @i int SET @i = 1 DECLARE @sql_alter nvarchar(4000) , @sql_update nvarchar(4000) , @sql_select nvarchar(4000) CREATE TABLE #FLAT_TABLE (FID_0 int, FENCODED_0 varchar(10)) SET @sql_select = N'SELECT FID_0, FENCODED_0' INSERT INTO #FLAT_TABLE (FID_0, FENCODED_0) SELECT MAPENTRY_ID , ENCODED FROM XCO_MASTER WHERE MAPENTRY_ID = PARENT_ID while (@@ROWCOUNT > 0) begin SET @sql_select = @sql_select + ', FID_' + @i SET @sql_alter = N' ALTER TABLE #FLAT_TABLE ADD COLUMN FID_' + @i + N' int ALTER TABLE #FLAT_TABLE ADD COLUMN FENCODED_' + @i + N' varchar(10) ' SET @sql_update = N' UPDATE #FLAT_TABLE SET FID_' + @i + N' = MAPENTRY_ID , FENCODED_' + @i + N' = ENCODED FROM XCO_MASTER WHERE MAPENTRY_ID <> PARENT_ID and MAPENTRY_ID = FID_' + (Cast (@i - 1) as nvarchar(8)) ' SET @i = @i + 1 sp_executesql @sql_alter sp_executesql @sql_update end @sql_select = @sql_select + ' FROM #FLAT_TABLE' SELECT @sql_select
SELECT . . ., COUNT(PO_Line.propA) OVER (PARTITION BY PO.ID) as LINES FROM PO LEFT JOIN PO_Lines ON PO.ID = PO_Lines.PO_ID;
Select * FROM ( Select *, CASE WHEN weekNo(Tableweeks) < week(TableX) THEN 1 ELSE 0 END 'Valid' from tableX CROSS APPLY Tableweeks ) WHERE Valid = 1
SELECT C.crsid, MAX(TC.score) as maxscore FROM Class C JOIN ClassSection CS on C.crsid = CS.crsid JOIN TookClass TC on TC.secid = CS.secid GROUP BY C.crsid order by maxscore desc;
SELECT a.city AS city FROM YOUR_TABLE a GROUP BY a.city HAVING COUNT(a.country) = 1 UNION ALL SELECT CONCAT(b.city, ', ', b.country) AS city FROM YOUR_TABLE b WHERE EXISTS (SELECT NULL FROM YOUR_TABLE c WHERE c.city = b.city GROUP BY c.city HAVING COUNT(c.country) > 1) ORDER BY city
SELECT CONNECT_BY_ROOT PART_NO as ROOT_PART_NO, LEVEL, PART_NO, COMPONENT_PART, QTY_PER_ASSEMBLY FROM MANUF_STRUCTURE CONNECT BY PRIOR COMPONENT_PART = PART_NO AND PRIOR CONTRACT = CONTRACT AND PRIOR BOM_TYPE_DB = BOM_TYPE_DB START WITH PART_NO IN ('&PN1', '&PN2', '&PN3') ORDER SIBLINGS BY LINE_ITEM_NO;
-- Retrieve maximum value of CustomerId DECLARE @maxid int = 0 SELECT @maxid = MAX(CustomerId) FROM Company.Customer -- When inserting data for column CustomerId add maximum id value and row number -- This should ensure that the key values do not clash INSERT INTO Company.Customer (CustomerId, FirstName, LastName) SELECT ROW_NUMBER() OVER (ORDER BY CustomerId ASC) + @maxid, FirstName, LastName FROM Company.Customer WHERE LastName LIKE '%JONES%';
select * from YourTable where charindex(' 18,', ' ' + AllowedSystems + ',') <> 0
SUBSTR (text, INSTR(text,'/Library/Caches/')+16)
SHOW CREATE TABLE Courses
SELECT origin, destination FROM mytable GROUP BY origin, destination HAVING COUNT(*) > 1
create table t1 (col1 number, col2 number, col1_col2_least generated always as (least(col1, col2)), col1_col2_greatest generated always as (greatest(col1, col2))); --not strictly necessary alter table t1 add constraint t1_u1 unique (col1, col2); alter table t1 add constraint t1_u2 unique (col1_col2_least, col1_col2_greatest); insert into t1 (col1, col2) values (1, 2); insert into t1 (col1, col2) values (2, 1); -- ORA-00001: unique constraint (SCHEMA.T1_U2) violated insert into t1 (col1, col2) values (2, 2);
SELECT FIELD_1, FIELD_2... FIELD_N, SUM(AMOUNT), (case when field_1 <> lag(field_1) over (order by FIELD_1, FIELD_2... FIELD_N) or lag(field_1) over (order by FIELD_1, FIELD_2... FIELD_N) is null then 'field_1' when field_2 <> lag(field_2) over (order by FIELD_1, FIELD_2... FIELD_N) then 'field_2' . . . else 'field_n' end) as WhichGrouping FROM TABLE GROUP BY FIELD_1, FIELD_2... FIELD_N ORDER BY FIELD_1, FIELD_2... FIELD_N
DATE_ADD(DATE_FORMAT(now(), "%Y-%m-%d %H:%i:00"), INTERVAL (30 + (IF(SECOND(now() > 29, 1, 0))) MINUTE)
DECLARE @var VARCHAR(MAX) = 'foo' SELECT *, (LEN(TextColumn) - LEN(REPLACE(TextColumn, @var, ''))) / LEN(@var) FROM tbl WHERE CHARINDEX(@var, TextColumn) > 0 ORDER BY (LEN(TextColumn) - LEN(REPLACE(TextColumn, @var, ''))) / LEN(@var) DESC
select sum(a.costoimp*movstocktotal.stock) FROM vsboremix.dbo.CompraLinea AS a INNER JOIN (SELECT compralinea.IdArticulo, MAX(compralinea.IdDocumento) AS iddocumento, IdListaEmpresa FROM vsboremix.dbo.Compralinea join vsboremix.dbo.documento on CompraLinea.IdDocumento = documento.IdDocumento join VsBoremix.dbo.articulo on compralinea.IdArticulo=articulo.IdArticulo where IdDeposito in(30,38,40,44,50,60,70,90,100) and compralinea.CostoImp>0.0 and idseccion=101 GROUP BY compralinea.IdArticulo, IdListaEmpresa) AS b ON b.IdArticulo = a.IdArticulo AND b.iddocumento = a.IdDocumento join vsboremix.dbo.movstocktotal on a.IdArticulo = MovStockTotal.IdArticulo and b.IdListaEmpresa=MovStockTotal.IdEmpresa
select * from ( (select * from observations where category = 'C' order by random() limit 243369* 0.1) union (select * from observations where category <> 'C') ) sub order by random() limit 1;
SELECT ID, Type, SubType, Percentage, Category FROM one UNION SELECT DISTINCT 0, t2.Type, t2.SubType, 0.00, t1.Category FROM one t1 INNER JOIN two t2 ON t2.Type = t1.Type AND t2.SubType NOT IN (SELECT t3.SubType FROM one t3 WHERE t3.Category = t1.Category and t3.Type = t1.Type) ORDER BY Category, Type, SubType
CHARACTERSET UTF8
psql -h hostname -p port_number -U username -f your_file.sql databasename
SELECT [item], [Prox], [z], coalesce([item], '') + coalesce([Prox], '') + coalesce([z], '') as result FROM [FIELD$];
select stdcode, group_concat(value separator ';') as values from table1 group by stdcode;
SQL> create table t( col1 varchar2(3) ); Table created. SQL> create sequence t_seq; Sequence created. SQL> ed Wrote file afiedt.buf 1 insert into t 2 select to_char( t_seq.nextval, 'fm009' ) 3 from dual 4* connect by level <= 10 SQL> / 10 rows created. SQL> select * from t; COL --- 004 005 006 007 008 009 010 011 012 013 10 rows selected.
select i.* from Instructor i where exists (select 1 from CourseInstructor ci join Course c on c.CourseId = ci.CourseId where ci.InstructorId = i.InstructorId and c.DepartmentId = @p0 );
select ROUTINE_NAME from information_schema.routines where DATEDIFF(CURDATE(),created) < 14
function combination(n in integer, k in integer) return integer is l_result integer; begin for i in 1..k loop l_result := l_result * (n-i+1) / k; end loop; return l_result; end; /
SELECT 100 * SUM( CASE WHEN (maint_fault_date + 5) < maint_action_date THEN 1 ELSE 0 END ) / COUNT(*) AS percentage FROM mainthistory;
SELECT name from products p WHERE backorder IS NULL OR backorder <> 2
from google.appengine.ext import ndb class User(ndb.Model): email = db.StringProperty() options = ndb.QueryOptions(keys_only=True) condition_1 = ndb.Query(User, options=options).filter(User.email == "mom@home.com") condition_1 = ndb.Query(User, options=options).filter(User.email == "dad@home.com") key_list = list(set(list(condition_1) + list(condition_2))) mom_and_dad = ndb.get_multi(key_list)
SELECT date, number, ROW_NUMBER() OVER(PARTITION BY date, number ORDER BY number DESC) AS index FROM myTable;
SELECT d.* FROM rule CROSS APPLY ( SELECT id, email FROM a WHERE a.id = rule.id UNION ALL SELECT id, email FROM b WHERE b.id = rule.id UNION ALL SELECT id, email FROM c WHERE c.id = rule.id ) d
select family.* from table as member join table as familiy on member.ParentID = family.ParentID where member.ItemID = 'firstGUID'
select idCust, Name, sum(quantity * unitPrice) as TotalPurchase, sum(case when sku = 1344 then quantity * unitPrice end) as TotalPurchase_1344 from table t where date >= '2014-06-01' and date < '2014-07-01' group by idCust, Name;
select A,B from ( select row_number() over(partition by A order by C desc)rn,A,B,C from yourtable ) where RN=1
SELECT Tbl_member.member_id, Sum(points_earned) - Sum(points_redeemed) Remaining_points FROM Tbl_member JOIN Tbl_member_participation ON tbl_member_participation.member_id = Tbl_member.member_id JOIN Tbl_member_redemption ON tbl_member_redemption.member_id = Tbl_member.member_id GROUP BY Tbl_member.member_id, Datepart(mm, datecol), Datepart(yyyy, datecol)
SELECT t1.name, t2.x, t2.y, t2.z FROM TABLENAME t1 JOIN TABLENAME t2 on t1.id = t2.refer
SELECT DISTINCT ON (book_container_id) isbn, book_container_id, shelf_id, update_time FROM bookshelf_configuration WHERE isbn = 555 AND update_time <= '2015-12-01 07:00' -- ISO 8601 format ORDER BY book_container_id, update_time DESC;
with s as ( select * from customers inner join orders using (custid) inner join itemsordered using (orderid) inner join items using (itemid) ) select distinct least(s1.name, s2.name), greatest(s1.name, s2.name) from s s1 inner join s s2 on s1.description = s2.description and s1.custid < s2.custid order by 1, 2
pg_restore -O dump_file | fix_latin | psql -d database
SELECT * FROM comments ORDER BY IF(ParentId = 0, Id, ParentId), ParentId!=0, Id desc
SELECT [SITE ID], [Parameter], Min(Results) As MinOfResults, Max(Results) As MaxOfResults, Avg(Results) As AvgOfResults, StDev(Results) As StDevOfResults, Count(Results) As CountOfResults FROM Chemistry1 WHERE [SITE ID] = 'LB-100' AND [Parameter] = 'Calcium, Dissolved' AND Year([SampleDate]) = 2014 GROUP BY [SITE ID], [Parameter]
public List<TaskClass> getAllTasks() { List<TaskClass> tasks = new ArrayList<TaskClass>(); Cursor cursor = db.query(tb_Name, null, null, null, null, null, "id asc"); Log.d(TAG, "Getting tasks: " + cursor.getCount()); while (cursor.moveToNext()) { TaskClass task = new TaskClass(); task.setId(cursor.getLong(0)); task.setTitle(cursor.getString(1)); // Populate rest of fields accordingly tasks.add(task); } Log.d(TAG, "Returning tasks: " + tasks); return tasks; }
SELECT a,b,c, SUM(d) AS d, SUM(e) AS e FROM tableT WHERE (SELECT COUNT(*) FROM tableT) <= 3 GROUP BY a,b,c UNION ALL SELECT a,b,c,d,e FROM tableT WHERE (SELECT COUNT(*) FROM tableT) > 3 ;
SELECT t1.Name, t2.Name FROM mytable AS t1 INNER JOIN mytable AS t2 ON t1.Name < t2.Name ORDER BY t1.Name, t2.Name
select emp_id, work_date from ( select emp_id, work_date, min(element) min_element, max(element) max_element, count(*) rows_counted from mytable where work_date = :p_workdate group by emp_id, work_date having count (*) > 1) where rows_counted > 2 or (min_element,max_element) not in (select 'element1' el1, 'element2' el2 from dual union all select 'element3' el1, 'element4' el2 from dual)
INSERT INTO Temp_table (column1, column2, column3, column4) SELECT column1, column2, ISNULL(column3,0), ISNULL(column4,0) FROM TABLE1 WHERE someCondition UNION ALL SELECT ISNULL(column1,0), ISNULL(column2,0), column3, column4 FROM TABLE1 WHERE someOtherCondition
select * from tab qualify row_number() over (partition by id order by date) = 1
;WITH Q1 AS ( SELECT pvt.probcat ,pvt.probdesc ,ISNULL(pvt.[Dev], 0) AS 'Dev' ,ISNULL(pvt.[QA], 0) AS 'QA' ,ISNULL(pvt.[Prod], 0) AS 'Prod' FROM ( SELECT pc.probcat ,pc.probdesc ,ps.noofproblems ,ps.stage FROM Probcat pc LEFT JOIN ProbSummary ps ON pc.probcat = ps.probcat ) t PIVOT(max(noofproblems) FOR stage IN ( [Dev] ,[QA] ,[Prod] )) pvt ), q2 as (SELECT q1.* ,sum(q1.Dev + q1.QA + q1.Prod) AS Total FROM q1 GROUP BY q1.probcat ,q1.probdesc ,q1.Dev ,q1.QA ,q1.Prod ) select q2.probcat ,q2.probdesc ,q2.Dev ,q2.QA ,q2.Prod ,cast(q2.Total as varchar(10)) + ' (' + cast(cast((cast(q2.Total as decimal(5,2))/cast(d.CrossSum as decimal(5,2)))*100 as decimal(5,2)) as varchar(10)) + '% )' as FinalTotal from q2 CROSS APPLY ( SELECT sum(q1.Dev + q1.QA + q1.Prod) AS CrossSum FROM q1 ) d ORDER BY q2.probcat
SELECT ASSETNAME,PROJECT,MIN(T.MIN)START_DAY,MAX(T.MAX) END_DAY, DATEDIFF(DD,MIN(t.min) ,MAX(T.MAX)) DURATION FROM ( SELECT ASSETNAME,PROJECT,DATEADD(DD,MIN(WEEK),WEEKBEGINNING) 'MIN',DATEADD(DD,MAX(WEEK),WEEKBEGINNING) 'MAX' FROM #TEMP T CROSS APPLY(SELECT 0 'WEEK' WHERE T.MONDAY=1 UNION ALL SELECT 1 WHERE T.TUESDAY=1 UNION ALL SELECT 2 WHERE T.WEDNESDAY=1 UNION ALL SELECT 3 WHERE T.THURSDAY=1 UNION ALL SELECT 4 WHERE T.FRIDAY=1 UNION ALL SELECT 5 WHERE T.SATURDAY=1 UNION ALL SELECT 6 WHERE T.SUNDAY=1 ) D GROUP BY ASSETNAME,PROJECT,WEEKBEGINNING )T
ColorPref ColorPrefQuestion Rating RatingQuestion
CREATE TABLE Recipes ( id int, name text, PRIMARY KEY (`id`) ); CREATE TABLE Ingredients( id int, name text, PRIMARY KEY (`id`) ); CREATE TABLE Recipes2Ingredients ( rec_id int, ing_id int, amount int, -- and maybe some other needed fields FOREIGN KEY (rec_id) REFERENCES Recipes(id), FOREIGN KEY (ing_id) REFERENCES Ingredients(id) );
SELECT * FROM StaffHours WHERE (SiteID = '164') AND (ID IN (SELECT Min(ID) FROM StaffHours WHERE (SiteID = '164') GROUP BY RecordID HAVING (COUNT(RecordID) > 1))) ORDER BY RecordID DESC
SELECT SUBSTRING( string , LEN(string) - CHARINDEX('/',REVERSE(string)) + 2 , LEN(string) ) FROM SAMPLE;
SELECT DATE_SUB( LAST_DAY( DATE_ADD(NOW(), INTERVAL 1 MONTH) ), INTERVAL DAY( LAST_DAY( DATE_ADD(NOW(), INTERVAL 1 MONTH) ) )-1 DAY ) AS firstOfNextMonth, LAST_DAY( DATE_ADD(NOW(), INTERVAL 1 MONTH) )AS lastOfNextMonth
select * from ( SELECT i.BOOK_ID , i.in_out , i.event_date AS in_time , LOCATION in_location , lag(event_date) over (partition by book_id order by event_date) out_date , lag(location) over (partition by book_id order by event_date) out_location FROM TRANSACTIONS i ORDER BY i.event_date) where in_out = 'I' and in_location != out_location;
select * from tablename where (flag & 64) = 64
select case when charindex(' ', member_name) > 0 then SUBSTRING(member_name, charindex('/', member_name) + 1, charindex(' ', member_name) - charindex('/', member_name)) when charindex(' ', member_name) < 1 then SUBSTRING(member_name, charindex('/', member_name) + 1, len(member_name) - charindex('/', member_name)) end as FIRST_NAME, left(member_name, charindex('/', member_name) - 1) + ' ' as last_name from member
select to_char(to_date(TMS,'YYYY-MM-DD')+3,'YYYY-MM-DD') from city;
SELECT dates.TheDate, count(recordID) FROM ( select convert(date,dateadd(d,number,'2013-08-12')) as theDate from master..spt_values where type='p' and number < 9 ) dates left join yourtable on dates.thedate = convert(date,yourtable.thedate) GROUP BY dates.TheDate
SELECT count(*) AS Cnt ,COALESCE(users.country, 'unknown') AS Country FROM sessions LEFT JOIN users ON sessions.username=users.username GROUP BY users.country;
select player_id, sum(total) total from ( select winner_id player_id, count(*) total from results group by winner_id union all select loser_id, count(*) from results group by loser_id ) s group by player_id order by total desc
SELECT site_id, MAX(download_date) AS download_date, count(*) FROM pages_urls GROUP BY site_id;
SELECT p.id, p.name, p.image, p.stock FROM Combine as c inner join Product as p on (c.item1=p.id or c.item2=p.id or c.item3=p.id) Where id = ###
<dg:DataGrid.ItemContainerStyle> <Style TargetType="{x:Type dg:DataGridRow}" BasedOn="{StaticResource {x:Type dg:DataGridRow}}"> <Setter Property="Background" Value="{Binding ItemColour}" /> </Style> </dg:DataGrid.ItemContainerStyle>
set rowcount 1 select * from data order by timestamp desc
select IDs.ID, ifnull(count(globals_lists.global_id),0) as group_count from (select 3 as ID UNION select 4 UNION select 5 UNION select 6) as IDs left join globals_lists on IDs.ID = globals_lists.global_id group by IDs.ID order by group_count desc;
SELECT OBJECT_NAME(object_id) FROM sys.sql_modules WHERE definition LIKE '%MyTable%'
ContentResolver cr = getContentResolver(); Cursor cur = cr.query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null); if (cur.getCount() > 0) { while (cur.moveToNext()) { String id = cur.getString(cur.getColumnIndex(ContactsContract.Contacts._ID)); String name = cur.getString(cur.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)); if (Integer.parseInt(cur.getString( cur.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) { Cursor pCur = cr.query( ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID +" = ?", new String[]{id}, null); while (pCur.moveToNext()) { String phoneNo = pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)); Log.e("TAG","Name :: "+Name); Log.e("TAG","Phone no :: "+phoneNo); } pCur.close(); } } }
select sum(case when category = 'value_a' then 1 else 0 end) as group_a, sum(case when category = 'value_b' then 1 else 0 end) as group_b from tbl where category in ('value_a', 'value_b')
;With T As ( SELECT 7 AirQuoteID,'M' Name,49.50 SalesValue UNION ALL SELECT 7 AirQuoteID,'N', 23.10 UNION ALL SELECT 7 AirQuoteID,'+45',233.20 UNION ALL SELECT 7 AirQuoteID,'+100',233.20 UNION ALL SELECT 7 AirQuoteID,'+250',2333.10 ) SELECT AirQuoteID, [M], [N], [+45], [+100], [+250] FROM T PIVOT ( MAX(SalesValue) FOR Name IN ([M], [N], [+45], [+100], [+250]) ) AS pvt;
C = Check Constraint D = Default or Default Constraint F = Foreign Key Constraint L = Log Fn = Scalar Function If = Inlined Table Function P = Stored Procedure Pk = Primary Key Constraint Rf = Replication Filter Stored Procedure S = System Table Tf = Table Function Tr = Trigger U = User Table Uq = Unique Constraint V = View SELECT DISTINCT SysObjects.Name 'Table Name', Procedures.Name 'Stored Procedure' FROM SysObjects JOIN (SysObjects Procedures JOIN SysDepends ON Procedures.Id = SysDepends.Id) ON SysDepends.DepId = SysObjects.Id WHERE SysObjects.XType = 'U' -- Change XType Values here using chart above AND Procedures.XType = 'P' GROUP BY SysObjects.Name, SysObjects.Id, Procedures.Name ORDER BY SysObjects.Name ASC
select t1.* from my_table t1 join (select serialno, max(Last_seen) Last_seen from my_table group by serialno) t2 on t1.serialno = t2.serialno and t1.Last_seen = t2.Last_seen order by t1.Last_seen desc
Declare @myDate Datetime Set @myDate = dateadd(HOUR, 5, getdate()) SELECT Left(Convert(varchar(10),@myDate,21),10) + stuff(right(convert(varchar(26), @myDate, 109 ), 15 ), 7, 7, ' ')
SELECT TOP 1 id FROM table WHERE date = '2010-01-01' ORDER BY value DESC
select case when Dr.DrugNDCType = 49 then Dr.DrugNDCNbr else stuff ( Dr.DrugNDCNbr, case when Dr.DrugNDCType in (50, 56) then 1 when Dr.DrugNDCType in (51, 57) then 6 when Dr.DrugNDCType = 52 then 10 end, 0, '0') end from drug Dr where Dr.drugnbrkey = 6284
SELECT TableOne.ID, TableOne_1.Name, TableOne_2.Address FROM (TableOne LEFT JOIN TableOne AS TableOne_1 ON TableOne.ID = TableOne_1.ID) LEFT JOIN TableOne AS TableOne_2 ON TableOne.ID = TableOne_2.ID GROUP BY TableOne.ID, TableOne_1.Name, TableOne_2.Address HAVING TableOne_1.Name Is Not Null AND TableOne_2.Address Is Not Null;
SELECT U.NetworkIdentifier, U.FirstName, U.LastName, H.HardwareName, H.SerialNumber FROM (SELECT UserID, MAX(AssignedOn) LastAssignment FROM HardwareAssignments GROUP BY UserID) AS T JOIN HardwareAssignments AS HA ON HA.UserId = T.UserID AND HA.AssignedOn = T.LastAssignment JOIN Users AS U ON U.ID = HA.UserID JOIN Hardware AS H ON H.ID = HA.HardwareID ORDER BY U.NetworkIdentifier;
field LIKE 'Hash.System.Data.DataSet has(%).ds'
SELECT tblCounty.ID, ISNULL(tblAddress.Code, 'none') --Whatever you want to select FROM tblCounty LEFT JOIN tblCode ON tblCounty.Name = tblCode.Name LEFT JOIN tblAddres ON ISNULL(tblCode.Code, 'none') = ISNULL(tblAddress.Code, 'none')
Select id , Sum(Case when Type='Link' then 1 else 0 end) as Links , Sum(Case when Type='Forms' then 1 else 0 end) as Forms , Sum(Case when Type='Page' then 1 else 0 end) as Pages From SomeTable Group by ID
from table1 inner join table2 on table1.x = table2.y and table1.a = table2.b
select FromUser, ToUser, Message, [Date], UserId, UserFullName, UserName, UserPhoto from (SELECT CM.FromUser, CM.ToUser, CM.Message, CM.Date, U.UserId, U.UserFullName, U.UserName, U.UserPhoto, row_number() over (partition by CM.FromUser, CM.ToUser order by [Date] desc) as seqnum FROM ConversationMessages CM INNER JOIN Users U ON U.UserName = CM.FromUser WHERE CM.ToUser = @user ) s WHERE seqnum = 1 ORDER BY CM.Date DESC ;
create table test2 ( rowid varchar(10), id varchar(20), person_id varchar(20), item_name varchar(20), value varchar(20)); insert into test2 (rowid,id, person_id,item_name,value) values ('1','1','1','first item','first value'); insert into test2 (rowid,id, person_id,item_name,value) values ('2','1','1','first item','first value'); commit; SELECT item_name,Count(*) FROM test2 GROUP BY person_id, item_name; DELETE FROM Test2 WHERE rowid NOT IN (SELECT * FROM (SELECT MAX(n.rowid) FROM test2 n GROUP BY n.person_id, n.item_name) x); SELECT item_name,Count(*) FROM test2 GROUP BY person_id, item_name;
SELECT x.client_id, x.project_id, x.project_name FROM (SELECT t.client_id, t.project_id, t.project_name, CASE WHEN @client_id != t.client_id THEN @rownum := 0 WHEN @client_id = t.client_id THEN @rownum := @rownum + 1 ELSE @rownum END AS rank, @client_id := t.client_id FROM TABLE t, (SELECT @rownum := 0, @client_id ORDER BY t.client_id) r) x ORDER BY x.rank, x.client_id
SELECT D.Username, SUM(CASE WHEN D.type = 'Yes' THEN 1 ELSE 0 END) AS Yes, SUM(CASE WHEN D.type = 'No' THEN 1 ELSE 0 END) AS No, SUM(CASE WHEN S.mobile IS NULL THEN 0 ELSE 1 END) AS MatchSales FROM dairy AS D LEFT JOIN (SELECT DISTINCT mobile FROM sales) AS S ON D.MobileNo = S.mobile WHERE D.source = 'Company' AND UNIX_TIMESTAMP(D.CheckDate) >= $From_timestamp AND UNIX_TIMTIMESTAMP(D.CheckDate) <= $To_timestamp GROUP BY D.Username
FileReader file = new FileReader(fileName); BufferedReader buffer = new BufferedReader(file); String line = ""; String tableName ="TABLE_NAME"; String columns = "_id, name, dt1, dt2, dt3"; String str1 = "INSERT INTO " + tableName + " (" + columns + ") values("; String str2 = ");"; db.beginTransaction(); while ((line = buffer.readLine()) != null) { StringBuilder sb = new StringBuilder(str1); String[] str = line.split(","); sb.append("'" + str[0] + "',"); sb.append(str[1] + "',"); sb.append(str[2] + "',"); sb.append(str[3] + "'"); sb.append(str[4] + "'"); sb.append(str2); db.execSQL(sb.toString()); } db.setTransactionSuccessful(); db.endTransaction();
010 009 1
SELECT `Part Name` FROM Parts p INNER JOIN OrderDetails o ON p.PartID = o.PartID WHERE o.OrderDetailsID = ...;
create function [dbo].[getCloaks] ( @String varchar(8000) ) returns @tbl table (s varchar(1000)) as begin declare @i int, @j int, @k int select @i = 1 while charindex('{cloak:id=', @String, @i) > 0 begin select @j = charindex('{cloak:id=', @String, @i) select @k = charindex('}', @String, @j) insert @tbl select substring(@String, @j + 10, @k - @j - 10) select @i = @k + 1 end return end
WITH cte AS (SELECT menuld, menutitle, parentmenuld FROM Yourtable WHERE menuld = 1601120013 UNION ALL SELECT t.menuld, t.menutitle, t.parentmenuld FROM cte c INNER JOIN Yourtable t ON t.menuld = c.parentmenuld) SELECT * FROM cte
select [date], sum( case when type = 'Electronics' then (ordersize) else 0 end) AS ElectronicsSum, sum( case when type = 'Electronics' then 1 else 0 end) AS ElectronicsCount, sum( case when type = 'Books' then (ordersize) else 0 end) AS BooksSum, sum( case when type = 'Books' then 1 else 0 end) AS BooksCoumt from orders group by [date]
where Txndate like '%' + CONVERT(VARCHAR(12), GETDATE(), 107) + '%'
select AgeGroup , count(*) from ( select case when age between 13 and 17 then 1 when age between 18 and 21 then 2 ... end as AgeGroup from ( SELECT ROUND(DATEDIFF(Cast(NOW() as Date), Cast(birthday as Date)) / 365, 0) as age FROM YourTable ) as SubQueryAlias ) as SubQueryAlias2 group by AgeGroup
and rownum = 1
SELECT Person, Sum(GiftAmount) FROM tblGifts WHERE Person NOT IN ( SELECT Person FROM tblGifts WHERE GiftDate > [Forms]![InputForm]![EndDate] OR GiftDate < [Forms]![InputForm]![StartDate] ) GROUP BY Person
IF EXISTS (SELECT ActiveStatus From TableName where ActiveStatus = 0) SELECT 'False' ELSE SELECT 'True' AS OutputColumn
SELECT OrderID,OrderDate, DATEADD(DAY,2,OrderDate) as ApproxShipDate, DATEDIFF(DAY,OrderDate,DATEADD(DAY,2,OrderDate)) as DaysToShip FROM Orders WHERE YEAR(OrderDate) = 2012 AND MONTH(OrderDate) = 3
select score, max(case when type = 'satisfaction' then count end) as satisfaction_count, max(case when type = 'response' then count end) as response_count, max(case when type = 'responder' then count end) as responder_count, max(case when type = 'service' then count end) as service_count from ( select satisfaction_score as score, count(satisfaction_score) as count, 'satisfaction' as type from j_survey_response where satisfaction_score != 0 group by satisfaction_score union all select response_score, count(response_score) as count, 'response' as type from j_survey_response where response_score != 0 group by response_score union all select responder_score, count(responder_score) as count, 'responder' as type from j_survey_response where responder_score != 0 group by responder_score union all select service_score, count(service_score) as count, 'service' as type from j_survey_response where service_score != 0 group by service_score) as t group by score
SELECT id2 , SUM(updated) as updates ,MAX(updated_on) as last_update FROM table1 GROUP BY id2 ORDER BY last_update DESC
DELETE FROM table1 WHERE exists( SELECT 1 FROM table2 WHERE table2.stn = table1.stn and table2.jaar = year(table1.datum) )
with userCTE as ( select u.userId , c.columnId from tblUsers as u cross join tblColumns as c ) select u.* , Coalesce(cd.ColumnDatacontent, 'N/A') AS columnDataContent from userCTE as u left join tblColumnData as cd on u.columnId = cd.columnId and u.userID = cd.userId
SELECT z.id, MAX(z.col) FROM (SELECT x.id, x.column1 AS col FROM TABLE x UNION SELECT y.id, y.column2 FROM TABLE y) z GROUP BY z.id
LIKE '%\%%' ESCAPE '\'
SELECT T.user_id, U.username, T.score, T.time FROM tests_1 T JOIN users U on U.user_id = T.user_id WHERE T.score = ( SELECT MAX(T2.score) FROM tests_1 T2 WHERE T2.user_id = T.user_id ) ORDER BY T.score DESC, T.time ASC;
SELECT MAX(Case When B.ValueOrdinal='1' Then B.Displayvalue end) as Account, MAX(case when B.ValueOrdinal='2' then B.Displayvalue end) as Department, MAX(case when B.ValueOrdinal='3' then B.Displayvalue end) as Misc, A.Text, Sum(A.reportingcurrencyamount) as PostedAmount, A.Recid From GeneralJournalAccountEntry A Inner Join DimensionAttributeLevelValueAllView B on A.Ledgerdimension = B.ValueCombinationRecID Inner Join DIMENSIONATTRIBUTEVALUECOMBINATION C on A.Ledgerdimension = C.RecID Where C.accountstructure in ('5637145326','5637165585') Group by A.Recid, A.Text;
ALTER TRIGGER [dbo].[trigger_insertInStatus] ON [dbo].[DeviceStatus] AFTER INSERT AS BEGIN --Update Records where DeviceIP does exist in GeneralStatus UPDATE GS SET GS.ServiceStatus = I.ServiceStatus FROM GeneralStatus GS INNER JOIN Inserted I ON GS.DeviceIP = I.DeviceIP -- Insert statements for trigger here: -- Insert records where DeviceIP does not exist in GeneralStatus INSERT INTO GeneralStatus ( DeviceIP,ServiceStatus ) SELECT DeviceIP , ServiceStatus FROM INSERTED I LEFT JOIN GeneralStatus GS ON GS.DeviceIP = I.DeviceIP WHERE GS.DeviceIP IS NULL; END
SELECT C.names FROM C INNER JOIN B ON C.B_ID = B.B_ID INNER JOIN A ON B.A_ID = A.A_ID WHERE A.A_ID = 3
SQL> DECLARE 2 CURSOR c IS SELECT 1 FROM DUAL; 3 BEGIN 4 NULL; 5 END; 6 / PL/SQL procedure successfully completed.
SELECT IFNULL(var1, 0) + IFNULL(var2, 0) FROM test
This works in oracle select a.* from route a start with a.rowid = (select min(rowid) from route ) connect by prior a.t = a.f;
DECLARE @std_y FLOAT, @std_x1 FLOAT, @std_x2 FLOAT SELECT @std_y = SUM(W*Y), @std_x1 = SUM(W*X1), @std_x2 = SUM(W*X2) FROM dbo.My_Table UPDATE dbo.My_Table SET Y = SQRT(W) * (Y - @std_y), X1 = SQRT(W) * (X1 - @std_y), X2 = SQRT(W) * (X2 - @std_y) SELECT @std_y AS std_y, @std_x1 AS std_x1, @std_x2 AS std_x2
SELECT pl.email FROM gameday.player_settings pl WHERE NOT EXISTS ( SELECT 1 FROM unnest(?) AS wanted_tags(tag) LEFT JOIN admin.tags tags ON tags.tag = wanted_tags.tag WHERE tags.player_id = pl.id AND wanted_tags.tag IS NULL );
select t1.id, t1.name, t1.value, t2.id as id2, t2.name as name2, t2.value as value2 from (select t1.*, row_number() over (order by id) as seqnum from table_1 t1 ) t1 full outer join (select t2.*, row_number() over (order by id) as seqnum from table_2 t2 ) t2 on t1.seqnum = t2.seqnum;
SET foreign_key_checks = 'ON'
dte = InputBox("What date was the Data Dump run?", "Please Input a date (MMDDYYYY)") clientQry = "SELECT DISTINCT t.[CLIENT ID], t.[CLIENT NAME] " & _ "FROM FN_DataDump_ALL_" & dte & " as t WHERE " & _ " (((t.[CLIENT NAME]) Not Like ""*Test*"" ));"
SELECT CASE WHEN e.ELECT_BONUS_DFRL_SEQ_ID IS NULL OR MAX(e.ELECT_BONUS_DFRL_SEQ_ID) < 1 THEN 1 ELSE MAX(e.ELECT_BONUS_DFRL_SEQ_ID) + 1 END AS ELECT_BONUS_DFRL_SEQ_ID FROM ELECT_BONUS_DFRL AS e GROUP BY e.ELECT_BONUS_DFRL_SEQ_ID;
SET NOCOUNT ON; DECLARE @user_name SYSNAME , @login_name SYSNAME; SELECT @user_name = 'user_name', @login_name = 'login_name' SELECT ' USE ' + QUOTENAME(NAME) + '; CREATE USER ' + QUOTENAME(@user_name) + ' FOR LOGIN ' + QUOTENAME(@login_name) + ' WITH DEFAULT_SCHEMA=[dbo]; EXEC sys.sp_addrolemember ''db_datareader'', ''' + QUOTENAME(@user_name) + '''; EXEC sys.sp_addrolemember ''db_denydatawriter'', ''' + QUOTENAME(@user_name) + '''; GO ' FROM sys.databases WHERE database_id > 4 AND state_desc = 'ONLINE'
select t1.ID from Table t1 where EXISTS ( SELECT * FROM Table t2 WHERE t2.DefID = 1 AND t2.ValStr = 'hi' ) and t1.ValInt = 1
SELECT * FROM task_id AS taskid INNER JOIN task_in AS taskin ON taskid.id = taskin.id INNER JOIN customer AS cust ON taskin.id = cust.id WHERE id = YOUR_VALUE_HERE
Select T1.TicketNumber,T1.Rules_Count_1,T2.Rules_Count_2 FROM ( Select [TicketNumber], COUNT([TicketNumber]) AS Rules_Count_1 from [Table1] T1 group by TicketNumber) T1 INNER JOIN ( Select [TicketNumber], COUNT([TicketNumber]) AS Rules_Count_2 from [Table2] T2 group by TicketNumber ) T2 on T1.TicketNumber = T2.TicketNumber
$count = $query->count()->execute();
SELECT TRIM(SUBSTRING(tag, 1, (CHAR_LENGTH(tag) - LOCATE('(', REVERSE(tag))))) AS new_tag FROM table_name;
SUM(COALESCE(WOSE,0) +COALESCE(WO,0) + COALESCE(SSSE,0)+COALESCE(SS,0))
select AssetID from ( select distinct AssetID, KeywordID from AssetKeyword where KeywordID in (3,4,5) ) t group by AssetID having COUNT(*) = 3
DECLARE @Range AS INT = 7374 ;WITH E1(N) AS( -- 10 ^ 1 = 10 rows SELECT 1 FROM(VALUES (1),(1),(1),(1),(1),(1),(1),(1),(1),(1))t(N) ), E2(N) AS(SELECT 1 FROM E1 a CROSS JOIN E1 b), -- 10 ^ 2 = 100 rows E4(N) AS(SELECT 1 FROM E2 a CROSS JOIN E2 b), -- 10 ^ 4 = 10,000 rows E8(N) AS(SELECT 1 FROM E4 a CROSS JOIN E4 b), -- 10 ^ 8 = 10,000,000 rows CteTally(N) AS( SELECT TOP(@Range) ROW_NUMBER() OVER(ORDER BY(SELECT NULL)) FROM E8 ) SELECT * FROM CteTally
SELECT PersonID FROM FormsSubmitted WHERE [type]="A" AND [month]="June" AND PersonID NOT IN ( SELECT PersonID FROM FormsSubmitted WHERE [type]="B" AND [month]="August" )
Wishlist wishlist_id, user_id, ... WishlistEntry wishlist_id, book_id, ...
SELECT scores.id, scores.name,items.id,items.weight, scores.score * items.weight/t.sum_weight AS 'last_score' from scores INNER JOIN items ON items.id = scores.item_id INNER JOIN (SELECT scores.name, sum(items.weight) sum_weight FROM scores INNER JOIN items ON items.id = scores.item_id GROUP BY scores.name) t ON scores.name=t.name
Select ... From wp_posts As P Where Exists ( Select 1 From wp_posts As P1 Join wp_term_relationship As WTR1 On WTR1.object_id = P1.ID And WTR1.term_taxonomy_id In(3) Where P1.post_parent = P.Id And P1.post_type = 'attachment' ) And P.post_type = 'post' Order By p.post_date DESC Limit 15
SELECT UserSessionSequenceID, SessionGuid, UserSessionID, SiteID, Timestamp, UrlTitle, Url FROM ( SELECT Seq.UserSessionSequenceID, Usr.SessionGuid, Usr.UserSessionID, Usr.SiteID, Usr.Timestamp AS UsrTimestamp, Seq.Timestamp, Seq.UrlTitle, Seq.Url, ROW_NUMBER() OVER (PARTITION BY Usr.UserSessionID ORDER BY Seq.UserSessionSequenceID DESC) AS rn FROM tblUserSession Usr INNER JOIN tblUserSessionSequence Seq ON Usr.UserSessionID = Seq.UserSessionID WHERE (Usr.Timestamp > DATEADD(mi, -45, GETDATE())) AND (Usr.SiteID = 15) ) T1 WHERE rn = 1 ORDER BY UsrTimestamp DESC
SELECT COUNT(*) AS count_value FROM submissions s JOIN ( SELECT username, number, tstmp FROM submissions WHERE id = 1 ) o ON s.number = o.number AND s.username = o.username AND s.tstmp < o.tstmp
select pt.Schedid, pt.schedname, max(case when ct.citerianame = 'color' then ct.criteriavalue end) as Color, max(case when ct.citerianame = 'width' then ct.criteriavalue end) as Width, max(case when ct.citerianame = 'depth' then ct.criteriavalue end) as Depth from parenttbl pt inner join criteriatbl ct on pt.schedid = ct.schedid group by pt.schedid, pt.schedname;
insert into FINAL_TABLE (EVENT_ID, OID, LINE_NUMBER) ( select EVENT_ID,OID, ROW_NUMBER() OVER(PARTITION BY EVENT_ID ORDER BY OID) as LINE_NUMBER from source_table );
SELECT id, code FROM table GROUP BY id, code HAVING COUNT(code) > 1;
with vw1(val,flg,sumval) as (select 1 val,0 flg,TOT_COUNT sumval from TEMP where RESOURCE_VALUE = '1' union all select vw1.val + 1 val, case when vw1.sumval + t1.TOT_COUNT > 300 then vw1.flg + 1 else vw1.flg end flg, case when vw1.sumval + t1.TOT_COUNT > 300 then t1.TOT_COUNT else vw1.sumval + t1.TOT_COUNT end sumval From TEMP t1,vw1 WHERE t1.RESOURCE_VALUE = TO_CHAR(vw1.val + 1)) select min(val) START_RESOURCE_VALUE,max(val) END_RESOURCE_VALUE, max(sumval) "SUM" from vw1 group by flg order by min(val);
select case cast(month as number) when 1 then 'Jan' when 2 then 'Feb' when 3 then 'Mar' when 4 then 'Apr' when 5 then 'May' when 6 then 'Jun' when 7 then 'Jul' when 8 then 'Aug' when 9 then 'Sep' when 10 then 'Oct' when 11 then 'Nov' when 12 then 'Dec' end as mon from ods_calendar_weeks cal where cal.year not in (0, 9999);
DECLARE @dtstart DATETIME= '20150101' DECLARE @dtend DATETIME= '20151231' ;WITH CTE AS ( SELECT 1 as WeekNo, @dtstart weekstart,DATEADD(d,6-DATEPART(WEEKDAY,@dtstart),@dtstart) weekend UNION ALL SELECT CTE.WeekNo + 1 as WeekNo, DATEADD(d,1,CTE.weekend),CASE WHEN DATEADD(d,7,CTE.weekend) < @dtend THEN DATEADD(d,7,CTE.weekend) ELSE @dtend END FROM CTE WHERE DATEADD(d,1,CTE.weekend) < @dtend ) SELECT * FROM CTE;
create table i (i_dt date, i_val number); insert into i values (to_date('18/5/2010 1pm','dd/mm/yyyy hham'), 40); insert into i values (to_date('18/5/2010 2pm','dd/mm/yyyy hham'), 20); insert into i values (to_date('18/5/2010 3pm','dd/mm/yyyy hham'), 60); insert into i values (to_date('18/5/2010 4pm','dd/mm/yyyy hham'), 30); insert into i values (to_date('18/5/2010 5pm','dd/mm/yyyy hham'), 60); insert into i values (to_date('18/5/2010 6pm','dd/mm/yyyy hham'), 25 ); insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'), 300 ); insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'), 450 ); insert into i values (to_date('19/5/2010 6pm','dd/mm/yyyy hham'), 375 ); insert into i values (to_date('20/5/2010 6pm','dd/mm/yyyy hham'), 250 ); insert into i values (to_date('20/5/2010 6pm','dd/mm/yyyy hham'), 310 ); select i_dt, i_val from (select i.*, rank() over (partition by trunc(i_dt) order by i_val desc, i_dt asc) rn from i) where rn = 1;
DELETE FROM `table_name` WHERE `P2` < `P1`;
DELETE FROM Element WHERE Id IN ( SELECT Ele FROM Cluster AS T CROSS APPLY (VALUES (T.Ele1) , (T.Ele2) , (T.Ele3) ) AS X (Ele) WHERE T.Group= 1 )
SELECT PROD_ID, GEOG_ID, SUM(VALUE1) AS TOTAL FROM database WHERE GEOG_ID = 'MT' AND TIME_ID IN ('JAN', 'FEB') GROUP BY PROD_ID, GEOG_ID
SELECT mt.emp_id FROM my_table mt LEFT JOIN my_table mtx ON (mtx.emp_id = mt.emp_id AND (mtx.isapproved = 0 OR mtx.isvalid = 0)) WHERE mt.isapproved = 1 AND mt.isvalid = 1 AND mtx.id IS NULL GROUP BY mt.emp_id
SELECT Heading, A Package_A, B Package_B, C Package_C, D Package_D FROM ( SELECT * FROM YourTable ) up PIVOT (sum(Limit) FOR Package IN (A, B, C, D)) AS pvt
SELECT FIND_IN_SET('b','a,b,c,d');
WITH t AS (SELECT 'first path**second path' text FROM DUAL UNION SELECT 'third pathfourth path' text FROM DUAL) SELECT SUBSTR(REGEXP_SUBSTR(t.text,'(\*{2})(.+)'),3) FROM t
SELECT name CASE WHEN ' ' || name || ' ' LIKE '% N %' THEN 'Red' WHEN ' ' || name || ' ' LIKE '% B %' THEN 'White' WHEN ' ' || name || ' ' LIKE '% RS %' THEN 'Green' ELSE 'Other' END FROM mytable
ORDER BY CASE WHEN RQID <> '' THEN 1 ELSE 0 END, RQID, NEWID()
select year, month, fixes, fixes - lag(fixes) over (order by year, month) as increase, from the_table;
SELECT A.sifKorisnikPK, IsNull(BrojDobrih,0) BrojDobrih, IsNull(BrojLosih,0) BrojLosih FROM (select distinct sifKorisnikPK from Rezervacija) A LEFT JOIN #LosaRez B ON A.sifKorisnikPK = B.sifKorisnikPK LEFT JOIN #DobraRez C ON A.sifKorisnikPK = C.sifKorisnikPK ORDER BY (IsNull(BrojDobrih,0) - IsNull(BrojLosih,0))
SELECT userID, testID, MAX(someDate) FROM @tmp GROUP BY testId,userID;
SELECT IF(a > b, a, b) AS max_value FROM (SELECT MAX(up) AS a, MAX(down) AS b FROM table) x
select * from ( select 'Test 1' thename union select 'Test 2' union select 'Test 3' ) where thename not in (select name from foo)
SELECT u.id AS userId, u.name AS userName, g.id AS gradeId, g.name As grade FROM users AS u INNER JOIN grades AS g ON g.id = u.grade_id
SELECT C.* FROM Customer C INNER JOIN CustDetail CD ON C.CustomerId = CD.CustomerId INNER JOIN Address A ON CD.DetailID = A.DetailID LEFT OUTER JOIN Group G ON C.CustomerId = G.CustomerId LEFT OUTER JOIN GroupDetail D ON G.GroupId = D.DetailId WHERE ((G.Active = 1 AND C.code = 1) OR G.Active IS NULL) AND ((D.code = '1' AND C.code = 1) OR D.code IS NULL) AND C.Id = @customerId
declare @xml xml set @xml = N'<CodeFiveReport><Owner UnitNumber="Mixed"/></CodeFiveReport>' select T1.C1.value('upper-case((/CodeFiveReport/Owner/@UnitNumber)[1])', 'varchar(10)') from @xml.nodes('/') T1(C1) SET @xml.modify(' replace value of (/CodeFiveReport/Owner/@UnitNumber)[1] with xs:string(upper-case((/CodeFiveReport/Owner/@UnitNumber)[1])) ') select @xml
Select @originalTxt = @SqlTxt, @orgtxt=@SqlTxt Set @len=LEN(@orgtxt) While @len > 0 Begin Set @len=LEN(@orgtxt) Select @start=CHARINDEX('from',@orgtxt) Select @end=CHARINDEX('where',@orgtxt) If(@start != 0 and @end!=0) Begin set @split = Substring(@orgtxt, @start, @end-@start) Set @orgtxt = SUBSTRING(@orgtxt,@end + 5 ,@len-@end) Set @txt=@split Select @split=Replace(Replace(Replace(Convert(Varchar(Max),@split),'from ','from AB.'),'join ','join AB.') ,',',', AB.') Select @originalTxt=REPLACE(@originalTxt,@txt,@split) Set @txt=@originalTxt End Else Begin break End End If @txt is null Begin Select @txt=Replace(Replace(Convert(Varchar(Max),@originalTxt),'from ','from AB.'),'join ','join AB.') End return @txt
CREATE TABLE #TEMP(id int, name varchar(100)) INSERT INTO #TEMP VALUES(1, 'John') INSERT INTO #TEMP VALUES(1, 'Adam') INSERT INTO #TEMP VALUES(1, 'Robert') INSERT INTO #TEMP VALUES(1, 'Copper') INSERT INTO #TEMP VALUES(1, 'Jumbo') INSERT INTO #TEMP VALUES(2, 'Jill') INSERT INTO #TEMP VALUES(2, 'Rocky') INSERT INTO #TEMP VALUES(2, 'Jack') INSERT INTO #TEMP VALUES(2, 'Lisa') INSERT INTO #TEMP VALUES(3, 'Amy') SELECT * FROM #TEMP; WITH CTE(N) AS ( SELECT ROW_NUMBER() OVER(PARTITION BY id ORDER BY id) FROM #Temp ) DELETE CTE WHERE N>3; SELECT * FROM #TEMP; DROP TABLE #TEMP
INSERT INTO studies ( id ,name_string ,description ,field ,is_active ,register_start ,register_end ) SELECT nextval('studiesSequence') ,NAME ,'' ,3 ,0 ,register_start ,register_end FROM dblink('dbname=mydb', 'select name,begins,ends from study') AS t1(NAME VARCHAR(50), register_start DATE, register_end DATE);
DECLARE @input VARCHAR(10) = ' Person '; DECLARE @sql NVARCHAR(MAX) = ' SELECT count(*) AS [@Input Open Data] FROM #Accounts a JOIN dbo.FileFeed t On t.ID = a.AccountID GROUP BY a.accountid'; SET @sql = REPLACE(@sql, '@Input', @Input); exec sp_executesql @sql;
Dim query As String = "SELECT * FROM [Hiragana List] WHERE Pronunciation='" & character & "';"
SELECT a from Frais a where a.libelle = 'FRET' or a.libelle = 'Douane' or a.libelle = 'Transitaire' order by case a.libelle when 'FRET' then 0 when 'Douane' then 1 when 'Transitaire' then 2 end
FMResultSet *results = [db executeQueryWithFormat:@"SELECT * FROM allitems WHERE choice1='%@' AND choice2='%@' AND choice3='%@' AND choice4='%@'" ,capsChoiceOne,capsChoiceTwo,capsChoiceThree,capsChoiceFour];
SQL> select to_char(systimestamp, 'YYYY-MM-DD HH24:MI:SS.FF TZD') as d from dual; D ---------------------------------- 2008-10-21 17:00:43.501591
Select id, type from (SELECT id, GROUP_CONCAT(type SEPARATOR ',') AS type FROM rock_types GROUP BY id) a WHERE INSTR(type,"DWS")>0 OR INSTR(type,"Top rope")>0
SELECT "DATE", BUS, VALUE FROM {your_table} WHERE "DATE" >= trunc(sysdate) and "DATE" < trunc(sysdate+1)
SELECT name, surname, max(greatest(tbl_name.ora_rowscn, tbl_surname.ora_rowscn)) over () as max_rowscn FROM tbl_name, tbl_surname WHERE tbl_name.id = tbl_surname.id
SELECT table_schema, table_name FROM information_schema.columns WHERE COLUMN_NAME = 'Id' AND DATA_TYPE = 'uniqueidentifier' OR COLUMN_NAME = 'Message' AND DATA_TYPE = 'nvarchar' OR COLUMN_NAME = 'EnteredOn' AND DATA_TYPE = 'datetime' GROUP BY table_schema, table_name HAVING COUNT(COLUMN_NAME) = 3
SELECT saledateid, sum(sl.quantity * sl.unitamount), sum(case when seqnum = 1 then s.saleamount end) FROM sales s JOIN (SELECT sl.*, row_number() over (partition by saleid order by saleid) as seqnum FROM salelines sl ) sl USING (saleid) GROUP BY saledateid;
SELECT T.ID, T.Date, Lookback = COUNT(CASE WHEN t2.Date < T.Date THEN t2.ID END), Lookahead = COUNT(CASE WHEN t2.Date > T.Date THEN t2.ID END) FROM T INNER JOIN T t2 ON t2.ID = t.ID AND t2.Date >= DATEADD(MONTH, -6, T.Date) AND T2.Date < DATEADD(MONTH, 6, T.Date) GROUP BY T.ID, T.Date, T.KeyID;
content_type = models.ForeignKey(ContentType) object_id = models.PositiveIntegerField() content_object = generic.GenericForeignKey('content_type', 'object_id')
UPDATE second_table ST SET ST.id = FT.id FROM first_table FT WHERE ST.date BETWEEN FT.run_date + interval '4 hour' AND FT.run_date + interval '4 hour' + interval '1 day'
SELECT [Value] = T.c.value('.', 'varchar(30)') FROM (SELECT Cast(( '<s>' + Replace ((SELECT tag_id+',' FROM tbl_container_track FOR xml path('')), ',', '</s> <s>') + '</s>' ) AS XML)) AS Data CROSS APPLY Data.nodes('/s') T(c)
SELECT SUM(t1.total_time) FROM table1 as t1 INNER JOIN table2 as t2 ON t1.vehicle_id = t2.vehicle_id AND t2.feature_id = 2
USE master; GO DENY VIEW ANY DATABASE TO [newlogin]; GO USE yourDB; GO DROP USER newlogin; GO USE master; GO ALTER AUTHORIZATION ON DATABASE::yourDB TO [newlogin]; GO
explain select * from from cars;
LOAD DATA LOCAL INFILE 'c:/mytestfile.csv' INTO TABLE report.test FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"' LINES TERMINATED BY '\n' IGNORE 1 LINES (ONE, TWO)
;WITH TEMPTABLE AS( SELECT DATE_STAMP, ID, ROW_NUMBER() OVER( PARTITION BY ID ORDER BY DATE_STAMP ) AS ROWNUMBER, Count(ID) OVER(PARTITION BY Date_Stamp, ID) as countID FROM #temp) SELECT DATE_STAMP, ID, MAX(CASE WHEN ROWNUMBER = 1 THEN 1 ELSE 0 END )AS FIRST_ATTEMPT, MAX(CASE WHEN ROWNUMBER = 2 THEN 1 ELSE 0 END) AS SECOND_ATTEMPT, MAX(CASE WHEN ROWNUMBER = 3 THEN 1 ELSE 0 END) AS THIRD_ATTEMPT, MAX(countID) Total_Attempts FROM TEMPTABLE GROUP BY DATE_STAMP,ID
SQL> SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual; Enter value for 10: old 1: SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual new 1: SELECT 'HYPERLINK(".\"&"-00.PDF")' FROM dual 'HYPERLINK(".\"&"-00.PDF" ------------------------- HYPERLINK(".\"&"-00.PDF") SQL> SET DEFINE OFF SQL> SELECT 'HYPERLINK(".\"&10&"-00.PDF")' FROM dual; 'HYPERLINK(".\"&10&"-00.PDF" ---------------------------- HYPERLINK(".\"&10&"-00.PDF") SQL>
SELECT level, components.component_id, components.component_label, component_color.component_color FROM compenents JOIN component_color ON components.component = component_color.component START WITH components.component_label = 'Sample' CONNECT BY PRIOR components.component_id = components.component_parent_id
SELECT Item.Titel, Item.Uitgever, Game.PEGI, Game.EAN, convert(varchar, Item.DvU, 101) AS DatumVUitgave, Platform.Soort as Platform, Media.soort as Media, GameGenre.Genre AS Genre, -- here's your new column: case when Item.Status=1 then 'Uitgeleend' else 'Binnen' end as Status FROM Game LEFT JOIN ITEM ON Item.ID = Game.itemID LEFT JOIN Media ON Game.MediaID = Media.Id LEFT JOIN Platform ON Game.PlatformID = Platform.Id LEFT JOIN GameGenre ON Game.GameGenreID = GameGenre.Id
WITH Cte AS( SELECT dtt.*, dt.Data, Total = SUM(dt.Data) OVER(PARTITION BY dtt.Data_Type_ID), rn = ROW_NUMBER() OVER(PARTITION by dtt.Data_Type_ID ORDER BY dt.Date_Entered DESC) FROM Data_Type_Table dtt LEFT JOIN Data_Table dt ON dt.Data_Type_ID = dtt.Data_Type_ID ) SELECT Data_Type, Total = ISNULL(Total, 0), Most_Recent = ISNULL(Data, 0) FROM CTE WHERE rn = 1
SELECT m0.rowid AS r0, m1.rowid AS rn, m0.timestamp AS a, m1.timestamp AS b, m1.timestamp - m0.timestamp AS rd, m1.timetick - m0.timetick AS d FROM (SELECT rowid, -- This is the core query attaching to each row timestamp, -- the rowid of its next timetick, (SELECT rowid FROM measurements WHERE timestamp > m.timestamp ORDER BY timestamp LIMIT 1 ) AS r1 FROM Measurements AS m ) AS m0 JOIN measurements AS m1 ON m0.r1 = m1.rowid WHERE m1.timetick - m0.timetick < 0;
SELECT G.value('@GroupId', 'varchar(max)') FROM ( SELECT CAST(Document.data as XML) AS Goods FROM Documents as Document WHERE type = 1 ) T CROSS APPLY T.Goods.nodes('Document/Good') D(G) LEFT JOIN @Groups GS ON G.value('@GroupId', 'varchar(max)') = GS.groupId WHERE GS.groupId IS NULL
SELECT transactions.idCampaignsList SUM(amountOriginal) AS euro, SUM(amountFinal) AS deducted, EXTRACT(YEAR_MONTH FROM(dateTransaction)) AS period FROM transactions INNER JOIN campaignsList ON campaignsList.idCampaignsList = transactions.idCampaignsList INNER JOIN customers ON customers.idCustomer = campaignsList.idCustomer WHERE customers.idCustomer = 14 GROUP BY period, transactions.idCampaignsList ORDER BY period
select rownum, id, substr(']'||check_number||']' ,instr(']'||check_number||']',']',1,level)+1 ,instr(']'||check_number||']',']',1,level+1) - instr(']'||check_number||']',']',1,level) - 1) C1VALUE, substr(']'||amount||']' ,instr(']'||amount||']',']',1,level)+1 ,instr(']'||amount||']',']',1,level+1) - instr(']'||amount||']',']',1,level) - 1) C2VALUE from table connect by id = prior id and prior dbms_random.value is not null and level <= length(check_number) - length(replace(check_number,']')) + 1 ROWNUM ID C1VALUE C2VALUE 1 1 1001 200 2 1 1002 300 3 1 1003 100 4 2 2001 500 5 2 2002 1000 6 3 3002 100 7 3 3004 300 8 3 3005 600 9 3 3007 200
SELECT id, description, CASE WHEN _dateUpdate IS NULL THEN _dateEntry WHEN _dateUpdate > _dateEntry THEN dateUpdate ELSE _dateEntry END as date FROM mytable ORDER BY CASE WHEN _dateUpdate IS NULL THEN _dateEntry WHEN _dateUpdate > _dateEntry THEN dateUpdate ELSE _dateEntry END desc
SELECT DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE) AS WEEK_ENDING_DATE ,Year(DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)) AS [YEAR] ,(SUM(Value1) + SUM(Value2)) AS [Total1] ,(SUM(Value3) + SUM(Value4)) AS [Total2] ,((SUM(Value1) + SUM(Value2)) / (SUM(Value3) + SUM(Value4))) AS [Quote] FROM tbl WHERE DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE) BETWEEN DATEADD(dd, 7-(DATEPART(dw, FromDatePickerField)), FromDatePickerField) AND DATEADD(dd, 7-(DATEPART(dw, ToDatePickerField)), ToDatePickerField) and date >= FromDatePickerField and date <= ToDatePickerField GROUP BY DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE) ORDER BY DATEADD(dd, 7-(DATEPART(dw, DATE)), DATE)
SELECT Rnk, min(CASE WHEN Categ = 'A' THEN Nm END) as A, min(CASE WHEN Categ = 'B' THEN Nm END) as B, min(CASE WHEN Categ = 'C' THEN Nm END) as C FROM (select t.*, row_number() over (partition by categ, rnk order by newid()) as sub_rnk from Tbl t ) t GROUP BY rnk, sub_rnk ORDER BY rnk;
select * from Vehicle v where not exists ( select 1 from Booking where regNo = v.regNo and date_from <= '2015-04-05' and date_to >= '2015-03-25' )
SELECT Tanks.*, main.*, DT.MaxInspectionID, DT.MaxInspectionOrComplianceDate FROM (TankInspections main INNER JOIN Tanks ON Tanks.TankID = main.TankID) INNER JOIN ( SELECT [TankID], Max(InspectionID) As MaxInspectionID, Min([Planned Inspection Date]) As MinInspection, Max([Planned Inspection Date]) As MaxInspection, Min([Inspection Out of Compliance Date]) As MinCompliance, Max([Inspection Out of Compliance Date]) As MaxCompliance, Max(IIF(([Planned Inspection Date]) Is Null, IIF(ISNULL([Inspection Out of Compliance Date]), NULL, [Inspection Out of Compliance Date]), [Planned Inspection Date])) As MaxInspectionOrComplianceDate FROM TankInspections GROUP BY [TankID] ) As DT ON main.TankID = DT.TankID AND main.InspectionID = DT.MaxInspectionID;
<cfset form.filename = CFFILE.serverfile>
SELECT id, type, description FROM cars UNION SELECT id, type, description FROM planes UNION SELECT id, type, description FROM trains ORDER BY id, type
with todelete as ( select t.*, row_number() over (partition by Patientid, state, grp order by id) as seqnum from (select t.*, (row_number() over (partition by PatientId order by id) - row_number() over (partition by PatientId, state order by id) ) as grp from table t ) t ) delete from todelete where seqnum > 1;
Sub Whatever() connection.ConnectionString = "server=***01\SQLEXPRESS; database=Billing; integrated security=yes" connection.Open() Using da As New SqlDataAdapter("Select * FROM [Billing] ORDER BY Customer", connection) da.Fill(datatableMain) End Using connection.Close() ' get distinct customers Dim dv As New DataView(datatableMain) Dim distinctCustomers As DataTable = dv.ToTable(True, "Customer") For Each customer As DataRow In distinctCustomers.Rows ' this messagebox is only to give you an idea which customer you are printing ' not required in actual code. MessageBox.Show("Exporting Customer... " & customer("Customer").ToString) Dim customerRows() As DataRow = datatableMain.Select("Customer=" & customer("Customer").ToString) '<-- put single quotes around value if "Customer" field is of string type. e.g. "Customer='value'" For Each customerRow As DataRow In customerRows ' all the rows related to this customer are here ' do whatever you do to export Next Next End Sub
CREATE OR REPLACE FUNCTION get_join_date( in_emp_no) RETURN DATE IS v_join_DATE DATE; BEGIN SELECT MIN(JOINED_DATE) INTO v_join_DATE FROM employee WHERE employee_number = in_emp_no AND TYPE=in_type; return v_join_DATE; end
SELECT * FROM x_world as xr INNER JOIN ( SELECT x, MAX(population) FROM x_world as xr GROUP BY x ) as xt ON xt.x = xr.x GROUP BY village
SELECT t2.CustomerID, t1.`Quarter` FROM ( SELECT 1 AS `Quarter` UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 ) AS t1 CROSS JOIN ( SELECT DISTINCT CustomerID FROM salesorderheader ) AS t2 LEFT JOIN ( SELECT CustomerID, QUARTER(OrderDate) AS `Quarter` FROM salesorderheader ) AS t3 ON t2.CustomerID = t3.CustomerID AND t1.`Quarter` = t3.`Quarter` WHERE t3.`Quarter` IS NULL ORDER BY t2.CustomerID
SELECT c.name, COUNT(n.category) AS count_in_name_table FROM categories c LEFT JOIN name n ON n.category = c.name GROUP BY c.name
with t as ( select 'cab1' as c1, 'ae1' as e1 from dual union all select 'cab1' , 'ae2' from dual union all select 'cab1' , 'ae3' from dual union all select 'cab1' , 'ae4' from dual union all select 'cab3' , 'ae1' from dual union all select 'cab3' , 'ae1' from dual union all select 'cab2' , 'ae' from dual ) SELECT c1, e1, COUNT(*) OVER (partition by c1) as p1 FROM t GROUP BY c1, e1
select a, b, c, value from tab where tab.state = 'A' and not exists ( select 1 -- let the optimizer do its thing from tab ti where tab.state = 'B' and ti.a=tab.a and ti.b=tab.b and ti.c=tab.c)
ALTER PROCEDURE [dbo].[Provider] ( @strPro varchar(200) ) AS BEGIN -- SET NOCOUNT ON added to prevent extra result sets from -- interfering with SELECT statements. SET NOCOUNT ON; DECLARE @SQL varchar(2000) -- Insert statements for procedure here SET @SQL = 'SELECT * FROM [db1].[dbo].[table1] ' if @strPro <> 'All People' BEGIN SET @SQL = @SQL + ' WHERE [Name] = ''' + @strPro + ''' END EXEC (@SQL) END
select product_id, sum(quantity) As ProductQtySum from OrdersProducts group by product_id order by ProductQtySum Desc
UPDATE table_name SET column1 = value, column2 = value2 WHERE some_column = some_value
SELECT * FROM Items WHERE (@ItemsWithPriceTenDollarsOrMore = 1 AND Price >=10) OR (@ItemsWithPriceTenDollarsOrMore = 0 AND Price <10) OR (@ItemsWithPriceTenDollarsOrMore IS NULL)
UPDATE regm SET regm_pk = REGM_SEQ.nextval
CREATE TABLE PHONE_NUMBERS(PH_ID NUMBER(12), PHONE_NUMBER VARCHAR2(20)); CREATE OR replace TRIGGER trg_test_numbers BEFORE INSERT OR UPDATE ON phone_numbers FOR EACH ROW BEGIN IF Substr(:new.phone_number, 1, 2) = '1-' THEN :new.phone_number := Substr(:new.phone_number, 1, 9) || '-' || Substr(:new.phone_number, 10); END IF; END trg_test_numbers; insert into phone_numbers(ph_id, phone_number) VALUES(1,'1-210-5551212'); SELECT * from phone_numbers;
select a from tt where B in ( select B from tt group by b having count(*) >= 2);
SELECT c.city_name, pc.subcategory_id, IFNULL((select `count` from products_counter where city_id = c.city_id and subcategory_id = pc.subcategory_id),0) as 'Count' FROM cities c CROSS JOIN products_counter pc
DECLARE @due_date DATE, @difference varchar(50), @id INT, @Now datetime = (Select GetDate()); DECLARE myCursor CURSOR FORWARD_ONLY FOR SELECT [Engr Due], [Progress] FROM dbo.Employee_Table OPEN myCursor FETCH NEXT FROM myCursor INTO @due_date, @Progress WHILE @@FETCH_STATUS = 0 BEGIN if (@Progress != 'Completed') BEGIN SELECT @difference = DATEDIFF(day, @Now, @due_date) UPDATE Employee_Table SET [Remaining Days]=@difference WHERE CURRENT OF myCursor END FETCH NEXT FROM myCursor INTO @due_date, @Progress END CLOSE myCursor DEALLOCATE myCursor
mysql> SELECT GREATEST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00'); +-------------------------------------------------------------------+ | GREATEST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00') | +-------------------------------------------------------------------+ | 2041-11-13 | +-------------------------------------------------------------------+ 1 row in set (0.00 sec) mysql> SELECT LEAST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00'); +----------------------------------------------------------------+ | LEAST ('2015-01-01', '2041-11-13', '1844-05-30', '0000-00-00') | +----------------------------------------------------------------+ | 0000-00-00 | +----------------------------------------------------------------+ 1 row in set (0.00 sec)
SELECT Contact , Customers , (SELECT SUM(Customers) FROM myTable t2 WHERE t2.Contact >= t1.Contact) as CummCustomers FROM myTable t1
ORDER by MODULE_ID , case when COALESCE(fun.parent_function, fun2.function_id) is null then 1 else 0 end , FUNCTION_ID
proc sql; create table want as select ed, sum(smoke=1) as smoke1, sum(smoke=0) as smoke0 from sashelp.bweight group by ed order by ed; quit;
INSERT INTO table_1 (user_id, room_id, enter_date) VALUES (1,1, NOW()) ON DUPLICATE KEY UPDATE enter_date = NOW() // or INSERT IGNORE INTO table_1 (user_id, room_id) VALUES (1,1)
insert Brands (AccountID, BrandName, Description, etc...) select 99, BrandName, Description, etc... from Brands where AccountID = 88;
select u.* from (select u.unit_name, sum(hp + shield) as totalhealth, rank() over (order by sum(hp + shield) desc) as seqnum from units u group by unit_name ) u where seqnum = 1;
SELECT * --You really should use only the columns you need instead of * FROM Careers where (Location = @country OR @country is null) and ([state] = @state OR @state is null) and (position = @position or @position is null)
SELECT ID, Name, Designation, ROW_NUMBER() OVER (PARTITION BY Designation ORDER BY ID) AS Appearance FROM theTable
UPDATE customers SET balance = balance - @amount WHERE id = @id;
SELECT a.idea_id, a.property_id, a.the_idea, a.user_id, a.added_date, a.status, SUM(b.thumbs = 1) AS up, SUM(b.thumbs = 0) AS down FROM idea_box a LEFT JOIN idea_box_voting b ON a.idea_id = b.idea_id GROUP BY a.idea_id;
select max(case when id = 1 then x1 end) as x1_1, max(case when id = 1 then x2 end) as x2_1, max(case when id = 2 then x1 end) as x1_2, max(case when id = 2 then x2 end) as x2_2, max(case when id = 3 then x1 end) as x1_3, max(case when id = 3 then x2 end) as x2_3 from (select t.*, row_number() over (partition by id order by (select null)) a seqnum from #test t ) t group by seqnum;
select u.userid from usergroup u where u.groupid in (27, 714) group by u.userid having count(u.userid) > 1
SELECT COALESCE(p.id, c.id), COALESCE(p.name, c.name), p.num AS pending, c.num AS completed, COALESCE (p.num, 0) + COALESCE (c.num, 0) AS total FROM pending p FULL OUTER JOIN completed c ON p.id = c.id
SELECT t1.date, t1.symbol, t1.MPR FROM table1 t1 WHERE t1.MPR IN ( SELECT TOP 2 t2.MPR FROM table1 t2 WHERE t2.date = t1.date ORDER BY t2.MPR DESC )
ALTER PROC SP_SampleOuter AS DECLARE @count int EXEC @count = SP_SampleInner IF @count > 0 BEGIN SELECT @count as Ctr,1 END ELSE BEGIN SELECT @count as Ctr,0 END
SELECT COUNT(it.mac_id) AS total_installations, COUNT(DISTINCT it.mac_id) AS unique_installations, COUNT(CASE WHEN it.uninstalled_date <> '0000-00-00 00:00:00' THEN it.mac_id ELSE NULL END) as total_uninstallations, COUNT(DISTINCT CASE WHEN it.uninstalled_date <> '0000-00-00 00:00:00' THEN it.mac_id ELSE NULL END) as unique_uninstallations FROM installation_tracking it GROUP BY it.rs_id
select count(*) as numCustomersFromSydney from table where Suburb = "Sydney";
SELECT * FROM ( SELECT id FROM ( SELECT id FROM VWTenantPropertiesResults WHERE ContentStreet = 'Holderness Road' UNION ALL SELECT id FROM VWTenantPropertiesResults WHERE ContentTown = 'Hull' UNION ALL SELECT id FROM VWTenantPropertiesResults WHERE ContentPostCode = 'HU' ) qi GROUP BY id HAVING COUNT(*) >= 2 ) q JOIN VWTenantPropertiesResults r ON r.id = q.id WHERE ContentBedrooms BETWEEN 1 AND 4 AND ContentPrice BETWEEN 50 AND 500 ORDER BY ContentPrice
SELECT estimates.id, estimates.estimate_number, estimates.description, estimates.meeting_date, estimates.job_date, estimates.status, estimates.price, count(estimate_versions.estimate_id) FROM (estimates) LEFT OUTER JOIN estimate_versions estimate_versions ON estimates.id = estimate_versions.estimate_id LEFT OUTER JOIN customers customers ON estimates.customer_id = customers.id WHERE customers.key = 'JsB4ND90bn' group by estimates.id, estimates.estimate_number, estimates.description, estimates.meeting_date, estimates.job_date, estimates.status, estimates.price
WHERE users_friends.bID='$USER' AND users_friends.type = '$typeUsers' AND ( (users.firstname = '$firstname' AND users.lastname='$lastname') OR (users.firstname LIKE '$firstname%' AND users.lastname LIKE '$lastname%') OR users.firstname LIKE '$firstname%' OR users.lastname LIKE '$firstname%' )
insert into tbl_Name (Name) values (EncryptByKey( Key_GUID('SymmetricKey1'), N'Catégories'))
update contacts set title =@title, firstName=@firstName, middleName=@middleName, lastName=@lastName where contactID=@ContactID
-- note table1 is your table UPDATE t1 set t1.filed3 = t2.filed3 from table1 t1, table1 t2 where t1.filed3 is null and t2.filed3 is not null and t1.filed2 = t2.filed2 and t1.filed1 = t2.filed1
UPDATE `contacts` SET `calls_to` = `calls_to`+1, `cost_to` = `cost_to`+0.25 WHERE `contact_no`='0412345678' AND calls_to is not null AND cost_to is not null;
SELECT st_astext(st_line_substring( st_linemerge(geom) , $bas/st_length(geom), $son/st_length(geom) )) FROM geom_line WHERE i_project = $id;
SELECT tsgroup FROM master GROUP BY tsgroup ORDER BY RIGHT(RTRIM(tsgroup), 3), LEFT(RTRIM(tsgroup), 3)
DECLARE @sql AS NVARCHAR(MAX) ,@table AS NVARCHAR(MAX) = 'DATA_table'; SET @sql = 'stuff(( SELECT distinct [Site] FROM [ProcterGamble_analytics].[dbo].' + @table + ' FOR XML PATH(''''), TYPE ).value(''.'', ''NVARCHAR(MAX)'') , 1, 0, '''')'; EXEC(@sql);
CAST(value AS int)
SELECT T.* FROM MyTable T LEFT JOIN TblCountries C ON(T.Country = C.Country AND T.CountryCode = C.CountryCode) WHERE C.CountryId IS NULL -- Assuming you have a column by that name that's not nullable.
select month, count(*) from status s outer apply (select top 1 s2.* from status s2 where s.person_id = s2.person_id and s2.month < s.month order by s2.month desc ) as sprev where s.status = 3 and (sprev.status is null or sprev.status = 2) group by month;
SELECT team, SUM(Win) As Won, SUM(Loss) as Lost, SUM(score) as Score FROM ( SELECT team_one as team, CASE WHEN one_score > two_score THEN 1 ELSE 0 END as Win, CASE WHEN one_score < two_score THEN 1 ELSE 0 END as Loss, one_score as score FROM matches UNION ALL SELECT team_two as team CASE WHEN two_score > one_score THEN 1 ELSE 0 END as Win, CASE WHEN two_score < one_score THEN 1 ELSE 0 END as Loss, two_score as score FROM matches ) t GROUP BY team ORDER By Won, Lost DESC, Score
values (NULL, "heart", "heart_shape.jpg", now());
SELECT n.id, IF(pmu.name IS NULL, pmm.name, pmu.name) recipient, pmus.name sender, pm.msg, m.modification_id FROM notification n LEFT JOIN user_modification m ON (n.modification_id = m.modification_id) LEFT JOIN pm ON (n.pm_id = pm.pm_id) LEFT JOIN users pmu ON (pm.recipent_id = pmu.user_id) LEFT JOIN users pmus ON (pm.sender_id = pmus.user_id) LEFT JOIN users pmm ON (m.user_id = pmm.user_id) WHERE (pmu.name = 'Peter' OR pmm.name = 'Peter') AND n.is_read = 0;
create schema authorization [schema name] create table department ( code varchar2(3) primary key, name varchar2(40) not null, chair varchar2(11), constraint departmentChairFk foreign key(chair) references facultyStaff(staffId) on delete set null ) create table facultyStaff ( staffID varchar2(5) primary key, dob date, firstName varchar2(20), lastName varchar2(20), rank varchar2(10), deptCode varchar2(3), constraint rankValue check (rank in ('Assistant', 'Associate', 'Full', 'Emeritus')), constraint facultyDeptFk foreign key (deptCode) references department (code) ) create table student ( studentId varchar2(5) primary key, dob date , firstName varchar2(20), lastName varchar2(20), status varchar(10), major varchar(3), constraint statusValue check (status in ('Freshman', 'Sophomore', 'Junior', 'Senior', 'Graduate')), constraint studentMajorFk foreign key (major) references department (code) );
WHERE CUS_joinDate BETWEEN DATEADD(mm,-1,GETDATE()) AND DATEADD(mm,1,GETDATE())
SELECT Centre.Centre_Name, Count(Shop_No) AS shopcount FROM Centre LEFT JOIN Space ON Centre.Centre_Name = Space.Centre_Name GROUP BY Centre.Centre_Name
declare @stepsize float = 20.0 declare @val float = 17.6 select CEILING(@val / @stepsize) * @stepsize -- Result 20.0 set @val = 31.2 select CEILING(@val / @stepsize) * @stepsize -- Result 40.0
select `table1`.`NAME` AS `NAME`,`table2`.`PROMOTERID` AS `Promoter` ,(IFNULL(sum(`table2`.`GUESTS`),0) + `table1`.`GUESTS`) AS `TOTAL` from (`table1` LEFT join `table2` on((`table1`.`ID` = `table2`.`PROMOTERID`))), group by `table1`.`ID`
select * from users where REGEXP_LIKE (first_name, '^[^0-9a-z]+$', 'i');
SELECT test_column FROM test_table ORDER BY cast(test_column as int)
DELETE d FROM device d JOIN ( SELECT DevNum, MAX(DevReadDate) maxDevReadDate FROM device WHERE devReadType = 'xx' GROUP BY DevNum ) b ON d.DevNum = b.DevNum AND (d.DevReadDate < b.maxDevReadDate OR d.devReadType = 'xx')
select @myWhereString =stuff((select 'or isnull('+COLUMN_NAME+','''') = '''' ' as [text()] from Primebet.INFORMATION_SCHEMA.COLUMNS where TABLE_NAME = 'YourTable' and (column_name like 'col_as%' or column_name like 'col_m%') for xml path('')),1,3,'') set @myWhereString ='rest of your query'+ @myWhereString exec executesql with your query
DROP TABLE IF EXISTS my_table; CREATE TABLE my_table (measurement_id INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,TreeID INT NOT NULL ,Diameter INT NOT NULL ); INSERT INTO my_table (treeid,diameter) VALUES (1 , 3), (1 , 2), (1 , 3), (2 , 2), (2 , 2), (2 , 1), (1 , 3); SELECT x.* , COUNT(*) rank FROM my_table x JOIN my_table y ON y.treeid = x.treeid AND ( y.diameter > x.diameter OR (y.diameter = x.diameter AND y.measurement_id <= x.measurement_id ) ) GROUP BY x.treeid, x.diameter, x.measurement_id -- HAVING rank < something ORDER BY treeid,rank; +----------------+--------+----------+------+ | measurement_id | TreeID | Diameter | rank | +----------------+--------+----------+------+ | 1 | 1 | 3 | 1 | | 3 | 1 | 3 | 2 | | 7 | 1 | 3 | 3 | | 2 | 1 | 2 | 4 | | 4 | 2 | 2 | 1 | | 5 | 2 | 2 | 2 | | 6 | 2 | 1 | 3 | +----------------+--------+----------+------+
Select Order.AccountID, Order.UserID, Order.OrderID, Order.OrderDate, User.UserName, Note.NoteID, Note.UserID, Note.NoteDate, Note.Text, NoteWriter.UserName as 'NoteWriter_Username' FROM INNER JOIN User ON (Order.UserID=User.UserID) LEFT OUTER JOIN Note ON (Order.AccountID=Note.AccountID) LEFT OUTER JOIN user NoteWriter on NoteWriter.userid = Note.userID WHERE Order.OrderDate >="2016-01-01" AND Order.OrderDate <= (current date -1 day) AND Note.NoteID IN (21,41,89) AND Note.NoteDate >="2016-01-01" AND Note.NoteDate<= (current date -1 day)
SELECT e.Text AS StatusText, a.Created AS [DATE], CASE a.status WHEN 2 THEN NULL WHEN 3 THEN NULL ELSE a.Username END, b.Name AS CustomerName, c.Name AS ServiceName, d.Message AS DeviationMessage FROM dbo.StatusUpdate AS a LEFT OUTER JOIN dbo.Customer AS b ON a.CustomerId = b.CustomerID LEFT OUTER JOIN dbo.Service AS c ON a.ServiceId = c.ServiceID LEFT OUTER JOIN dbo.Deviation AS d ON a.DeviationId = d.DeviationID LEFT OUTER JOIN dbo.StatusText AS e ON a.Status = e.ID
SELECT 'allEqual' AS COL1, COUNT(*) AS imgCount FROM ( SELECT imgId AS primaryId FROM primary_images pi WHERE pi.ImgId = '$imgId' AND pi.imgWidth = '$maxImageWidth' AND pi.imgHeight = '$maxImageHeight' UNION ALL SELECT primaryId FROM secondary_images si WHERE si.primaryId = '$imgId' AND si.imgWidth = '$maxImageWidth' AND si.imgHeight = '$maxImageHeight' ) AS union_table
SELECT COUNT(CASE WHEN id = 2 THEN 1 END) / COUNT(CASE WHEN id = 2 || id = 3 THEN 1 END) FROM candidate
UPDATE DestinationTable SET DestinationTable.money_owed = SourceTable.Credit FROM DestinationTable INNER JOIN SourceTable ON DestinationTable.Field2 = SourceTable.Field2
client_win_api_environment.get_windows_username();
Declare @total varchar (max) set @total = 1 Declare @total2 varchar (max) set @total2 = '1,4' exec ('if '+@total+' in ('+@total2+') print ''Success'' ' )
DECLARE @cols AS NVARCHAR(MAX), @query AS NVARCHAR(MAX) select @cols = STUFF((SELECT distinct ',' + QUOTENAME(task) from t1 FOR XML PATH(''), TYPE ).value('.', 'NVARCHAR(MAX)') ,1,1,'') set @query = 'SELECT entity, ' + @cols + ' from ( select entity, task, timespan from t1 ) x pivot ( min(timespan) for task in (' + @cols + ') ) p ' execute(@query)
$result = db_query('SELECT nid FROM {node} WHERE ((status = :status) AND (type IN (:type)) ORDER BY created DESC', array(':status'=>'1', ':type'=>'_my_content_type'))->fetchAll(PDO::FETCH_ASSOC); foreach ($result as $row) { $node = node_load($row['nid']); // Access the field as $node->field_data_my_field_node_entity_type. }
Select p.*, m.* From ( Select p.*, ph.*, count(pv.vote) vote_count, sum(pv.vote) vote_sum, sum(case when pv.vote > 0 Then 1 else 0 end) plus_votes, sum(case when pv.vote < 0 then 1 else 0 end) minus_votes From pictures p left join picture_votes pv On pv.picture_id = p.picture_id left join photographers ph On p.photographer_id = ph.photographer_id Where p.authenticated = 1 And p.picture_id = ? ) p left join picture_models m On p.model_id = m.model_id
update group_table join ( select tab1.letter, tab1.id_group_table from ( select letter, id_group_table, count(letter) as occurrences from letter group by id_group_table, letter order by occurrences desc ) tab1 group by tab1.id_group_table having max(tab1.occurrences) ) tab2 on group_table.id_group_table = tab2.id_group_table set champion = tab2.letter where group_table.id_whatever in (1,2,3,4);
=SUBSTITUTE(A1, "'", "''")
select id_one from yourtable union select id_two from yourtable
2|4|8|16 -- rather than 30 1|32 -- rather than 33
String whereClause = "package_mane = ?"; // package_name perhaps? String[] whereArgs = new String[]{"com.mynamespase.db"};
select s.id, s.classDate, s.instructor , count(distinct e.id) as enrolled, count(distinct w.id) as waiting from schedule as s left outer join enrolled as e on s.id = e.scheduleID left outer join waitlist as w on s.id = w.scheduleID group by s.id
SQL> select rpad('*', level, '*') as c from dual connect by level <= 20 order by length(c) desc; C ------------------------------------ ******************** ******************* ****************** ***************** **************** *************** ************** ************* ************ *********** ********** ********* ******** ******* ****** ***** **** *** ** * 20 rows selected. SQL> select rpad('*', 2*level-1, ' *') as c from dual connect by level <= 20 order by length(c) desc; C -------------------------------------------------- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 20 rows selected.
select t.PATIENT_NUMBER, t.DATE_OF_VISIT, t.BMI from t inner join (select PATIENT_NUMBER, max(DATE_OF_VISIT) as maxdate from t group by PATIENT_NUMBER ) tmax on t.PATIENT_NUMBER = tmax.PATIENT_NUMBER and t.DATE_OF_VISIT = tmax.maxdate;
select project sum(case when score = 'labour' then hours else 0 end) as labourHrs, sum(case when score = 'travel' then hours else 0 end) as travelhours from t group by project;
CREATE OR REPLACE TRIGGER check_order_employee_no ON INSERT INTO orders BEFORE EACH ROW AS match_count INTEGER; BEGIN SELECT COUNT(*) INTO match_count FROM employee WHERE employee_no = :new.employee_no AND position IN (3,4,5,6); IF match_count = 0 THEN raise_application_error( -20000, 'Employee # for order must be for a Sales employee' ); END IF; END check_order_employee_no;
SELECT MAX(RIGHT('0000000' + REVERSE(LEFT(REVERSE(YourTextColumn), PATINDEX('%[a-z]%', REVERSE(YourTextColumn)) - 1)), 7)) FROM YourTable
Declare @test as datetime set @test = '2014-09-09 9:00:00' SELECT DATEADD(second, DATEDIFF(second, GETDATE(), GETUTCDATE()), @test)
DECLARE max_length INTEGER; --Declare a variable to store max length in. v_owner VARCHAR2(255) :='exampleSchema'; -- Type the owner of the tables you are looking at BEGIN -- loop through column names in all_tab_columns for a given table FOR t IN (SELECT table_name, column_name FROM all_tab_cols where owner=v_owner and table_name = 'exampleTableName') LOOP EXECUTE IMMEDIATE -- store maximum length of each looped column in max_length variable 'select nvl(max(length('||t.column_name||')),0) FROM '||t.table_name INTO max_length; IF max_length >= 0 THEN -- this isn't really necessary but just to ignore empty columns. nvl might work as well dbms_output.put_line( t.table_name ||' '||t.column_name||' '||max_length ); --print the tableName, columnName and max length END IF; END LOOP; END;
WITH MaxSalarySum AS ( SELECT deptNo , twelveMonthsPlusYear , SUM(salValue) salValueSum FROM ( select deptno, 12*month+year twelveMonthsPlusYear, salvalue from career join salary on career.empno = salary.empno and startdate<=to_date('01-'||to_CHAR(month)||'-'||to_CHAR(year),'dd-mm-yyyy') and ( enddate>=to_date('01-'||to_CHAR(month)||'-'||to_CHAR(year),'dd-mm-yyyy') or enddate is null ) ) GROUP BY deptNo, twelveMonthsPlusYear ) SELECT deptNo FROM MaxSalarySum WHERE salValueSum = (SELECT MAX(salValueSum) FROM MaxSalarySum) ;
SELECT MAX(Date), SUM(Value) FROM MyTable WHERE Date BETWEEN '2014-01-01' AND '2014-08-15';
SELECT MAX(a) + CASE WHEN (5 IN (SELECT a FROM t)) THEN 1 ELSE 2 END AS max_plus_something FROM t
declare @sqlstring varchar(1000) set @sqlstring = 'SELECT * FROM Order WHERE 1=1 ' if @StartTime <> null OR @StartTime <> '' BEGIN set @sqlstring = @sqlstring + 'AND CreatedOn > CAST(@StartTime as datetime) ' END if @EndTime <> null OR @EndTime <> '' BEGIN set @sqlstring = @sqlstring + 'AND CreatedOn < CAST(@EndTime as datetime) ' END if @OrderStatusID <> null OR @OrderStatusID <> '' BEGIN set @sqlstring = @sqlstring + 'AND OrderStatusID = @OrderStatusID ' END if @CustomerEmail <> null OR @CustomerEmail <> '' BEGIN set @sqlstring = @sqlstring + 'AND CustomerEmail > @CustomerEmail ' END print @sqlstring Exec(@sqlstring)
SQL> SELECT root || ',' || stragg(DISTINCT column2) 2 FROM (SELECT CONNECT_BY_ROOT(column1) root, t.* 3 FROM t 4 CONNECT BY PRIOR column2 = column1 5 START WITH column1 IN (SELECT column1 6 FROM t 7 WHERE column1 NOT IN (SELECT column2 8 FROM t))) v 9 GROUP BY root; ROOT||','||STRAGG(DISTINCTCOLU ----------------------------------------- value1,value2,value3,value4,value7 value8,value9
SELECT memno.1 EDTCDE(L), name.2, 'SYS1' NAME(SYS), "&&startdate" NAME(StartDate), CURRENT DATE NAME(CurDate) FROM library1/table1, library1/table2 JOIN SSAN.1=SSAN.2 WHERE DATE(TIMESTAMP)>StartDate AND RSCODE='STP' UNION SELECT memno.1 EDTCDE(L), name.2, 'SYS2' NAME(SYS), "&&startdate" NAME(StartDate), CURRENT DATE NAME(CurDate) FROM library2/table1, library2/table1 JOIN SSAN.1=SSAN.2 WHERE DATE(TIMESTAMP)>StartDate AND RSCODE='STP' ORDER BY sys ASC, memno ASC
SELECT TO_CHAR(TO_DATE(TABLE.timestamp,'YYYYMMDDHH24MISS'), 'mm/dd/yyyy hh24:mi') From XXXX.TABLE WHERE ROWNUM < 10;
db2 VALUES CURRENT TIMEZONE db2 "select CURRENT TIMEZONE from sysibm.sysdummy1"
SQL> ed Wrote file afiedt.buf 1 with x as ( 2 select 'Steve Jobs' str from dual union all 3 select 'Stack Overflow Question' from dual 4 ) 5 select substr( str, instr( str, ' ', -1 ) + 1 ) last_word 6* from x SQL> / LAST_WORD ---------------------------------------------------------------------- Jobs Question
SELECT PRVDR_NUM,SUM(ITM_VAL) as SumReimb FROM hha2011num INNER JOIN hha2011rpt ON hha2011num.RPT_REC_NUM = hha2011rpt.RPT_REC_NUM WHERE WKSHT_CD='D000000' AND LINE_NUM = '01201' AND CLMN_NUM in('0100','0200') GROUP BY PRVDR_NUM ORDER BY PRVDR_NUM
ALTER TABLE tableA ADD version AS CHECKSUM(CityName) PERSISTED
UPDATE Car SET brand = 'Renault' FROM Car c INNER JOIN Driver d ON c.driver = d.id WHERE d.Name = 'Marc'
SELECT * FROM T_USER u WHERE NOT EXISTS (SELECT NULL FROM T_MESSAGE WHERE user_id = u.user_id AND msgType = 1 AND answered = 0)
SELECT DISTINCT Renter.RenterID, Property.PropertyId, Property.PropertyName, Type.TYPEName FROM Rental inner join Property on Rental.PropertyID = Property.PropertyID inner join Type on Property.TypeID = Type.TypeID inner join Renter on Rental.RenterID = Renter.RenterID where Type.TypeName = 'villa' and Renter.RenterFirstName = 'al' and Renter.RenterLastName = 'smith'
SELECT state_name,district_name from TableName WHERE id='jk-01' //you can have your specific id here
SELECT table_1.id FROM table_1 LEFT JOIN table_2 ON table_2.id = table_1.id WHERE table_2.id IS NULL
Insert into taggings (id,tag_id,taggable_id,taggable_type,created_at) values (...your values...)
SELECT `UserName`, `Message`, SUM(CASE WHEN `status` = 'SendingOK' THEN 1 ELSE 0 END) OkStat, SUM(CASE WHEN `status` = 'SendingFailed' THEN 1 ELSE 0 END) FailedStat FROM db1.SmsBroadcast as A JOIN db2.sentitems as B ON A.MessageSMS1 = B.TextDecoded WHERE A.Username = 'jamesbond' GROUP BY A.Username, A.Message
declare @start_date datetime, @end_Date datetime select @start_date='2012-05-29 08:30:00.000', @end_date='2012-05-29 15:00:00.000' select datediff(minute,@start_date ,@end_Date)/60.0
select p.id, p.name, t.id as toyid, t.name as toyname from person p inner join toys t on p.id = t.person_id inner join ( select person_id from toys group by person_id having sum(name = 'hat') > 0 and sum(name = 'doll') > 0 ) t2 on p.id = t2.person_id
select user_id, days, date from ( select user_id, days, date, @sum_days := @sum_days + days as sum_days from myTable order by date desc ) t cross join (select @sum_days := 0) const -- resetting your @sum_days var. where sum_days < X -- fill a number in for X here.
SELECT * FROM `category` AS c INNER JOIN images AS i ON i.category = c.id INNER JOIN ( SELECT category, MAX(ID) AS MAXId FROM `images` GROUP BY `category` )AS a ON i.category = a.category AND i.ID = a.MaxID WHERE c.`parent` = '1';
select xp.productid, xp.product, xc.classid, xco.optionid, xco.option_name, count(xi.optionid) as cnt from xcart_products xp inner join xcart_classes xc on xp.productid = xc.productid and xc.class = 'Color' inner join xcart_class_options xco on xc.classid = xco.classid left outer join xcart_images_D xi on xi.optionid = xco.optionid group by xp.product order by xp.product desc
SELECT * FROM Messages main LEFT JOIN Messages earlier ON earlier.time < main.time AND ( earlier.To_User = main.To_User AND earlier.From_User = main.From_User OR earlier.To_User = main.From_User AND earlier.From_User = main.To_User ) WHERE (main.To_User = x OR main.From_User = x) AND earlier.id IS NULL ORDER BY main.Time DESC
function h($s) { return htmlspecialchars($s); } $conn = mysqli_connect(…); $result = mysqli_query($conn, 'select * from fixtures order by date'); $lastdate = NULL; while(($row = mysqli_fetch_assoc($result)) !== FALSE) { if($lastdate != $row['date']) { // output date divider/header echo '<h1>',h($row['date']),'</h1>'; $lastdate = $row['date']; } echo h($row['hometeam']), ', ', h($row['awayteam']), ', ', h($row['time']); }
SELECT * FROM wp_booking_transaction WHERE /* Conditions that appeared in both original queries */ DATE(launched) >= "2013-10-10" AND DATE(launched) <= "2013-11-10" AND type = 2 AND student_id = 81569 AND /* Conditions that are different between the two queries */ ((action = 1 AND status = 1) OR (action IN(20, 21) AND status = 0)) ORDER BY launched DESC
CREATE PROCEDURE p_GetFromLog(@LogId int) AS BEGIN DECLARE @exe nvarchar(1000) ,@RefID int ,@RefTbl varchar(200) SET @RefTbl = SELECT [ReferenceLocation] FROM dbo.[Log] WHERE [LogID] = @LogId SET @RefID = SELECT [ReferenceID] FROM dbo.[Log] WHERE [LogID] = @LogId SET @exe= N'select * from database.schema.table_here WHERE [ID] = refrence_id_here' SET @exe = replace(@exe, 'database.schema.table_here', @RefTbl) SET @exe = replace(@exe, 'refrence_id_here', cast(@RefID AS varchar(12))) EXEC sp_executesql @exe END
DEFAULT 0
SELECT CONVERT(VARCHAR(15),CAST(sa.StartDateTime AS TIME),100
SELECT Year, CASE WHEN Item IN ('A', 'B', 'C') THEN 'Group1' WHEN Item IN ('D', 'E', 'F') THEN 'Group2' ELSE 'Others' END AS Item, SUM(Cost1), SUM(Cost2) FROM myTable GROUP BY Year, CASE WHEN Item IN ('A', 'B', 'C') THEN 'Group1' WHEN Item IN ('D', 'E', 'F') THEN 'Group2' ELSE 'Others' END;
SELECT REGEXP_SUBSTR('Outstanding Trade Ticket Report_08 Apr 14.xlsx', '\_(.*)\.', 1, 1, NULL, 1) from dual
select Col_2, count(*) from your_table group by Col_2 having count(*) > 1
SELECT p.id_user, ap.post AS last_post, COUNT(*) as count FROM posts p JOIN posts ap on ( p.id_user = ap.id_user AND ap.post_id = ( SELECT MAX(post_id) FROM posts ip WHERE p.id_user = ip.id_user ) GROUP BY p.id_user, ap.post ORDER BY COUNT(*) DESC
SYS.DBMS_LOGMNR_D.BUILD(options => SYS.DBMS_LOGMNR_D.STORE_IN_REDO_LOGS); ^^^^^^^^^^^^^^^^^^
SELECT addon, status, SUM(amt1), SUM(amt2), company FROM test WHERE (addon = 'theft cover' OR addon = 'key loss') AND (status = 'yes') GROUP BY company, addon
SELECT `idMedication`,`idPatient`, CONCAT('(', `Drug` ,')') AS Drug from medication
select * from qsys2.systables where table_schema IN ('LAWMOD9T', 'LIBDDS')
SQL> show parameter spfile; NAME TYPE VALUE ---- ---- ---------------------------------------------------------- spfile string /root/apps/oracle/10g/dbs/spfile<DB_NAME>.ora
select a.x, select(mean(b.y) where b.x<a.x from data2 b) as m_y from data1 a
CREATE TRIGGER ... BEFORE UPDATE ... DECLARE l_exists number(10); ... BEGIN ... WHEN UPDATING ('SFBETRM_ESTS_CODE') THEN SELECT COUNT(*) INTO l_exists FROM DUAL WHERE EXISTS (SELECT null FROM SFBETRM_ESTS_CODE WHERE code = :new.SFBETRM_ESTS_CODE) ; IF l_exists = 1 THEN ... -- perform the update operation ELSE ... -- ignore update operation END IF; ... END;
where '#'+LangCodes+'#' like '%#en-us#%'
SELECT DISTINCT pbox.id as pbid, cbox.id as cbid, box.upload_type, box.id, box.box_type, box.page_name, box.title, box.connect, box.type, box.uid, box.description, box.image, box.url, box.status, box.date, box.time FROM boxes as box LEFT JOIN page_boxes as pbox on pbox.bid=box.id JOIN page_subcribers as pages on pages.page_id=pbox.page_id LEFT JOIN category_boxes as cbox on cbox.bid=box.id LEFT JOIN subcribers as catsb on cbox.category_id=catsb.cid WHERE (pages.uid='".$session_id."' or catsb.uid='".$session_id."') and box.status='".$approval."' and cbox.id<'".$cbid."' and pbox.id<'".$pbid."' ORDER BY pbox.id desc,cbox.id DESC LIMIT 10
var criteria = unitOfWork.CurrentSession.CreateCriteria(typeof(PageDetails)) .CreateAlias("PageDetails", "pageDetails") .Add(Restrictions.Eq("pageDetails.PageRoom_Id", pageRoom.PageRoom_Id)) .AddOrder(Order.Desc("SentDate")) .AddOrder(Order.Desc("Id"));
<?php include("path/to/cake/config/database.php"); $db = new DATABASE_CONFIG; echo $db->default['login']; echo $db->default['password']; echo $db->default['database']; ?>
select cast(left(r, charindex('%', r) - 1) AS float) as minVal, cast(replace(right(r, charindex('-', r) - 1), '%', '') as float) AS maxVal from ( select '22.45% - 42.32%' as r ) as tableStub
where Info like '%foo%foo%'
SELECT * FROM YourTable T WHERE CustId IN (SELECT CustId FROM YourTable GROUP BY CustId HAVING MIN(Location) <> MAX(Location))
SELECT Animal, SUM(CASE WHEN flg = 'A' THEN V1 ELSE 0 END) AS A_V1, SUM(CASE WHEN flg = 'A' THEN V2 ELSE 0 END) AS A_V2, SUM(CASE WHEN flg = 'B' THEN V1 ELSE 0 END) AS B_V1, SUM(CASE WHEN flg = 'B' THEN V2 ELSE 0 END) AS B_V2 FROM MyTab GROUP BY Animal
select [Order qty] from [Client sales]
SELECT vf.Value AS Updated, item.ID AS ItemId, item.Name AS ItemName FROM VersionedFields vf JOIN Items item ON item.ID = vf.ItemId WHERE vf.FieldId = 'D9CF14B1-FA16-4BA6-9288-E8A174D4D522' -- id of the __updated field -- vf.FieldId = '25BED78C-4957-4165-998A-CA1B52F67497' -- id of the __created field AND vf.Value > '20151027'
SELECT distinct c1.companyName, STUFF((SELECT ', '+ cn.name from WMCCMCategories cn INNER JOIN CategorySets uc ON uc.categoryId = cn.categoryID INNER JOIN KeyProcesses u ON u.categorySetId = uc.setId INNER JOIN Companies c ON c.companyId = u.companyId WHERE c.companyName = c1.companyName ORDER BY cn.name FOR XML PATH('')), 1, 1, '') AS listStr FROM Companies c1 Group by c1.companyName
SELECT * FROM myTable WHERE ( YEAR(myfield) = '2009') AND ( MONTH(myfield) = '1')
CREATE OR REPLACE TYPE NUMBER_TABLE_TYPE AS TABLE OF NUMBER; DECLARE updatedEmp NUMBER_TABLE_TYPE; sqlstr VARCHAR2(1000); tableName VARCHAR2(30) := 'EMPLOYEE'; deptId NUMBER := 12; BEGIN sqlstr := 'UPDATE '||tableName||' SET SALARY = SALARY * 2 WHERE DEPT_ID = :deptId '|| 'RETURNING EMP_ID INTO :res'; EXECUTE IMMEDIATE sqlstr USING deptId RETURNING BULK COLLECT INTO updatedEmp ; END;
SET ROWCOUNT 1 SELECT %s FROM %s
SELECT ID, things = STUFF( ( SELECT ',' + t2.thing FROM Table2 AS t2 INNER JOIN Table1 AS ti ON ',' + ti.ids + ',' LIKE '%,' + CONVERT(VARCHAR(12), t2.id) + ',%' WHERE ti.ID = tout.ID FOR XML PATH, TYPE ).value('.[1]', 'nvarchar(max)'), 1, 1, '') FROM Table1 AS tout ORDER BY ID
UPDATE board a LEFT JOIN pins b ON a.id = b.board_ID SET a.hide = 1 WHERE b.board_ID IS NULL
DELETE t1 FROM mytable t1 JOIN (SELECT Title, MAX(Created_at) AS max_date FROM mytable GROUP BY Title) t2 ON t1.Title = t2.Title AND t1.Created_at < t2.max_date
update table1 set "date" = to_date(date_txt, 'MM/DD/YYYY HH:MI:ss AM')
SELECT DISTINCT r.id, r.name FROM resource r WHERE NOT EXISTS( SELECT * FROM resource_role_join rrj LEFT OUTER JOIN user_role_join urj ON urj.role_id = rrj.role_id AND urj.user_id = :USER_ID WHERE r.id = rrj.resource_id AND urj.role_id IS NULL ) ;
WITH archive AS ( SELECT CASE WHEN EXISTS(SELECT 1 FROM dbo.tbl_Department d WHERE d.DepartmentID = e.DepartmentID) THEN 'Department Found' ELSE 'Department Not Found' END AS DepartmentStatus FROM dbo.tbl_Employee WITH (NOLOCK) e ) SELECT DepartmentStatus, Count(*) As Cnt FROM archive GROUP BY DepartmentStatus
cd /opt/db DATESTRING=$(date "+%Y-%m-%d 00:00:00" -d "now -90 day") for DBFILE in *.db do echo "delete from tbl_outbox where time<='$DATESTRING'; vacuum;" | sqlite3 $DBFILE done
select id from table2 where feature = 'Car' intersect select id from table2 where feature = 'Moto'
UPDATE DOT_WORKS SET START_DATE = case when END_DATE IS NULL then :StartDate else START_DATE end, WORKS_TYPE = case when WORKS_GROUP = :WorksGroup then :WorksType else WORKS_TYPE end, WORKS_CONNECTION = case when WORKS_PLACE = :WorksPlace then :WorksConn else WORKS_CONNECTION end WHERE ID = :WorksId and ( END_DATE IS NULL OR WORKS_GROUP = :WorksGroup OR WORKS_PLACE = :WorksPlace )
SELECT t1.v FROM (VALUES (1), (2), (3), (4), (5)) t1(v) LEFT JOIN mytable t2 ON t1.v = t2.id WHERE t2.id IS NULL
LOAD DATA LOCAL INFILE 'file.csv' INTO TABLE my_table FIELDS TERMINATED BY ',' ENCLOSED BY '"' LINES TERMINATED BY '\n' (name, address, @var1) set dateOfBirth = STR_TO_DATE(@var1, '%d-%b-%y')
--Cursor for iterating DECLARE @tableCursor CURSOR DECLARE @TABLE_NAME NVARCHAR(255) DECLARE @COLUM_NAME NVARCHAR(255) DECLARE @ID_COLUM NVARCHAR(255) DECLARE @CODELANGUE_COLUMN NVARCHAR(255) SET @tableCursor = CURSOR FOR SELECT TABLE_NAME, COLUM_NAME, ID_COLUMN, CODELANGUE_COLUMN FROM [tableData] -- Substitute with the name of your table as given in your question (which you didn't specify) OPEN @tableCursor FETCH NEXT FROM @tableCursor INTO @TABLE_NAME, @COLUM_NAME, @ID_COLUMN, @CODELANGUE_COLUMN WHILE (@@fetch_status = 0) BEGIN --dynamic sql DECLARE @sql NVARCHAR(max) --Your logic here... SET @sql = 'SELECT ' + @COLUM_NAME + ', ' + @ID_COLUM + ' FROM ' + @TABLE_NAME + ' WHERE ' + @CODELANGUE_COLUMN + ' = 1' EXEC dbo.sp_executesql @sql FETCH NEXT FROM @tableCursor INTO @TABLE_NAME, @COLUM_NAME, @ID_COLUMN, @CODELANGUE_COLUMN END CLOSE @tableCursor DEALLOCATE @tableCursor
select * from MyDatabase.dbo.MyTable
select id from foo inner join bar b1 on b1.fooId=foo.id and b1.baz=94 left outer join bar b2 on b2.fooId=foo.id and b2.baz=100 where b2.fooId is null
var query = from a in context.TB_UTILIDADE_PUBLIC_UTP join b in context.TB_UTILIDADE_PUBLIC_SECTOR_UPS on a.UPS_ID equals b.UPS_ID join c in context.TB_UTILIDADE_PUBLIC_SUBSECTOR_USS on new { a.USS_ID, a.UPS_ID } equals new { c.USS_ID, c.UPS_ID } select new { a.UTP_NAME, b.UPS_NAME, c.USS_NAME };
SELECT DATE(c.date_created) AS `date` ,COUNT(DISTINCT c.customer_id) AS registered_customers_who_bought FROM customer AS c JOIN purchase AS p ON c.customer_id = p.customer_id AND DATE(c.date_created) = DATE(p.date_modified) WHERE (c.`date_created` >= '2011/09/01' and c.`date_created` < '2014/05/14') GROUP BY DATE(c.date_created)
BEGIN FOR rs in (SELECT TABLESPACE_NAME FROM DBA_DATA_FILES WHERE FILE_NAME LIKE '/vol1/u06%') LOOP BEGIN EXECUTE IMMEDIATE 'DROP TABLESPACE ' || rs.TABLESPACE_NAME || ' INCLUDING CONTENTS AND DATAFILES CASCADE CONSTRAINTS'; END; END LOOP; END;
CREATE TABLE table1 ( column1 VARCHAR(255) DEFAULT NULL ); CREATE TABLE messages ( id INT(11) NOT NULL AUTO_INCREMENT, message VARCHAR(255) DEFAULT NULL, time TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (id) ); DELIMITER $$ CREATE TRIGGER trigger1 AFTER INSERT ON table1 FOR EACH ROW BEGIN INSERT INTO messages(message) VALUES ('new action'); END $$ DELIMITER ;
select P.ID from dbo.Partners as P left outer join dbo.vw_Partners_Codes2 as PC with (noexpand) on PC.Partner_ID = P.ID;
SELECT field, ca2.c2, ca3.c3 FROM table t cross apply(SELECT COUNT(*) c2 FROM table2 t2 WHERE t2.field = t.field)ca2 cross apply(SELECT COUNT(*) c3 FROM table3 t3 WHERE t3.field = t.field)ca3 where ca2.c2 <> ca1.c1
SELECT ti.FIRST_NAME "Technician",wo.WORKORDERID "Request ID",aau.FIRST_NAME "Requester",ti.FIRST_NAME "Technician", wotodesc.FULLDESCRIPTION "Description",DATEDIFF(day, DATEADD(s, wo.CREATEDTIME/1000, '01-01-1970 00:00:00'), getDate()) "Created Time", std.STATUSNAME "Request Status" FROM WorkOrder wo LEFT JOIN SDUser sdu ON wo.REQUESTERID=sdu.USERID LEFT JOIN AaaUser aau ON sdu.USERID=aau.USER_ID LEFT JOIN WorkOrderToDescription wotodesc ON wo.WORKORDERID=wotodesc.WORKORDERID LEFT JOIN WorkOrderStates wos ON wo.WORKORDERID=wos.WORKORDERID LEFT JOIN SDUser td ON wos.OWNERID=td.USERID LEFT JOIN AaaUser ti ON td.USERID=ti.USER_ID LEFT JOIN StatusDefinition std ON wos.STATUSID=std.STATUSID WHERE ((std.STATUSNAME != N'Closed' COLLATE SQL_Latin1_General_CP1_CI_AS) OR (std.STATUSNAME IS NULL)) AND (DATEDIFF(day, DATEADD(s, wo.CREATEDTIME/1000, '01-01-1970 00:00:00'), getDate()) >= 7) order by ti.FIRST_NAME
INSERT INTO receiving_tbl(id, name, color) SELECT id, name , CASE color_id WHEN 1 THEN 'Green' WHEN 2 THEN 'Red' ... ELSE NULL END FROM parent_tbl
If CurrentRecord = Recordset.RecordCount And CurrentRecord <> 1 Then DoCmd.GoToRecord , "", acFirst Else DoCmd.GoToRecord , "", acNext End If
select Steuersatz% from USt where Steuersatz = 1 and Datum = (select max(Datum) from USt where Steuersatz = 1 and Datum <= your_date)
SELECT * FROM node_weather JOIN ( SELECT tblInner.P_id, MAX(tblInner.time) AS maxTime FROM node_weather as tblInner GROUP BY tblInner.P_id ) AS tblMax ON tblMax.maxTime = node_weather.time AND tblMax.P_id = node_weather.P_id
Private Sub SearchButton_Click(sender As Object, e As EventArgs) Handles SearchButton.Click Dim connection = New SqlConnection("Your Connection string here") Dim command = New SqlCommand("SELECT StringColumn, BooleanColumn FROM YourTable WHERE KeyColumn=@KeyColumn", connection) command.Parameters.Add(New SqlParameter("@KeyColumn", Int32.Parse(KeyColumnTextBox.Text))) connection.Open() Dim reader = command.ExecuteReader() While reader.Read() StringColumnTextBox.Text = reader.GetString(0) BooleanColumnCheckBox.Checked = reader.GetBoolean(1) End While End Sub
declare @idToDelete varchar(max) = '10' declare @sql nvarchar(max) = '' set @sql = ( select 'delete ' + object_name(c.object_id) + ' where id = ' + @idToDelete + char(10) from sys.columns c join sys.objects o on o.object_id = c.object_id join sys.schemas s on s.schema_id = o.schema_id and s.name = 'dbo' where c.name = 'id' for xml path('') ) print @sql exec sp_executesql @sql
select k.* from (select k.*, row_number() over (partition by cla_id order by final_score desc) as seqnum from klas ) k where seqnum <= 10;
having amount <> 0
select emp_id,name, (select name from employee_details a where a.emp_id = b.manager_id) as manager_name from employee_details b
where a.c1 in ( SELECT CAST(token AS INT) FROM TABLE (STRTOK_SPLIT_TO_TABLE(1, '1,2,3,4,5,6,7,8,9,5000', ',') RETURNS (outkey INTEGER, tokennum INTEGER, token VARCHAR(10) CHARACTER SET UNICODE) ) AS dt )
SELECT CASE WHEN (SELECT TOP 1 x FROM y) IS NULL THEN 'No' ELSE 'Yes' END AS BooleanValue
SELECT Value1, CASE WHEN Value2 = 50 THEN 0 ELSE Value2 END Value2, .....
... AND EXTRACT(YEAR FROM "ExpiryDate") = 2012 ...
SELECT service_name, GROUP_CONCAT(sensor_name ORDER BY sensor_name) AS sensors FROM sensor_common_service GROUP BY service_name HAVING sensors='humidity,temperature'
select t.* from TeamRankings t inner join (select team_id, year, min(source_id) as minSource from TeamRankings group by team_id, year) f on t.team_id = f.team_id AND t.year = f.year AND t.source_id = f.minSource
select f1.data, f2.data, f3. data from (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f1 left join (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f2 on f2.row_num = f1.row_num + (select CEILING(COUNT(1) / 3) + 1 from your_table) left join (select data, ROW_NUMBER() over (order by data) as row_num from your_table) f3 on f3.row_num = f1.row_num + (select CEILING(COUNT(1) / 3) + 1 from your_table) * 2 where f1.row_num between 1 and FLOOR((select COUNT(1) from your_table) / 3) + 1
SELECT row_number() over (ORDER BY something) as num_by_something, * FROM table ORDER BY something;
-- find t1 where it has 2 and 7 in t2 select t1.* from table1 t1 join table2 ov2 on t1.id=ov2.masterid and ov2.optionValue=2 join table2 ov7 on t1.id=ov7.masterid and ov7.optionValue=7 -- find t1 where it has 2 and 7 in t2, and no others in t2 select t1.*, ovx.id from table1 t1 join table2 ov2 on t1.id=ov2.masterid and ov2.optionValue=2 join table2 ov7 on t1.id=ov7.masterid and ov7.optionValue=7 LEFT OUTER JOIN table2 ovx on t1.id=ovx.masterid and ovx.optionValue not in (2,7) WHERE ovx.id is null
// Join table B on table A through a foreign key $sql = 'select a.id, a.x, b.y from a left join b on b.a_id=a.id order by a.id'; // Execute query $result = $this->db->query($sql)->result_array(); // Initialise desired result $shaped_result = array(); // Loop through the SQL result creating the data in your desired shape foreach ($result as $row) { // The primary key of A $id = $row['id']; // Add a new result row for A if we have not come across this key before if (!array_key_exists($id, $shaped_result)) { $shaped_result[$id] = array('id' => $id, 'x' => $row['x'], 'b_items' => array()); } if ($row['y'] != null) { // Push B item onto sub array $shaped_result[$id]['b_items'][] = $row['y']; } }
**Customer table** CustomerId LastName FirstName ... **CustomerAttributes table** CustomerId AttributeName AttributeValue
if coalesce(@var, 0) <> 1 PRINT 'not 1' ELSE PRINT 'equals 1'
SELECT Path FROM PathTable WHERE Path NOT LIKE '%/%'
IF ((SELECT COUNT(*) FROM table1 WHERE project = 1) > 0) SELECT product, price FROM table1 WHERE project = 1 ELSE IF ((SELECT COUNT(*) FROM table1 WHERE project = 2) > 0) SELECT product, price FROM table1 WHERE project = 2 ELSE IF ((SELECT COUNT(*) FROM table1 WHERE project = 3) > 0) SELECT product, price FROM table1 WHERE project = 3
SELECT e.Name, (SELECT SUM(TravelDurationDays) FROM TravelType1 WHERE EmployeeID = e.EmployeeID ) TravelType1Days, (SELECT COUNT(*) FROM TravelType2 WHERE EmployeeID = e.EmployeeID AND Travel = 'yes' ) TravelType2Days FROM Employees e
ORDER BY RIGHT(CONVERT(CHAR(4), InvoiceDate, 100) + CONVERT(CHAR(4), InvoiceDate, 120),4) MONTH(InvoiceDate)
DECLARE @InputString VARCHAR(100); SET @InputString = 'hello i am here in this bright room'; SELECT * FROM YourTable WHERE CHARINDEX(YourColumn, @InputString) <> 0;
DECLARE @sqlstmt VARCHAR(MAX) SET @sqlstmt = 'SELECT vin FROM cars WHERE 1=1' IF @interior<>'No Preference' SET @sqlstmt = @sqlstmt + ' AND interior = '''+@interior+''' IF @color<>'No Preference' SET @sqlstmt = @sqlstmt + ' AND color = '''+@color+''' ... exec(@sqlstmt)
alter table category modify column catid int(11) NOT NULL;
SELECT g.id group_id, g.name group_name, a.last_written, a.total_articles, a.total_done, c.last_comment FROM groups g LEFT JOIN ( SELECT `group`, MAX(CASE WHEN done = 1 THEN written END) last_written, COUNT(*) total_articles, SUM(done) total_done FROM articles WHERE active = 1 AND user_id = 1 GROUP BY `group` ) a ON g.id = a.`group` LEFT JOIN ( SELECT a.`group`, MAX(date_added) last_comment FROM commants c JOIN articles a ON c.article_id = a.id WHERE a.active = 1 AND a.user_id = 1 GROUP BY a.`group` ) c ON g.id = c.`group` WHERE user_id = 1
SELECT ss1.userid, ss2.userid, SUM(sales) FROM session ss1 JOIN session ss2 ON ss2.sessionid = ss1.sessionid AND ss2.userid < ss1.userid JOIN sales s ON s.sessionid = ss1.sessionid GROUP BY ss1.userid, ss2.userid
SELECT * FROM ( SELECT deptno , ename , sal , RANK() OVER (PARTITION BY deptno ORDER BY sal desc) rnk , ROW_NUMBER() OVER (PARTITION BY deptno ORDER BY sal desc) rno , MAX(hiredate) OVER (PARTITION BY deptno ORDER BY deptno) max_hire_date FROM emp_test WHERE deptno = 20 ORDER BY deptno ) WHERE rnk = 1 --AND rno = 1 -- or 2 or any other number... / SQL> DEPTNO ENAME SAL RNK RNO HIREDATE MAX_HIRE_DATE ----------------------------------------------------------- 20 SCOTT 3000 1 1 1/28/2013 1/28/2013 20 FORD 3000 1 2 12/3/1981 1/28/2013
SELECT user_id, username, SUM(revenue) FROM table GROUP BY user_id /* add ', username' ONLY if two different usernames with the same user_id is a possible case */ ORDER BY SUM(revenue) DESC LIMIT 0,1
SELECT * FROM ( SELECT * FROM TableA WHERE ColA = '001' ) PIVOT ( MAX(ColC) FOR ColB IN ('AA1','AB1','AC1') )
update table1 t1 join table2 t2 on t1.B = t2.B set t1.A = 'some value'
DELETE target FROM MnA target INNER JOIN MnA temp ON (target.symbol = temp.symbol AND target.direction = temp.symbol AND target.start_doy = temp.start_doy AND target.diff = temp.diff AND target.id != temp.id AND temp.avg_percent > target.avg_percent);
SELECT * from customers WHERE customer_id not in (select customer_id from order)
select empcode, DateValue(PunchTime), sum(IIF(IsInPunch='F',PunchTime,0)) - sum(IIF(IsInPunch='T',PunchTime,0)) from TimeSheet group by empcode, DateValue(PunchTime)
CREATE TABLE Emp(EPID INT PRIMARY KEY, t CHAR(2) NOT NULL, UNIQUE (EPID,t)); CREATE TABLE EmpFT(EPID INT PRIMARY KEY, ... other columns t CHAR(2) NOT NULL CHECK (t = 'FT'), FOREIGN KEY (EPID,t) REFERENCES Emp (EPID,t)); CREATE TABLE EmpPT(EPID INT PRIMARY KEY, ... other columns t CHAR(2) NOT NULL CHECK (t = 'PT'), FOREIGN KEY (EPID,t) REFERENCES Emp (EPID,t));
public partial class LegacyDate { public static implicit operator DateTime?(LegacyDate value) { return LegacyDateConverter.ToDate(value.DbData); } public static implicit operator LegacyDate(DateTime? value) { return new LegacyDate { DbData = LegacyDateConverter.ToLegacyDate(value) }; } } internal static class LegacyDateConverter { public static DateTime? ToDate(int data) { if (data == 0) return null; int year = data/10000; int month = (data%10000)/100; int day = data/1000000; DateTime date; try { date = new DateTime(year, month, day); } catch (Exception e) { throw new ArgumentException(String.Format( "Value {0} kan not be converted to DateTime", data), e); } return date; } public static int ToLegacyDate(DateTime? value) { int dateInt = 0; if (value.HasValue) { dateInt = value.Value.Year*10000 + value.Value.Month*100 + value.Value.Day; } return dateInt; } }
UPDATE `Products` SET `Price` = REPLACE(`Price`, '$', '') WHERE `Price` LIKE '%$%';
SELECT * FROM User u1 INNER JOIN User u2 on u2.id_company = u1.id_company INNER JOIN Ticket t on t.id_author = u2.id_user WHERE u1.Name = @SessionUser
SELECT * FROM table1 t1 WHERE EXISTS ( SELECT null FROM Table1 t2 WHERE t1."TEACHER" = t2."TEACHER" AND t1."SUBJECT" = t2."SUBJECT" AND t1."ID" <> t2."ID" ) ORDER BY "ID"
TINYBLOB, TINYTEXT L + 1 bytes, where L < 2^8 (255 Bytes) BLOB, TEXT L + 2 bytes, where L < 2^16 (64 Kilobytes) MEDIUMBLOB, MEDIUMTEXT L + 3 bytes, where L < 2^24 (16 Megabytes) LONGBLOB, LONGTEXT L + 4 bytes, where L < 2^32 (4 Gigabytes)
SELECT serialnumber, state, at, operatorid, LAG(state) OVER (PARTITION BY serialnumber ORDER BY at) AS previous FROM voucher WHERE serialnumber in (SELECT DISTINCT serialnumber FROM voucher WHERE at LIKE '&1')
SELECT stats.gds_id, TRUNC(stats.stat_date) stat_date, SUM(stats.A_BOOKINGS_NBR) as "Bookings", SUM(stats.RESPONSES_LESS_1_NBR) as "<1", SUM(stats.RESPONSES_LESS_2_NBR) AS "<2", SUM(STATS.RESPONSES_LESS_3_NBR) AS "<3", SUM(stats.RESPONSES_LESS_4_NBR) AS "<4", SUM(stats.RESPONSES_LESS_5_NBR) AS "<5", SUM(stats.RESPONSES_LESS_6_NBR + stats.RESPONSES_LESS_7_NBR + stats.RESPONSES_GREATER_7_NBR) AS ">5", SUM(stats.RESPONSES_LESS_6_NBR) AS "<6", SUM(stats.RESPONSES_LESS_7_NBR) AS "<7", SUM(stats.RESPONSES_GREATER_7_NBR) AS ">7", SUM(stats.RESPONSES_LESS_1_NBR + stats.RESPONSES_LESS_2_NBR + stats.RESPONSES_LESS_3_NBR + stats.RESPONSES_LESS_4_NBR + stats.RESPONSES_LESS_5_NBR + stats.RESPONSES_LESS_6_NBR + stats.RESPONSES_LESS_7_NBR + stats.RESPONSES_GREATER_7_NBR) as "Total" FROM gwydb.statistics stats WHERE stats.stat_date >= '01-JUN-2011' GROUP BY stats.gds_id, TRUNC(stats.stat_date)
SELECT a.cost, a.quantity, COUNT(b.id) AS count FROM accounts AS a LEFT JOIN accounts AS b ON b.cost = a.cost
ON DUPLICATE KEY UPDATE total = VALUES(total)
SELECT A.ID, A.NAME, A.STORE, B.STOREADDRESS as yourAlias /* AS is ok for column aliases ... */ FROM TableALong A /* ... but not for table aliases */ LEFT OUTER JOIN TableBLong B /* JOIN syntax */ ON (A.NAME = B.NAME and A.STORE = B.STORE) WHERE ...
SELECT delivery_name FROM orders WHERE CONCAT('a',orders_id) = CONCAT('a','985225a')
select my, interesting, columns from ( select distinct GUID, ... from ... )
SELECT A.[Date], A.[Hour], SUM(CASE WHEN (B.[SessionID] IS NULL) THEN 0 ELSE 1 END) AS [Number_of_Sessions_Per_Hour] FROM ( SELECT DISTINCT CONVERT(DATETIME, LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date])))) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2) , 120) AS [Date], hours_table.[Hour] FROM userlog, ( SELECT 1 AS [Hour] UNION ALL SELECT 3 AS [Hour] UNION ALL SELECT 4 AS [Hour] UNION ALL SELECT 5 AS [Hour] UNION ALL SELECT 6 AS [Hour] UNION ALL SELECT 7 AS [Hour] UNION ALL SELECT 7 AS [Hour] UNION ALL SELECT 8 AS [Hour] UNION ALL SELECT 9 AS [Hour] UNION ALL SELECT 10 AS [Hour] UNION ALL SELECT 11 AS [Hour] UNION ALL SELECT 12 AS [Hour] UNION ALL SELECT 13 AS [Hour] UNION ALL SELECT 14 AS [Hour] UNION ALL SELECT 15 AS [Hour] UNION ALL SELECT 16 AS [Hour] UNION ALL SELECT 17 AS [Hour] UNION ALL SELECT 18 AS [Hour] UNION ALL SELECT 19 AS [Hour] UNION ALL SELECT 20 AS [Hour] UNION ALL SELECT 21 AS [Hour] UNION ALL SELECT 22 AS [Hour] UNION ALL SELECT 23 AS [Hour] UNION ALL SELECT 24 AS [Hour] ) as hours_table ) AS A LEFT OUTER JOIN ( SELECT userlog.SessionID, MAX(CASE WHEN userlog.LogType = 'LOGON' THEN CONVERT(DATETIME, LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date])))) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2) , 120) ELSE CONVERT(DATETIME, '1900-01-01', 120) END) AS [Date_Session_START], MAX(CASE WHEN userlog.LogType = 'LOGOFF' THEN CONVERT(DATETIME, LTRIM(RTRIM(CONVERT(NVARCHAR(10), YEAR(userlog.[Date])))) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), MONTH(userlog.[Date])))), 2) + '-' + RIGHT('0' + LTRIM(RTRIM(CONVERT(NVARCHAR(10), DAY(userlog.[Date])))), 2) , 120) ELSE CONVERT(DATETIME, '1900-01-01', 120) END) AS [Date_Session_END], MAX(CASE WHEN userlog.LogType = 'LOGON' THEN DATEPART(HOUR, userlog.[Date]) ELSE 0 END) AS [Hour_Session_START], MAX(CASE WHEN userlog.LogType = 'LOGOFF' THEN DATEPART(HOUR, userlog.[Date]) ELSE 0 END) AS [Hour_Session_END], FROM userlog GROUP BY userlog.SessionID ) AS B ON (A.[Date] >= B.[Date_Session_START] AND A.[Date] <= B.[Date_Session_END]) AND (A.[Hour] >= B.[Hour_Session_START] AND A.[Hour] <= B.[Hour_Session_END]) WHERE A.[Date] Between @X and @Y GROUP BY A.[Date], A.[Hour]
SELECT (SELECT ...) AS `005` FROM table1 GROUP BY ... HAVING `005` > 0
SELECT MAX(cov_julian(t.tatime)) FROM table1 t WHERE t.tatime <= TO_NUMBER(TO_CHAR(SYSDATE,'J')) AND (EXISTS (SELECT NULL FROM table2 a WHERE a.empid = t.personid) OR EXISTS (SELECT NULL FROM table3 c WHERE c.col5 = t.personid2)) ;
postgresqlExecStatement(con, "DELETE FROM foos WHERE id = $1 AND baz = $2", list(1, "bar"))
WHERE FREETEXT(k.Keyword, @SearchQ) AND d.IsSearch=1 AND d.IsApproved=1 AND ((@CategoryId NOT IN (1,2,3)) OR (d.CategoryId = @CategoryId)) ) AS Search_Data
public class AppContext : DbContext { public DbSet<Instrument> Instruments { get; set; } public DbSet<Order> Orders { get; set; } } public class Instrument { public int Id { get; set; } public string Book { get; set; } public string Page { get; set; } public virtual ICollection<MatchedInstrument> MatchedInstruments { get; set; } } public class Order { public int Id { get; set; } public string OrderName { get; set; } public virtual ICollection<MatchedInstrument> MatchedInstruments { get; set; } } public class MatchedInstrument { public int Id { get; set; } public int InstrumentId { get; set; } public Instrument Instrument { get; set; } public int OrderId { get; set; } public Order Order { get; set; } public bool IsFavorite { get; set; } public string Notes { get; set; } }
SELECT ID, Value1, CASE WHEN Value1 = 1 THEN 0 ELSE Value2 END Value2 FROM ( SELECT ID, MAX(CASE WHEN Value1 = 1 THEN 1 ELSE 0 END) Value1, MAX(Value2) Value2 FROM YourTable GROUP BY ID) A
SELECT fieldId, COUNT(Id) AS count FROM tag GROUP BY fieldId
mysql> SELECT 'abc' LIKE 'ABC'; -> 1 mysql> SELECT 'abc' LIKE BINARY 'ABC'; -> 0
delete viewed_product where id in ( select id from ( select id, row_number() over (order by created_at desc) rn from viewed_product where my_id = :bindvar ) where rn > 20 )
CREATE TABLE #Test (ID int, LOC int, RNK char(1), NBR1 int, NBR2 char(1) ) INSERT INTO #Test VALUES (1, 2, 'A', 10, 'b'), (3, 4, 'A', 10, 'b'), (5, 6, 'A', 11, 'C'), (8, 2, 'A', 12, 'D'), (6, 3, 'A', 10, 'b') SELECT * FROM #Test t1 WHERE EXISTS (SELECT 1 FROM #Test t2 WHERE t1.NBR1 = t2.NBR1 AND t1.NBR2 = t2.NBR2 GROUP BY NBR1, NBR2 HAVING COUNT(1) > 1)
SELECT owner, name, type FROM dba_dependencies WHERE referenced_name = 'SEND_MAIL' AND referenced_owner = <<owner of procedure>>
declare @tmpGuid uniqueidentifier select @tmpGuid = CLIENT_GUID from #mapping where NEW_CLIENT_GUID is null while @@ROWCOUNT > 0 begin --Set the first unset guid to itself update #mapping set NEW_CLIENT_GUID = @tmpGuid where CLIENT_GUID = @tmpGuid --set all other duplicates to the guid we just used. update #mapping set NEW_CLIENT_GUID = @tmpGuid where CLIENT_GUID in (select CLIENT_GUID from FindDuplicateClientsByClient(@tmpGuid)) and NEW_CLIENT_GUID is null --get next guid select @tmpGuid = CLIENT_GUID from #mapping where NEW_CLIENT_GUID is null end set nocount off go
SELECT B.Var1, A.Var2 FROM A LEFT OUTER JOIN B ON A.Var1 = B.Var1
SELECT t1.Name, t1.BirthDate, t1.OrderNumber FROM Table1 t1 WHERE NOT EXISTS(SELECT NULL FROM Table2 t2 WHERE t2.Name = t1.Name AND t2.BirthDate = t1.BirthDate AND t2.OrderNumber = t1.OrderNumber)
SELECT TRUNC(SYSDATE) - TRUNC(SYSDATE,'MONTH') + 1 FROM DUAL
UPDATE (SELECT T3.SOME_VALUE1 TARGET1, T3.OTHER_VALUE1 TARGET2, T3.SOME_VALUE2 TARGET3, T3.OTHER_VALUE2 TARGET4, T1.SOME_VALUE1 SOURCE1, T1.OTHER_VALUE1 SOURCE2, T2.SOME_VALUE2 SOURCE3, T2.OTHER_VALUE2 SOURCE4 FROM TABLE1 T1 JOIN TABLE2 T2 ON T1.ID = T2.ID JOIN T3 ON T3.FK = T1.ID) SET TARGET1 = SOURCE1, TARGET2 = SOURCE2, TARGET3 = SOURCE3, TARGET4 = SOURCE4;
CREATE TABLE employees ( employee_id INT UNSIGNED NOT NULL AUTO_INCREMENT, family_name VARCHAR(100) NOT NULL, first_name VARCHAR(100) NOT NULL, birth_date DATETIME NULL DEFAULT NULL, PRIMARY KEY(employee_id) ) ENGINE=INNODB; CREATE TABLE employee_bonus ( bonus_id INT UNSIGNED NOT NULL AUTO_INCREMENT, employee_id INT UNSIGNED NOT NULL, bonus_value DECIMAL(10,2) DEFAULT 0.00, PRIMARY KEY(bonus_id), KEY fk_employee_id (employee_id), CONSTRAINT fk_employee_constraint FOREIGN KEY fk_employee_id(employee_id) REFERENCES employees(employee_id) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE=INNODB;
SELECT DISTINCT(BINARY name) AS Name FROM X;
DELETE * FROM contacts WHERE value='x'
where DATEDIFF(MM, OrderDate, GETDATE()) < 4
push-location import-module sqlps -disablenamechecking pop-location
@Offset = ((DATEDIFF(day, @BaseDate, GETDATE()) % @DayCount)
-- CTE to the rescue!!! WITH cal AS ( SELECT generate_series('2012-02-02 00:00:00'::timestamp , '2012-03-02 05:00:00'::timestamp , '1 hour'::interval) AS stamp ) , qqq AS ( SELECT date_trunc('hour', executiontime) AS stamp , count(*) AS zcount FROM mytable GROUP BY date_trunc('hour', executiontime) ) SELECT cal.stamp , COALESCE (qqq.zcount, 0) AS zcount FROM cal LEFT JOIN qqq ON cal.stamp = qqq.stamp ORDER BY stamp ASC ;
select * from table1 t1 cross apply ( select * from (select top 1 * from table2 t2 where t1.rn = t2.rn order by t2.id desc) t where t.name <> t1.name) c
select * from table where trunc(es_date) = TO_DATE('27-APR-12','dd-MON-yy')
SELECT USERNAME, COUNT(USERNAME) AS TotalCount, MAX(logindate) AS LastLoginDate FROM LOGINTABLE GROUP BY USERNAME
WITH CTE AS ( SELECT PeriodStart, PeriodEnd, SUM(TotalActive) As TotalActive, SUM(TotalAdded) As TotalAdded, SUM(TotalRemoved) As TotalRemoved FROM ( SELECT PeriodStart = CASE @Frequency WHEN 'day' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, [Date])) WHEN 'week' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(DAY, 1 - DATEPART(WEEKDAY, [Date]), [Date]))) WHEN 'month' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(MONTH, DATEDIFF(MONTH, 0, [Date]), 0))) WHEN 'quarter' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]), 0))) WHEN 'year' THEN DATEADD(hour, 0, DATEDIFF(DAY, 0, DATEADD(YEAR, DATEDIFF(YEAR, 0, [Date]), 0))) END, PeriodEnd = CASE @Frequency WHEN 'day' THEN DATEADD(s, -1, DATEADD(day, 1, DATEDIFF(DAY, 0, [Date]))) WHEN 'week' THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, 7 - DATEPART(WEEKDAY, [Date]), [Date])))) WHEN 'month' THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(MONTH, DATEDIFF(MONTH, 0, [Date]) + 1, 0))))) WHEN 'quarter' THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(QUARTER, DATEDIFF(QUARTER, 0, [Date]) + 1, 0))))) WHEN 'year' THEN DATEADD(s, -1, DATEADD(hour, 0, DATEDIFF(DAY, -1, DATEADD(DAY, -1, DATEADD(YEAR, DATEDIFF(YEAR, 0, [Date]) + 1, 0))))) END, TotalActive, TotalAdded, TotalRemoved FROM TrendReport P WHERE [Date] BETWEEN @DateStart AND @DateEnd ) s GROUP BY PeriodStart, PeriodEnd ORDER BY PeriodStart ), U AS ( SELECT qty_type, PeriodStart, qty FROM CTE UNPIVOT(qty FOR qty_type IN([TotalActive], [TotalAdded], [TotalRemoved]))Q ) SELECT * FROM U PIVOT (SUM(Qty) FOR PeriodStart IN([03/01/2011], [03/08/2011], [03/15/2011])) AS P
SELECT [RowKey], x.y.value('(.)[1]', 'INT') AS ItemKey FROM dbo.[tbl_MyDataTable] AS t CROSS APPLY t.[Format].nodes('/MultiSelect/ItemKey') x(y)
SELECT MAX(score), MAX(whenadded) FROM scores
CAST (FLAGS AS NUMBER(19))
SELECT M1.city AS iCity , M2.city AS jCity , M1.month , M1.temperature - M2.temperature AS final_temperature FROM MASTER M1 CROSS APPLY MASTER M2 ON M2.month = M1.month
SELECT CAT_NO, PROD_CODE, DESCRIPTION, COLOR FROM ( SELECT *, ROW_NUMBER() OVER (PARTITION BY PROD_CODE ORDER BY CAT_NO) AS row_num FROM TABLE ) t WHERE t.row_num = 1
SELECT b.id, COUNT(i.id) AS num_inspections, COUNT(v.id) AS num_violations FROM BUSINESS b LEFT JOIN INSPECTION i ON i.business_id = b.id LEFT JOIN VIOLATION v ON v.inspection_id = i.id GROUP BY b.id
select top 1 with ties MessageID, MessageSent, MessageSenderUserID, MessageRecipientUserID from [Messaging_Message] order by row_number() over (partition by MessageSenderUserID order by MessageSent desc)
SELECT sum(case when Stat='1' then 1 else 0 end) as Counted, sum(case when Stat='2' then 1 else 0 end) as Counted2 from dbo.Batch
Where Status = 0 or (Department = 100 And Status = 1)
SELECT l.BuildingID, l.ApartmentID, l.LeaseID, l.ApplicantID, ROW_NUMBER() OVER (PARTITION BY l.ApartmentID ORDER BY s.Importance DESC, MovedOut, MovedIN DESC, LLSigned DESC, Approved DESC, Applied DESC) AS 'RowNumber' FROM dbo.NPleaseapplicant AS l INNER JOIN dbo.NPappstatus AS s ON l.BuildingID = s.BuildingID AND l.AppStatus = s.Code WHERE (l.BuildingID = @BuildingID)
SELECT b.id FROM big_table b WHERE EXISTS (SELECT 1 FROM small_table s WHERE s.name LIKE 'something%' AND s.id = b.small_id ) ORDER BY b.name;
select a.*, b.* from tablea a outer apply (select top 1 b.* from tableb b where b.id = a.id and b.date <= a.date order by b.date desc ) b;
RETURN(LPAD(_RESTRICTEDROUTE, 4, "0"))
select DATEADD(s, dateTimeInMilliseconds, '19700101')
SELECT * FROM mytable WHERE name LIKE 'a%' OR name like 'A%'
SELECT client, email, alt_email FROM ( select 'user.CustomAttribute.Client' client ,'user.Email' email ,'user.customAttribute.alternateEmail' alt_email -- here we add an aid to ordering, 1 comes first , 1 displayorder from dual UNION ALL Select c.client ,c.email ,c.alt_email -- here we add an aid to ordering, 2 comes after our header , 2 displayorder from contact ) order by displayorder, client;
ALTER TABLE `TableAB` DROP FOREIGN KEY FK_KEY_Test; ALTER TABLE `TableAB` ADD CONSTRAINT FK_KEY_Test FOREIGN KEY ('some_column') REFERENCES `TableA` ('Test_column1') ON UPDATE CASCADE ON DELETE CASCADE;
IF OBJECT_ID('TempDB.dbo.#DuplicateAssignments') IS NOT NULL BEGIN DROP TABLE #DuplicateAssignments END
SELECT DISTINCT contact.id, contact.`Contact group`, contact.Media, contact.E-mail, contact.Nationality, contact.Country, contact.City, contact.Area, contact.Gender, contact.Married, contact.Children, contact.`Drivers license` FROM contact INNER JOIN contactlanguage ON contact.id = contactlanguage.contactid INNER JOIN language ON contactlanguage.languageid = language.id WHERE isdeleted = 0 AND language.language in ('English', 'Hindi', '');
select * from (select *, ROW_NUMBER() OVER (PARTITION BY tkid order by DateTimeStamp desc) as rn from Prog_Timer ) T where T.rn = 1 -- the latest status for each tkid and T.Status = 'Start' -- returns only started and not stopped timers -- if timer is stopped, t.Status will be 'Stop' in the latest row
SELECT ST_AsText (centroid), ST_SRID (centroid) FROM (SELECT ST_Centroid(ST_GeomFromText(geom, srid)) as centroid) as t;
SELECT e.event_name, SUM(invited.contact_id) 'total_invited', SUM(confirmed.contact_id) 'total_invitations_confirmed' FROM EVENT e JOIN INVITATIONS invited ON invited.event_id = e.event_id JOIN INVITATIONS confirmed ON confirmed.event_id = e.event_id AND confirmed.responded = 'Y' GROUP BY e.event_id, e.event_name
CREATE TABLE emp(ename varchar(100),DOB date, Age varchar(100)) INSERT INTO emp VALUES('d','06/02/2011',NULL)--,('b','07/10/1947',NULL),('c','12/21/1982',NULL) ;WITH CTE(ename,DOB,years,months,days) AS ( SELECT ename,DOB,DATEDIFF(yy,DOB,getdate()),DATEDIFF(mm,DOB,getdate()),DATEDIFF(dd,DOB,getdate()) FROM emp ) SELECT ename,DOB,CAST(months/12 as varchar(5))+' Years'+ CAST((months % 12) as varchar(5))+' month/s '+ CAST(CASE WHEN DATEADD(MM,(months % 12),DATEADD(YY,(months/12),DOB)) <= GETDATE() then DATEDIFF(dd,DATEADD(MM,(months % 12),DATEADD(YY,(months/12),DOB)),GETDATE()) ELSE DAY(getdate()) END as varchar(5))+' days' as Age FROM CTE
SELECT t.*, CASE WHEN s.quantity is null then null ELSE CASE WHEN s.quantity > 0 and t.quantity - s.quantity > 0 then s.quantity ELSE CASE WHEN s.quantity > 0 and t.quantity - s.quantity < 0 then t.quantity end end end as 'UPGRADE' from YourTable t LEFT OUTER JOIN YourTable s ON(t.group = s.group and t.year = s.year-1 AND t.type = 't2' and s.type = 't1')
declare @ds nvarchar(22); declare @qry nvarchar(max); set @ds = 'KaamKaaj'; set @qry = N' SELECT '''+ @ds + ''' as DBName , T.name AS [TABLE NAME], I.rows AS [ROWCOUNT] FROM @ds.sys.tables AS T INNER JOIN @ds.sys.sysindexes AS I ON T.object_id = I.id AND I.indid < 2 ORDER BY I.rows DESC'; SET @qry = REPLACE(@qry, '@ds', @ds) print @qry; declare @TableList TABLE(Id int IDENTITY(1,1),DataBaseName VARCHAR(100),TableName VARCHAR(100),RecordCount INT,NameOfIndex VARCHAR(100),TypeOfIndex VARCHAR(100)) INSERT INTO @TableList(DataBaseName,TableName,RecordCount) exec(@qry ); declare @qry2 nvarchar(max); set @qry2 = N'SELECT '''+ @ds + ''' as DBName, t.name, ind.name, ind.type_desc FROM @ds.sys.indexes ind INNER JOIN @ds.sys.index_columns ic ON ind.object_id = ic.object_id and ind.index_id = ic.index_id INNER JOIN @ds.sys.columns col ON ic.object_id = col.object_id and ic.column_id = col.column_id INNER JOIN @ds.sys.tables t ON ind.object_id = t.object_id WHERE ind.is_primary_key = 0 AND ind.is_unique = 0 AND ind.is_unique_constraint = 0 AND t.is_ms_shipped = 0 ORDER BY t.name, ind.name, ind.index_id, ic.index_column_id '; SET @qry2 = REPLACE(@qry2, '@ds', @ds) declare @TableListWithIndex TABLE(Id int IDENTITY(1,1),DataBaseName VARCHAR(100),TableName VARCHAR(100),NameOfIndex VARCHAR(100),TypeOfIndex VARCHAR(100)) INSERT INTO @TableListWithIndex(DataBaseName,TableName,NameOfIndex,TypeOfIndex) exec(@qry2 ); select * from @TableList select * from @TableListWithIndex
int sumAlias = 0; _dataAccessor.QueryOver<Player>() .Inner.JoinQueryOver<PlayerPerformance>(player => player.Performances) .Inner.JoinQueryOver<Achievement>(perf => perf.Achievements, () => achievementAlias) .Where(a => a.Descriptor == "Goals Scored") .SelectList(list => list.SelectGroup(player => player.Id).SelectSum(() => achievementAlias.Value).WithAlias(() => sumAlias) .OrderByAlias(() => sumAlias).Desc .List<object[]>() ;
select {fn timestampdiff(SQL_TSI_MINUTE, startdate, enddate)}/60 as diff
Select CP.ProductName,sum(Cp.ProductQuantity) FROM VendorTrading VT inner join CustomerProducts CP ON VT.Id = CP.VendorTradingId WHERE CP.ProductName = ISNULL('XYZ', CP.ProductName) AND VT.Tradedate = isnull('2015-01-20',VT.Tradedate) AND CP.ProductName in ('xyz','abc') GROUP BY CP.ProductName
SELECT redCount, COUNT(*) FROM (SELECT user_id, COUNT(color) as redCount FROM cars WHERE color = 'red' GROUP BY user_id ) uc GROUP BY redCount;
select stuff(( select ' ' + cast(product as char(10)) from datainformation for XML path('')),1,1,'') as products, stuff(( select ' ' + cast(quantity as char(10)) from datainformation for XML path('')),1,1,'') as quantity
SELECT date_trunc(...)::date;
DECLARE @mindate DATETIME DECLARE @maxdate DATETIME DECLARE @diff INT SET @maxdate = '2014-02-15' SET @mindate = '2014-01-15' SET @diff = DATEDIFF(DAY, @mindate,@maxdate) ;WITH cte(dt,level) AS ( SELECT @mindate AS dt, 0 AS level UNION ALL SELECT DATEADD(day,1,cte.dt),level + 1 from cte WHERE level < @diff ) SELECT dt FROM cte option (maxrecursion 32767)
SELECT t2.a,t2.b,t2.c FROM (SELECT a, b, max(d) as max_d FROM TABLE_NAME GROUP BY a,b) t1 inner join TABLE_NAME t2 on(t1.a=t2.a AND t1.b=t2.b AND t1.max_d=t2.d)
AddHandler myConnection.InfoMessage, New SqlInfoMessageEventHandler(AddressOf OnInfoMessage) Private Sub OnInfoMessage(ByVal sender As Object, ByVal e As System.Data.SqlClient.SqlInfoMessageEventArgs) mySB.AppendLine(e.Message) End Sub
create table search_thread ( thread_id int, date_entered datetime, PRIMARY KEY (thread_id) FOREIGN KEY (thread_id) REFERENCES thread(thread_id)); create table search_results ( thread_id int, result_id int, PRIMARY KEY (thread_id, result_id), FOREIGN KEY (thread_id) REFERENCES search_thread(thread_id), FOREIGN KEY (thread_id) REFERENCES thread(thread_id). FOREIGN KEY (result_id) REFERENCES thread(thread_id));
select EMPID, EMPNAME, COMPANY1 from EMPLOYEE where COMPANY1 is not null union select EMPID, EMPNAME, COMPANY2 from EMPLOYEE where COMPANY2 is not null union select EMPID, EMPNAME, COMPANY3 from EMPLOYEE where COMPANY3 is not null union select EMPID, EMPNAME, COMPANY4 from EMPLOYEE where COMPANY4 is not null
SELECT c.id, t.line_id, t.date, u.name, a.name, sum(case when t.adjustment_no IS NOT NULL then t.sale_amount else 0 end) as adjustment, sum(case when t.adjustment_no IS NULL then t.sale_amount else 0 end) as sales FROM invoice i JOIN contract c on c.contract_no = i.contract_no JOIN transaction t on t.invoice_no = i.invoice_no JOIN unit u on u.unit_no = t.unit_no JOIN agency a on a.agency_no = i.agency_no WHERE t.unit_no in (44) AND i.hard_invoice = 'Y' AND t.code in ('New', 'Edit') GROUP BY c.id, t.date, u.name, a.name, t.line_id;
SELECT name , create_date, modify_date ,sm.definition FROM sys.procedures sp Inner join sys.sql_modules sm ON sp.object_id = sm.object_id WHERE CONVERT(DATE,sp.modify_date) = CONVERT(DATE, '02/19/2013')
SELECT b.BOOKINGID, b.GUESTID, d.DEPENDANTID, d.FORENAME AS firstname, d.SURNAME AS lastname, br.FLOORNO, br.ROOMNO FROM BOOKING b LEFT JOIN BOOKINGDEPENDANT bd ON b.BOOKINGID = bd.BOOKINGID LEFT JOIN DEPENDANT d ON d.DEPENDANTID = bd.DEPENDANTID LEFT JOIN BOOKINGROOM br ON br.ID = bd.ROOMID and ON br.BOOKINGID = b.BOOKINGID WHERE b.BOOKINGID = &BOOKINGID;
insert into table1 ( col1, col2, col3, col4 ) select col1, col2, col3, 'foo' from table2 where something = 'foo'
declare @t table ([Date] date, Clockin time, CLockout time, Trip1 int, Trip2 int) insert into @t select '01/01/2013', '13:00', '17:00', 3, 3 union all select '01/01/2013', '13:00', '17:00', 0, 3 union all select '01/01/2013', '13:00', '17:00', 0, 0 union all select '01/01/2013', '13:00', '17:00', 3, null; select [minutes]=datediff(mi, Clockin, Clockout), [trips] = ((isnull(Trip1, 0)+isnull(Trip2,0))), [calc] = datediff(mi, Clockin, Clockout)/ (nullif((isnull(Trip1, 0)+isnull(Trip2,0)), 0)), [calc2] = datediff(mi, Clockin, Clockout)/ isnull((nullif((isnull(Trip1, 0)+isnull(Trip2,0)), 0)), 1) from @t
declare v_pk my_pk_arr; v_cur t_cursor; begin v_pk := MY_PK_ARR(MY_PK(1, 'a'), MY_PK(2, 'b')); -- or build in a loop etc. get_data(v_pk, v_cur); end; /
SELECT SubjectID, DepartmentID, SubjectName, SubjectDescription, SubjectShortCode FROM BS_Subject WHERE NOT EXISTS (SELECT SubjectToClassID FROM BS_SubjectToClass WHERE BS_Subject.SubjectID = BS_SubjectToClass.SubjectID AND BS_SubjectToClass.ClassID =2)
select ps.* from @ProductSub ps inner join ( select CASE WHEN c.ClientID is null THEN m.ClientID WHEN m.ClientID is null THEN c.ClientID WHEN m.ExpiryDate is not null and c.ExpiryDate is not null THEN CASE WHEN c.ExpiryDate > m.ExpiryDate THEN c.ClientID ELSE m.ClientID END WHEN m.ExpiryDate is null THEN m.ClientID WHEN c.ExpiryDate is null THEN c.ClientID ELSE m.ClientID END as ClientId, COALESCE(m.ProductId, c.ProductId) as ProductId from @ProductSub m full outer join @ProductSub c on m.ProductID = c.ProductID and m.ClientID <> c.ClientID where IsNull(m.clientid,@MasterClient) = @MasterClient and IsNull(c.clientid,@ConsolClient) = @ConsolClient ) filter on filter.clientid = ps.clientid and filter.productid = ps.productid order by ps.ProductId
SELECT m.* FROM messages m INNER JOIN users u ON m.userId = u.userId WHERE u.username = 'UsernameHere';
Sub Reformat() Dim arr, d1, d2, arrOut(), r As Long, ub As Long Dim r2 As Long, c As Long arr = Selection.Value 'select the source data first ub = UBound(arr, 1) Set d1 = distinct(arr, 1) Set d2 = distinct(arr, 2) ReDim arrOut(1 To d1.Count, 1 To 1 + (d2.Count * 2)) For r = 1 To ub r2 = d1(arr(r, 1)) c = 2 + (d2(arr(r, 2)) - 1) * 2 arrOut(r2, 1) = arr(r, 1) arrOut(r2, c) = arr(r, 2) arrOut(r2, c + 1) = arr(r, 3) Next r With ThisWorkbook.Sheets("out") .Range("A2").Resize(UBound(arrOut, 1), UBound(arrOut, 2)).Value = arrOut End With End Sub 'get all distinct values in a "column" of a 2-d array Function distinct(arr As Variant, colNum) As Object Dim r As Long, ub As Long, i As Long, d Set d = CreateObject("scripting.dictionary") ub = UBound(arr, 1) i = 1 For r = 1 To ub If Not d.exists(arr(r, colNum)) Then d.Add arr(r, colNum), i i = i + 1 End If Next r Set distinct = d End Function
select name from tbl where movid in (select movid from tbl where name = 'me') and name <> 'me' group by name having count(*) = (select count(*) from tbl where name = 'me')
DECLARE @SQL varchar(500) SELECT @SQL = 'osql -S' +@@servername +' -E -q "exec dbName..sprocName "' EXEC master..xp_cmdshell @SQL
DECLARE @xmlTest xml; SET @xmlTest = '<Mapping> <Element name="FirstTable"> <Column> <Source>SourceColumn1</Source> <Destination>DestinationColumn1</Destination> </Column> <Column> <Source>SourceColumn2</Source> <Destination>DestinationColumn2</Destination> </Column> <Column> <Source>SourceColumn3</Source> <Destination>DestinationColumn3</Destination> </Column> </Element> <Element name="SecondTable"> <Column> <Source>SourceColumn4</Source> <Destination>DestinationColumn4</Destination> </Column> <Column> <Source>SourceColumn5</Source> <Destination>DestinationColumn5</Destination> </Column> </Element> </Mapping>' ;With Map As ( SELECT x.value('../@name', 'nvarchar(50)') TableName ,x.value('Source[1]', 'nvarchar(50)') SourceColumn ,x.value('Destination[1]', 'nvarchar(50)') DestinationColumn from @xmlTest.nodes('/Mapping/Element/Column') T(x) ) select distinct 'INSERT INTO [' + M.TableName + '] (' + Left(DC.DestinationColumns, Len(DC.DestinationColumns) - 1) + ') SELECT (' + Left(SC.SourceColumns, Len(SC.SourceColumns) - 1) + ') FROM [RawDataTable]' as SQLs from Map M cross apply ( select CONVERT(VARCHAR(255), SourceColumn) + ',' AS [text()] from Map M2 where M.TableName = M2.TableName FOR XML PATH('') ) SC(SourceColumns) cross apply ( select CONVERT(VARCHAR(255), DestinationColumn) + ',' AS [text()] from Map M2 where M.TableName = M2.TableName FOR XML PATH('') ) DC(DestinationColumns)
SELECT SUM(tfspm.PaymentOn) AS Amount, tfsp.campaignID, cc.Name FROM tbl_FormSubmissions_PaymentsMade tfspm INNER JOIN tbl_FormSubmissions_Payment tfsp ON tfspm.SubmissionID = tfsp.SubmissionID INNER JOIN tbl_CurrentCampaigns cc ON tfsp.CampaignID = cc.ID WHERE tfspm.isApproved = 'True' AND ( tfspm.PaymentOn BETWEEN '2013-05-01 12:00:00.000' AND '2013-05-07 12:00:00.000' OR tfspm.PaymentOn BETWEEN '2013-05-08 12:00:00.000' AND '2013-05-14 12:00:00.000' ) GROUP BY tfsp.campaignID, cc.Name
SELECT id, name, [begin], [end] FROM orders o WHERE EXISTS( SELECT * FROM access WHERE orderId = o.id AND [user] = @user AND role >= 1 )
SELECT Contact.Email, Contact.FirstName, Contact.Surname, recent.HotlineID, Hotline.Action FROM (SELECT HotlineID, MAX([Date]) as maxDate FROM Hotline GROUP BY HotlineID) recent INNER JOIN Hotline ON recent.HotlineId = Hotline.HotlineId LEFT JOIN Contact ON Hotline.HotlineId = Contact.HotlineId WHERE datediff(hour, recent.maxDate, GetDate()) < 48 AND Hotline.Flag = 1
WITH example AS ( SELECT ad.applicantdetailid, ad.applicantmasterid, ad.dateeffective, ROW_NUMBER() OVER(PARTITION BY ad.applicantmasterid ORDER BY ad.dateeffective DESC) AS rank FROM #APPLICANTDETAIL ad) SELECT e.applicantdetailid FROM example e WHERE e.rank = 1 ORDER BY e.applicantmasterid, e.dateeffective
SELECT sub.name AS ARName, sub.desc AS ARDescription, m.name AS MessageName, m.subj AS MessageDescription, clk.type AS EventType, COUNT(DISTINCT clk.eid) AS CountAdmins, COUNT(DISTINCT CASE WHEN my.my_id = 3347 THEN clk.eid END) AS CountUpgradeAdmins, COUNT(DISTINCT CASE WHEN my.my_id = 2765 THEN my.data END) AS CountAccounts, COUNT(DISTINCT my2.data ) AS CountUpgradedAccounts FROM bata.sseq seq INNER JOIN bata.messages m ON m.id = seq.mid INNER JOIN bm_arc.clicks208 clk ON clk.camp = seq.camp INNER JOIN bemails.cid cid ON cid.id = clk.eid INNER JOIN bonfig.sub ON sub.id = seq.sid LEFT JOIN bemails.my208 my ON cid.id = my.eid AND (my.my_id = 3347 OR my.my_id = 2765) # only return people who upgraded and LEFT JOIN bemails.my208 my2 ON my2.my_id = 2765 and my2.userID = my.userID and my.my_id=3347 #get the accounts that the user belongs to WHERE seq.cid = 208 AND sub.desc REGEXP '^Home pg free trail (A|B)' GROUP BY ARName, ARDescription, MessageName, MessageDescription, EventType
SELECT * FROM mytable WHERE %%LOCKRES%% = '{0000ABCDEFAB}'
insert into table1 (_id) select _id from table2;
select object_name as view_name, to_number(extractvalue(xmltype(dbms_xmlgen.getxml('select count(*) c from "'||owner||'"."'||object_name||'"')),'/ROWSET/ROW/C')) as row_count from dba_objects where object_type = 'VIEW' and owner = 'ADMIN' order by 1;
INSERT INTO #Temp (id, id2, a, b) SELECT TABLE_A.ID, TABLE_B.ID2, TABLE_A.A, TABLE_B.B FROM TABLE_A INNER JOIN TABLE_B ON TABLE_A.[primary_key] = TABLE_B.[foreign_key]
BEGIN TRAN 'tran1' INSERT INTO Whatever table... IF(... check for null) BEGIN ROLLBACK TRAN 'tran1' RETURN 0 END COMMIT TRAN 'tran1'
CREATE TABLE DATA_TABLE(VALUE NUMBER, REJECT_COUNT NUMBER DEFAULT 1, A NUMBER, B NUMBER, C NUMBER, CONSTRAINT DAT_PK PRIMARY KEY (VALUE)); CREATE OR REPLACE TRIGGER DATA_TABLE_TRIGGER BEFORE UPDATE ON DATA_TABLE FOR EACH ROW DECLARE BEGIN :NEW.REJECT_COUNT := :OLD.REJECT_COUNT + 1; END;
SET @the_list = myStoredProc(); SET @the_query = CONCAT('SELECT * FROM myTable WHERE columnName IN (' , @the_list , ')'); PREPARE the_statement FROM @the_query; EXECUTE the_statement;
SELECT COUNT(*) FROM ( SELECT p.prod_id, p.prod_list_price, avg(c.unit_cost) avg_cost FROM products p inner join costs c ON c.prod_id = p.prod_id GROUP BY p.prod_id, p.prod_list_price ) WHERE prod_list_price < 1.15 * avg_cost
SELECT rep.RPT_ID ,tech.TECH_ID ,proc.PROC_ID FROM REPORT rep LEFT JOIN TECHNICIAN tech ON tech.RPT_ID = rep.RPT_ID LEFT JOIN PROCEDURE proc ON proc.RPT_ID = rep.RPT_ID AND proc.PROC_ID = tech.PROC_ID WHERE rep.LAB_ID in ('test_lab');
SELECT [1 Cut Wire & Cable Only].Element FROM [1 Cut Wire & Cable Only] WHERE ( [1 Cut Wire & Cable Only].Product_ID = [Forms]![New Report]![cbProduct_ID] );
SELECT events.event_id, COALESCE(attendance.status, 0) status FROM events LEFT JOIN attendance ON events.event_id = attendance.event_id AND attendance.user_id='someoutsideinput' ORDER BY events.event_date ASC
;WITH x AS ( SELECT col1, col2, ROW_NUMBER() OVER(ORDER BY id DESC) rn FROM Table1 ) SELECT col1, col2 FROM x x1 WHERE NOT EXISTS ( SELECT 1 FROM x x2 WHERE x2.rn <= x1.rn AND x2.col2 = 'b' )
SELECT t.userid MAX(CASE WHEN t.fieldname = 'Username' THEN t.fieldvalue ELSE NULL END) AS Username, MAX(CASE WHEN t.fieldname = 'Password' THEN t.fieldvalue ELSE NULL END) AS Password, MAX(CASE WHEN t.fieldname = 'Email Address' THEN t.fieldvalue ELSE NULL END) AS Email FROM TABLE t GROUP BY t.userid
<cfscript> q = queryNew("LTM,LTM_1,LTM_2,LTM_3,LTM_4"); queryAddRow(q); QuerySetCell(q, "LTM", "OSTAPOWER"); QuerySetCell(q, "LTM_1", "VENKAT"); QuerySetCell(q, "LTM_2", "LYNN"); QuerySetCell(q, "LTM_3", "SMITH"); QuerySetCell(q, "LTM_4", "HARTLEY"); queryAddRow(q); QuerySetCell(q, "LTM", "OSTAPOWER"); QuerySetCell(q, "LTM_1", "VENKAT"); QuerySetCell(q, "LTM_2", "LYNN"); QuerySetCell(q, "LTM_3", "SMITH"); QuerySetCell(q, "LTM_4", "SHREVE"); function collect(q) { var data = {}; for (var row in q) { var varName = "data"; for (var i = 0; i <= 4; i++) { var col = i == 0 ? "LTM" : "LTM_#i#"; var name = row[col]; if (len(name)) varName = listAppend(varName, name, "."); else break; } setVariable(varName, {}); } return data; } function transform(tree, nodeName, level=0, parent="") { if (structIsEmpty(tree)) return ""; var node = { 'name': nodeName, 'parent': len(parent) ? parent : javacast("null",""), 'level': javacast("int", level), 'groups': [] }; var branch = tree[nodeName]; for (var child in branch) arrayAppend(node.groups, transform(branch, child, level+1, nodeName)); return node; } c=collect(q); writeDump(transform(c,'OSTAPOWER')); </cfscript>
with minRow(ID) as (select min(ID) from Table_1 group by data1, data2, data3) select t1.* from Table_1 t1 join minRow m1 on t1.ID = m1.ID
SELECT product, condition1 FROM table_name UNION SELECT product, condition2 FROM table_name UNION SELECT product, condition3 FROM table_name UNION ORDER BY product
JOIN [cubing].[dbo].[WCA_export_RanksAverage] AS RanksAverage ON RanksAverage.personId = RanksSingle.personId AND RanksAverage.eventId = RanksSingle.eventId
SELECT * FROM sys.views
select column1,column2,1 as column3 from mytable
SELECT a.pk_FamilyID, a.Salutation, e.Title, e.Forename, e.Surname, c.Title, c.Forename, c.Surname FROM Family a INNER JOIN PersonFamily b ON a.pk_FamilyID = b.fk_FamilyID INNER JOIN Person c ON b.fk_PersonID = c.pk_PersonID INNER JOIN Relation d ON c.pk_PersonID = d.fk_RelatedPersonID INNER JOIN Person e ON d.fk_PersonID = e.pk_PersonID WHERE (d.Relationship LIKE '%Father' OR d.Relationship LIKE '%Mother') AND e.pk_PersonID IN('" & Substitute ( ListOfPersonUUID ; ¶ ; "','" ) & "') ORDER BY e.SurnameForename ASC
UPDATE ltm_op_risk_event ltm SET ltm.sent_into_wf_by_id = (SELECT ltmRev.adm_user_id FROM ltm_op_risk_event_rev ltmRev WHERE ltmRev.ltm_op_risk_event_id = ltm.ltm_op_risk_event_id AND ltmRev.status != (SELECT ltmRev2.status FROM LTM_OP_RISK_EVENT_REV ltmRev2 WHERE valid_from IS NOT NULL AND ltmRev.ltm_op_risk_event_id = ltmRev2.ltm_op_risk_event_id ORDER BY valid_from ASC LIMIT 1) ORDER BY ltmRev.valid_to ASC LIMIT 1) WHERE ltm.sent_into_wf_by_id IS NULL;
where completeddate <= dateadd(hour, 4, createddate)
SELECT o.official_name Official, p.official_name Supervisor FROM official o LEFT JOIN officialsupervisor s ON o.official_id = s.official_id LEFT JOIN official p ON p.official_id = s.supervisor_official_id
select id, sum, sum_amount, pair, (case when max(sum_amount) over (partition by pair) = sum_amount then sum_amount / min(sum_amount) over (partition by pair) else sum_amount / max(sum_amount) over (partition by pair) end) as div from t;
select StepID, cast(sum(case when Rating > 9 then 100.0 else 0 end) /count(*) as decimal(5,2)) pct from yourtable group by StepID
SELECT E.Visitor Toilet_Type, SUM(case when SE.SemiEnragedPotty_ID is not null and M.Toilet_ID is not null then 1 else 0 end) MANUAL_PORTA_POTTY, SUM(case when R.Toilet_ID is not null then 1 else 0 end) REGULAR_PORTA_POTTY FROM BORE.EnragedPotty E, BORE.SemiEnragedPotty SE, BORE.ManualPotty M, BORE.RegularPotty R WHERE E.SemiEnragedPotty_ID = SE.SemiEnragedPotty_ID (+) AND E.Toilet_ID = M.Toilet_ID (+) E.Toilet_ID = R.Toilet_ID (+) GROUP BY Visitor ORDER BY Visitor ASC
select * from `owners` join `records` ON (`records`.`pa_no` = `owners`.`contact_no`) WHERE email <> "" and not exists (select reg_no from `buyers` where `buyers`.reg_no = `records`.reg_no)
SELECT status FROM all_objects WHERE object_name = 'MYFUNCTIONNAME' AND object_type = 'FUNCTION';
SELECT modify_date ,type_desc ,name FROM sys.objects WHERE is_ms_shipped=0 --AND modify_date>='yyyy/mm/dd' <--optionally put in your date here ORDER BY 1 DESC
$id = 5;$parent_id = 5; /* set default to values you want*/ while($parent_id != 0) { $sql = 'SELECT id,parent_id from sub_table where id = $parent_id '; $rs= $mysqli->query($sql); /* fetch details */ $old_id = $id; /* this will save the last id in current iteration */ $parent_id = $rs['parent_id']; $id = $rs['id']; }
SELECT (CASE WHEN postedDate IS NULL THEN '0' ELSE CAST(postedDate AS VARCHAR(MAX))) postedDate ...
$file = "D:\PostDeployment.sql" $SQLCommandText = @(Get-Content -Path $file) # loads content foreach($SQLString in $SQLCommandText) { if($SQLString -ne "go") # if string is not equal to go then add it to existing string { #Preparation of SQL packet $SQLPacket += $SQLString + "`n" } else { Write-Host "---------------------------------------------" Write-Host "Executed SQL packet:" Write-Host $SQLPacket $SQLPacket = "" # clear up sql string } }
--get rid of the sparsely used commas --get rid of the duplicate spaces update MyTable set CityStZip= replace( replace( replace(CityStZip,' ',' '), ' ',' '), ',','') select --check if state and zip are there and then grab the city case when isNumeric(right(CityStZip,1))=1 then left(CityStZip,len(CityStZip)-charindex(' ',reverse(CityStZip), charindex(' ',reverse(CityStZip))+1)+1) --no zip. check for state when left(right(CityStZip,3),1) = ' ' then left(CityStZip,len(CityStZip)-charIndex(' ',reverse(CityStZip))) else CityStZip end as City, --check if zip is there and then grab the city case when isNumeric(right(CityStZip,1))=1 then substring(CityStZip, len(CityStZip)-charindex(' ',reverse(CityStZip), charindex(' ',reverse(CityStZip))+1)+2, 2) --no zip. check if 3rd to last char is a space and grab the last two chars when left(right(CityStZip,3),1) = ' ' then right(CityStZip,2) end as [State], --grab everything after the last space if the last character is numeric case when isNumeric(right(CityStZip,1))=1 then substring(CityStZip, len(CityStZip)-charindex(' ',reverse(CityStZip))+1, charindex(' ',reverse(CityStZip))) end as Zip from MyTable
SELECT generate_series, COUNT("timeStarted") FROM generate_series('2015-04-07 00:00:00+01', '2015-04-07 23:59:00+01', '1 hour'::interval) LEFT JOIN session s ON date_trunc('hour', "timeStarted"::timestamp) = generate_series AND "timeStarted" BETWEEN timestamp with time zone '2015-04-07 00:00:00+01' AND timestamp with time zone '2015-04-07 23:59:00+01' GROUP BY generate_series ORDER BY generate_series;
select firstname, lastname, scheduled, posted, eventadded from (select rs.*, row_number() over (partition by firstname, lastname order by (case when eventadded is not null then 1 else 2 end) ) as seqnum from ResultSet rs ) rs where seqnum = 1;
select t1.id, t1.name, case when t2.id is null then 'False' else 'True' end DoesExist from Table1 t1 left join Table2 t2 on t1.ID = t2.ID
INSERT INTO `test_data` (`product_id`, `meta_key`, `meta_value`) SELECT td.`product_id`, wp2.`meta_key`, wp2.`meta_value` FROM `test_data` td INNER JOIN `wp_postmeta` wp1 ON wp1.`meta_value` = td.`meta_value` AND wp1.`meta_key`= '_wpsc_sku' INNER JOIN `wp_postmeta` wp2 ON wp2.`post_id` = wp1.`post_id` AND wp2.`meta_key`= '_wpsc_smaak'
array_length(array[[1, 2], [3, 4], [5, 6]], 1) ---> 3 array_length(array[[1, 2], [3, 4], [5, 6]], 2) ---> 2
SELECT table1.user_id, schools.value AS school, languages.value AS language FROM table1 LEFT JOIN table2 AS schools ON schools.user_id = table1.user_id AND schools.key = 'school' LEFT JOIN table2 AS languages ON languages.user_id = table1.user_id AND languages.key = 'language'
Select FFE.form_entry_id , Min( Case When FF.name = 'Foo' Then FFE.value End ) As `Foo` , Min( Case When FF.name = 'Bar' Then FFE.value End ) As `Bar` , ... From FormFieldEntry As FFE Join FormField As FF On FF.id = FFE.form_field_id Group By FFE.form_entry_id
SELECT * FROM table t1 JOIN table t2 ON t1.Title = t2.Title WHERE t1.Codes = '020' AND t2.Codes = '021'
select count(distinct l1.leadId) as accepted from leads l1 left join leads l2 on l1.leadId = l2.leadId and l1.date < l2.date where l2.date is null and l1.`change` like '%OK%'
select sum(case when col1 in ('a','b') then col2 end) as ab_sum, sum(case when col1 in ('c','d') then col2 end) as cd_sum from your_table
CREATE transaction_vw AS SELECT t.* ,CASE WHEN date_returned is null and (sysdate - date_returned_out) > DECODE(rental_code ,'R101', 1 ,'R103', 3 ,'R105', 5) THEN trunc(sysdate - date_returned_out) * 2 END AS fine_due FROM transaction t;
DELETE FROM table WHERE primary_key NOT IN (SELECT MIN(primary_key) FROM table GROUP BY secondID)
SELECT user_id,GROUP_CONCAT(id separator ",") as sets FROM my_table GROUP BY user_id;
Select Count(*) as CountRecord from Account
SELECT t.*, m.* FROM topic t LEFT JOIN (SELECT id_topic, MAX(created) AS created FROM message GROUP BY id_topic ) T2 ON t.id = T2.id_topic LEFT JOIN message m ON m.id_topic = T2.id_topic AND m.created = T2.created
SELECT Initialdate, OriginalTime, Gate1, Destindate, DestinationTime, Gate2, COUNT(1) as Freq FROM TABLE1 GROUP BY Initialdate, OriginalTime, Gate1, Destindate, DestinationTime, Gate2
Select EmailAddress,Birthday From table1 Where Birthday Between to_date('01-01-1946','MM-DD-YYYY') AND to_date('01-01-1988','MM-DD-YYYY');
SQL> select 2 translate( 3 initcap('newyork is a BEAUTIFUL city') 4 , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz' 5 , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 6 ) 7 from dual 8 / TRANS ----- NIABC SQL>
if($sql = $db->prepare('select zip from _zipcode where zip like ?')) { $sql->bind_param("s", $consulta); $sql->execute(); $sql->bind_result($zip); while ($sql->fetch()) { echo "Zip: $zip\n"; } $sql->close(); }
DECLARE @liststr VARCHAR(MAX); SET @liststr = '';
DELETE a.* FROM Aliases_Table a WHERE a.Aliase_ID IN ( SELECT c.Aliase_ID FROM CI_Aliases c WHERE c.CI_Ref = 3 )
SELECT n.id FROM news INNER JOIN news_tag_cross ntc ON ntc.newsid = n.id INNER JOIN tags t ON t.id = ntc.tagid GROUP BY n.id HAVING SUM(t.name = 'Dealer') > 0 AND SUM(t.name = 'Client') > 0;
$query = "INSERT INTO `user` (`fname`, `lname`, `email`, `password`, `permission`, `idcustomer`) select '" . $firstname . "', '" . $lastname . "', '" . $email . "', '" . $password . "', 'admin', " . $idcustomer . " from customer where idcustomer = 2 and (number_of_users - (select count(*) from user where idcustomer=2)) > 0 );";
Update Table_A Set A.ColX = B.Colx From Table_A A Join Table_B B on B.col1 = A.col1 and (B.col2 = A.col2 OR or B.col2 is null)
UPDATE test_t t SET t.complete_flag = (SELECT tt.complete_flag FROM test_t tt WHERE tt.component_id = 30101 AND tt.form_id = t.form_id) WHERE t.component_id = 30162;
id int auto_increment & primary key title varchar(*) content text or big varchar according to your needs posted_on datetime or timestamp posted_by int key representing the authors id
UPDATE my_table SET column_1 = COALESCE(column_1,'') , column_2 = COALESCE(column_2,'') ... WHERE column_1 IS NULL OR column_2 IS NULL OR ... -- avoid empty updates ;
Create Table admin.dupes( col1, col2, col3 ) AS select col1, col2,right(rtrim(col3),1) as col3 FROM table GROUP BY col1, col2,right(rtrim(col3),1) having COUNT(NULLIF(ltrim(col4), '')) =1 and COUNT(*)=2 delete from table where table.col4 is not null and LTRIM(table.col4)<>'' and exists (select 1 from dupes d where table.col1 = d.col1 and table.col2= d.col2 and right(rtrim(table.col3),1) = d.col3 ) Drop Table admin.dupes
SELECT wp_posts.post_title as name, address.meta_value as address, latitude.meta_value as lat, longitude.meta_value as lng, telephone.meta_value as telephone, ( 3959 * acos( cos( radians( '%s' ) ) * cos( radians( CONVERT( latitude.meta_value, DECIMAL( 10, 6 ) ) ) ) * cos( radians( CONVERT( longitude.meta_value, DECIMAL( 10, 6 ) ) ) - radians( '%s' ) ) + sin( radians( '%s' ) ) * sin( radians( CONVERT( latitude.meta_value, DECIMAL( 10, 6 ) ) ) ) ) ) AS distance FROM wp_posts LEFT JOIN wp_postmeta AS address ON( wp_posts.ID = address.post_id AND address.meta_key = '_dealer_address' ) LEFT JOIN wp_postmeta AS latitude ON( wp_posts.ID = latitude.post_id AND latitude.meta_key = '_dealer_latitude' ) LEFT JOIN wp_postmeta AS longitude ON( wp_posts.ID = longitude.post_id AND longitude.meta_key = '_dealer_longitude' ) LEFT JOIN wp_postmeta AS telephone ON( wp_posts.ID = telephone.post_id AND telephone.meta_key = '_dealer_telephone' ) WHERE wp_posts.post_type = 'dealers' HAVING distance < '%s' ORDER BY distance LIMIT 0 , 20
SELECT p.* FROM person p JOIN person_availability pa ON p.id = pa.person_id JOIN availability a ON a.id = pa.availability_id WHERE p.id = 1 AND a.day IN (1,2,3) GROUP BY p.id HAVING COUNT(a.day) = 3;
SET @sql = NULL; SELECT GROUP_CONCAT(DISTINCT CONCAT('MAX(CASE WHEN job_id = ''', job_id, ''' THEN start_time END) `', job_id, '_start`', ',', 'MAX(CASE WHEN job_id = ''', job_id, ''' THEN end_time END) `', job_id, '_end`' ) ORDER BY start_time ASC ) INTO @sql FROM t; SET @sql = CONCAT('SELECT exec_id, ', @sql, ' FROM t GROUP BY exec_id'); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt;
CREATE TABLE t1 (a integer PRIMARY KEY); CREATE FUNCTION test_exception() RETURNS boolean LANGUAGE plpgsql AS $$BEGIN INSERT INTO t1 (a) VALUES (1); INSERT INTO t1 (a) VALUES (2); INSERT INTO t1 (a) VALUES (1); INSERT INTO t1 (a) VALUES (3); RETURN TRUE; EXCEPTION WHEN integrity_constraint_violation THEN RAISE NOTICE 'Rollback to savepoint'; RETURN FALSE; END;$$; BEGIN; SELECT test_exception(); NOTICE: Rollback to savepoint test_exception ---------------- f (1 row) COMMIT; SELECT count(*) FROM t1; count ------- 0 (1 row)
SELECT user.name, photo_a.url AS profile_photo_url, photo_b.url as background_photo_url FROM user LEFT JOIN photo as photo_a ON user.profile_photo_uuid = photo_a.uuid LEFT JOIN photo as photo_b ON user.background_photo_uuid = photo_b.uuid WHERE user.uuid = SOME_ID
select min(category_id) as min_cat, group_concat(distinct category_id order by category_id) as category_list, bookmark_id from your_table group by bookmark_id
SELECT COUNT(C1), COUNT(C2), COUNT(C3) FROM table WHERE uid=2
Update statement Update `table_name` Set `field_name` = '{"notifyEmailSystem":1,"privacyProfileView":0,"privacyPhotoView":0,"privacyFriendsView":0,"privacyGroupsView":"","privacyVideoView":0,"notifyEmailMessage":1,"notifyEmailApps":1,"notifyWallComment":0}'
SELECT ... (SELECT ... ) AS 'Current - 1', (SELECT ... ) AS 'Current - 2', ... FROM ...
declare @searchvalue varchar(100) set nocount off set @searchvalue = 'Hello world' create table #tt (table_name varchar(64), column_name varchar(64), count int) select * into #t from ( select 'select ''' + a.table_name + ''' ''table_name'',''' + a.column_name + ''' ''column_name'', count(*) count from [' + a.table_name +'] where [' +a.column_name+']='''+@searchvalue +'''' + ' group by ['+ a.column_name+']' sqlstring from INFORMATION_SCHEMA.COLUMNS a join INFORMATION_SCHEMA.TABLES b on a.table_name = b.table_name and b.table_type = 'base table' where data_type = 'varchar' ) a --loop cursor Declare @sqlstring as nvarchar(500) Declare SqlCursor CURSOR FAST_FORWARD FOR SELECT sqlstring FROM #t OPEN SqlCursor FETCH NEXT FROM SqlCursor INTO @sqlstring WHILE @@FETCH_STATUS = 0 BEGIN insert #tt exec(@sqlstring) FETCH NEXT FROM SqlCursor INTO @sqlstring END CLOSE SqlCursor DEALLOCATE SqlCursor select * from #tt drop table #tt drop table #t
update orders set shipname = replace(replace(shipname, '[',''),']','')
select userId from myTable group by userId having count(*) = 91
Public Sub SaveAnswer(ByVal answer As String) Dim sql As String = "INSERT INTO [table1] (ans) VALUES (@Answer)" Using cn As New SqlConnection(getConnectionString()), _ cmd As New SqlCommand(sql) cmd.Parameters.Add("@Answer", SqlDbType.VarChar, 50).Value = answer cn.Open() cmd.ExecuteNonQuery() End Using End Sub Private Function getConnectionString() As String ''//normally read from a config file for this Return "Server=(local)\SQLEXPRESS;Database=testdb;Trusted_Connection=True;" End Function
select * from ( select addresses.phone, addresses.name, orders.order_number, count(orders.order_number) over (partition by addresses.phone) as cnt from orders inner join carts on orders.order_number = carts.id inner join address on carts.address_id = addresses.id ) t where cnt = 1;
SELECT u.id AS user_id, SUM(CASE WHEN p.`case` = 1 THEN p.amount ELSE 0 END) AS total_amount_case_1, SUM(CASE WHEN p.`case` = 2 THEN p.amount ELSE 0 END) AS total_amount_case_2 FROM users u LEFT JOIN payments p ON u.id = p.user_id GROUP BY u.user_id ORDER BY u.user_id ;
select userid, state, ctime as start_time, lead(ctime) over (partition by userid order by ctime) as end_time from userstate;
if not exists (select ID from where name = @...) insert into ... select SCOPE_IDENTITY() else (select ID from where name = @...)
Update app_chatmessage set seen='FALSE' where activity_id in ( SELECT app_activity.id FROM app_chatmessage JOIN app_activity ON app_chatmessage.activity_id = app_activity.id GROUP BY app_activity.name HAVING COUNT(app_chatmessage.owner_id) = 1 );
mysql> create table city ( id int not null auto_increment, name varchar(45), active tinyint, primary key (id), unique key (id, active)); mysql> create table person ( id int not null auto_increment, city_id int, active tinyint, primary key (id), foreign key (city_id, active) references city (id, active) on update cascade); mysql> insert into city (name, active) values ('New York', 1); mysql> insert into person (city_id, active) values (1, 1); mysql> select * from person; +----+---------+--------+ | id | city_id | active | +----+---------+--------+ | 1 | 1 | 1 | +----+---------+--------+ mysql> update city set active = 0 where id = 1; mysql> select * from person; +----+---------+--------+ | id | city_id | active | +----+---------+--------+ | 1 | 1 | 0 | +----+---------+--------+
SELECT COLUMN_NAME, DATA_TYPE, IS_NULLABLE, COLUMN_DEFAULT FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = 'tbl_name' [AND table_schema = 'db_name'] [AND column_name LIKE 'wild'] ORDER BY COLUMN_NAME
select * from (SELECT a, b, a+b as TOTAL FROM ( select 7 as a, 8 as b FROM DUAL UNION ALL select 8 as a, 8 as b FROM DUAL UNION ALL select 0 as a, 0 as b FROM DUAL) ) WHERE TOTAL <> 0 ;
SELECT t.Name, t.Street, t.City, t.State FROM table t INNER JOIN ( SELECT m.Name, MIN(m.Street + ';' + m.City + ';' + m.State) AS comb FROM table m GROUP BY m.Name ) x ON x.Name = t.Name AND x.comb = t.Street + ';' + t.City + ';' + t.State
INSERT INTO SASH1.VALIDOSES (col1, col2, ... ,coln) SELECT SWOSNAME, 'IBM', SWOSNAME, 'Y', SWPLATFORM FROM SASH1.LISTOSNAMES
// Generate random value for use as the 'state'. Mitigates // risk of CSRF attacks when this value is verified against the // value returned from the OAuth provider with the authorization // code. $_SESSION['state'] = rand(0,999999999); $authorizationUrlBase = 'https://accounts.google.com/o/oauth2/auth'; $redirectUriPath = '/oauth2callback.php'; // For example only. A valid value for client_id needs to be obtained // for your environment from the Google APIs Console at // http://code.google.com/apis/console. $queryParams = array( 'client_id' => '240195362.apps.googleusercontent.com', 'redirect_uri' => (isset($_SERVER['HTTPS'])?'https://':'http://') . $_SERVER['HTTP_HOST'] . $redirectUriPath, 'scope' => 'https://www.googleapis.com/auth/tasks', 'response_type' => 'code', 'state' => $_SESSION['state'], 'approval_prompt' => 'force', // always request user consent 'access_type' => 'offline' // obtain a refresh token ); $goToUrl = $authorizationUrlBase . '?' . http_build_query($queryParams); // Output a webpage directing users to the $goToUrl after // they click a "Let's Go" button include 'access_request_template.php';
DECLARE @Source table ( SourceUrl varchar(200) ) INSERT INTO @Source (SourceUrl) VALUES ('<a href="/publications/gss2007/gss2007_6879.ppt">Presentation (PowerPoint File)</a><br> <a href="http://xxx.xx.xxx.xx:xxxx/ramgen/Ipam/2007/smil/7-09-am1.smil">Presentation (Webcast)</a>'); -- INSPECT THIS, IF APPROPRIATE THEN SELECT S.SourceUrl AS Before , CHARINDEX('<a href="http://', S.SourceUrl) AS WhereFound , LEFT(S.SourceUrl, CHARINDEX('<a href="http://', S.SourceUrl) -1) AS After FROM @Source AS S WHERE S.SourceUrl LIKE '%smil%'; -- Only run this if you like the results of the above UPDATE S SET SourceUrl = LEFT(S.SourceUrl, CHARINDEX('<a href="http://', S.SourceUrl) -1) FROM @Source AS S WHERE S.SourceUrl LIKE '%smil%';
create trigger LimitTable on YourTableToLimit after insert as declare @tableCount int select @tableCount = Count(*) from YourTableToLimit if @tableCount > 50 begin rollback end go
CREATE VIEW MRClockByEmployee (ece_employee_ID, ece_most_recent_datetime) AS AS SELECT ece_employee_ID, MAX(ece_datetime) FROM employee_clock_events GROUP BY ece_employee_id; CREATE VIEW MRClockInfoByEmployee (ece_id, ece_employee_ID, ece_type, ece_datetime, ece_active) AS SELECT CE.* FROM employee_clock_events CE JOIN MRClockByEmployee MR ON CE.ece_employee_ID = MR.ece_employee_id AND CE.ece_datetime = MR.ece_most_recent_datetime SELECT ece_employee_id FROM MRClockInfoByEmployee WHERE type IN ('shift_start', 'shift_resume')
update X set data.modify('delete /date/entry[@insertedTime < sql:column("M.I")]') from xmltemp as X cross apply ( select dateadd(day, -2, max(E.X.value('@insertedTime', 'datetime'))) from X.data.nodes('/date/entry') as E(X) ) as M(I)
SELECT u.firstname, u.lastname, t.* FROM #users AS u CROSS APPLY (SELECT TOP 1 * FROM OtherTable AS ot WHERE u.userid = ot.userid ORDER BY something) t
MATCH (u)-[:VIEW]->(v) RETURN u.username,v.title
Update SomeTable set MyField = case when LEFT(MyField, 1) = '|' then '' else '|' end + MyField + case when Right(MyField, 1) = '|' then '' else '|' end
where (($P{parameter1} is null) or (user.id = $P{parameter1}))
update table t set pin = lpad(pin, 3, '0') where length(pin) < 3;
; with transponded as ( select ID, Type, Value from ( select ID, Name, cast (Cost as varchar(100)) Cost, cast (case when Included = 1 then 'Yes' else 'No' end as varchar(100)) Included from ProductInfo ) p unpivot (Value for Type in (Name, Cost, Included) ) a ) select t1.Type, t1.Value Product1, t2.Value Product2, t3.Value Product3 from transponded t1 left join transponded t2 on t1.Type = t2.Type and t2.id = 2 left join transponded t3 on t1.Type = t3.Type and t3.id = 3 where t1.id = 1
SELECT MIN([PrimaryCompensationBasis-Amount(USD)) FROM (SELECT TOP 50 PERCENT [PrimaryCompensationBasis-Amount(USD)] FROM qryEEGroup ORDER BY [PrimaryCompensationBasis-Amount(USD)]) tab;
SELECT NOBLOC, SUP_HA, AVG(TigehaBOP) AS NOM_BOP, AVG(TigehaPET) AS NOM_PET, AVG(TigehaSEP) AS NOM_SEP, AVG(VolhaBOP) AS VOL_BOP, AVG(VolhaPET) AS VOL_PET, AVG(VolhaSEP) AS VOL_SEP FROM Table GROUP BY NOBLOC, SUP_HA
SELECT SERVERPROPERTY ('InstanceName')
SELECT state, max(orderamount) AS amount FROM table GROUP BY state HAVING amount > 15;
SELECT * FROM Reps CROSS APPLY ( SELECT * FROM Invoices WHERE Invoices.RepID = Reps.ID AND Invoices.InvoiceID < Reps.MaxInvoiceID ) AS CA ;
CommandText = "Insert into FileMaster(Subject,FileID) Values('" & obj.Subject & "','" & obj.FileID & "')
select sum(case when ws.ID_WorkflowType = 1 then 1 else 0 end) as cntCM_PRWK , sum(case when ws.ID_WorkflowType = 3 then 1 else 0 end) as cntCM_CMQ from dbo.CaseWorkflow cw join vew_CasePersonnelSystemIDs vcps on cw.ID_Case = vcps.ID_Case join dbo.WorkflowStates ws on ws.ID_WorkflowState = cw.ID_WorkflowState where CMSUID = @nSUID
DoCmd.SetWarnings = False DoCmd.RunSQL ... DoCmd.SetWarnings = True
select * from table1 where key not in (select tab1 from table2)
select tid from teacher t where not exists ( select 'x' from course_score cs inner join course c on cs.cid = c.cid where c.tid = t.tid group by c.cid having avg(score) <= 80 );
CREATE PROCEDURE GetData(@key int = null) BEGIN SELECT * FROM Table WHERE (@Key Is NULL or id = @Key) END
select lPE.Person, Sum(lpe.ethnicity) as SumOfIDs, Ethnicity = stuff((select ', ' + E.Name as [text()] from _linkPersonEthnicity lPE2 join _Ethnicities e on lpe2.Ethnicity = e.id where lpe2.Person = lPE.Person for xml path('') ), 1, 2, '') from _linkPersonEthnicity lPE group by lPE.Person;
CREATE OR REPLACE TRIGGER trigger_name BEFORE UPDATE of unique_id_to_match ON table FOR EACH ROW AS BEGIN select NVL( (SELECT b.unique_to_update_from FROM table b WHERE B.other_unique_id = :new.unique_id_to_match ), 0) into :new.unique_to_update FROM dual; END;
WITH q AS ( SELECT CAST('<root><node>1</node></root>' AS XML) AS doc ) SELECT doc.value('(/root/node)[1]', 'INT'), doc.value(N'(/root/node)[1]', 'INT') FROM q
select c1, c2, c3 from form_name where data_created >'1273446000' and data_creazione<'1274569200' group by c1,c2, c3 having count(c3)>1 INTERSECT select c1, c2, c3 from form_name where data_created>'1272236400' and data_creazione<'1274569200' group by c1,c2, c3 having count(c3)>2
ObjectQuery<Article> articles = (db as IObjectContextAdapter).ObjectContext.CreateObjectSet<Article>(); articles = articles.OrderBy("it." + orderBy + ((bool)desc ? " desc" : "")); IQueryable<Article> iArticles = articles; if(!String.IsNullOrEmpty(search)) iArticles = iArticles.Where(a => a.Title.Contains(search) || a.FullArticle.Contains(search)); Response.AppendHeader("X-Total-Row-Count", iArticles.Count().ToString()); return PartialView(iArticles.Skip(start).Take((int)itemsPerPage));
WITH cte2 AS (SELECT TOP (100) PERCENT ContractServices_1.ContractServiceID, ContractServices_1.ContractID, ContractServices_1.ServiceType, ContractServices_1.QuoteID, ContractParts_1.PartDescription, ServiceCallCharges_1.ChargeDescription, ServiceCalls_1.ServiceCallID, ServiceCallCharges_1.ShowOnFieldTicket, ContractServices_1.Renewed FROM dbo.ContractServices AS ContractServices_1 INNER JOIN dbo.ContractParts AS ContractParts_1 ON ContractServices_1.ContractServiceID = ContractParts_1.ContractServiceID INNER JOIN dbo.ServiceCallCharges AS ServiceCallCharges_1 ON ServiceCallCharges_1.ChargeDescription LIKE '%' + ContractParts_1.PartDescription + '%' INNER JOIN dbo.ServiceCalls AS ServiceCalls_1 ON ServiceCallCharges_1.ServiceCallID = ServiceCalls_1.ServiceCallID AND ContractServices_1.ContractID = ServiceCalls_1.ContractID AND ContractParts_1.ContractID = ServiceCalls_1.ContractID WHERE (ServiceCallCharges_1.ChargeDescription LIKE ' -%' OR ServiceCallCharges_1.ChargeDescription LIKE '%') AND (ServiceCallCharges_1.ShowOnFieldTicket = 'True') AND (ContractServices_1.Renewed = 'True') GROUP BY ContractServices_1.ContractServiceID, ContractServices_1.ContractID, ContractServices_1.ServiceType, ContractServices_1.QuoteID, ContractParts_1.PartDescription, ServiceCallCharges_1.ChargeDescription, ServiceCalls_1.ServiceCallID, ContractServices_1.Renewed, ServiceCallCharges_1.ShowOnFieldTicket ORDER BY ContractServices_1.ContractID), cte1 AS (SELECT TOP (100) PERCENT dbo.ContractServices.ContractServiceID, dbo.ContractServices.ContractID, dbo.ContractServices.ServiceType, dbo.ContractServices.QuoteID, dbo.ContractParts.PartDescription, dbo.ServiceCallCharges.ChargeDescription, dbo.ServiceCalls.ServiceCallID, dbo.ServiceCallCharges.ShowOnFieldTicket, dbo.ContractServices.Renewed FROM dbo.ContractServices INNER JOIN dbo.ContractParts ON dbo.ContractServices.ContractServiceID = dbo.ContractParts.ContractServiceID INNER JOIN dbo.ServiceCallCharges ON dbo.ServiceCallCharges.ChargeDescription LIKE '%' + dbo.ContractParts.PartDescription + '%' INNER JOIN dbo.ServiceCalls ON dbo.ServiceCallCharges.ServiceCallID = dbo.ServiceCalls.ServiceCallID AND dbo.ContractServices.ContractID = dbo.ServiceCalls.ContractID AND dbo.ContractParts.ContractID = dbo.ServiceCalls.ContractID WHERE (dbo.ServiceCallCharges.ChargeDescription LIKE ' -%' OR dbo.ServiceCallCharges.ChargeDescription LIKE '%') AND (dbo.ServiceCallCharges.ShowOnFieldTicket = 'False') AND (dbo.ContractServices.Renewed = 'True') GROUP BY dbo.ContractServices.ContractServiceID, dbo.ContractServices.ContractID, dbo.ContractServices.ServiceType, dbo.ContractServices.QuoteID, dbo.ContractParts.PartDescription, dbo.ServiceCallCharges.ChargeDescription, dbo.ServiceCalls.ServiceCallID, dbo.ContractServices.Renewed, dbo.ServiceCallCharges.ShowOnFieldTicket ORDER BY dbo.ContractServices.ContractID) SELECT TOP (100) PERCENT cte1_1.ContractServiceID, cte1_1.ContractID, cte1_1.ServiceType, cte1_1.QuoteID, cte1_1.PartDescription, cte1_1.ChargeDescription, cte1_1.ServiceCallID, cte1_1.ShowOnFieldTicket, cte1_1.Renewed FROM cte1 AS cte1_1 LEFT OUTER JOIN cte2 AS cte2_1 ON cte1_1.PartDescription = cte2_1.PartDescription AND cte1_1.ContractID = cte2_1.ContractID WHERE (cte2_1.ShowOnFieldTicket IS NULL) GROUP BY cte1_1.ContractServiceID, cte1_1.ContractID, cte1_1.ServiceType, cte1_1.QuoteID, cte1_1.PartDescription, cte1_1.ChargeDescription, cte1_1.ServiceCallID, cte1_1.ShowOnFieldTicket, cte1_1.Renewed, cte2_1.ShowOnFieldTicket ORDER BY cte1_1.ContractID
select t.* from (select t.*, row_number() over (partition by ordernum order by createdon desc) as seqnum from table t ) t where seqnum = 1;
SELECT user.id, campaign_id, user_id FROM user LEFT JOIN email_solus ON email_solus.user_id=user.id WHERE user.id NOT IN ( SELECT user_id FROM email_solus WHERE campaign_id = 3 )
update table1 inner join table2 on (//join condition) set table1.column1=table2.column2 where // the clause
SELECT A.* FROM YourTable A INNER JOIN SPLIT(@Status,',') B ON A.Status = B.Value
SELECT c.[id_Cust] ,[Name] ,[Omset] ,[Colour] ,[seq] ,(SELECT a.[Address],a.[no1],a.[no2] FROM address_BSM a WHERE a.id_cust = c.id_cust FOR XML PATH ('address_bsm'), TYPE) FROM [dbo].[Customer_BSM] c FOR XML PATH ('customer_bsm')
If coalesce( expr1, expr2, ... expr_n ) is not null then do something end if;
select user_id, req_time, item, v[1] as value1, v[2] as value2 from ( select t.*, ( select array[ coalesce(sum(is_active::integer), 0), count(*) ] as v from t s where user_id = t.user_id and item = t.item and req_time <= t.req_time - interval '1 hour' ) as v from t ) s order by req_time, user_id, item
;WITH emps AS ( SELECT [EmpName] AS 'EmployeeName', [EndYear] - [Begin Year] AS 'TotalYears' FROM [dbo].[Employee] ) SELECT * FROM emps WHERE TotalYears = (SELECT MAX(TotalYears) FROM emps)
$like_city = preg_replace('//', '%', $search_city); // Hyderbad => %H%y%d%e%r%b%a%d% $sql = "SELECT * FROM jobs_tbl WHERE job_city LIKE '$like_city' "
$ java -jar path/to/gerrit.war reindex -d path/to/gerrit-site-dir
SELECT T1.Animal_ID, T1.TestDate, (SELECT min(TestDate) FROM Exams WHERE Animal_ID = T1.Animal_ID AND TestDate > T1.TestDate GROUP BY Animal_ID ) AS Next_TestDate, datediff((SELECT min(TestDate) FROM Exams WHERE Animal_ID = T1.Animal_ID AND TestDate > T1.TestDate GROUP BY Animal_ID ), T1.TestDate) AS Elapsed_Days FROM Exams T1 ORDER BY Animal_ID, TestDate;
SELECT WMSYS.WM_CONCAT('PARTITION TABLE_NAME_' || TO_CHAR(sysdate + (level-1)/24, 'yyyymmddHH24') || ' VALUES LESS THAN (TIMESTAMP''' || TO_CHAR(sysdate + (level)/24, 'yyyy-mm-dd HH24') || ':00:00'') ') OUTPUT FROM DUAL CONNECT BY level <= 24 -----------------------------OUTPUT---------------------------------------- OUTPUT PARTITION TABLE_NAME_2016041907 VALUES LESS THAN (TIMESTAMP'2016-04-19 08:00:00') ,PARTITION TABLE_NAME_2016041908 VALUES LESS THAN (TIMESTAMP'2016-04-19 09:00:00') ,PARTITION TABLE_NAME_2016041909 VALUES LESS THAN (TIMESTAMP'2016-04-19 10:00:00') ,PARTITION TABLE_NAME_2016041910 VALUES LESS THAN (TIMESTAMP'2016-04-19 11:00:00') ,PARTITION TABLE_NAME_2016041911 VALUES LESS THAN (TIMESTAMP'2016-04-19 12:00:00') ,PARTITION TABLE_NAME_2016041912 VALUES LESS THAN (TIMESTAMP'2016-04-19 13:00:00') ,PARTITION TABLE_NAME_2016041913 VALUES LESS THAN (TIMESTAMP'2016-04-19 14:00:00') ,PARTITION TABLE_NAME_2016041914 VALUES LESS THAN (TIMESTAMP'2016-04-19 15:00:00') ,PARTITION TABLE_NAME_2016041915 VALUES LESS THAN (TIMESTAMP'2016-04-19 16:00:00') ,PARTITION TABLE_NAME_2016041916 VALUES LESS THAN (TIMESTAMP'2016-04-19 17:00:00') ,PARTITION TABLE_NAME_2016041917 VALUES LESS THAN (TIMESTAMP'2016-04-19 18:00:00') ,PARTITION TABLE_NAME_2016041918 VALUES LESS THAN (TIMESTAMP'2016-04-19 19:00:00') ,PARTITION TABLE_NAME_2016041919 VALUES LESS THAN (TIMESTAMP'2016-04-19 20:00:00') ,PARTITION TABLE_NAME_2016041920 VALUES LESS THAN (TIMESTAMP'2016-04-19 21:00:00') ,PARTITION TABLE_NAME_2016041921 VALUES LESS THAN (TIMESTAMP'2016-04-19 22:00:00') ,PARTITION TABLE_NAME_2016041922 VALUES LESS THAN (TIMESTAMP'2016-04-19 23:00:00') ,PARTITION TABLE_NAME_2016041923 VALUES LESS THAN (TIMESTAMP'2016-04-20 00:00:00') ,PARTITION TABLE_NAME_2016042000 VALUES LESS THAN (TIMESTAMP'2016-04-20 01:00:00') ,PARTITION TABLE_NAME_2016042001 VALUES LESS THAN (TIMESTAMP'2016-04-20 02:00:00') ,PARTITION TABLE_NAME_2016042002 VALUES LESS THAN (TIMESTAMP'2016-04-20 03:00:00') ,PARTITION TABLE_NAME_2016042003 VALUES LESS THAN (TIMESTAMP'2016-04-20 04:00:00') ,PARTITION TABLE_NAME_2016042004 VALUES LESS THAN (TIMESTAMP'2016-04-20 05:00:00') ,PARTITION TABLE_NAME_2016042005 VALUES LESS THAN (TIMESTAMP'2016-04-20 06:00:00') ,PARTITION TABLE_NAME_2016042006 VALUES LESS THAN (TIMESTAMP'2016-04-20 07:00:00') -----------------------------------------------------------------------------
select field1 , f2 , f3 , 'FLOW'||trim(to_char(rnk)) from (select field1 , f2 , f3 , sum(case when f3 = 1 then 1 else 0 end) over (order by field1, f3 range between unbounded preceding and current row) rnk from your_table )
bcp "SELECT * FROM CustomerTable" queryout "c:\temp\CustomerTable.bcp" -N -S SOURCESERVERNAME -T bcp TargetDatabaseTable in "c:\temp\CustomerTable.bcp" -N -S TARGETSERVERNAME -T -E
SELECT display_order AS CurrentDisplayOrder, ROW_NUMBER() OVER (ORDER BY display_order) AS NewDisplayOrder FROM YourTable ORDER BY display_order
DECLARE @PersonID INT INSERT INTO dbo.Person (Name, Address) VALUES (@Name, @Address) SET @PersonID = SCOPE_IDENTITY() INSERT INTO dbo.Product_Data (PersonID, Product, Quantity, DueDate) VALUES (@PersonID, @Product, @Quantity, @DueDate)
update mytable set a = first_part(gen.id), b = second_part(gen.id), c = third_path(gen.id) from ( select genid() as genid, id from mytable where package_id = 10 ) gen where mytable.id = gen.id; --and package_id = 10 -- This predicate is no longer necessary as the subquery -- already filters on package_id, as Erwin mentioned
delete from posts where timestampdiff(hour, current_timestamp, time_published)>=4
SELECT * FROM COM WHERE DateofPurchase between trunc((trunc(sysdate,'MM')-1),'MM') and trunc(sysdate,'MM')-1 trunc((trunc(sysdate,'MM')-1),'MM') --> last_month_fist_day trunc(sysdate,'MM')-1 --> last_month_last_day
SELECT M.ConversationID, MAX(CASE WHEN M.DateTime = X.FirstRow THEN M.Subject END) AS Subject, CAST(COALESCE(MAX(CASE WHEN M.DateTime = X.LastRowSentByOtherUser THEN M.DateTime END),X.LastRow) AS DateTime)AS LastTime, MAX(CASE WHEN M.DateTime = X.LastRow THEN M.Message END) AS Message, MAX(CASE WHEN FromID = 1 THEN ToID ELSE FromID END) AS OtherParticipantId FROM messages M JOIN ( SELECT ConversationID, MIN(DateTime) AS FirstRow, MAX(DateTime) AS LastRow, MAX(CASE WHEN FromID<>1 THEN DateTime END) AS LastRowSentByOtherUser FROM messages WHERE FromID=1 OR ToID=1 GROUP BY ConversationID ) X ON X.ConversationID = M.ConversationID AND (M.DateTime IN (X.FirstRow, X.LastRow, X.LastRowSentByOtherUser)) GROUP BY M.ConversationID HAVING MAX(CASE WHEN M.DateTime = X.LastRowSentByOtherUser THEN M.DateTime END) IS NOT NULL
SELECT DISTINCT LOWER(SUBSTR(firstName,1,1)) firstChars FROM your_table WHERE LOWER(SUBSTR(firstName,1,1)) IN ('a','b','c','d','e','f','g','h','i','j', 'k','l','m','n','o','p','q','r','s','t', 'u','v','w','x','y','z') ORDER BY firstChars
SELECT strftime('%s','now','localtime')-strftime('%s','2011-08-18 22:49:00') as date;
UPDATE T_Example SET MT_Lang_DE = upper(substring(MT_Lang_DE, 1, 1)) + substring(lower(MT_Lang_DE), 2, length(MT_Lang_DE)-1)
DROP TABLE dbo.Report CREATE TABLE dbo.Report ( PatientID varchar(10) NOT NULL, ReviewId int NOT NULL ) DECLARE c_patients CURSOR READ_ONLY FOR SELECT DISTINCT PatientID, ReviewId FROM dbo.BloodSampleData ORDER BY PatientID ASC DECLARE @patient_id varchar(10), @review_id int OPEN c_patients FETCH NEXT FROM c_patients INTO @patient_id, @review_id WHILE (@@fetch_status <> -1) BEGIN IF (@@fetch_status <> -2) BEGIN INSERT INTO dbo.Report (PatientID, ReviewId) VALUES (@patient_id, @review_id) DECLARE c_reviews CURSOR READ_ONLY FOR SELECT [Date], [BloodSampleID] FROM dbo.BloodSampleData WHERE PatientID = @patient_id AND ReviewId = @review_id ORDER BY [Date] ASC DECLARE @date DATE, @blood_sample_id INT, @review_num int OPEN c_reviews SET @review_num = 0 FETCH NEXT FROM c_reviews INTO @date, @blood_sample_id WHILE (@@fetch_status <> -1) BEGIN IF (@@fetch_status <> -2) BEGIN IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'Report' AND COLUMN_NAME LIKE '%' + CAST(@review_num AS VARCHAR)) EXEC ('ALTER TABLE dbo.Report ADD [Date' + @review_num + '] date, [BloodSampleID' + @review_num + '] int') DECLARE @update_sql VARCHAR(MAX) SET @update_sql ='UPDATE dbo.Report SET [Date' + CAST(@review_num AS VARCHAR) + '] = CONVERT(date, ''' + CONVERT(varchar, @date, 120) + ''', 120), [BloodSampleID' + CAST(@review_num AS VARCHAR) + '] = ' + CAST(@blood_sample_id AS VARCHAR) + ' WHERE PatientID = ''' + @patient_id + ''' AND ReviewId = ' + CAST(@review_id AS varchar) PRINT @update_sql EXEC (@update_sql) SET @review_num = @review_num + 1 END FETCH NEXT FROM c_reviews INTO @date, @blood_sample_id END CLOSE c_reviews DEALLOCATE c_reviews END FETCH NEXT FROM c_patients INTO @patient_id, @review_id END CLOSE c_patients DEALLOCATE c_patients GO SELECT * FROM dbo.Report
1, 1, 1 1, 6, 2
select s.*, f.firma_adi, (select SUM(sd.fiyat) from fuar_sozlesme1_detay fd where sd.sozlesme_id = s.id ) as konak, (select SUM(ss.fiyat) from fuar_sozlesme1_sponsor ss where (ss.sozlesme_id = s.id) ) as sponsor from fuar_sozlesme1 s inner join fuar_firma_2012 f on (s.cari = f.cari) order by s.id DESC
create table numbers ( number int not null check(number >= 1234 and number <= 4523), ... ) create table numbers ( number int not null, check(number >= 1234 and number <= 4523), ... ) create table numbers ( number int not null, constraint number_range_check check(number >= 1234 and number <= 4523), ... )
SELECT Widget, to_char(timestamp_,'YYYY-MM-DD'), Count(Widget) FROM Widget WHERE timestamp_ BETWEEN to_date('YYYY-MM-DD HH24:MI:SS','%date1%') AND to_date('YYYY-MM-DD HH24:MI:SS','%date2%') AND action LIKE 'reject' GROUP BY Widget, to_char(timestamp_,'YYYY-MM-DD') HAVING Count(Widget) > 1;
INSERT INTO basic_data (customer,total_value) SELECT customer, total_value FROM ( SELECT customer, SUM(sales) total_value FROM sales a GROUP BY customer ) c ON DUPLICATE KEY UPDATE total_value = c.total_value
SELECT DATE_FORMAT(dateadded, '%y-%m-%d') FROM my_table
select datediff(second, date1, date2) / 60.0 as diff_in_minutes
BEGIN if (@ANSI_Attachment = 1) begin --Copy temp attachments to sysmail_attachments INSERT INTO sysmail_attachments(mailitem_id, filename, filesize, attachment) SELECT @mailitem_id, filename, filesize, convert(varbinary(max), substring( -- remove BOM mark from unicode convert(varchar(max), CONVERT (nvarchar(max), attachment)), 2, DATALENGTH(attachment)/2 ) ) FROM sysmail_attachments_transfer WHERE uid = @temp_table_uid end else begin --Copy temp attachments to sysmail_attachments INSERT INTO sysmail_attachments(mailitem_id, filename, filesize, attachment) SELECT @mailitem_id, filename, filesize, attachment FROM sysmail_attachments_transfer WHERE uid = @temp_table_uid end END `
SELECT a.Id,a.Value,a.Year,MAX(b.Value) FROM tableA A JOIN tableB B ON A.Year = b.Year AND b.Value < A.Value GROUP BY a.Id,a.Value,a.Year
SELECT m.match_id FROM match m WHERE m.match_id NOT IN ( SELECT ml.match_id FROM message_log ml )
SELECT MAX(ID) FROM YourTable WHERE Result = 'PASS' GROUP BY `GROUP`;
SELECT t.inv, MAX(CASE WHEN t.description = 'CHARGES' THEN t.amount ELSE NULL END) AS charges, MAX(CASE WHEN t.description = 'FREIGHT' THEN t.amount ELSE NULL END) AS freight, MAX(CASE WHEN t.description = 'INSURANCE' THEN t.amount ELSE NULL END) AS insurance FROM YOUR_TABLE t GROUP BY t.inv ORDER BY t.inv
-- declare a helper table variable DECLARE @TableOfID TABLE (OldID INT, NewID INT) -- insert rows into the "newtable" - OUTPUT the inserted ID (assuming it's INT IDENTITY) -- and the "old ID" into the table variable INSERT INTO dbo.newTable(OldID, Col1, Col2, ..., ColN) OUTPUT Inserted.ID, Inserted.OldID INTO @TableOfID(NewID, OldID) SELECT ID, Col1, Col2, .., ColN FROM dbo.oldtable WHERE ..... (some WHERE conditions here) -- update the "oldtable" UPDATE dbo.oldtable SET NewID = t.NewID FROM @TableOfID t WHERE dbo.oldtable.ID = t.OldID
CREATE OR REPLACE FUNCTION dwh.dim_table_notification() RETURNS void LANGUAGE plpgsql AS $func$ DECLARE myschema text; BEGIN -- truncate simply goes here: TRUNCATE dwh.prod_table_notify; FOR myschema IN SELECT quote_ident(table_schema) FROM information_schema.tables WHERE table_name IN ('dim_loan_type', 'dim_acct_type') AND table_schema NOT LIKE 'pg_%' AND table_schema NOT IN ('information_schema', 'ad_delivery', 'dwh', 'users', 'wand', 'ttd') ORDER BY table_schema LOOP EXECUTE ' INSERT INTO dwh.prod_table_notify (userid, acct_type_id, acct_type, acct_type_desc, loan_type) SELECT '''|| myschema ||''', loan_type_id, loan_type::varchar(10) , loan_type_desc::varchar(50), term_code, 1 AS loan_type FROM '|| myschema || '.dim_loan_type WHERE term_code IS NULL UNION ALL SELECT '''|| myschema ||''' AS userid, acct_type_id, acct_type::varchar(10) , acct_type_desc::varchar(50), term_code, 0 AS loan_type FROM '|| myschema || '.dim_acct_type WHERE term_code IS NULL'; END LOOP; END $func$
Date mmsDate = new Date(dateVal * 1000);
;with FundCounts As ( Select FundID, Count(*) * 0.2 As TopTwentyCount From Finance Group By FundID ) select F.FundID, Sum(Value) as TopTwentyValueSum from Finance F inner join FundCounts FC on F.FundID = FC.FundID where F.[Rank] <= FC.TopTwentyCount group by F.FundID
SELECT rec.id, title.name FROM Records rec LEFT JOIN Titles title ON title.record_id = rec.id and title.language='de'; SELECT rec.id, title.name FROM Records rec LEFT JOIN Titles title ON title.record_id = rec.id and title.language='en'; ID NAME 1 ACHTUNG 2 (null) ID NAME 1 Warning 2 Ambulance
Sub LoadSheet() Dim accappl As Access.Application Dim strpathdb As String Dim strpathxls As String Dim myrange As String, myrow1 As String, myrow2 As String myrow1 = Range("a1").End(xlDown).End(xlDown).Row myrow2 = Range("a1").End(xlDown).End(xlDown).End(xlDown).Row myrange = ActiveSheet.Name & "!A" & myrow1 & ":H" & myrow2 'path to the database strpathdb = "X:\cre\dep\STRAT_PLAN\StratPlan.mdb" 'path to the upload file strpathxls = ActiveWorkbook.FullName Set accappl = New Access.Application accappl.OpenCurrentDatabase strpathdb accappl.DoCmd.TransferSpreadsheet transfertype:=acImport, _ tablename:="Tbl_Growth_Metric", _ Filename:=strpathxls, Hasfieldnames:=True, _ Range:=myrange, SpreadsheetType:=5 'The Spreadsheet type = 5 specifies an Excel 5.0/7.0 file 'format MsgBox "All records are loaded" accappl.Quit End Sub
select utl_raw.cast_to_number(low_value), utl_raw.cast_to_number(high_value) from cols where column_name = '<column_name>' and table_name = '<table_name>'
--Create table of dummy data create table #person ( personID integer IDENTITY(1,1) NOT NULL, name varchar(255) not null, dob date, father integer ); INSERT INTO #person(name,dob,father)Values('Pops','1900/1/1',NULL); INSERT INTO #person(name,dob,father)Values('Grandma','1903/2/4',null); INSERT INTO #person(name,dob,father)Values('Dad','1925/4/2',1); INSERT INTO #person(name,dob,father)Values('Uncle Kev','1927/3/3',1); INSERT INTO #person(name,dob,father)Values('Cuz Dave','1953/7/8',4); INSERT INTO #person(name,dob,father)Values('Billy','1954/8/1',3); DECLARE @OldestPerson INT; SET @OldestPerson = 1; -- Set this value to the ID of the oldest person in the family WITH PersonHierarchy (personID,Name,dob,father, HierarchyLevel) AS ( SELECT personID ,Name ,dob ,father, 1 as HierarchyLevel FROM #person WHERE personID = @OldestPerson UNION ALL SELECT e.personID, e.Name, e.dob, e.father, eh.HierarchyLevel + 1 AS HierarchyLevel FROM #person e INNER JOIN PersonHierarchy eh ON e.father = eh.personID ) SELECT * FROM PersonHierarchy ORDER BY HierarchyLevel, father; DROP TABLE #person;
select column_name from information_schema.columns where table_name = 'yourTableName' and data_type like '%date%'
;WITH Payments AS ( SELECT CARHARTAR, CARHARREFNO, CARHARCARKOD, CARHARCARUNVAN, CARHARACIKLAMA, CARHARTUTAR, ROW_NUMBER() OVER(PARTITION BY CARHARCARKOD ORDER BY CARHARTAR DESC) [RowNumber] FROM CARHAR WHERE CARHARTIPI IN (2, 4) AND CARHARISTIPNO IN (2, 6) AND CARHARCARKOD NOT LIKE 'W%' AND CARHARCARKOD NOT LIKE 'Z%' AND CARHARGCFLAG = 2 AND CARHARIADEFLAG = 0 ) SELECT CARHARTAR, CARHARREFNO, CARHARCARKOD, CARHARCARUNVAN, CARHARACIKLAMA, CARHARTUTAR FROM Payments WHERE RowNumber = 1 ORDER BY CARHARTAR
select movie.name from movie join moviehascast mc on mc.movieid = movie.id join cast on cast.id = mc.castid where cast.name in (@actor1, @actor2) group by movie.name having count(1) = @numberOfActorsSearched
UPDATE [rs_DEVICES] SET [device] = dbo.pad_zero(12,[device]) WHERE LEN([device]) < 12 AND NOT EXISTS ( SELECT 1 FROM rs_DEVICES r1 WHERE r1.device = dbo.pad_zero(12,[device]) )
SELECT Place.*, IF(IFNULL(MIN(place_discount.idDiscount),0)>0,1,0) AS hasDiscount FROM place LEFT JOIN place_discount ON Place.id=place_discount.idPlace GROUP BY Place.id
SELECT fruits FROM tblEatables WHERE EatID NOT IN (SELECT Eatbles_Id WHERE Edible_Status = 1)
select t1.ID1 , t2.grade , t1.ID2 , t3.grade from Friends t1 join Highschooler t2 on t1.ID1 = t2.ID join Highschooler t3 on t1.ID2 = t3.ID
IF @DefaultID IS NULL
CREATE FUNCTION getDescription1 (@code varchar(32)) RETURNS nvarchar(1000) AS DECLARE @p_str NVARCHAR(1000) SET @p_str = '' SELECT @p_str = @p_str + (specName+': '+specStr+', ') FROM productSpecs where specStr<>'' and visibility=1 and productCode=@code RETURN LEFT(@p_str, len(@p_str) -1)
Map(x => x.BirthDate) .Column("dtBirthDate") .Not.Nullable() .CustomSqlType("smalldatetime") .CustomType("datetime")
select * from releases, (select min(id) as x, max(id) as y from releases where released > "2011-12-01" ) as D where id between D.x and D.y limit 0,30
SELECT * FROM test_table WHERE test_column != ASCIISTR(test_column)
select p.* from person p where p.datetime = (select max(p2.datetime) from person p2 where p2.name = p.name);
select time_decimal ,cast(cast(cast(time_decimal as int) as varchar)+ ':'+cast(cast((time_decimal - cast(time_decimal as int)) * 60 as int) as varchar)+ ':'+cast(cast(((time_decimal - cast(time_decimal as int)) * 60- cast((time_decimal - cast(time_decimal as int)) * 60 as int)) * 60 as int) as varchar) as time) as real_time from time1
select * from UserLog l1 where Operation = 'Enter' and not exists(select * from UserLog l2 where l1.user = l2.user and l2.Operation = 'Exit' and l2.Time > l1.Time)
SELECT * FROM data RIGHT JOIN ( select 2 as o, 2 as p union all select 4, 6 ) as t ON p = set1_value AND o = set2_value where id is null;
SELECT [item_id], STUFF( (SELECT ',' + [item] FROM TableName WHERE [item_id] = a.[item_id] AND item_id = 82 FOR XML PATH ('')) , 1, 1, '') AS NamesList FROM TableName AS a WHERE item_id = 82 GROUP BY [item_id]
<cfset sortable_column_list = "age,height,weight,first_name"> <cfquery ...> SELECT first_name, age, height, weight FROM people ORDER BY <cfif ListFindNoCase(sortable_column_list, url.sort_column)>#url.sort_column#<cfelse>first_name</cfif> </cfquery>
CREATE TRIGGER dbo.uniqueUserQuestion ON dbo.submit_Answer INSTEAD OF INSERT AS BEGIN SET NOCOUNT ON IF EXISTS ( SELECT 1 FROM dbo.submit_Answer T INNER JOIN INSERTED I ON T.user_name = I.user_name AND T.question_id = I.question_id ) BEGIN -- Do dupe handling here PRINT 'duplicate' raiserror('cant submit answer to same question twice') return END -- actually add it in INSERT INTO dbo.submit_Answer SELECT * FROM INSERTED I END GO
INSERT INTO [dbo].[Users] ( [Name] ,[Surname] ,[Email] ,[Password] ,[Status] ,[DepartmentId] ,[Guid] ) VALUES ( 'david' ,'van staden' ,'ds@ik.io' ,123123 ,0 ,8 ,newid() )
select m.name, count (distinct m2.name) from Membership m join Membership m2 on m.clubName = m2.clubName group by m.name order by count (distinct m2.name) desc
DECLARE TYPE table1 IS TABLE OF NUMBER INDEX BY PLS_INTEGER; TYPE table2 IS TABLE OF table1 INDEX BY PLS_INTEGER; var_i table2 BEGIN var_i (1) (1) := 1; var_i (1) (2) := 12; END;
select t1.* from table1 t1 left join table2 t2 on substring_index(t2.path, '/', -1) = substring_index(t1.path, '/', -1) and t2.frn = t1.frn and t2.byte = t1.byte where t2.path is null or t2.frn is null or t2.byte is null
select t.*, (case when expiry_date > @somdate and row_number() over (partition by cod_suc, cod_ramo, (case when expiry_date > @somdate then 1 else 0 end) order by id_pv desc) as col1 then 1 else 0 end) from table t;
EXEC xp_cmdshell 'bcp "EXEC DatabaseName.dbo.pn_FlatProductXML ''KA-0009'' " queryout "C:\test.txt" -T -c '
SELECT `age` FROM `users` WHERE `userid`= (SELECT `id` FROM `second` WHERE `second`.`name` = 'Berna')
DECLARE i INT DEFAULT 1; DECLARE count DEFAULT ExtractValue(xml, 'count(//child)'); WHILE i <= count DO SELECT ExtractValue(xml, '//child[$i]'); SET i = i+1; END WHILE
CREATE FUNCTION [dbo].[ufn_test] ( @deptid INT ) RETURNS TABLE AS RETURN (SELECT * FROM workorder WHERE deptid = @deptid);
$sql = "INSERT INTO table(column1, column2) VALUES(:value1, :value2)"; $result = DB::query(Database::INSERT, $sql)->bind(':value1', $val1)->bind(':value2', $val2)->execute(); echo $result[0]; // last_insert_id echo $result[1]; // total rows inserted
SELECT MIN(value_0-value) as MinDiff FROM TableName WHERE value_0>=value
DECLARE @test TABLE ( SampleCol varchar(50) ) INSERT INTO @Test VALUES ('Test') INSERT INTO @Test VALUES ('Test 1') INSERT INTO @Test VALUES ('Test 2') INSERT INTO @Test VALUES ('Test 3') INSERT INTO @Test VALUES ('Test 4') DECLARE @aa varchar(200) SET @aa = '' SELECT @aa = COALESCE(CASE WHEN @aa = '' THEN SampleCol ELSE @aa + ',' + SampleCol END , '') FROM @test SELECT @aa
CREATE OR REPLACE FUNCTION trigA() RETURNS trigger AS $BODY$ begin new.modify=LOCALTIMESTAMP; return new; end; $BODY$ LANGUAGE plpgsql VOLATILE
$this->Student->find('all', array('conditions' => array('Human.first_name' => 'AnyFirstNameYouWant')));
select name, sum(col1*weighting) as weightedCol1, sum(col2*weighting) as weightedCol2, n.date, [hour] from nodes n inner join weights w on w.nodeid = n.nodeid and w.date = n.date group by name, n.date, [hour]
SELECT USERID, OTHER, (SELECT TOP 1 c.CLASS FROM DBCLASSTABLE c WHERE c.USERID = u.USERID AND c.EFFECTIVEDATE < '2015-01-01' ORDER BY A.EFFECTIVEDATE DESC ) as Class FROM @USERS u;
create table #tmp (c1 int, c2 int, dt datetime default(getdate()) ) insert into #tmp (c1, c2) exec mysproc
foreach (var deleteMe in deleteThese) { // Delete validation if(CanDeleteItem(deleteMe.ItemId)) { /// deleteMe.Prices.ToList().ForEach(p => db.ItemPrices.Remove(p)); /// db.Entry(deleteMe).State = EntityState.Deleted; } } db.SaveChanges();
select case substring(mystring,1,1) when 'G' then 'Green' when 'R' then 'Red' else '?' end as mycolumn from test;
-- Setup a test table DECLARE @tbl AS TABLE(R1 NVARCHAR(10), R2 NVARCHAR(10), R3 NVARCHAR(10), R4 NVARCHAR(10), PC NVARCHAR(10)); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','x','i',NULL,'1'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','y','i',NULL,'2'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','y','j',NULL,'2'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('a','z','k',NULL,'3'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('b','u','m',NULL,'4'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('b',NULL,'n',NULL,'4'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('c',NULL,NULL,NULL,'5'); INSERT INTO @tbl(R1,R2,R3,R4,PC) VALUES ('c','q',NULL,NULL,'6'); -- Calculate the result: SELECT PC, CASE WHEN LVL1 = 1 THEN R1 ELSE NULL END AS R1, CASE WHEN LVL2 = 1 THEN R2 ELSE NULL END AS R2, CASE WHEN LVL3 = 1 THEN R3 ELSE NULL END AS R3, CASE WHEN LVL4 = 1 THEN R4 ELSE NULL END AS R4 FROM ( SELECT PC, MAX(R1) AS R1, MAX(R2) AS R2, MAX(R3) AS R3, MAX(R4) AS R4, COUNT(DISTINCT ISNULL(R1,'.')) AS LVL1, COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.')) AS LVL2, COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.') + ISNULL(R3,'.')) AS LVL3, COUNT(DISTINCT ISNULL(R1,'.') + ISNULL(R2,'.') + ISNULL(R3,'.') + ISNULL(R4,'.')) AS LVL4 FROM @tbl GROUP BY PC ) A
CREATE TRIGGER SetReason BEFORE UPDATE ON <table1> FOR EACH ROW BEGIN SET NEW.event_id = (CASE WHEN OLD.name != NEW.name THEN 1 ELSE 0 END) + (CASE WHEN OLD.oid != NEW.oid THEN 2 ELSE 0 END) + (CASE WHEN OLD.state != NEW.state THEN 4 ELSE 0 END) + (CASE WHEN OLD.ctrl != NEW.ctrl THEN 8 ELSE 0 END) END;
ALTER TABLE points ADD xy POINT; UPDATE points SET xy = Point(x, y); ALTER TABLE points MODIFY xy POINT NOT NULL; CREATE SPATIAL INDEX sx_points_xy ON points (xy); SELECT * FROM points WHERE MBRContains(LineString(Point(100, 100), Point(200, 200), xy) AND z BETWEEN 100 and 200 AND otherParameter > 10;
select tt.trainingCode from TotalTraining tt left join SelectedTraining st on tt.trainingCode = st.trainingCode and st.EmpCode = 7190 and st.appraisalId = 12 where st.trainingCode is null ;
SELECT Package, SUM(Licences) as TotalLicences FROM ( SELECT Package, Licences FROM Table1 UNION ALL SELECT Package, Licences FROM Table2 UNION ALL SELECT Package, Licences FROM Table3 ) AS AllLicences GROUP BY Package
connection.open(); foreach (DictionaryEntry myInfo in myOrderInfo){//contain 183 times foreach (DictionaryEntry myBi in myInfo.value){//loop 13 times ...//some code cmd2.Parameters.AddWithValue("@" + myBi.Key, myBi.Value + ""); .... cmd2.ExecuteNonQuery(); } .....//some conditions cmd.Parameters.AddWithValue("@" + myInfo.Key, myInfo.Value + ""); .....//some conditions cmd.ExecuteNonQuery(); } connection.close();
create table posts ( id int not null auto_increment primary key, user_id int, post_date date ) engine = myisam; insert into posts (user_id,post_date) values (1,'2011-03-02'), (1,'2011-04-10'), (1,'2011-11-13'), (2,'2011-03-02'), (2,'2011-03-02'), (3,'2011-01-01'), (3,'2011-01-02'), (3,'2011-01-03'); select * from ( select posts.*, @num := if(@user_id = user_id, @num + 1, 1) as rownum, @user_id:=user_id as uid from posts,(select @user_id := 0, @num := 1) as t order by user_id asc, post_date asc) as tab where rownum = 3 order by post_date limit 1
UPDATE [tablename] SET lab_no = REPLACE(lab_no, 'EPI8', 'EPI80');
GROUP BY categories.name, color_variant.pcode, color_variant.price
where concat(a.name, a.surname) like . . .
CREATE TYPE num_tbl AS TABLE OF NUMBER; CREATE FUNCTION has_kw( p_k IN VARCHAR2 ) RETURN num_tbl PIPELINED IS BEGIN FOR i IN (SELECT DISTINCT id FROM kw WHERE k = p_k) LOOP PIPE ROW( i.id ); END LOOP; RETURN; END;
-- {0} is your table name -- {1} is your identity value of the reset IF EXISTS (SELECT null FROM sys.identity_columns WHERE OBJECT_NAME(OBJECT_ID) = '{0}' AND last_value IS NOT NULL) DBCC CHECKIDENT ({0}, RESEED, {1});
select pair_1, pair_2 from (select distinct name as pair_1 from TABLE_NAME), (select distinct name as pair_2 from TABLE_NAME) where pair_1 <> pair_2
Select *, (Select Count(*) From YourTable As T Where T.well_name = W.well_name And T.rpt_date <= W.rpt_date) As [Normalized Time] From YourTable As W Order By well_name, rpt_date
select date_part('second',date1) - date_part('second',date2)
ALTER TABLE foo ADD COLUMN tempbar text; UPDATE foo SET tempbar = cast(cast(bar as varchar) as text); ALTER TABLE foo DROP COLUMN bar; ALTER TABLE foo ADD COLUMN bar text; UPDATE foo SET bar = tempbar; ALTER TABLE foo DROP COLUMN tempbar;
declare @T table ( [key] char(4), code int, primary key([key], code) ) insert into @T values ('key1', 220), ('key1', 221), ('key2', 220), ('key2', 221), ('key2', 222), ('key3', 220), ('key3', 333), ('key4', 255), ('key5', 220), ('key5', 221) declare @Match table (code int) insert into @Match values (220),(221) select T.[key] from @T as T left outer join @Match as M on T.code = M.code group by T.[key] having count(*) = (select count(*) from @Match) and count(M.code) = (select count(*) from @Match)
select (id/1000)+((id%1000)/100)+((id%100)/10)+(id%10)
SELECT orig_loc, COUNT(*) order_ct, COUNT(DISTINCT dest_loc) dest_ct FROM order_table GROUP BY orig_loc
CREATE TRIGGER trigger_Insert_TableB ON TableB FOR INSERT AS Begin Select * FROM Inserted //This will give you the inserted data End
SELECT COUNT(*) FROM (SELECT values FROM table GROUP BY values HAVING COUNT(*) > 1) t
select count(distinct username) as TotalUserCountOnTheDay from dbo.LoginHistory where datediff(day,LoginDate, '2014-11-19') = 0;
declare @str1 varchar(1024) = 'and hello w w w search how are you', @str2 varchar(1024) = 'and hello w w search how are you', @likeStr varchar(512), @pos int, @maxMatch int; set @maxMatch = 2; set @pos = 0; set @likeStr = '%hello'; while (@pos < @maxMatch) begin set @likeStr += ' [^ ]'; set @pos += 1; end set @likeStr += ' search%'; select @likeStr, (case when @str1 like @likeStr then 1 else 0 end), (case when @str2 like @likeStr then 1 else 0 end)
SELECT c.ROW_ID , p.NAME , p.DATE FROM Cust c JOIN ( SELECT row_number() over (partition by pc.CUST_ID order by p.DATE) rn , pc.CUST_ID , p.NAME , p.DATE FROM Prod p JOIN ProdCust pc ON pc.PROD_ID = p.ROW_ID ) p ON c.ROW_ID = p.CUST_ID AND p.rn = 1 -- First row only
dev> create table dctest (x number); Table created. dev> insert into dctest VALUES (0.98692326671601283); 1 row created. dev> select * from dctest; X ---------- .986923267 dev> column x format 0.000000000000000000000000000 dev> / X ------------------------------ 0.986923266716012830000000000
if v_type IN ('ABC','DEF','ASD') then do things; end if;
SELECT * FROM produit WHERE date_format(date_commande, '%Y-%m-%d) BETWEEN $filtre_Date1 AND $filtre_Date2;
select column1, column2 from table1 where (@filtertype=1 AND (column3 in (select columnb from table2))) OR (@filtertype=2 AND (column2 in (select columnb from table2)))
DECLARE @temp YOURTYPE DECLARE c CURSOR FOR SELECT CodeDesc FROM authors OPEN c FETCH NEXT FROM c INTO @temp WHILE @@FETCH_STATUS = 0 BEGIN -do something with temp FETCH NEXT INTO @temp END CLOSE c DEALLOCATE c
UPDATE a SET a.fieldA = b.fieldA, a.fieldB = b.fieldB FROM TableA a INNER JOIN TableB b ON a.keyA = b.keyA AND a.keyB = b.keyB
select name, DOB, truncate(datediff(sysdate(),DOB)/365.25,0) as 'age' from animal where colour = 'Brown' and truncate(datediff(sysdate(),DOB)/365.25,0) <=2;
SELECT TO_CHAR(DATE_OF_BIRTH,'fm MONTH')"Month", COUNT(TO_CHAR(DATE_OF_BIRTH,'fm MONTH'))"NoS" FROM EMP WHERE DATE_OF_BIRTH <= TO_DATE('31-12-1990','DD-MM-YYYY') AND DATE_OF_BIRTH >= TO_DATE('01-01-1990','DD-MM-YYYY') GROUP BY TO_CHAR(DATE_OF_BIRTH,'fm MONTH') HAVING COUNT(TO_CHAR(DATE_OF_BIRTH,'fm MONTH')) >= 2
ALTER TABLE emp ADD listOfSalaries salaryList NESTED TABLE listOfSalaries STORE AS salaryList_tab;
SELECT ss.softwareId AS 'Software ID', s.softwareDescription AS 'Software Description', sv.vendorName AS 'Vendor Name', c.cityName AS 'City Name' FROM software AS s left outer JOIN systemSoftware AS ss ON s.softwareId = ss.softwareId left outer JOIN softwareVendor AS sv ON s.vendorId = sv.vendorId left outer JOIN city AS c ON sv.zipCode = c.zipCode WHERE ss.softwareId is NULL ORDER BY s.softwareId
SELECT R1.id, R1.way_id, R1.node_id, R1.sort FROM Relations R1 WHERE R1.way_id = 107187465 AND R1.id = (SELECT MAX(R2.id) FROM Relations R2 WHERE R1.node_id = R2.node_id)
Proc SurveySelect data=Have out=Want noprint Method = urs N = 1 outhits rep = 1; Strata Id ; run;
drop table if exists users; create table users ( _id bigint unsigned auto_increment primary key, name varchar(50) not null, number_of_posts integer not null default 0 ); drop table if exists posts; create table posts ( _id bigint unsigned auto_increment primary key, user_id bigint unsigned not null, post_text text ); -- Populate with dummy data insert into users (name) values ('Bob'), ('Sally'); insert into posts (user_id, post_text) values (1, 'First!!'), (1, 'Second...'), (2, 'Post 1'), (2, 'another post'), (2, 'more posts'); -- One-time update of users table update users u set u.number_of_posts = ( select count(0) from posts p where u._id = p.user_id ); -- trigger to keep post count up to date when future posts are made drop trigger if exists trg_post_count; delimiter $$ create trigger trg_post_count after insert on posts for each row begin select count(0) into @post_count from posts where user_id = NEW.user_id; update users set number_of_posts = @post_count where _id = NEW.user_id; end; $$ delimiter ; -- test trigger insert into posts (user_id) values (2); select * from users;
... UPDATE dbo.system_numbers SET @return_value = current_number = current_number + auto_increment, last_updated_on = GETDATE() WHERE [type] = @parmtype AND auto_increment = 1 ; IF @@ROWCOUNT = 0 SELECT @return_value = current_number FROM dbo.system_numbers WHERE [type] = @parmtype ;
select * from tbl t where name = ( select name from tbl where billnumber = 100756 -- can be any of his ) and date = ( select max(date) from tbl x where x.name = t.name )
-- First you have to enable SB for your database USE master ALTER DATABASE Playground SET ENABLE_BROKER GO USE Playground GO -- Then create a message type; usually it will be XML -- because it's very easy to serialize/deserialize it CREATE MESSAGE TYPE [//Playground/YourMessageType] VALIDATION = WELL_FORMED_XML GO -- Then create a contract to have a rule for communication -- Specifies who sends which message type CREATE CONTRACT [//Playground/YourContract] ( [//Playground/YourMessageType] SENT BY ANY) GO --Creates queues, one for initiator (1) and one for target (2) CREATE QUEUE MyQueue1 GO CREATE QUEUE MyQueue2 GO -- Finally, configure services that 'consume' queues CREATE SERVICE [//Playground/YourService1] ON QUEUE MyQueue1 ([//Playground/YourContract]) GO CREATE SERVICE [//Playground/YourService2] ON QUEUE MyQueue2 ([//Playground/YourContract]) GO -- Now you can send a message from service to service using contract DECLARE @dHandle uniqueidentifier, @Msg nvarchar(max) BEGIN DIALOG @dHandle FROM SERVICE [//Playground/YourService1] TO SERVICE '//Playground/YourService2' ON CONTRACT [//Playground/YourContract] WITH ENCRYPTION = OFF SELECT @Msg = ( SELECT TOP 3 * FROM Table1 FOR XML PATH('row'), ROOT('Table1')) ;SEND ON CONVERSATION @dHandle MESSAGE TYPE [//Playground/YourMessageType] (@Msg) PRINT @Msg GO -- To get the message on the other end, use RECEIVE -- Execute this in another query window DECLARE @dHandle uniqueidentifier DECLARE @MsgType nvarchar(128) DECLARE @Msg nvarchar(max) ;RECEIVE TOP(1) @dHandle = conversation_handle, @Msg = message_body, @MsgType = message_type_name FROM MyQueue2 SELECT @MsgType SELECT @Msg END CONVERSATION @dHandle GO
WITH sumQuart AS ( SELECT *, CASE WHEN ROW_NUMBER() -- for the 1st month in a quarter OVER (PARTITION BY CCP, Years, Quart ORDER BY months) = 1 -- return the sum of all GTS of this quarter THEN SUM(GTS) OVER (PARTITION BY CCP, Years, Quart) ELSE NULL -- other months END AS sumGTS FROM gts ) ,cte AS ( SELECT sq.*, COALESCE(b.Baseline, -- 1st quarter -- product of all previous quarters CASE WHEN MIN(ABS(sumGTS)) -- any zeros? OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING) = 0 THEN 0 ELSE -- product EXP(SUM(LOG(NULLIF(ABS(COALESCE(b.Baseline,1) * sumGTS),0))) OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING)) -- product -- odd number of negative values -> negative result * CASE WHEN COUNT(CASE WHEN sumGTS < 0 THEN 1 END) OVER (PARTITION BY sq.CCP ORDER BY sq.Years, sq.Quart, sq.Months ROWS BETWEEN UNBOUNDED PRECEDING AND 3 PRECEDING) % 2 = 0 THEN 1 ELSE -1 END END) AS newBaseline FROM sumQuart AS sq LEFT JOIN BASELINE AS b ON B.CCP = sq.CCP AND b.Quart = sq.Quart AND b.Years = sq.Years ) SELECT CCP, months, Quart, Years, GTS, round(newBaseline * GTS,2), round(newBaseline,2) FROM cte
SELECT CONCAT('http://site.com/uni-', number, '-uni') as url FROM table
1,"a string",100.20 2,"a string containing a , comma",102.20 3,"a string containing a \" quote",102.20 4,"a string containing a \", quote and comma",102.20
DATE_FORMAT(my_date, '%Y-%m-%d')
with cte_dates as ( select distinct [Date] from MyTable ), cte_vals as ( select distinct ColA from MyTable ) select d.[Date], v.ColA, T1.ColB as ColB_Today, T2.ColB as ColB_Prev_Day from cte_dates as d cross join cte_vals as v left outer join MyTable as T1 on T1.ColA = v.ColA and T1.[Date] = d.[Date] outer apply ( select top 1 TT.ColB from MyTable as TT where TT.ColA = v.ColA and TT.[Date] < d.[Date] order by TT.[Date] desc ) as T2
SELECT @sSQL = 'SELECT @xCount = COUNT(ID) FROM Authors' EXEC sp_ExecuteSQL @sSQL, N'@xCount int output', @count = @xCount output
SELECT MONTH(user_lastlogin) AS Month, YEAR(user_lastlogin) AS Year, COUNT(*) AS 'Total Reg', SUM(CASE WHEN user_regtype = 'LR' THEN 1 ELSE 0 END) AS 'LR Reg', SUM(CASE WHEN IS NULL OR user_regtype = 'BBR' THEN 1 ELSE 0 END) AS 'BBR Reg' FROM bb_user GROUP BY MONTH(user_lastlogin), YEAR(user_lastlogin) ORDER BY Year DESC, Month DESC
WITH Pivoted AS ( SELECT person_ID, eye, hair, teeth FROM SourceBodyPartColors PIVOT ( MAX (color) FOR body_part_name IN ( [eye], [hair], [teeth] ) ) AS pvt ) MERGE TargetBodyPartColors AS target USING Pivoted AS source ON (target.person_ID = source.person_ID) WHEN MATCHED THEN UPDATE SET eye_color = source.eye, hair_color = source.hair, teeth_color = source.teeth ;
CREATE TEMPORARY TABLE IF NOT EXISTS people_hours ( people_id INTEGER NOT NULL, society_id INTEGER NOT NULL, year INTEGER NOT NULL, month INTEGER NOT NULL, hours DOUBLE NOT NULL, PRIMARY KEY(people_id, society_id, year, month) ); CREATE TEMPORARY TABLE IF NOT EXISTS people_cost ( people_id INTEGER NOT NULL, year INTEGER NOT NULL, month INTEGER NOT NULL, cost DOUBLE NOT NULL, PRIMARY KEY(people_id, year, month) ); TRUNCATE people_hours; TRUNCATE people_cost; INSERT INTO people_hours (people_id, society_id, year, month, hours) SELECT p.id as people_id, s.id as society_id, YEAR(t.assigndate) as year, MONTH(t.assigndate) as month, SUM(t.timeunits)/60 as hours FROM people p, society s, timesheet t WHERE t.society_id = s.id AND t.people_id = p.id GROUP BY year, month, people_id, society_id; INSERT INTO people_cost (people_id, year, month, cost) SELECT p.id as people_id, YEAR(o.date) as cost_year, MONTH(o.date) as cost_month, SUM(o.hourtarif + s.hourtarif) as cost FROM people p, salarystate s, overhead o WHERE s.people_id = p.id AND CONVERT(SUBSTRING(s.month FROM 1 FOR 4), UNSIGNED) = YEAR(o.date) AND CONVERT(SUBSTRING(s.month, -2), UNSIGNED) = MONTH(o.date) GROUP BY cost_year, cost_month, people_id; SELECT h.year, h.month, h.society_id, h.hours, c.cost, (h.hours * c.cost) AS total_cost, CONCAT(p.name, ' ', p.firstname) AS employee, CONCAT(ps.name, ' ', ps.firstname) AS society FROM people_hours h, people_cost c, people p, people ps, society s WHERE h.society_id = s.id AND h.people_id = p.id AND h.people_id = c.people_id AND s.people_id = ps.id AND h.year = c.year AND h.month = c.month ORDER BY h.year, h.month, h.people_id, h.society_id;
select min(A),B from table group by B
SELECT DATEADD(hour, -DATEPART(hour, TimeToLive), GETDATE());
WITH CTE as ( SELECT RN = ROW_NUMBER() OVER (ORDER BY id), * FROM tablename ) SELECT [Current Row].* FROM CTE [Current Row] LEFT JOIN CTE [Previous Row] ON [Previous Row].RN = [Current Row].RN - 1 LEFT JOIN CTE [Next Row] ON [Next Row].RN = [Current Row].RN + 1 WHERE not([Current Row].value = 0 AND [Next Row].value = 0) AND // this deletes the row where value is zero and the next rows value is zero not([Previous Row].value = 0 AND [Current Row].value = 0) // this deletes the row where value is zero and the previous rows value is zero
select t.Id from Tent as t left join ( select p.tentId, count(*) as occupiedSpots from person as p group by p.tentId) as i ON i.tentId = z.id where t.numberOfSpots > IFNULL(i.occupiedSpots,0)
SELECT *, match(project_title) against('sample project 55') as similarity FROM projects WHERE status IN(1, 2, 3, 4, 5, 6) AND id != ? AND match('sample project 55') against(?) ORDER BY similarity DESC
DECLARE rec_count integer default 0; str varchar(100); BEGIN str := 'select count(*) from emp_table'; EXECUTE IMMEDIATE str into rec_count; dbms_output.put_line(rec_count); END;
create or replace function split_xmcuser_groups_to_tuples() RETURNS SETOF RECORD AS $$ DECLARE r a%rowtype; strLen integer; curIdx integer; commaCnt integer; curCSV varchar; BEGIN curIdx := 1; commaCnt := 1; FOR r IN SELECT * FROM a LOOP strLen := char_length(r.csv); while curIdx <= strLen LOOP curIdx := curIdx + 1; if substr(r.csv, curIdx, 1) = ',' THEN commaCnt := commaCnt + 1; END IF; END LOOP; curIdx := 1; while curIdx <= commaCnt LOOP curCSV := split_part(r.csv, ',', curIdx); if curCSV != '' THEN RETURN QUERY select r.a,curCSV; END IF; curIdx := curIdx + 1; END LOOP; END LOOP; RETURN; END $$ LANGUAGE 'plpgsql';
SELECT GROUP_CONCAT(product,',' ,quantity) FROM ORDERS;
min(timestamp) as first_interaction format = datetime.
SELECT id, header, text, ... FROM CONTENT WHERE online_at < current_timestamp MINUS SELECT id, header, text, ... FROM CONTENT WHERE offline_at < current_timestamp
How to reset the root password for mysql: Stop mysql: 1. service mysql stop Run mysql with skip grants to be able to login without any password 2. mysqld_safe --skip-grant-tables & Login as root 3. mysql -u root 4. mysql commands: mysql> use mysql; mysql> update user set password=PASSWORD("YourPWHere") where User='root'; mysql> flush privileges; mysql> quit Stop mysql 5. service mysql stop Start mysql normally: 6. service mysql start Try to login using your new password: 7. mysql -u root -p
Select * From ( Select Transacion_ID, Case When C.lvl = 1 Then 'GROSS' When C.lvl = 2 Then 'DISC' End TYPE, Case When C.lvl = 1 Then GROSS_AMOUNT When C.lvl = 2 Then DISCOUNT_AMOUNT End AMOUNT From T cross join (select level lvl from dual connect by level<=2) c ) where amount is not null order by 1
Create PROCEDURE [dbo].[SCN_SP_SCE_Weekly_Report] @startdate as datetime AS BEGIN SET NOCOUNT ON; declare @date datetime declare @LastWeekStart datetime declare @LastWeekEnd datetime declare @ThisWeekStart datetime declare @ThisWeekEnd datetime set @date=(select dateadd(w, -7, @startdate)) set @LastWeekStart=(SELECT DATEADD(DAY, 1 - DATEPART(WEEKDAY, @date), CAST(@date AS DateTime))) set @LastWeekEnd=(DATEADD(DAY, 7 - DATEPART(WEEKDAY, @date), CAST(@date AS DateTime))) set @ThisWeekStart=(SELECT DATEADD(DAY, 1 - DATEPART(WEEKDAY, @startdate), CAST(@startdate AS DateTime))) set @ThisWeekEnd=(DATEADD(DAY, 7 - DATEPART(WEEKDAY, @startdate), CAST(@startdate AS DateTime))) select * into #a from( select BU.bu_desc as [BU], prod.Product_Desc as [Product Name], NULL as [SC-ID], 'OVERALL PROJECT STATUS' as [Project Name],'' as [Requestor], NULL as [Request Date], case when BU.bu_desc in ('DSM','Synexis','ALD') then 'GW' when BU.bu_desc in ('Etch','SRP','FEP') then 'MS' when BU.bu_desc in ('CMP','MDP') then 'RS' else 'PT' end as [PM], '' as [SCE], (count(parts.part_id_num)-count(parts.cancelled_date)) as [Total Parts Requested], null as [No. Of Parts Completed Last Week], null as [No. Of Parts Completed This Week], count(parts.analysis_Complete_date) as [Total No.Of Parts Completed], case when (((count(parts.part_id_num)-count(parts.cancelled_date))-(count(parts.analysis_Complete_date)))=0) then 100 when ((count(parts.analysis_Complete_date))=0) then 0 else ((count(parts.analysis_Complete_date)*100)/(count(parts.part_id_num)-count(parts.cancelled_date))) end as [SC Analysis Completed (%)],NULL as [Requested Completion Date], NULL as [Committed Date],NULL as Notes,'' as sc_id from scn_project_details as proj left join scn_part_details as parts on proj.project_id=parts.project_id left join SCN_BU bu on bu.bu_id=proj.bu_id left join dbo.SCN_Product_Name prod on prod.Product_Id=proj.Product_Id where proj.status_id<>12 and (proj.analysis_complete_date between @startdate and getdate() or (proj.status_id >= 4 and proj.status_id < 8)) and parts.sc_id is not null group by BU.bu_desc,prod.Product_Desc union select BU.bu_desc as [BU], prod.Product_Desc as [Product Name], proj.project_id as [SC-ID], proj.project_name as [Project Name],usr1.fname+' '+usr1.lname as [Requestor], proj.created_date as [Request Date],left(proj.pm_id,2) as [PM],usr2.fname+' '+usr2.lname as [SCE], (count(parts.part_id_num)-count(parts.cancelled_date)) as [Total Parts Requested], null as [No. Of Parts Completed Last Week], null as [No. Of Parts Completed This Week], count(parts.analysis_Complete_date) as [Total No.Of Parts Completed], case when (((count(parts.part_id_num)-count(parts.cancelled_date))-(count(parts.analysis_Complete_date)))=0) then 100 when ((count(parts.analysis_Complete_date))=0) then 0 else ((count(parts.analysis_Complete_date)*100)/(count(parts.part_id_num)-count(parts.cancelled_date))) end as [SC Analysis Completed (%)], proj.project_completition_date as [Requested Completion Date], proj.original_commit_date as [Committed Date], NULL as Notes,parts.sc_id as sc_id from scn_project_details as proj join scn_part_details as parts on proj.project_id=parts.project_id and parts.sc_id is not null left join SCN_users usr1 on proj.created_by=usr1.[user_id] left join SCN_users usr2 on parts.sc_id=usr2.[user_id] left join SCN_BU bu on bu.bu_id=proj.bu_id left join dbo.SCN_Product_Name prod on prod.Product_Id=proj.Product_Id where proj.status_id<>12 and (proj.analysis_complete_date between @startdate and getdate() or (proj.status_id >= 4 and proj.status_id < 8)) and parts.sc_id is not null group by BU.bu_desc,prod.Product_Desc,proj.project_id,proj.project_name,usr1.fname+' '+usr1.lname, proj.created_date,proj.project_completition_date,proj.original_commit_date, proj.pm_id,usr2.fname+' '+usr2.lname,proj.analysis_complete_date,parts.sc_id ) as t update a set a.[No. Of Parts Completed Last Week]=c.cnt from #a a, ( select count(b.sc_id) as cnt,b.project_id,b.sc_id from scn_part_details as b where b.analysis_complete_date between @LastWeekStart and @LastWeekEnd group by b.project_id,b.sc_id) as c where a.[SC-ID]=c.project_id and a.sc_id=c.sc_id update a set a.[No. Of Parts Completed This Week]=c.cnt from #a a, ( select count(b.sc_id) as cnt,b.project_id,b.sc_id from scn_part_details as b where b.analysis_complete_date between @ThisWeekStart and @ThisWeekEnd group by b.project_id,b.sc_id) as c where a.[SC-ID]=c.project_id and a.sc_id=c.sc_id select BU,[Product Name],[SC-ID],[Project Name],Requestor,[Request Date],PM,SCE, [Total Parts Requested],[No. Of Parts Completed Last Week],[No. Of Parts Completed This Week], [Total No.Of Parts Completed], [SC Analysis Completed (%)],[Requested Completion Date], [Committed Date],Notes from #a End GO
SELECT r.name AS radio_name,Pod.*,Sh.* FROM podcasts Pod INNER JOIN radios r ON r.id = Pod.radio_id INNER JOIN shows Sh ON Sh.podcast_id = Pod.id WHERE NOT EXISTS (select 1 from shows sh2 where sh2.podcast_id = sh.podcast_id.id and sh2.publication_date > sh.publication_date ) ORDER BY sh.publication_date DESC LIMIT 5;
BEGIN AUTONOMOUS TRANSACTION INSERT INTO LogTable () VALUES (); COMMIT; RESIGNAL; END;
UPDATE targetTable t, sourceTable s SET t.y1 = s.y1, t.y2 = s.y2 -- (and so on...) WHERE t.member = s.member AND t.year = m.year;
SELECT `company_name`, `employee_name`, COUNT(`cid`) FROM `tbl_reports` GROUP BY `company_name`, `employee_name`;
SELECT MD.*, P.City, P.State, P.Areacode FROM MemberDetails AS MD LEFT JOIN PostcodeData P ON MD.Postcode = P.Postcode
declare o anydata; begin o := anydata.convertobject(myclass('hi ancestor')); end; /
SELECT name FROM groups WHERE id = ( SELECT DISTINCT immediateparentid FROM cachedgroupmembers WHERE groupid = ( SELECT g.id FROM Tickets t, groups g WHERE t.Id = 124 AND t.id = g.instance AND g.type = 'AdminCc' ) AND immediateparentid != groupid )
SELECT count(local_doc.providerno) NumberofReferals, LOCAL_DOC.FULLNAME FULLNAME, LOCAL_DOC.TELNUMBER TELNUMBER, LOCAL_DOC.STREET STREET, LOCAL_DOC.SUBURB SUBURB, LOCAL_DOC.STATE STATE, LOCAL_DOC.POSTCODE POSTCODE, LOCAL_DOC.PROVIDERNO FROM LOCAL_DOC, PATIENT WHERE PATIENT.PROVIDERNO = LOCAL_DOC.PROVIDERNO AND PATIENT.REFERALDATE <= sysdate AND PATIENT.REFERALDATE >= ADD_MONTHS(sysdate, -6) GROUP BY LOCAL_DOC.FULLNAME , LOCAL_DOC.TELNUMBER , LOCAL_DOC.STREET , LOCAL_DOC.SUBURB , LOCAL_DOC.STATE , LOCAL_DOC.POSTCODE , LOCAL_DOC.PROVIDERNO
select * from ls_comments c where c.itemID = 9 or c.parentID in (select c2.commentId from ls_comments c2 where c2.itemId = 9)
SELECT t.tag_name, i.image_name FROM image_tags it INNER JOIN images i on it.image_id = i.id INNER JOIN tags t on it.tag_id = t.id WHERE t.tag_name in ('beach', 'palms')
SELECT v.id as venue, COUNT(a.id) as visits FROM users AS u CROSS JOIN venues as v --<-- CROSS JOIN for Cartesian product between users and venues LEFT JOIN activities AS a ON u.id = a.user_id AND a.venue_id = v.id WHERE u.id = 1234 GROUP BY v.id ORDER BY v.id
SELECT DATE(JULIANDAY('NOW', 'START OF MONTH')+d1*9+d2*3+d3) AS Days FROM ( SELECT 0 AS d1 UNION SELECT 1 UNION SELECT 2 UNION SELECT 3 ) JOIN ( SELECT 0 AS d2 UNION SELECT 1 UNION SELECT 2 ) JOIN ( SELECT 0 AS d3 UNION SELECT 1 UNION SELECT 2 ) WHERE STRFTIME('%m', Days)=STRFTIME('%m', 'NOW') ORDER BY Days;
select distinct fk_col from table1 minus (select distinct fk_col from table1 where col_entry='ab3' intersect select distinct fk_col from table1 where col_entry='ab4')
CREATE TABLE name ( id int , UNIQUE (col_name1 type , col_name2 type) ON CONFLICT IGNORE )
SELECT `performers`.`hash`, `performers`.`alias`, `performers`.`date_updated`, `performers`.`status`, IF(`performers`.`status` = 'active', 'deleted','active') AS `statususe`, `images`.`image_hash_file` FROM `performers` LEFT JOIN `images` ON `images`.`asset_id` = `performers`.`id` AND `images`.`asset_type` = 'performer' ORDER BY `alias` ASC LIMIT 12
create dbo.MyProc ( @Param int = 30; ) . . .
WITH cte AS ( SELECT CatId AS ParentCatId, CatName, CatName AS ParentName, HigherCatId, CatId, CAST(CatName AS VARCHAR(255)) AS PATH FROM Categories UNION ALL SELECT c.CatId AS ParentCatId, cte.CatName, c.CatName AS ParentName, c.HigherCatId, cte.CatId, CAST(cte.path + ', ' + c.CatName AS VARCHAR(255)) AS PATH FROM cte INNER JOIN Categories c ON c.CatId = cte.HigherCatId ) SELECT c.parentName, COUNT(p.ProductId) AS ProductsCount FROM cte c LEFT OUTER JOIN products p ON c.CatId = p.CatId GROUP BY c.ParentCatId, c.ParentName ORDER BY c.ParentCatId
create table abc_new as select *,sysdate as someDate from abc
bool overlap = db.Records.Any(x=>(x.TerminationDate >= givenRecord.StartDate && x.StartDate <= givenRecord.TerminationDate) || (x.TerminationDate <= givenRecord.TerminationDate && x.StartDate >= givenRecord.StartDate));
select A, max(B) from tbl group by A having count(A) > 1
select k.id, k.title from knowledge k inner join ( select kID from sorting group by kID having count(kID) < 2 ) s on k.id = s.kid LIMIT 0,8;
SELECT links.*, users.user_name FROM links INNER JOIN terms ON links.link_id = terms.terms_link_id AND terms.terms_tag_id = $tag_id INNER JOIN users ON links.link_user = users.user_id;
SET @total = 0, @lasttime = 0, @laststatus = 0; SELECT IF(`status`=0, @total := IF(@lasttime=0, 0, @total+TIMEDIFF(`datetime`,@lasttime) ), @lasttime := `datetime` ), (@laststatus := `status`) FROM `table`; SET @total = @total + IF(@laststatus=1,TIMEDIFF(NOW(),@lasttime),0); SELECT @total AS `result`
SELECT images.image_id, COUNT(votes.vote_id) AS cote_count FROM votes JOIN images ON images.image_id=votes.image_id GROUP BY images.image_id
SELECT * FROM weapons LEFT OUTER JOIN weapon_powers ON weapons.ID = weapon_powers.WEAPONTYPE WHERE weapons.ID = @somevariable
SELECT convert(date, column1) as date from table1 where convert(date, column1) < '01/25/2011' and date is not null and date <> ''
SELECT * FROM cars LEFT JOIN carLog ON cars.id=carLog.car AND carLog.username='Juddling'
SELECT p.*, u.firstname, u.lastname, l.post_id AS liked FROM `posts` p LEFT JOIN `users` u ON u.id = p.author_id LEFT JOIN `likes` l ON l.user_id = p.author_id AND l.post_id = p.id WHERE p.author_id=1 AND p.published = 1 ORDER BY p.post_date DESC LIMIT 0, 10
select bill.bill_no,bill.total,bill.discount,bill.to_be_paid, isnull(Service_bill.total_amt,0) as ServiceCharge, isnull(Damage_cost.total_amt,0) as DamageCost, isnull(Extraperson_cost.total_amt,0) as ExtraCost, isnull(Advance_cost.total_amount,0) as Advance from bill left join Advance_cost on bill.bill_no=Advance_cost.room_bill_no left outer join Service_bill on bill.bill_no=Service_bill.room_bill_no left outer join Damage_cost on bill.bill_no=Damage_cost.room_bill_no left outer join Extraperson_cost on bill.bill_no=Extraperson_cost.room_bill_no where bill.bill_no='57'
CREATE TABLE TEAM ( TEAM_ID INT PRIMARY KEY -- Other fields... ); CREATE TABLE SCORE ( TEAM1_ID INT, TEAM2_ID INT, -- Other field(s) that descibe the score... PRIMARY KEY (TEAM1_ID, TEAM2_ID), FOREIGN KEY (TEAM1_ID) REFERENCES TEAM (TEAM_ID), FOREIGN KEY (TEAM2_ID) REFERENCES TEAM (TEAM_ID) );
Select * from table1 where my_id in ( Select Max(My_Id) from table1 where phase='Close' group by your_id)
SELECT event_id, event_name, LAG (event_end_date ) OVER (ORDER BY event_end_date ASC )+1 event_start_date, event_end_date FROM event
select STD_ID from SCHOOL order by STD_ID+0
SELECT * FROM ps_product WHERE id_product=44 OR id_product=29
SELECT a_case.Id, ISNULL(R1.Type, 'ND') AS Referred_by_1, ISNULL(R2.Type, 'ND') AS Referred_by_2, ISNULL(R3.Type, 'ND') AS Referred_by_3 FROM ...
select distinct substring(convert(varchar(20),RunDateTime, 9), 13, 5) +' ' + substring(convert(varchar(30),RunDateTime, 9), 25, 2) from TestDates;
ALTER TABLE table1 ADD INDEX (fk_id);
management.call_command('flush')
position('\xefbbbf'::bytea IN convert_to(your_text_column,'UTF-8'))=1
SELECT COUNT(*) FROM table_name WHERE DATEPART(HOUR, date_created) BETWEEN 9 AND 21
with cte as ( select *, row_number() over (partition by report_id order by timestamp desc) as RowNum from report_status_log ) select * from report r inner join cte c on r.report_id = c.report_id where c.code = 'finished' and RowNum = 1
SELECT DISTINCT item FROM myTable WHERE something = 3
SQL> with tbl(str) as ( select 'SERO02~~~NA_@ERO5' from dual ) select regexp_substr(str, '(.*?)(~~~|$)', 1, level, null, 1) element from tbl connect by level <= regexp_count(str, '~~~') + 1; ELEMENT ----------------- SERO02 NA_@ERO5 SQL>
UPDATE some_table SET some_column = some_column || '_more_data';
WITH "Period" (PeriodM, PeriodName) AS ( -- // I would store it as another table basically, but having it as part of the view would do SELECT 01, '1 mo' UNION ALL SELECT 02, '2 mo' -- // data not stored UNION ALL SELECT 03, '3 mo' UNION ALL SELECT 06, '6 mo' UNION ALL SELECT 12, '1 yr' UNION ALL SELECT 24, '2 yr' UNION ALL SELECT 36, '3 yr' UNION ALL SELECT 48, '4 yr' -- // data not stored UNION ALL SELECT 60, '5 yr' UNION ALL SELECT 72, '6 yr' -- // data not stored UNION ALL SELECT 84, '7 yr' UNION ALL SELECT 96, '8 yr' -- // data not stored UNION ALL SELECT 108, '9 yr' -- // data not stored UNION ALL SELECT 120, '10 yr' -- ... // add more UNION ALL SELECT 240, '20 yr' -- ... // add more UNION ALL SELECT 360, '30 yr' ) , "Yield" (ID, PeriodM, Date, Value) AS ( -- // ** This is the TABLE your data is stored in ** -- // -- // value of ID column is not important, but it must be unique (you may have your PK) -- // ... it is used for a Tie-Breaker type of JOIN in the view -- // -- // This is just a test data: SELECT 101, 01 /* '1 mo'*/, '2009-05-01', 0.06 UNION ALL SELECT 102, 03 /* '3 mo'*/, '2009-05-01', 0.16 UNION ALL SELECT 103, 06 /* '6 mo'*/, '2009-05-01', 0.31 UNION ALL SELECT 104, 12 /* '1 yr'*/, '2009-05-01', 0.49 UNION ALL SELECT 105, 24 /* '2 yr'*/, '2009-05-01', 0.92 UNION ALL SELECT 346, 36 /* '3 yr'*/, '2009-05-01', 1.39 UNION ALL SELECT 237, 60 /* '5 yr'*/, '2009-05-01', 2.03 UNION ALL SELECT 238, 84 /* '7 yr'*/, '2009-05-01', 2.72 UNION ALL SELECT 239,120 /*'10 yr'*/, '2009-05-01', 3.21 UNION ALL SELECT 240,240 /*'20 yr'*/, '2009-05-01', 4.14 UNION ALL SELECT 250,360 /*'30 yr'*/, '2009-05-01', 4.09 ) , "ReportingDate" ("Date") AS ( -- // this should be a part of the view (or a separate table) SELECT DISTINCT Date FROM "Yield" ) -- // This is the Final VIEW that you want given the data structure as above SELECT d.Date, p.PeriodName, --//p.PeriodM, CAST( COALESCE(y_curr.Value, ( (p.PeriodM - y_prev.PeriodM) * y_prev.Value + (y_next.PeriodM - p.PeriodM) * y_next.Value ) / (y_next.PeriodM - y_prev.PeriodM) ) AS DECIMAL(9,4) -- // TODO: cast to your type if not FLOAT ) AS Value FROM "Period" p CROSS JOIN "ReportingDate" d LEFT JOIN "Yield" y_curr ON y_curr.Date = d.Date AND y_curr.PeriodM = p.PeriodM LEFT JOIN "Yield" y_prev ON y_prev.ID = (SELECT TOP 1 y.ID FROM Yield y WHERE y.Date = d.Date AND y.PeriodM <= p.PeriodM ORDER BY y.PeriodM DESC) LEFT JOIN "Yield" y_next ON y_next.ID = (SELECT TOP 1 y.ID FROM Yield y WHERE y.Date = d.Date AND y.PeriodM >= p.PeriodM ORDER BY y.PeriodM ASC) --//WHERE d.Date = '2009-05-01'
;with T(f) as ( select '' union select 'xxx' union select 'xxx (yyy)' union select 'xxx (yyy) (zzz)' ) select right(f, patindex('%(%', reverse(f) + '(')) from T >> (No column name) xxx (yyy) (zzz)
UPDATE `table` SET `current` = `max` WHERE `id` = 1
UPDATE t1 SET t1.codeA = t2_1.codeB FROM table1 t1 JOIN table2 t2_1 ON CHARINDEX(t2_1.colB, t1.colA) > 0 LEFT JOIN table2 t2_2 ON CHARINDEX(t2_2.colB, t1.colA) > 0 AND t2_1.codeB <> t2_2.codeB AND LEN(t2_2.colB) > LEN(t2_1.colB) WHERE t2_2.colB IS NULL;
SELECT 'ALTER TABLE ' + OBJECT_NAME(so.parent_obj) + ' DROP CONSTRAINT ' + so.name FROM sysobjects so WHERE so.xtype = 'UQ'
CreateDocumentAsync(coll_link, new {foo: "bar"}, new RequestOptions {IncludePreTrigger = "TriggerName"});
select client_name, count(*) as transactions from TableA group by client_name order by count(*) DESC
SELECT t.name, c.name, COUNT(item.id) FROM typelookup t CROSS JOIN codelookup c LEFT JOIN itemCodePivot icp ON icp.codeId = c.codeId LEFT JOIN item i ON i.itemId = icp.itemId AND i.TypeId = t.TypeId GROUP BY t.name, c.name
SELECT pd.saleid, pd.firstpaymentdate AS FirstPaymentDate, (SELECT amountdue FROM repaymentschedule WHERE saleid = pd.saleid AND paymentduedate = pd.firstpaymentdate) AS FirstPaymentValue, (SELECT TOP 1 amountdue FROM repaymentschedule WHERE saleid = pd.saleid AND paymentduedate <> pd.firstpaymentdate AND paymentduedate <> pd.lastpaymentdate) AS RegularPaymentValue, (SELECT amountdue FROM repaymentschedule WHERE saleid = pd.saleid AND paymentduedate = pd.lastpaymentdate) AS FinalPaymentValue FROM (SELECT saleid, Min(paymentduedate) AS FirstPaymentDate, Max(paymentduedate) AS LastPaymentDate FROM repaymentschedule GROUP BY saleid) pd
SELECT u.* FROM Users u INNER JOIN ( SELECT ur.UserID FROM Users_Roles ur INNER JOIN Roles r ON r.RoleID = ur.RoleID WHERE r.PermissionLevel > 100 GROUP BY ur.UserID ) ur ON u.UserId = ur.UserId WHERE u.Active = 1 ORDER BY u.LastName
SELECT d.ID, GROUP_CONCAT(m.Field) AS ConcatFields FROM d JOIN m ON d.ID = m.dID GROUP BY d.ID
SELECT SUM(`quant`), MONTH(`date`) AS month, `id` FROM ((SELECT `date`, `id`, count(`hit`) AS `quant` FROM `stat_2014_07` WHERE `k_id` = '123') t1 UNION ALL (SELECT `date`, `id`, count(`hit`) AS `quant` FROM `stat_2014_08` WHERE `k_id ` = '123') t2 ) t_union GROUP BY id, month
select count(case tipo_sangre when 'apositivo' then 1 end) as apositivo, count(case tipo_sangre when 'anegativo' then 1 end) as anegativo, ..... count(case tipo_sangre when 'onegativo' then 1 end) as onegativo from donate
Select NULLIF(Column1, '') as [Column1], NULLIF(Column2, '') as [Column2] From TableA UNION Select NULLIF(Column1, '') as [Column1], NULLIF(Column2, '') as [Column2] From TableB
STUDENT_CHOICES=( ('None', 'None'), )
CREATE TEMP TABLE items AS SELECT rowid FROM tblEvent_basic WHERE sguid=11 DELETE FROM tblEvent_type WHERE eguid in (select rowid from items) DELETE FROM tblEvent_group WHERE eguid in (select rowid from items) DROP TABLE items
SELECT Name , MemberNumber FROM ( SELECT members.Name, friends.MemberNumber1 as MemberNumber FROM friends INNER JOIN members ON friends.MemberNumber1= members.MemNo WHERE friends.MemberNumber2 LIKE 1 UNION ALL SELECT members.Name, friends.MemberNumber2 as MemberNumber FROM friends INNER JOIN members ON friends.MemberNumber2= members.MemNo WHERE friends.MemberNumber1 LIKE 1) AS derived1 ORDER BY derived1.Name
select id,version, team, date, time, oppo from fixtures A where id in ( select max(id)from fixtures where date = "2012-06-01" group by team )
select * from faculty F JOIN course C on CHARINDEX((','+CAST(c.id as varchar(10))+','), (','+f.courseid+',')) > 0 JOIN subject s on CHARINDEX((','+CAST(s.id as varchar(10))+','), (','+f.subjectid+',')) > 0
SELECT CONCAT(city , ', ', country) AS x_axis, COUNT(*) as y_axis FROM beer GROUP BY city, country HAVING COUNT(*) > 100 ORDER BY country, city;
SELECT * FROM TABLE WHERE COLUMN BETWEEN '1' AND '9' and LEN(COLUMN) = 1;
add_library(sql_cpp_target EXCLUDE_FROM_ALL myfile.sql.in.c)
UPDATE my_table SET my_field = CASE WHEN position('a' in my_field) = 0 THEN my_field WHEN position('a' in my_field) = 1 THEN substring(my_field from 1 for 5) WHEN position('a' in my_field) > 1 THEN substring(my_field from 2 for 5) END
SELECT a.STATE , COALESCE(b.count, 0) AS Count FROM ( SELECT 'done' AS STATE UNION SELECT 'open' AS STATE UNION SELECT 'pending' AS STATE UNION SELECT 'draft' AS STATE UNION SELECT 'cancel' AS STATE ) a LEFT JOIN ( SELECT STATE , count(*) AS count FROM crm_lead GROUP BY STATE ) b ON a.STATE = b.STATE
select a1.acnumber, a1.opening_balance + coalesce(sum(a2.transaction_amount), 0) from account a1 left join trandetails a2 on a1.acnumber = a2.acnumber and a2.transaction_type like 'Deposit' group by a1.acnumber, a1.opening_balance;
SELECT ID FROM TableA WHERE ID NOT IN(SELECT ID FROM TableA WHERE CODE='AAA')
;WITH CTE AS ( SELECT EmployeeID, EmployeeName, Department, ROW_NUMBER() OVER(PARTITION BY Department ORDER BY(SELECT 1)) rownum FROM table1 ) SELECT EmployeeId, EmployeeName, CASE rownum WHEN 1 THEN Department ELSE '' END AS Department FROM CTE ORDER BY EmployeeID;
Cursor cursor = db.rawQuery("Select * from tbl_name",SelectionArgs[]);
SELECT DATEADD(day, DATEDIFF(day, 0, GETDATE()), '03:30:00')
CREATE TABLE Swap ( a CHAR(1), b CHAR(1) ); INSERT INTO Swap (a, b) VALUES ('a', 'b'); UPDATE Swap SET a = b, b = a; SELECT * FROM Swap;
select s.StudentName, a.AssignmentName, a.PointsPossible, g.PointsReceived from students s cross join assignments a left outer join grades g on g.StudentId = a.StudentId and g.AssignmentId = a.AssignmentId; order by s.StudentName;
SELECT x.col1, x.col2, MAX(CASE WHEN x.rk = 1 THEN x.col3 END) AS Res1, MAX(CASE WHEN x.rk = 2 THEN x.col3 END) AS Res2, MAX(CASE WHEN x.rk = 3 THEN x.col3 END) AS Res3 FROM (SELECT yt.col1, yt.col2, yt.col3, ROW_NUMBER() OVER(PARTITION BY yt.col1, yt.col2 ORDER BY yt.col3) AS rk FROM YOUR_TABLE yt) x GROUP BY x.col1, x.col2
SELECT SUM(rl.paxon) ,r.id AS port_id ,rl.[date] FROM runlogs rl INNER JOIN runs r ON r.code = rl.runsegment INNER JOIN runsegments rs ON rs.code = rl.runsegment WHERE rl.[date] BETWEEN '20120709' AND '20120716' AND rl.account in ('311','312','313') AND rs.org_id = 13 GROUP BY rl.[date], r.id
SELECT Employee.Name , Employee.ID , Sum(Sales.Money) , Year(Sales.Date) , Month(Sales.Date) FROM Database.Sales.Sales INNER JOIN Database.Employee.Employee ON Sales.ID=Employee.ID WHERE Sales.Date BETWEEN '2000-01-01' AND '2001-01-01' group by Employee.Name , Employee.ID , Year(Sales.Date) , Month(Sales.Date) ORDER BY Employee.Name, Year(Sales.Date), Month(Sales.Date)
SELECT TOP 1 a.logtime, a.BL1_data_SS_ST, a.BL2_data_SS_ST, a.BL3_data_SS_ST, a.BL4_data_SS_ST, a.BL5_data_SS_ST, a.BL6_data_SS_ST, a.BL7_data_SS_ST, a.BL8_data_SS_ST, a.BL9_data_SS_ST, a.BL10_data_SS_ST, a.BL11_data_SS_ST, a.BL12_data_SS_ST, a.BL13_data_SS_ST, a.BL14_data_SS_ST, a.BL15_data_SS_ST, a.BL16_data_SS_ST, a.BL17_data_SS_ST, a.BL18_data_SS_ST, a.BL19_data_SS_ST, a.BL20_data_SS_ST, a.BL21_data_SS_ST, a.BL22_data_SS_ST, a.BL23_data_SS_ST, a.BL24_data_SS_ST, a.BL25_data_SS_ST, a.BL26_data_SS_ST, a.BL27_data_SS_ST, b.st1_prmt_status_p45,c.beam_current, c.beam_energy FROM INDUS2_BLFE.dbo.main_BLFE_status a INNER JOIN INDUS2_MSIS.dbo.main_MSIS_status b on a.logtime = b.logtime INNER JOIN INDUS2_BDS.dbo.DCCT c on b.logtime = c.logtime '' ORDER BY a.logtime DESC
;WITH MaxPricePerCategory AS ( SELECT MAX(Price) AS [Price] -- You can remove category if you just need the maximum price , Category FROM Table1 WHERE VendorID = 69041 AND Table1.Category IN (49,50,45) GROUP BY Category ) SELECT DISTINCT Table2.name , Table2.city , Table2.state FROM Table1 JOIN Table2 ON Table1.VendorID = Table2.VendorID JOIN MaxPricePerCategory MPPC ON Table1.Category = MPPC.Category AND Table1.price > MPPC.Price
select coalesce(t.SalesOrderID, 0) SalesOrderID , coalesce(t.OrderDate, d.OrderDate) OrderDate , coalesce(t.ItemID, 0) ItemID , coalesce(t.Quantity, 0) Quantity , coalesce(t.PromotionCode, 0) PromotionCode from (select @dateParameter OrderDate) d left outer join ( SELECT SalesOrderID, OrderDate, ItemID, Quantity, PromotionCode FROM tblSalesOrder ) t on t.OrderDate = d.OrderDate
$sql = "DELETE adjectives.*, declensions.* FROM adjectives adj JOIN declensions decl ON (adj.decl_m_id = decl.id OR adj.decl_f_id = decl.id OR adj.decl_n_id = decl.id OR adj.decl_pl_id = decl.id) WHERE adj.word_id IN ?";
Plan Hash Total Elapsed 1st Capture Last Capture Value Time(ms) Executions Snap ID Snap ID --- ---------------- ---------------- ------------- ------------- -------------- 54069910 81,459 256 19864 19864
CREATE OR REPLACE PROCEDURE SP_EMPLOYEE_LOOKUP_BY_EMP_ID ( IN_USER_ID IN NUMBER, IN_EMPLOYEE_ID NUMBER, IN_HC_AS_ON_DATE VARCHAR2, emp_cursor OUT SYS_REFCURSOR ) IS is_found_rec boolean := false; CURSOR employees IS SELECT * FROM EMPLOYEE e; BEGIN FOR employee IN employees LOOP is_found_rec := true; // do something END LOOP; if not is_found_rec then // do something else end if; END;
SELECT ban_id, ban_url, IFNULL(SUM(bansta_event = 'C'), 0) as num_impressions, IFNULL(SUM(bansta_event = 'I'), 0) as num_clicks FROM banner LEFT JOIN banner_statistics ON bansta_ban_id = ban_id AND bansta_event IN ('I', 'C') WHERE ban_id = 1
SELECT count(DISTINCT wp_postmeta.`post_id`) FROM wp_posts LEFT JOIN wp_postmeta ON (wp_posts.ID = wp_postmeta.post_id) LEFT JOIN wp_term_relationships ON (wp_posts.ID = wp_term_relationships.object_id) LEFT JOIN wp_term_taxonomy ON (wp_term_relationships.term_taxonomy_id = wp_term_taxonomy.term_taxonomy_id) WHERE wp_postmeta.meta_key = 'betting_status' AND wp_postmeta.meta_value = 'yes' AND wp_posts.post_status = 'publish' AND wp_term_taxonomy.taxonomy = 'category' AND wp_term_taxonomy.term_id = 106;
Select * from Page where Page.page_title = 'AccessibleComputing'
WITH times as ( SELECT t3.EmplID , t3.EmplName , min(t1.RecTime) AS InTime , max(t2.RecTime) AS [TimeOut] , cast(min(t1.RecTime) as datetime) AS InTimeSub , cast(max(t2.RecTime) as datetime) AS TimeOutSub , xx.RecDate AS [DateVisited] , CASE WHEN max(t1.EmplID) is null and max(t2.EmplID) is NULL then 'Yes' else 'No' END IsAbsent FROM HrEmployee t3 CROSS JOIN (SELECT DISTINCT RecDate FROM AtdRecord) xx LEFT JOIN AtdRecord t1 ON t3.EmplID = t1.EmplID and t1.RecDate = xx.RecDate LEFT JOIN AtdRecord t2 ON t3.EmplID = t2.EmplID AND t1.RecDate = t2.RecDate AND t1.RecTime < t2.RecTime AND t2.RecDate = xx.RecDate group by t3.EmplID , t3.EmplName , xx.RecDate ) SELECT EmplID ,EmplName ,InTime ,[TimeOut] ,[DateVisited] ,convert(char(5),cast([TimeOutSub] - InTimeSub as time), 108) totaltime ,convert(char(5), case when TimeOutSub - InTimeSub >= '08:01' then cast(TimeOutSub - dateadd(hour, 8, InTimeSub) as time) else '00:00' end, 108) as overtime, isAbsent FROM times
for rec in ( SELECT T.ID ID1, U.ID ID2, V.EQ FROM T FULL OUTER JOIN U ON T.ID = U.ID FULL OUTER JOIN (SELECT ID, 1 EQ FROM T NATURAL JOIN U) V ON U.ID = V.ID) loop if rec.id1 is null then -- row in U but not in T elsif rec.id2 is null then -- row in T but not in U elsif rec.eq is null -- row present in both tables -- but content mismatch end if end loop
DECLARE @RAOID INT, @ORGID INT SET @ORGID = 28 SET @RAOID = (SELECT RAOID FROM tblOrganisation WHERE ORGID = @ORGID) PRINT @RAOID IF @RAOID IS NOT NULL BEGIN SELECT CASE WHEN tblOrganisation.ORGID IS NOT NULL THEN tblOrganisation.ORGID ELSE 'No ORGID' END AS ORGID, **CASE isnull(tblOrganisation.Name,'') WHEN '' THEN 'No SubSource for this RAO' ELSE tblOrganisation.Name** END as SUBSOURCENAME FROM tblOrganisation LEFT OUTER JOIN tblSubGroup ON tblOrganisation.SubGroupID = tblSubGroup.SubGroupID WHERE tblSubGroup.RAOID = @RAOID END
declare @table_that_changes varchar(100) declare @linked_server1 varchar(20) declare @linked_server2 varchar(20) declare @DB_onserver1 varchar(100) declare @DB_onserver2 varchar(100) select @linked_server1 = '[server109]', @linked_server2 = '[server104]', @DB_onserver1 = '[database203434]', @DB_onserver2= '[database416541]', @table_that_changes = 'LossTable_2191' declare @sql varchar(1000) set @sql = 'create view linked1.table1 as select * from ' + @linked_server2 + '.' + @DB_onserver1 + '.table1' exec( @sql)
SELECT SUM(comission), token, DATE(transdate) FROM t GROUP BY token, DATE(transdate)
WHERE UPDATE_TIME BETWEEN TIMESTAMP(CHAR(CURRENT DATE,ISO) || ' 06:00:00') - 1 DAY AND TIMESTAMP(CHAR(CURRENT DATE,ISO) || ' 06:00:00')
select a.mjor, a.course, b.grade from degree_plan as a left join student_record as b on a.course_no=b.course_no and b.id=4455 where a.major='COE'
select t.table_name, p.object_name, count(*) from user_tables t cross join user_objects p join user_source s on s.name = p.object_name and s.type = 'PACKAGE BODY' and upper(s.text) like '%' || upper(t.table_name) || '%' where p.object_type = 'PACKAGE BODY' group by t.table_name, p.object_name having count(*) > 5;
select * from foo order by coalesce(created_at, scheduled_at)
SELECT [Pre].[pfPrefix], [Pro].[prId], [Pro].[prName], (CASE WHEN [EnP].[enNumber] IS NULL THEN [EnT].[enNumber] ELSE (SELECT TOP 1 [iET].[enNumber] FROM [SerialsDB].[dbo].[Entries] AS [iET] LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [iEP] ON (([iEP].[enProduct] IS NULL AND [iET].[enProduct] IS NULL) OR ([iEP].[enProduct] = [iET].[enProduct])) AND (([iEP].[enOrder] IS NULL AND [iET].[enOrder] IS NULL) OR ([iEP].[enOrder] = [iET].[enOrder])) AND (([iEP].[enClient] IS NULL AND [iET].[enClient] IS NULL) OR ([iEP].[enClient] = [iET].[enClient])) AND (([iEP].[enNfe] IS NULL AND [iET].[enNfe] IS NULL) OR ([iEP].[enNfe] = [iET].[enNfe])) AND (([iEP].[enDate] IS NULL AND [iET].[enDate] IS NULL) OR ([iEP].[enDate] = [iET].[enDate])) AND (([iEP].[enAuth] IS NULL AND [iET].[enAuth] IS NULL) OR ([iEP].[enAuth] = [iET].[enAuth])) AND (([iEP].[enStatus] IS NULL AND [iET].[enStatus] IS NULL) OR ([iEP].[enStatus] = [iET].[enStatus])) AND ([iEP].[enNumber] = ([iET].[enNumber] - 1)) WHERE (([iET].[enProduct] IS NULL AND [EnT].[enProduct] IS NULL) OR ([iET].[enProduct] = [EnT].[enProduct])) AND (([iET].[enOrder] IS NULL AND [EnT].[enOrder] IS NULL) OR ([iET].[enOrder] = [EnT].[enOrder])) AND (([iET].[enDate] IS NULL AND [EnT].[enDate] IS NULL) OR ([iET].[enDate] = [EnT].[enDate])) AND (([iET].[enClient] IS NULL AND [EnT].[enClient] IS NULL) OR ([iET].[enClient] = [EnT].[enClient])) AND (([iET].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR ([iET].[enNfe] = [EnT].[enNfe])) AND (([iET].[enAuth] IS NULL AND [EnT].[enAuth] IS NULL) OR ([iET].[enAuth] = [EnT].[enAuth])) AND (([iET].[enStatus] IS NULL AND [EnT].[enStatus] IS NULL) OR ([iET].[enStatus] = [EnT].[enStatus])) AND ([iET].[enNumber] <= [EnP].[enNumber]) AND ([iEP].[enNumber] IS NULL) ORDER BY [iET].[enNumber] DESC) END) AS [Initial], [EnT].[enNumber] AS [Final], [EnT].[enOrder], [EnT].[enDate], [EnT].[enNfe], [EnT].[enClient], [Cli].[clGroup], [EnT].[enAuth] FROM [SerialsDB].[dbo].Entries AS [EnT] LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [EnN] ON ([EnN].[enProduct] = [EnT].[enProduct]) AND ([EnN].[enOrder] = [EnT].[enOrder]) AND ([EnN].[enClient] = [EnT].[enClient]) AND (([EnN].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR ([EnN].[enNfe] = [EnT].[enNfe])) AND ([EnN].[enDate] = [EnT].[enDate]) AND ([EnN].[enStatus] = [EnT].[enStatus]) AND ([EnN].[enAuth] = [EnT].[enAuth]) AND ([EnN].[enNumber] = ([EnT].[enNumber] + 1)) LEFT OUTER JOIN [SerialsDB].[dbo].[Entries] AS [EnP] ON ([EnP].[enProduct] = [EnT].[enProduct]) AND ([EnP].[enOrder] = [EnT].[enOrder]) AND ([EnP].[enClient] = [EnT].[enClient]) AND (([EnP].[enNfe] IS NULL AND [EnT].[enNfe] IS NULL) OR ([EnP].[enNfe] = [EnT].[enNfe])) AND ([EnP].[enDate] = [EnT].[enDate]) AND ([EnP].[enStatus] = [EnT].[enStatus]) AND ([EnP].[enAuth] = [EnT].[enAuth]) AND ([EnP].[enNumber] = ([EnT].[enNumber] - 1)) LEFT OUTER JOIN [SerialsDB].[dbo].[Prefixes] AS [Pre] ON ([EnT].[enPrefix] = [Pre].[pfId]) LEFT OUTER JOIN [SerialsDB].[dbo].[Products] AS [Pro] ON ([EnT].[enProduct] = [Pro].[prId]) LEFT OUTER JOIN [SerialsDB].[dbo].[Clients] AS [Cli] ON ([EnT].[enClient] = [Cli].[clId]) WHERE ([EnT].[enOrder] IS NOT NULL) AND ([EnT].[enClient] IS NOT NULL) AND ([EnN].[enNumber] IS NULL) AND ([EnT].[enStatus] = 4) AND ([EnT].[enAuth] IS NOT NULL)
SELECT * FROM OpenQuery(PGEXAMPLE, 'select * from yourtable');
WHERE two = 2 AND three = 3 -- no one
R1 <(E M), {E → M}> R2 <(E L T), {L T → E, E T → L}>
whereString = "LabDate Between #" & myStartDate & "# AND #" & myEndDate & "#"
SELECT t.NAME AS TableName, p.rows AS RowCounts FROM sys.tables t INNER JOIN sys.partitions p ON t.object_id = p.OBJECT_ID WHERE t.NAME NOT LIKE 'dt%' AND t.is_ms_shipped = 0 AND p.rows = 0 GROUP BY t.Name, p.Rows ORDER BY t.Name
/*Set up test table*/ DECLARE @T TABLE ( RowID INT, Employee CHAR(7), [Server] CHAR(6), [timestamp] DATETIME ); INSERT INTO @T SELECT 5,'E000001','Serv-B', '20010501' UNION ALL SELECT 4,'E000001','Serv-A', '20010401' UNION ALL SELECT 3,'E000001','Serv-B', '20010301' UNION ALL SELECT 2,'E000001','Serv-A', '20010201' UNION ALL SELECT 1,'E000001','Serv-A', '20010101'; WITH cte As (SELECT ROW_NUMBER() OVER (PARTITION BY Employee ORDER BY RowID) - ROW_NUMBER() OVER (PARTITION BY Employee, Server ORDER BY RowID) AS Grp, * FROM @T), cte2 AS (SELECT *, ROW_NUMBER() OVER (PARTITION BY Employee, Grp ORDER BY RowID) AS Rn FROM cte) /* Edit: Actually - You want a SELECT not a DELETE I think? DELETE FROM cte2 WHERE Rn > 1*/ SELECT RowID, Employee, [Server], [timestamp] FROM cte2 WHERE Rn = 1
Function GetAccessRecordset(sDatabase As String, sSQL As String) As Variant Dim oAccess As Object Set oAccess = CreateObject("Access.Application") oAccess.OpenCurrentDatabase (sDatabase) oAccess.Visible = False Dim dbs As Object Set dbs = oAccess.CurrentDb.OpenRecordSet(sSQL) GetAccessRecordset = dbs.GetRows(dbs.RecordCount) dbs.Close oAccess.Quit End Function
UPDATE the_table SET lastname = (SELECT lastname FROM the_table ORDER BY RAND())
mysql -uroot -p database_name < backup.sql
SELECT e.* FROM employee e LEFT JOIN class c ON e.emp_id = c.emp_id WHERE (c.timing <> '3-4' OR c.timing IS NULL) ; SELECT * FROM employee WHERE NOT EXISTS ( SELECT 1 FROM class WHERE timing = '3-4' AND class.emp_id = employee.emp_id ) ;
DECLARE @Table1 TABLE (id int, text varchar(8), sender varchar(4), datetime varchar(25), hour int) ; INSERT INTO @Table1 (id, text, sender, datetime, hour) VALUES (1, 'Hi, John', 'Amy', '2015-12-10 13:37:25 +0000', 13), (2, 'Yup', 'Mike', '2015-12-10 15:49:11 +0000', 15) ; DECLARE @Table2 TABLE (hour int) ; INSERT INTO @Table2 (hour) VALUES (0), (1), (2), (3), (4), (6), (7), (8), (9), (13), (15), (16), (23) ; Select T.hour, CASE WHEN cnt <> 0 THEN ROW_NUMBER()OVER(PARTITION BY T.cnt ORDER BY (SELECT NULL)) ELSE CNT END cnt from ( select TT.hour, CASE WHEN ISNULL(T.hour,0)<> 0 THEN 1 ELSE ISNULL(T.hour,0) END cnt from @Table1 T FULL JOIN @Table2 TT ON TT.hour = T.hour )T ORDER BY T.hour
SELECT asset_id, entered_date, max(modified_date) FROM price_data GROUP BY asset_id, entered_date
select row_number() over (partition by Meal order by Time) , * from YourTable
